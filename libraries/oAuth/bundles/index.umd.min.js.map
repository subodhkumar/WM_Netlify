{"version":3,"sources":["ng://@wm/oAuth/oAuth.utils.ts","ng://@wm/oAuth/oAuth.service.ts","ng://@wm/oAuth/oAuth.module.ts"],"names":["accessTokenSuffix","parseConfig","serviceParams","val","param","config","urlParams","url","method","key","headers","hasOwnProperty","_","isUndefined","replace","RegExp","params","data","dataParams","byPassResult","isDirectCall","isExtURL","preventMultiple","responseType","listeners","ACCESSTOKEN_PLACEHOLDERS","STUDIO","RUN","newWindowProps","removeAccessToken","provider","accessTokenKey","getAccessTokenPlaceholder","sessionStorage","removeItem","_WM_APP_PROJECT","id","setAccessToken","accesstoken","setItem","checkAuthenticationStatus","providerId","successCallback","removeProviderConfigCallBack","evt","accessToken","localStorage","getItem","origin","window","location","removeEventListener","setTimeout","checkAccessTokenInWindow","onSuccess","onError","startTime","loginObj","performFakeLocalStorageUpdate","dummy_key","timeDiff","moment","duration","format","subtract","getAccessToken","accesstoken_retrieved","minutes","handleLoginForIE","open","postGetAuthorizationURL","oAuthWindow","hasCordova","then","onAuthWindowOpen","callback","bind","undefined","addEventListener","checkForWindowExistence","closed","checkLocalStorage","performAuthorization","http","addProviderConfigCallBack","requestSourceType","getAuthorizationUrl","serviceSettings","target","action","projectId","send","response","name","body","invoke","isIE","OAuthService","httpService","this","providers","Subject","providersConfig","prototype","getOAuthProvidersAsObservable","asObservable","addProviderConfig","find","push","next","removeProviderConfig","remove","perfromOAuthorization","Injectable","AbstractHttpService","OAuthModule","forRoot","ngModule","NgModule","args"],"mappings":"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","sourcesContent":["import { _WM_APP_PROJECT, hasCordova, isIE } from '@wm/core';\n\ndeclare const moment, _;\n\nconst accessTokenSuffix = '.access_token';\nconst isWaveLens = false;\n\nexport const parseConfig = (serviceParams: any): any => {\n\n    let val, param, config;\n    const urlParams = serviceParams.urlParams;\n\n    config = {\n        url: 'services/oauth2/:providerId/authorizationUrl',\n        method: 'GET'\n    };\n\n    /*To handle dynamic urls, append the serviceParams.config.url with the static url(i.e., config.url)*/\n    if (serviceParams.config) {\n        config.url = (serviceParams.config.url || '') + config.url;\n        config.method = serviceParams.config.method || config.method;\n        config.headers = config.headers || {};\n\n        // TODO[Shubham] - change to for - of\n        for (const key in serviceParams.config.headers) {\n            val = serviceParams.config.headers[key];\n            config.headers[key] = val;\n        }\n    }\n    /* check for url parameters to replace the url */\n    if (urlParams) {\n        for (param in urlParams) {\n            if (urlParams.hasOwnProperty(param)) {\n                val = urlParams[param];\n                if (!_.isUndefined(val) && val !== null) {\n                    config.url = config.url.replace(new RegExp(':' + param, 'g'), val);\n                }\n            }\n        }\n    }\n\n    /* check for data */\n    if (serviceParams.params) {\n        config.params = serviceParams.params;\n    }\n    /* check for data */\n    if (!_.isUndefined(serviceParams.data)) {\n        config.data = serviceParams.data;\n    }\n    /* check for data parameters, written to support old service calls (.json calls) */\n    if (serviceParams.dataParams) {\n        config.data.params = serviceParams.dataParams;\n    }\n    /* check for headers */\n    if (serviceParams.headers) {\n        config.headers = serviceParams.headers;\n    }\n\n    /* set extra config flags */\n    config.byPassResult    = serviceParams.byPassResult;\n    config.isDirectCall    = serviceParams.isDirectCall;\n    config.isExtURL        = serviceParams.isExtURL;\n    config.preventMultiple = serviceParams.preventMultiple;\n    config.responseType    = serviceParams.responseType;\n\n    return config;\n};\n\nconst listeners = {},\n    ACCESSTOKEN_PLACEHOLDERS = {\n        'STUDIO': 'WM_STUDIO_',\n        'RUN': 'WM_RUN_'\n    },\n    newWindowProps = 'width=400,height=600';\n\n/**\n * This function remove the accessToken for a provider\n * @param provider\n */\nexport const removeAccessToken = (provider) => {\n    const accessTokenKey = getAccessTokenPlaceholder(provider);\n    sessionStorage.removeItem(accessTokenKey);\n};\n\n/**\n * This function returns the accesstoken placeholder based on the studio or run mode for the project\n * @param provider\n * @returns {*}\n */\nfunction getAccessTokenPlaceholder(provider) {\n    let accessTokenKey;\n    accessTokenKey = ACCESSTOKEN_PLACEHOLDERS.RUN + _WM_APP_PROJECT.id + '_' + provider + accessTokenSuffix;\n    return accessTokenKey;\n}\n\n/**\n * This function performs the fake local storage update, so the IE gets the latest token instead of returning the cached localStorageValue\n */\nfunction performFakeLocalStorageUpdate() {\n    const dummy_key = 'dummy_key';\n    localStorage.setItem(dummy_key, dummy_key);\n    localStorage.removeItem(dummy_key);\n}\n\n/**\n * This function sets the accessToken\n * @param provider\n * @param accesstoken\n */\nfunction setAccessToken(provider, accesstoken) {\n    const accessTokenKey = getAccessTokenPlaceholder(provider);\n    sessionStorage.setItem(accessTokenKey, accesstoken);\n}\n\n/**\n * this is a callback function to check if the authentication is done and invokes the successCallback\n * @param providerId\n * @param successCallback\n * @param evt\n */\nfunction checkAuthenticationStatus(providerId, successCallback, removeProviderConfigCallBack, evt) {\n    const accessTokenKey = providerId + accessTokenSuffix,\n        accessToken = localStorage.getItem(accessTokenKey);\n    if (evt && evt.origin !== window.location.origin) {\n        return;\n    }\n    if (accessToken) {\n        removeProviderConfigCallBack(providerId);\n        localStorage.removeItem(accessTokenKey);\n        setAccessToken(providerId, accessToken);\n        window.removeEventListener('message', listeners[providerId]);\n        setTimeout(() => {\n            delete listeners[providerId];\n            if (successCallback) {\n                successCallback(accessToken);\n            }\n        });\n    }\n}\n\n/**\n * this function keeps on checking the accesstoken in the LocalStorage and updates it accordingly\n * @param providerId\n * @param onSuccess\n * @param onError\n * @param startTime\n * @param loginObj\n */\nfunction checkAccessTokenInWindow(providerId, onSuccess, onError, startTime, loginObj, removeProviderConfigCallBack) {\n    performFakeLocalStorageUpdate();\n    const currentTime = moment.duration(moment().format('HH:mm'), 'HH:mm'),\n        timeDiff = currentTime.subtract(startTime),\n        accessToken = getAccessToken(providerId, true);\n    if (accessToken) {\n        loginObj.accesstoken_retrieved = true;\n        setAccessToken(providerId, accessToken);\n        localStorage.removeItem(providerId + accessTokenSuffix);\n        removeProviderConfigCallBack(providerId);\n        if (onSuccess) {\n            onSuccess();\n        }\n    } else if (timeDiff.minutes() > 1 && onSuccess && !loginObj.accesstoken_retrieved) {\n        onSuccess('error');\n    } else {\n        setTimeout(() => {\n            checkAccessTokenInWindow(providerId, onSuccess, onError, startTime, loginObj, removeProviderConfigCallBack);\n        }, 3000);\n    }\n}\n\n/**\n * checks for the window existence i.e if the window is manually closed by the user or any such\n * @param oAuthWindow\n * @param provider\n * @param callback\n */\nfunction checkForWindowExistence(oAuthWindow, provider, callback) {\n    if (oAuthWindow && listeners[provider]) {\n        if (!oAuthWindow.closed) { // .closed is supported across major browser vendors however for IE the user has to enable protected mode from security options\n            setTimeout(checkForWindowExistence.bind(undefined, oAuthWindow, provider, callback), 3000);\n        } else {\n            window.removeEventListener('message', listeners[provider]);\n            delete listeners[provider];\n            if (callback) {\n                callback('error');\n            }\n        }\n    }\n}\n/**\n * this functions handles the logic related to the window operations in IE\n * @param url\n * @param providerId\n * @param onSuccess\n * @param onError\n */\nfunction handleLoginForIE(url, providerId, onSuccess, onError, removeProviderConfigCallBack) {\n    const loginObj = {\n        'accesstoken_retrieved': false\n    };\n    window.open(url, '_blank', newWindowProps);\n    checkAccessTokenInWindow(providerId, onSuccess, onError, moment.duration(moment().format('HH:mm'), 'HH:mm'), loginObj, removeProviderConfigCallBack);\n}\n\n/**\n * this function adds the listener on the window and assigns the listener\n * @param provider\n * @param callback\n */\nfunction onAuthWindowOpen(provider, callback, removeProviderConfigCallBack) {\n    listeners[provider] = checkAuthenticationStatus.bind(undefined, provider, callback, removeProviderConfigCallBack);\n    window.addEventListener('message', listeners[provider], false);\n}\n\n/**\n * this function is a callback function which enables the listener and checks for the window existence\n * @param providerId\n * @param onSuccess\n * @param url\n */\nfunction postGetAuthorizationURL(url, providerId, onSuccess, removeProviderConfigCallBack) {\n    let oAuthWindow;\n\n     if (hasCordova()) {\n         window.open(url, '_system');\n         window['OAuthInMobile'](providerId).then(accessToken => {\n             const key = providerId + accessTokenSuffix;\n             if (accessToken) {\n                 localStorage.setItem(key, accessToken);\n                 checkAuthenticationStatus(providerId, onSuccess, removeProviderConfigCallBack, null);\n             } else {\n                 onSuccess('error');\n             }\n         });\n     } else {\n         oAuthWindow = window.open(url, '_blank', newWindowProps);\n         onAuthWindowOpen(providerId, onSuccess, removeProviderConfigCallBack);\n         checkForWindowExistence(oAuthWindow, providerId, onSuccess);\n     }\n}\n\n/**\n * function to get the authorization url\n * @param params provider id for which the auth url has to be fetched\n * @param successCallback callback to be invoked upon successful fetch of the providers\n * @param failureCallback callback to be invoked upon error\n * @returns {*}\n */\nfunction getAuthorizationUrl(params, http) {\n    const action = 'getAuthorizationUrl',\n        serviceSettings = parseConfig({\n            target: 'oauthConfiguration',\n            action: action,\n            urlParams: {\n                projectId: _WM_APP_PROJECT.id,\n                providerId: params.providerId\n            },\n            params: {\n                'requestSourceType': params.requestSourceType\n            }\n        });\n    return http.send(serviceSettings);\n}\n\n/**\n * this function retrieves the accessToken based on the run/studiomode\n * @param provider\n * @returns {*}\n */\nexport const getAccessToken = (provider, checkLocalStorage) => {\n    const accessTokenKey = getAccessTokenPlaceholder(provider);\n    if (checkLocalStorage) {\n        return localStorage.getItem(provider + accessTokenSuffix);\n    }\n    return sessionStorage.getItem(accessTokenKey);\n};\n\n\n/**\n * this function is used to perform the authorization by opening the window and having active listeners\n * @param url\n * @param providerId\n * @param onSuccess\n * @returns {*}\n */\nexport const performAuthorization = (url, providerId, onSuccess, onError, http, addProviderConfigCallBack, removeProviderConfigCallBack) => {\n    let requestSourceType = 'WEB';\n    if (url) {\n        if (isIE()) { // handling for IE\n            handleLoginForIE(url, providerId, onSuccess, onError, removeProviderConfigCallBack);\n        } else {\n            postGetAuthorizationURL(url, providerId, onSuccess, removeProviderConfigCallBack);\n        }\n    } else {\n        if (isWaveLens) {\n            requestSourceType = 'WAVELENS';\n        } else if (hasCordova()) {\n            requestSourceType = 'MOBILE';\n        }\n        return getAuthorizationUrl({\n            'providerId': providerId,\n            'requestSourceType': requestSourceType\n        }, http).then((response) => {\n            addProviderConfigCallBack({\n                name: providerId,\n                url: response.body,\n                invoke: () => {\n                    if (isIE()) { // handling for IE\n                        handleLoginForIE(response, providerId, onSuccess, onError, removeProviderConfigCallBack);\n                    } else {\n                        postGetAuthorizationURL(response.body, providerId, onSuccess, removeProviderConfigCallBack);\n                    }\n                }\n            });\n        });\n    }\n};\n","import { Injectable } from '@angular/core';\n\nimport { Observable, Subject } from 'rxjs';\n\nimport { AbstractHttpService } from '@wm/core';\n\nimport { getAccessToken, performAuthorization, removeAccessToken } from './oAuth.utils';\n\ndeclare const _;\n\n@Injectable()\nexport class OAuthService {\n    constructor(private httpService: AbstractHttpService) {}\n\n    providers = new Subject();\n\n    providersConfig = [];\n\n    getOAuthProvidersAsObservable(): Observable<any> {\n        return this.providers.asObservable();\n    }\n\n    addProviderConfig(provider) {\n        if (!(_.find(this.providersConfig, {'name' : provider.name}))) {\n            this.providersConfig.push(provider);\n        }\n        this.providers.next(this.providersConfig);\n    }\n\n    removeProviderConfig(providerId) {\n        _.remove(this.providersConfig, provider => provider.name === providerId);\n        this.providers.next(this.providersConfig);\n    }\n\n    perfromOAuthorization(url, providerId, onSuccess, onError) {\n        performAuthorization(url, providerId, onSuccess, onError, this.httpService, this.addProviderConfig.bind(this), this.removeProviderConfig.bind(this));\n    }\n\n    getAccessToken(provider, checkLocalStorage) {\n        return getAccessToken(provider, checkLocalStorage);\n    }\n\n    removeAccessToken(provider) {\n        removeAccessToken(provider);\n    }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\n\nimport { OAuthService } from './oAuth.service';\n\n@NgModule({})\nexport class OAuthModule {\n\n    static forRoot(): ModuleWithProviders {\n        return {\n            ngModule: OAuthModule,\n            providers: [OAuthService]\n        };\n    }\n}\n"]}