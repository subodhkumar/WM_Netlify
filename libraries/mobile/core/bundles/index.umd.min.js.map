{"version":3,"sources":["ng://@wm/mobile/core/services/device-file.service.ts","ng://@wm/mobile/core/services/device-file-download.service.ts","ng://@wm/mobile/core/services/device-file-cache.service.ts","ng://@wm/mobile/core/services/device-file-opener.service.ts","ng://@wm/mobile/core/services/device.service.ts","ng://@wm/mobile/core/services/network.service.ts","ng://@wm/mobile/core/core.module.ts","ng://@wm/mobile/core/services/device-file-upload.service.ts","ng://@wm/mobile/core/services/ext-app-message.service.ts"],"names":["FileType","IMAGE_EXTENSIONS","VIDEO_EXTENSIONS","AUDIO_EXTENSIONS","APP_FOLDER_STRUCTURE","name","children","fileType","IMAGE","AUDIO","VIDEO","DOCUMENT","DeviceFileService","cordovaAppVersion","cordovaFile","this","serviceName","_fileTypeVsPathMap","temporary","persistent","prototype","addMediaToGallery","filePath","isAndroid","isPersistentType","Promise","resolve","reject","cordova","plugins","MediaScannerPlugin","scanFile","appendToFileName","fileName","attachment","splits","_","now","split","length","join","clearTemporaryStorage","removeRecursively","getTemporaryRootPath","_appName","copy","sourceFilePath","_this","sourceFilename","pop","destFolder","findFolderPath","sourceFolder","substring","lastIndexOf","newFileName","then","destFilename","copyFile","typeMap","findFileType","getPersistentRootPath","file","dataDirectory","cacheDirectory","getUploadDirectory","_uploadDir","startsWith","isValidPath","folder","checkFile","listFiles","search","resolveLocalFileSystemURL","directory","files","createReader","readEntries","entries","filter","e","match","map","isDirectory","path","nativeURL","extIndex","removeFile","i","dir","removeDir","dirPath","parentdir","movedDir","checkDir","moveDir","catch","noop","start","FileReader","READ_CHUNK_SIZE","getAppName","appName","promises","push","createFolderIfNotExists","setupUploadDirectory","all","readAsText","externalRootDirectory","parent","folders","fileTypeLocationMap","childPromises","forEach","folderPath","replace","p","createDir","extension","indexOf","toLowerCase","some","a","uploadsDirName","appDir","Injectable","args","providedIn","AppVersion","File","DeviceFileDownloadService","http","deviceFileService","fileExtensionFromMimePipe","_downloadQueue","_concurrentDownloads","download","url","isPersistent","destFile","progressObserver","addToDownloadQueue","downloadNext","req_1","shift","downloadFile","req","blob","sendHttpRequest","body","getFileName","type","writeFile","response","JSON","stringify","mimeType","fileExtension","hasFileExtension","disposition","headers","get","filename","matches","exec","transform","isArray","find","endsWith","HttpRequest","responseType","reportProgress","request","pipe","next","HttpEventType","DownloadProgress","Response","complete","toPromise","HttpClient","FileExtensionFromMimePipe","CACHE_FILE_INDEX_NAME","DeviceFileCacheService","fileService","downloadService","_cacheIndex","addEntry","filepath","writeCacheIndexToFile","getLocalPath","downloadIfNotExists","invalidateCache","content","parse","_writing","_saveCache","setTimeout","DeviceFileOpenerService","cordovaFileOpener","cacheService","getFileMimeType","fileEntry","metadata","openRemoteFile","open","downloadsParent","externalCacheDirectory","isIos","documentsDirectory","_downloadsFolder","generateFileName","fromDir","fromFile","newFilePath","FileOpener","REGISTRY_FILE_NAME","DeviceService","_registry","_isReady","_whenReadyPromises","_backBtnTapListeners","_startUpServices","console","warn","maxWaitTime","document","addEventListener","executeBackTapListeners","bind","$event","fn","$appDigest","addStartUpService","service","onBackButtonTap","unshift","splice","hasCordova","window","s","error","dispatchEvent","CustomEvent","whenReady","getAppBuildTime","applicationDirectory","appConfig","storeEntry","key","value","getEntry","AUTO_CONNECT_KEY","IS_CONNECTED_KEY","excludedList","RegExp","originalXMLHttpRequestOpen","XMLHttpRequest","networkState","send","isConnecting","isConnected","localStorage","getItem","isNetworkAvailable","isServiceAvailable","blockUrl","block","regExp","test","method","async","user","password","urlSplits","pathIndex","substr","apply","NetworkService","httpClient","app","network","_autoConnect","_isCheckingServer","disableAutoConnect","setAutoConnect","navigator","connection","checkForNetworkStateChange","connect","tryToConnect","disconnect","tryToDisconnect","isAvailable","pingServer","onConnect","defer","cancelSubscription","getAbortableDefer","subscribe","promise","retryIfNetworkFails","retryIfFails","onConnectPromise","abort","onDisconnect","data","checkForServiceAvailiblity","unblock","urlRegex","isEqual","_lastKnownNetworkState","clone","notify","intervalId","setInterval","available","clearInterval","maxTimeout","oReq","baseURL","deployedUrl","timer","status","clearTimeout","Date","flag","setItem","silentMode","App","Network","MobileCoreModule","deviceService","fileCacheService","fileOpener","networkService","addStartupServices","initialized","NgModule","declarations","imports","providers","bootstrap","UploadRequest","_files","_params","_headers","addFile","addHeader","addParam","post","formData","FormData","append","convertToBlob","result","params","setRequestHeader","onload","getResponseHeader","text","responseText","onerror","onabort","DeviceFileUploadService","upload","fileParamName","k","v","ExtAppMessageService","handlers","message","handler","address","pattern","callBack","messageAddressPattern","listener","remove","subString","str","begin","end","undefined","createMessage","extractAddress","extractData","entry","esplits","handleOpenURL","isReady","detail","lastURL"],"mappings":"k3BAcA,IAAYA,GAAAA,EAAAA,EAAAA,WAAAA,EAAAA,SAAQ,KAChB,MAAA,QACAA,EAAA,SAAA,WACAA,EAAA,MAAA,QACAA,EAAA,MAAA,QAGJ,IAAMC,EAAmB,CAAC,MAAO,MAAO,MAAO,MAAO,OAAQ,OAAQ,MAAO,OAAQ,OACjFC,EAAmB,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAC1FC,EAAmB,CAAC,MAAO,MAAO,OAAQ,KAAM,MAAO,OAErDC,EAAuB,CAAC,CAC1BC,KAAO,aACPC,SAAW,CAAC,CACRD,KAAO,QACPC,SAAW,CACP,CACID,KAAO,oBACPE,SAAWP,EAAAA,SAASQ,OAExB,CACIH,KAAO,mBACPE,SAAWP,EAAAA,SAASS,OAExB,CACIJ,KAAO,oBACPE,SAAWP,EAAAA,SAASU,OAExB,CACIL,KAAO,uBACPE,SAAWP,EAAAA,SAASW,eAMpCC,EAAA,WAYI,SAAAA,EAAoBC,EAAuCC,GAAvCC,KAAAF,kBAAAA,EAAuCE,KAAAD,YAAAA,EATpDC,KAAAC,YAAcJ,EAAkBP,KAG/BU,KAAAE,mBAAqB,CACzBC,UAAc,GACdC,WAAe,WAQZP,EAAAQ,UAAAC,kBAAP,SAAyBC,GACrB,OAAIC,EAAAA,aAAeR,KAAKS,iBAAiBF,GAC9B,IAAIG,QAAQ,SAACC,EAASC,GACzBC,QAAQC,QAAQC,mBAAmBC,SAAST,EAAUI,EAASC,KAGhEF,QAAQC,WAGZd,EAAAQ,UAAAY,iBAAP,SAAwBC,EAAkBC,GACtC,IAAIC,EAIJ,OAHAD,EAAaA,GAAc,IAAME,EAAEC,MAGf,GADpBF,GADAF,EAAWA,GAAY,UACLK,MAAM,MACbC,QACPJ,EAAOA,EAAOI,OAAS,GAAKJ,EAAOA,EAAOI,OAAS,GAAKL,EACjDC,EAAOK,KAAK,MAEhBP,EAAWC,GAGftB,EAAAQ,UAAAqB,sBAAP,WACI,OAAO1B,KAAKD,YAAY4B,kBAAkB3B,KAAK4B,uBAAyB5B,KAAK6B,SAAW,IAAK,UAG1FhC,EAAAQ,UAAAyB,KAAP,SAAY1B,EAAqB2B,GAAjC,IAAAC,EAAAhC,KACUiC,EAAiBF,EAAeR,MAAM,KAAKW,MAC7CC,EAAanC,KAAKoC,eAAehC,EAAY6B,GAC7CI,EAAeN,EAAeO,UAAU,EAAGP,EAAeQ,YAAY,MAC1E,OAAOvC,KAAKwC,YAAYL,EAAYF,GAC/BQ,KAAM,SAAAC,GAAgB,OAAAV,EAAKjC,YAAY4C,SAASN,EAAcJ,EAAgBE,EAAYO,GACtFD,KAAK,WAAM,OAAAN,EAAaO,OAG9B7C,EAAAQ,UAAA+B,eAAP,SAAsBhC,EAAqBc,GACvC,IAAM0B,EAAUxC,EAAaJ,KAAKE,mBAAmBE,WAAaJ,KAAKE,mBAAmBC,UAE1F,OAAOyC,EADQ5C,KAAK6C,aAAa3B,KACL0B,EAAQ3D,EAAAA,SAASW,WAG1CC,EAAAQ,UAAAyC,sBAAP,WACI,OAAOjC,QAAQkC,KAAKC,eAGjBnD,EAAAQ,UAAAuB,qBAAP,WACI,OAAOf,QAAQkC,KAAKE,gBAGjBpD,EAAAQ,UAAA6C,mBAAP,WACI,OAAOlD,KAAKmD,YAGTtD,EAAAQ,UAAAI,iBAAP,SAAwBF,GACpB,OAAOA,EAAS6C,WAAWpD,KAAK8C,0BAG7BjD,EAAAQ,UAAAgD,YAAP,SAAmB9C,GACf,IAAI+C,EAAQpC,EACZ,OAAKX,GAGL+C,EAAS/C,EAAS+B,UAAU,EAAG/B,EAASgC,YAAY,KAAO,GAC3DrB,EAAWX,EAASgB,MAAM,KAAKW,MACxBlC,KAAKD,YAAYwD,UAAUD,EAAQpC,GACrCuB,KAAK,WAAM,OAAAlC,KALLG,QAAQE,OAAO,0BAQvBf,EAAAQ,UAAAmD,UAAP,SAAiBF,EAAgBG,GAC7B,OAAO,IAAI/C,QAAQ,SAACC,EAASC,GACzB8C,0BAA0BJ,EAAQ,SAAAK,GACzBA,EAAUC,MAeXjD,EAAQ,IAdRgD,EAAUE,eAAeC,YAAY,SAAAC,GAC7BN,IACAM,EAAUA,EAAQC,OAAO,SAAAC,GAAK,OAAAA,EAAE3E,KAAK4E,MAAMT,MAE/CM,EAAUA,EAAQI,IAAK,SAAAF,GACnB,MAAO,CACH3E,KAAO2E,EAAE3E,KACT8E,YAAcH,EAAEG,YAChBC,KAAOJ,EAAEK,aAGjB3D,EAAQoD,IACTnD,IAIRA,MAIJf,EAAAQ,UAAAmC,YAAP,SAAmBc,EAAgBpC,GAAnC,IAAAc,EAAAhC,KACI,OAAOA,KAAKD,YAAYwD,UAAUD,EAAQpC,GACrCuB,KAAK,WACF,IAAM8B,EAAWrD,EAASqB,YAAY,KAMtC,OAJIrB,EADW,EAAXqD,EACWrD,EAASoB,UAAU,EAAGiC,GAAY,IAAMlD,EAAEC,MAAQ,IAAMJ,EAASoB,UAAUiC,EAAW,GAEtFrD,EAAW,IAAMG,EAAEC,MAE3BU,EAAKQ,YAAYc,EAAQpC,IACjC,WAAM,OAAAA,KAGVrB,EAAAQ,UAAAmE,WAAP,SAAkBjE,GACd,IAAMkE,EAAIlE,EAASgC,YAAY,KAC3BmC,EAAMnE,EAAS+B,UAAU,EAAGmC,GAC5B1B,EAAOxC,EAAS+B,UAAUmC,EAAI,GAClC,OAAOzE,KAAKD,YAAYyE,WAAWE,EAAK3B,IAQrClD,EAAAQ,UAAAsE,UAAP,SAAiBC,GAAjB,IAAA5C,EAAAhC,KACUyE,EAAIG,EAAQrC,YAAY,KAC1BsC,EAAYD,EAAQtC,UAAU,EAAGmC,EAAI,GACrCC,EAAME,EAAQtC,UAAUmC,EAAI,GAC5BK,EAAWJ,EAAMrD,EAAEC,MACvB,OAAOtB,KAAKD,YAAYgF,SAASF,EAAWH,GACvCjC,KAAK,WAMF,OAAOT,EAAKjC,YAAYiF,QAAQH,EAAWH,EAAKG,EAAWC,GACtDrC,KAAK,WAAM,OAAAT,EAAKjC,YAAY4E,UAAUE,EAAWC,OACvDG,SAAMC,EAAAA,OAGVrF,EAAAQ,UAAA8E,MAAP,WAAA,IAAAnD,EAAAhC,KAMI,OADAoF,WAAWC,gBAAkB,OACtB,IAAI3E,QAAQ,SAACC,EAASC,GACzBoB,EAAKlC,kBAAkBwF,aAAa7C,KAAK,SAAA8C,GACrC,IAAMC,EAAW,GASjB,OARAxD,EAAKH,SAAW0D,EAChBC,EAASC,KAAKzD,EAAK0D,wBAAwB1D,EAAKJ,uBAC5CvC,EACA2C,EAAK9B,mBAAmBC,YAC5BqF,EAASC,KAAKzD,EAAK0D,wBAAwB1D,EAAKc,wBAC5CzD,EACA2C,EAAK9B,mBAAmBE,aAC5BoF,EAASC,KAAKzD,EAAK2D,wBACZjF,QAAQkF,IAAIJ,KACpB/C,KAAK,WACJ,GAAIjC,EAAAA,YAEA,OAAOwB,EAAKjC,YAAY8F,WAAWhF,QAAQkC,KAAK+C,sBAAuB,8BAA8Bb,SAAMC,EAAAA,QAEhHzC,KAAK9B,EAASC,MAIjBf,EAAAQ,UAAAqF,wBAAR,SAAgCK,EAAgBC,EAASC,GAAzD,IAAAjE,EAAAhC,KACUkG,EAAgB,GAetB,GAdIF,GACAA,EAAQG,QAAQ,SAAA7C,GACZ,IAAI8C,EACJ9C,EAAOhE,KAAOgE,EAAOhE,KAAK+G,QAAQ,aAAcrE,EAAKH,UACrDuE,EAAaL,EAASzC,EAAOhE,KAAO,IAChCgE,EAAO9D,WAAayG,EAAoB3C,EAAO9D,YAC/CyG,EAAoB3C,EAAO9D,UAAY4G,GAE3C,IAAME,EAAItE,EAAKjC,YAAYwG,UAAUR,EAAQzC,EAAOhE,MAAM,GACrDmD,KAAK,WAAM,OAAAT,EAAK0D,wBAAwBU,EAAY9C,EAAO/D,SAAU0G,IAClE,WAAM,OAAAjE,EAAK0D,wBAAwBU,EAAY9C,EAAO/D,SAAU0G,KACxEC,EAAcT,KAAKa,KAGA,EAAvBJ,EAAc1E,OACd,OAAOd,QAAQkF,IAAIM,IAInBrG,EAAAQ,UAAAwC,aAAR,SAAqB3B,GACjB,IAAIsF,EACJ,GAA4B,EAAxBtF,EAASuF,QAAQ,KAAU,CAE3B,GADAD,EAAYtF,EAASK,MAAM,KAAKW,MAAMwE,cAClCxH,EAAiByH,KAAK,SAAAC,GAAK,OAAAA,IAAMJ,IACjC,OAAOvH,EAAAA,SAASQ,MAEpB,GAAIN,EAAiBwH,KAAK,SAAAC,GAAK,OAAAA,IAAMJ,IACjC,OAAOvH,EAAAA,SAASU,MAEpB,GAAIP,EAAiBuH,KAAK,SAAAC,GAAK,OAAAA,IAAMJ,IACjC,OAAOvH,EAAAA,SAASS,MAGxB,OAAOT,EAAAA,SAASW,UAGZC,EAAAQ,UAAAsF,qBAAR,WAAA,IAAA3D,EAAAhC,KACU6G,EAAiB,UACnBC,EAASjG,QAAQkC,KAAKC,cAC1B,OAAOhD,KAAKD,YAAYgF,SAAS+B,EAAQD,GACpCpE,KAAK,WAAM,OAAAT,EAAKmB,WAAa2D,EAASD,GACnC,WAAM,OAAA7E,EAAKjC,YAAYwG,UAAUO,EAAQD,GAAgB,GACpDpE,KAAK,WAAM,OAAAT,EAAKmB,WAAa2D,EAASD,2BA5N1DE,EAAAA,WAAUC,KAAA,CAAC,CAAEC,WAAY,oDAhDjBC,EAAAA,kBACAC,EAAAA,sJA+CT,GCpCAC,EAAA,WAMI,SAAAA,EACYrH,EACAsH,EACAC,EACDC,GAHCvH,KAAAD,YAAAA,EACAC,KAAAqH,KAAAA,EACArH,KAAAsH,kBAAAA,EACDtH,KAAAuH,0BAAAA,EAPHvH,KAAAwH,eAAiB,GACjBxH,KAAAyH,qBAAuB,SAUxBL,EAAA/G,UAAAqH,SAAP,SAAgBC,EAAaC,EAAuBzF,EAAqB0F,EAAmBC,GACxF,OAAO9H,KAAK+H,mBAAmBJ,EAAKC,EAAczF,EAAY0F,EAAUC,IAIpEV,EAAA/G,UAAA0H,mBAAR,SAA2BJ,EAAaC,EAAuBzF,EAAqB0F,EAAmBC,GAAvG,IAAA9F,EAAAhC,KACI,OAAO,IAAIU,QAAgB,SAACC,EAASC,GACjCoB,EAAKwF,eAAe/B,KAAK,CACrBkC,IAAKA,EACLC,aAAcA,EACdzF,WAAYA,EACZ0F,SAAUA,EACVlH,QAASA,EACTC,OAAQA,EACRkH,iBAAkBA,IAElB9F,EAAKyF,qBAjCY,GAkCjBzF,EAAKgG,kBAKTZ,EAAA/G,UAAA2H,aAAR,WAAA,IAAAhG,EAAAhC,KACI,GAAiC,EAA7BA,KAAKwH,eAAehG,OAAY,CAChC,IAAMyG,EAAMjI,KAAKwH,eAAeU,QAChClI,KAAKmI,aAAaF,GAAKxF,KAAK,SAAAlC,GACxB0H,EAAItH,QAAQJ,GACZyB,EAAKgG,gBACN,WACCC,EAAIrH,SACJoB,EAAKgG,mBAMTZ,EAAA/G,UAAA8H,aAAR,SAAqBC,GAArB,IACQ7H,EAAU8H,EADlBrG,EAAAhC,KAII,OAFAA,KAAKyH,uBAEEzH,KAAKsI,gBAAgBF,EAAIT,IAAKS,EAAIN,kBAAkBrF,KAAK,SAACwB,GAE7D,OADAoE,EAAQpE,EAAyBsE,KAC1BvG,EAAKwG,YAAYvE,EAAGmE,EAAKC,EAAKI,QACtChG,KAAK,SAACvB,GAKL,OAJKkH,EAAIjG,aACLiG,EAAIjG,WAAaH,EAAKsF,kBAAkBlF,eAAegG,EAAIR,aAAc1G,IAE7EX,EAAW6H,EAAIjG,WAAajB,EACrBc,EAAKjC,YAAY2I,UAAUN,EAAIjG,WAAYjB,EAAUmH,KAC7D5F,KAAK,WAEJ,OADAT,EAAKyF,uBACElH,GACR,SAACoI,GAGA,OAFA3G,EAAKyF,uBACLzF,EAAKjC,YAAYyE,WAAW4D,EAAIjG,WAAYiG,EAAIP,UACzCnH,QAAQE,OAAO,yBAAyBwH,EAAIT,IAAG,eAAeiB,KAAKC,UAAUF,OAgBpFvB,EAAA/G,UAAAmI,YAAR,SAAoBG,EAAUP,EAAKU,GAC/B,IAcIC,EAIAC,EAlBEC,EAAcN,EAASO,QAAQC,IAAI,uBACrCC,EAAWhB,EAAIP,SACnB,IAAKuB,GAAYH,IAAsD,IAAvCA,EAAYxC,QAAQ,cAAsB,CACtE,IACM4C,EADgB,yCACQC,KAAKL,GACnB,OAAZI,GAAoBA,EAAQ,KAC5BD,EAAWC,EAAQ,GAAGhD,QAAQ,QAAS,KAG1C+C,IAEDA,GADAA,EAAWhB,EAAIT,IAAIpG,MAAM,KAAK,IACVA,MAAM,KAAKW,OAI/B4G,IACAC,EAAgB/I,KAAKuH,0BAA0BgC,UAAUT,IAIzDzH,EAAEmI,QAAQT,KACVC,EAAmB3H,EAAEoI,KAAKV,EAAe,SAAAvC,GAAa,OAAAnF,EAAEqI,SAASN,EAAU5C,MAE1EwC,GAAqB3H,EAAEqI,SAASN,EAAUL,KAC3CK,GAAsBL,GAG1B,IAAMzF,EAAS8E,EAAIjG,YAAcnC,KAAKsH,kBAAkBlF,eAAegG,EAAIR,aAAcwB,GACzF,OAAOpJ,KAAKsH,kBAAkB9E,YAAYc,EAAQ8F,IAG9ChC,EAAA/G,UAAAiI,gBAAR,SAAwBX,EAAaG,GACjC,IAAMM,EAAM,IAAIuB,EAAAA,YAAY,MAAOhC,EAAK,CACpCiC,aAAc,OACdC,eAAoC,MAApB/B,IAEpB,OAAO9H,KAAKqH,KAAKyC,QAAQ1B,GACpB2B,KACG5F,EAAAA,IAAI,SAAAF,GAIA,OAHI6D,GAAoBA,EAAiBkC,MAAQ/F,EAAEwE,OAASwB,EAAAA,cAAcC,kBACtEpC,EAAiBkC,KAAK/F,GAEnBA,IAEXD,EAAAA,OAAO,SAAAC,GAAK,OAAAA,EAAEwE,OAASwB,EAAAA,cAAcE,WACrChG,EAAAA,IAAK,SAAAF,GAID,OAHI6D,GAAoBA,EAAiBsC,UACrCtC,EAAiBsC,WAEbnG,KAGfoG,iCA1IZtD,EAAAA,WAAUC,KAAA,CAAC,CAAEC,WAAY,oDAXjBE,EAAAA,YAFAmD,EAAAA,kBAQAzK,SAFA0K,EAAAA,6NAOT,GCFMC,EAAwB,gBAE9BC,EAAA,WASI,SAAAA,EAA2B1K,EAChB2K,EACAC,GAFgB3K,KAAAD,YAAAA,EAChBC,KAAA0K,YAAAA,EACA1K,KAAA2K,gBAAAA,EARJ3K,KAAAC,YAAcwK,EAAuBnL,KAEpCU,KAAA4K,YAAc,UAUfH,EAAApK,UAAAwK,SAAP,SAAgBlD,EAAKmD,GACjB9K,KAAK4K,YAAYjD,GAAOmD,EACxB9K,KAAK+K,yBAGFN,EAAApK,UAAA2K,aAAP,SAAoBrD,EAAasD,EAA8BrD,GAA/D,IAAA5F,EAAAhC,KACUO,EAAWP,KAAK4K,YAAYjD,GAClC,OAAO3H,KAAK0K,YAAYrH,YAAY9C,GAC3B0E,SAAM,WAEH,UADOjD,EAAK4I,YAAYjD,GACpBsD,EACA,OAAOjJ,EAAK0F,SAASC,EAAKC,GAE1BlH,QAAQE,OAAO,sBAAwB+G,MAKpD8C,EAAApK,UAAA6K,gBAAP,WACIlL,KAAK4K,YAAc,GACnB5K,KAAK+K,wBACL/K,KAAK0K,YAAYhJ,yBAGd+I,EAAApK,UAAA8E,MAAP,WAAA,IAAAnD,EAAAhC,KACI,OAAOA,KAAKD,YAAY8F,WAAWhF,QAAQkC,KAAKC,cAAewH,GAC1D/H,KAAK,SAAA0I,GACFnJ,EAAK4I,YAAchC,KAAKwC,MAAMD,IAC/BjG,EAAAA,OAGHuF,EAAApK,UAAAqH,SAAR,SAAiBC,EAAaC,GAA9B,IAAA5F,EAAAhC,KACI,OAAOA,KAAK2K,gBAAgBjD,SAASC,EAAKC,GACrCnF,KAAK,SAAAqI,GAGF,OAFA9I,EAAK4I,YAAYjD,GAAOmD,EACxB9I,EAAK+I,wBACED,KAIXL,EAAApK,UAAA0K,sBAAR,WAAA,IAAA/I,EAAAhC,KACSA,KAAKqL,SAmBNrL,KAAKsL,YAAa,GAlBlBtL,KAAKqL,UAAW,EAChBrL,KAAKD,YAAY2I,UAAU7H,QAAQkC,KAAKC,cAAewH,EAAuB5B,KAAKC,UAAU7I,KAAK4K,aAC9F,CACIvE,SAAS,IAEZpB,SAAMC,EAAAA,MACNzC,KAAK,WACET,EAAKsJ,WACLC,WAAW,WACPvJ,EAAKqJ,UAAW,EAChBrJ,EAAKsJ,YAAa,EAClBtJ,EAAK+I,yBACN,KAEH/I,EAAKqJ,UAAW,0BAvEvCtE,EAAAA,WAAUC,KAAA,CAAC,CAAEC,WAAY,oDAZjBE,EAAAA,YAKAtH,SACAuH,oJAMT,gBCSI,SAAAoE,EAAoBzL,EACA0L,EACAf,EACAgB,EACAf,GAJA3K,KAAAD,YAAAA,EACAC,KAAAyL,kBAAAA,EACAzL,KAAA0K,YAAAA,EACA1K,KAAA0L,aAAAA,EACA1L,KAAA2K,gBAAAA,EARb3K,KAAAC,YAAcuL,EAAwBlM,YAatCkM,EAAAnL,UAAAsL,gBAAP,SAAuBpL,GACnB,OAAO,IAAIG,QAAc,SAACC,GAEtB+C,0BAA0BnD,EAAU,SAAAqL,GAChCA,EAAU7I,KAAK,SAAA8I,GACXlL,EAAQkL,EAASpD,aAM1B+C,EAAAnL,UAAAyL,eAAP,SAAsBnE,EAAanB,EAAmBtF,GAAtD,IAAAc,EAAAhC,KACI,OAAOA,KAAKgL,aAAarD,EAAKnB,EAAWtF,GACpCuB,KAAK,SAAAlC,GACF,OAAOyB,EAAK2J,gBAAgBpL,GAAUkC,KAAK,SAAAgG,GACvC,OAAOzG,EAAKyJ,kBAAkBM,KAAKxL,EAAUkI,QAKtD+C,EAAAnL,UAAA8E,MAAP,WAAA,IACQ6G,EADRhK,EAAAhC,KASI,OANIgM,EADAxL,EAAAA,YACkBK,QAAQkC,KAAKkJ,uBACxBC,EAAAA,QACWrL,QAAQkC,KAAKoJ,mBAAqB,WAElCtL,QAAQkC,KAAKC,cAE5BhD,KAAKD,YAAYwG,UAAUyF,EAAiB,aAAa,GAC3D/G,SAAMC,EAAAA,MACNzC,KAAK,WACFT,EAAKoK,iBAAmBJ,EAAkB,gBAI9CR,EAAAnL,UAAAgM,iBAAR,SAAyB1E,EAAanB,GAClC,IAAItF,EAAWyG,EAAIpG,MAAM,KAAK,GAG9B,OAFAL,EAAWA,EAASK,MAAM,KAAKW,MAC/BhB,EAAWlB,KAAK0K,YAAYzJ,iBAAiBC,EAAU,GAAKG,EAAEC,OAC1DkF,EACOtF,EAASK,MAAM,KAAK,GAAK,IAAMiF,EAEnCtF,GAGHsK,EAAAnL,UAAA2K,aAAR,SAAqBrD,EAAanB,EAAoB4C,GAAtD,IAAApH,EAAAhC,KACI,OAAO,IAAIU,QAAS,SAACC,EAASC,GAC1B,OAAOoB,EAAK0J,aAAaV,aAAarD,GAAK,GAAO,GACzClF,KAAM,SAAAlC,GACH,IAAIW,EAAUuD,EAAG6H,EAASC,EAEtBhM,EAAS6C,WAAWpB,EAAKoK,kBACzBzL,EAAQJ,IAERW,EAAWkI,GAAYpH,EAAKqK,iBAAiB1E,EAAKnB,GAClD/B,EAAIlE,EAASgC,YAAY,KACzB+J,EAAU/L,EAAS+B,UAAU,EAAGmC,GAChC8H,EAAWhM,EAAS+B,UAAUmC,EAAI,GAClCzC,EAAKjC,YAAY4C,SAAS2J,EAASC,EAAUvK,EAAKoK,iBAAkBlL,GAC/DuB,KAAK,WACF,IAAM+J,EAAcxK,EAAKoK,iBAAmBlL,EAC5Cc,EAAK0J,aAAab,SAASlD,EAAK6E,GAChC7L,EAAQ6L,QAGrBvH,SAAM,WACLjD,EAAK2I,gBAAgBjD,SAASC,GAAK,EAAO3F,EAAKoK,iBAAkBhD,GAC5D3G,KAAK,SAAAlC,GACFyB,EAAK0J,aAAab,SAASlD,EAAKpH,GAChCI,EAAQJ,IACTK,4BAvF9BmG,EAAAA,WAAUC,KAAA,CAAC,CAAEC,WAAY,oDAdjBE,EAAAA,YACAsF,EAAAA,kBAMA5M,SAFA4K,SACArD,0LCEHsF,EAAqB,gBAE3BC,EAAA,WASI,SAAAA,EAA2B5J,GAA3B,IAAAf,EAAAhC,KAA2BA,KAAA+C,KAAAA,EANnB/C,KAAA4M,UAAY,GACZ5M,KAAA6M,UAAW,EACX7M,KAAA8M,mBAAqB,GACrB9M,KAAA+M,qBAAuB,GACvB/M,KAAAgN,iBAA4C,GAIhDzB,WAAW,WACFvJ,EAAK6K,WACNI,QAAQC,KAAK,6CACbD,QAAQC,KAAK,iBAAkBlL,EAAKgL,iBAAiB7I,IAAI,SAAAM,GAAK,OAAAA,EAAExE,iBAErEkN,KACHC,SAASC,iBAAiB,aAAcrN,KAAKsN,wBAAwBC,KAAKvN,cAGvE2M,EAAAtM,UAAAiN,wBAAP,SAA+BE,GAC3BnM,EAAE8E,QAAQnG,KAAK+M,qBAAsB,SAAAU,GACjC,OAAsB,IAAfA,EAAGD,KAKdE,EAAAA,cAGGf,EAAAtM,UAAAsN,kBAAP,SAAyBC,GACrB5N,KAAKgN,iBAAiBvH,KAAKmI,IAGxBjB,EAAAtM,UAAAwN,gBAAP,SAAuBJ,GAAvB,IAAAzL,EAAAhC,KAEI,OADAA,KAAK+M,qBAAqBe,QAAQL,GAC3B,WACH,IAAMhJ,EAAIzC,EAAK+K,qBAAqBtG,QAAQgH,GACnC,GAALhJ,GACAzC,EAAK+K,qBAAqBgB,OAAOtJ,EAAG,KAKzCkI,EAAAtM,UAAA8E,MAAP,WAAA,IAAAnD,EAAAhC,KACI,OAAIA,KAAK6M,UAA6C,IAAjC7M,KAAKgN,iBAAiBxL,QACvCxB,KAAK6M,UAAW,EACTnM,QAAQC,WAER,IAAID,QAAQ,SAACC,GACZqN,EAAAA,aACAZ,SAASC,iBAAiB,cAAe,WAAM,OAAA1M,MAAW,GAE1DA,MAEL8B,KAAK,WACJ,GAAIwL,OAAgB,QAChB,OAAOjM,EAAKe,KAAK8C,WAAWhF,QAAQkC,KAAKC,cAAe0J,GACnDjK,KAAK,SAAA0I,GAAY,OAAAnJ,EAAK4K,UAAYhE,KAAKwC,MAAMD,IAAUjG,EAAAA,QAEjEzC,KAAK,WACJ,OAAO/B,QAAQkF,IAAI5D,EAAKgL,iBAAiB7I,IAAI,SAAA+J,GACzC,OAAOA,EAAE/I,QAAQF,SAAM,SAACkJ,GAEpB,OADAlB,QAAQkB,MAAM,gCAAiCD,EAAEjO,YAAakO,GACvDzN,QAAQE,OAAOuN,UAG/B1L,KAAK,WACJwL,OAAsB,eAAI,EAC1Bb,SAASgB,cAAc,IAAIC,YAAY,kBACvCrM,EAAKgL,iBAAiBxL,OAAS,EAC/BQ,EAAK8K,mBAAmB3G,QAAQ,SAAAsH,GAAM,OAAAA,MACtCzL,EAAK6K,UAAW,KAKrBF,EAAAtM,UAAAiO,UAAP,WAAA,IAAAtM,EAAAhC,KACI,OAAIA,KAAK6M,SACEnM,QAAQC,UAER,IAAID,QAAc,SAACC,GACtBqB,EAAK8K,mBAAmBrH,KAAK9E,MAQlCgM,EAAAtM,UAAAkO,gBAAP,WACI,OAAOvO,KAAK+C,KAAK8C,WAAWhF,QAAQkC,KAAKyL,qBAAuB,MAAO,eAClE/L,KAAK,SAAAgM,GAAa,OAAC7F,KAAKwC,MAAMqD,GAAoB,aAUpD9B,EAAAtM,UAAAqO,WAAP,SAAkBC,EAAaC,GAE3B,OADA5O,KAAK4M,UAAU+B,GAAOC,EACf5O,KAAK+C,KAAK2F,UAAU7H,QAAQkC,KAAKC,cACpC0J,EACA9D,KAAKC,UAAU7I,KAAK4M,WACpB,CAAEvG,SAAS,KAOZsG,EAAAtM,UAAAwO,SAAP,SAAgBF,GACZ,OAAO3O,KAAK4M,UAAU+B,wBAnH7B5H,EAAAA,WAAUC,KAAA,CAAC,CAAEC,WAAY,oDAVjBE,EAAAA,+HAUT,GCDM2H,EAAmB,iCACrBC,EAAmB,gCACnBC,EAAe,CAAC,IAAIC,OAAO,qBAC3BC,EAA6BC,eAAe9O,UAAU0L,KAEtDqD,GAD6BD,eAAe9O,UAAUgP,KACvC,CACXC,cAAe,EACfC,YAAyD,SAA3CC,aAAaC,QAAQV,GACnCW,oBAAqB,EACrBC,oBAAqB,IASvBC,EAAW,SAAAjI,GACb,IAAIkI,GAAST,EAAaG,aAAelO,EAAE+B,WAAWuE,EAAK,QAI3D,OAHIkI,IACAA,GAASxO,EAAEoI,KAAKuF,EAAc,SAAAc,GAAU,OAAAA,EAAOC,KAAKpI,MAEjDkI,OAIXV,eAAe9O,UAAU0L,KAAO,SAAUiE,EAAgBrI,EAAasI,EAAuBC,EAAeC,GACzG,QADmE,IAAAF,IAAAA,GAAA,GAC/DL,EAASjI,GAAM,CACf,IAAMyI,EAAYzI,EAAIpG,MAAM,OACtB8O,EAAYD,EAAU,GAAG3J,QAAQ,KACvC2J,EAAU,GAAK,aAA2B,EAAZC,EAAgBD,EAAU,GAAGE,OAAOD,GAAa,KAC/E1I,EAAMyI,EAAU3O,KAAK,OAEzB,OAAOyN,EAA2BqB,MAAMvQ,KAAM,CAACgQ,EAAQrI,EAAKsI,EAAOC,EAAMC,KAG7E,IAAAK,EAAA,WASI,SAAAA,EAAoBC,EAAgCC,EAAkBC,GAAtE,IAAA3O,EAAAhC,KAAoBA,KAAAyQ,WAAAA,EAAgCzQ,KAAA0Q,IAAAA,EAAkB1Q,KAAA2Q,QAAAA,EAN/D3Q,KAAAC,YAAcuQ,EAAelR,KAE5BU,KAAA4Q,aAA0D,UAA3CpB,aAAaC,QAAQX,GAEpC9O,KAAA6Q,mBAAoB,EAqBrB7Q,KAAA8Q,mBAAqB,WAAM,OAAA9O,EAAK+O,gBAAe,IAmC/C/Q,KAAAuP,YAAc,WAMjB,OAJIlO,EAAE8H,IAAI6H,UAAW,eAAiBA,UAAUC,WAAWxI,OACvD2G,EAAaG,YAAcH,EAAaG,aAA8C,SAA9ByB,UAAUC,WAAWxI,MAEjFzG,EAAKkP,6BACE9B,EAAaG,aAQjBvP,KAAAsP,aAAe,WAAM,OAAAF,EAAaE,qBA3DlCkB,EAAAnQ,UAAA8Q,QAAP,WAEI,OADAnR,KAAK+Q,gBAAe,GACb/Q,KAAKoR,gBAgBTZ,EAAAnQ,UAAAgR,WAAP,WACI,IAAM/K,EAAItG,KAAKsR,kBAEf,OADAtR,KAAK8Q,qBACExK,GASJkK,EAAAnQ,UAAAkR,YAAP,SAAmBC,GAAnB,IAAAxP,EAAAhC,KACI,YADe,IAAAwR,IAAAA,GAAA,GACXA,EACOxR,KAAK2P,qBAAqBlN,KAAK,WAElC,OADAT,EAAKkP,6BACE9B,EAAaO,qBAGrBP,EAAaO,oBA6BjBa,EAAAnQ,UAAAoR,UAAP,WAAA,IACQC,EACAC,EAFR3P,EAAAhC,KAGI,OAAIA,KAAKuP,cACE7O,QAAQC,WAEnB+Q,EAAQE,EAAAA,oBACRD,EAAqB3R,KAAK0Q,IAAImB,UAAU,uBAAwB,WACxD7P,EAAKuN,gBACLmC,EAAM/Q,SAAQ,GACdgR,OAGRD,EAAMI,QAAQ7M,SAAM,WAChB0M,MAEGD,EAAMI,UAUVtB,EAAAnQ,UAAA0R,oBAAP,SAA2BtE,GAA3B,IAAAzL,EAAAhC,KACU0R,EAAQE,EAAAA,oBAYd,OAXAI,EAAAA,aAAavE,EAAI,EAAG,EAAG,WACnB,IAAIwE,EACJ,OAAKjQ,EAAKuN,gBACN0C,EAAmBjQ,EAAKyP,YACxBC,EAAMI,QAAQ7M,SAAM,WAChBgN,EAAiBC,UAEdD,KAGZxP,KAAKiP,EAAM/Q,QAAS+Q,EAAM9Q,QACtB8Q,EAAMI,SAGVtB,EAAAnQ,UAAA8E,MAAP,WAAA,IAAAnD,EAAAhC,KA0CI,OAzCIiO,OAAgB,SAEZA,OAAmB,YAAK+C,UAAUC,aAClC7B,EAAaM,mBAAmD,SAA9BsB,UAAUC,WAAWxI,KACvD2G,EAAaG,YAAcH,EAAaM,oBAAsBN,EAAaG,YAK3EvP,KAAK2Q,QAAQc,YAAYI,UAAU,WAC/BzC,EAAaM,oBAAqB,EAClC1N,EAAKoP,eAAenM,SAAMC,EAAAA,QAM9BlF,KAAK2Q,QAAQwB,eAAeN,UAAU,WAClCzC,EAAaM,oBAAqB,EAClCN,EAAaO,oBAAqB,EAClC3N,EAAKsP,oBAGTtR,KAAK0Q,IAAImB,UAAU,uBAAwB,SAACO,IAKpCA,EAAK1C,oBAAuB0C,EAAKzC,oBAAuB3N,EAAK6O,oBAC7D7O,EAAK6O,mBAAoB,EACzB7O,EAAKqQ,6BAA6B5P,KAAK,WACnCT,EAAK6O,mBAAoB,EACzB7O,EAAKmP,WACN,WACCnP,EAAK6O,mBAAoB,QAOtC7Q,KAAKoR,cAAa,GAAMnM,SAAMC,EAAAA,OASlCsL,EAAAnQ,UAAAiS,QAAP,SAAeC,GACXvD,EAAavJ,KAAK,IAAIwJ,OAAOsD,KAGzB/B,EAAAnQ,UAAA6Q,2BAAR,WACS7P,EAAEmR,QAAQxS,KAAKyS,uBAAwBrD,KACxCpP,KAAKyS,uBAAyBpR,EAAEqR,MAAMtD,GACtCpP,KAAK0Q,IAAIiC,OAAO,uBAAwB3S,KAAKyS,0BAQ7CjC,EAAAnQ,UAAAgS,2BAAR,WAAA,IAAArQ,EAAAhC,KAEI,OAAO,IAAIU,QAAc,SAAAC,GACrB,IAAMiS,EAAaC,YAAY,WACvBzD,EAAaM,oBACb1N,EAAK2N,mBAJE,MAI6BlN,KAAK,SAAAqQ,GACjCA,IACAC,cAAcH,GACdjS,QAIb,QASH6P,EAAAnQ,UAAAsP,mBAAR,SAA2BqD,GACvB,OAAOhT,KAAKwR,WAAWwB,GAAYvQ,KAAK,SAAAkG,GAMpC,OALAyG,EAAaO,mBAAqBhH,EAC7ByG,EAAaO,qBACdP,EAAaE,cAAe,EAC5BF,EAAaG,aAAc,GAExB5G,KAUP6H,EAAAnQ,UAAAmR,WAAR,SAAmBwB,GAAnB,IAAAhR,EAAAhC,KACI,YADe,IAAAgT,IAAAA,EAAA,KACR,IAAItS,QAAiB,SAAAC,GACxB,IAAMsS,EAAO,IAAI9D,eACb+D,EAAUlR,EAAK0O,IAAIyC,YACnBD,IAAY7R,EAAEqI,SAASwJ,EAAS,KAChCA,GAAW,IAEXA,EAAUA,GAAW,GAGzB,IAAME,EAAQ7H,WAAW,WACrB0H,EAAKf,QACLvR,GAAQ,IACTqS,GAEHC,EAAK5F,iBAAiB,OAAQ,WACN,MAAhB4F,EAAKI,OACL1S,GAAQ,GAERA,GAAQ,GAERyS,GACAE,aAAaF,KAIrBH,EAAK5F,iBAAiB,QAAS,WAAM,OAAA1M,GAAQ,KAC7CsS,EAAKlH,KAAK,MAAOmH,EAAU,0CAA4CK,KAAKjS,OAC5E2R,EAAK5D,UAILmB,EAAAnQ,UAAA0Q,eAAR,SAAuByC,GACnBxT,KAAK4Q,aAAe4C,EACpBhE,aAAaiE,QAAQ3E,EAAkB,GAAK0E,IAWxChD,EAAAnQ,UAAA+Q,aAAR,SAAqBsC,GAArB,IAAA1R,EAAAhC,KACI,YADiB,IAAA0T,IAAAA,GAAA,GACV,IAAIhT,QAAiB,SAACC,EAASC,GAClCoB,EAAK2N,mBAAmB,KAAMlN,KAAK,WAC3B2M,EAAaO,oBAAsB3N,EAAK4O,cACxCxB,EAAaE,cAAe,EACvBoE,GACD1R,EAAKkP,6BAET3F,WAAW,WACP6D,EAAaE,cAAe,EAC5BF,EAAaG,aAAc,EAC3BC,aAAaiE,QAAQ1E,EAAkB,IAAK,GACvC2E,GACD1R,EAAKkP,6BAETvQ,GAAQ,IACT+S,EAAa,EAAI,OAEpBtE,EAAaE,cAAe,EAC5BF,EAAaG,aAAc,EAC3BC,aAAaiE,QAAQ1E,EAAkB,IAAK,GAC5CnO,IACAoB,EAAKkP,mCAMbV,EAAAnQ,UAAAiR,gBAAR,WAKI,OAJAlC,EAAaG,aAAc,EAC3BH,EAAaE,cAAe,EAC5BtP,KAAKkR,6BACL1B,aAAaiE,QAAQ1E,EAAkB,GAAKK,EAAaG,aAClD7O,QAAQC,QAAQyO,EAAaG,kCApT3CxI,EAAAA,WAAUC,KAAA,CAAC,CAAEC,WAAY,oDA/CjBqD,EAAAA,kBAIAqJ,EAAAA,WAFAC,EAAAA,4KA6CT,gBCVI,SAAAC,EACIC,EACAxM,EACAyM,EACAC,EACAC,GAEAJ,EAAiBK,mBAAmBJ,EAAexM,EAAoByM,EAAkBC,EAAYC,GAE7G,OA1BWJ,EAAAK,mBAAP,SAA0BJ,EACRxM,EACAyM,EACAC,EACAC,GACVjU,KAAKmU,cAGTL,EAAcnG,kBAAkBsG,GAC5BjG,EAAAA,eACA8F,EAAcnG,kBAAkBrG,GAChCwM,EAAcnG,kBAAkBoG,GAChCD,EAAcnG,kBAAkBqG,IAEpChU,KAAKmU,aAAc,IAhBhBN,EAAAM,aAAc,sBATxBC,EAAAA,SAAQpN,KAAA,CAAC,CACNqN,aAAc,GACdC,QAAS,GACTC,UAAW,GAGXC,UAAW,gDATN7H,SADA9M,SAFA4K,SACAe,SAGAgF,KAuCTqD,kBC3BI,SAAAY,EAAqB9M,EAAqB5H,GAArBC,KAAA2H,IAAAA,EAAqB3H,KAAAD,YAAAA,EAJlCC,KAAA0U,OAAS,GACT1U,KAAA2U,QAAU,GACV3U,KAAA4U,SAAW,GAiEvB,OA3DWH,EAAApU,UAAAwU,QAAP,SAAevV,EAAc+E,EAAc+E,GAMvC,OALApJ,KAAK0U,OAAOjP,KAAK,CACbnG,KAAMA,EACN+E,KAAMA,EACNnD,SAAUkI,IAEPpJ,MAGJyU,EAAApU,UAAAyU,UAAP,SAAiBxV,EAAcsP,GAK3B,OAJA5O,KAAK4U,SAASnP,KAAK,CACfnG,KAAMA,EACNsP,MAAOA,IAEJ5O,MAGJyU,EAAApU,UAAA0U,SAAP,SAAgBzV,EAAcsP,GAK1B,OAJA5O,KAAK2U,QAAQlP,KAAK,CACdnG,KAAMA,EACNsP,MAAOA,IAEJ5O,MAGJyU,EAAApU,UAAA2U,KAAP,WAAA,IAAAhT,EAAAhC,KACUiV,EAAW,IAAIC,SAErB,OADAlV,KAAK2U,QAAQxO,QAAS,SAAAlC,GAAK,OAAAgR,EAASE,OAAOlR,EAAE3E,KAAM2E,EAAE2K,SAC9ClO,QAAQkF,IAAI5F,KAAK0U,OAAOvQ,IAAK,SAAAF,GAChC,OAAIA,EAAEI,KACK+Q,EAAAA,cAAcnR,EAAEI,MAClB5B,KAAK,SAAA4S,GACF,MAAO,CACH/V,KAAM2E,EAAE3E,KACR4B,SAAU+C,EAAE/C,SACZmH,KAAMgN,EAAOhN,QAItBpE,KACPxB,KAAK,SAAA6S,GAEL,OADAA,EAAOnP,QAAQ,SAAAlC,GAAK,OAAAgR,EAASE,OAAOlR,EAAE3E,KAAM2E,EAAEoE,MAAQpE,EAAEI,KAAMJ,EAAE/C,YACzD,IAAIR,QAAyB,SAACC,EAASC,GAC1C,IAAMkJ,EAAU,IAAIqF,eACpBrF,EAAQiC,KAAK,OAAQ/J,EAAK2F,KAC1B3F,EAAK4S,SAASzO,QAAQ,SAAAlC,GAAK,OAAA6F,EAAQyL,iBAAiBtR,EAAE3E,KAAM2E,EAAE2K,SAC9D9E,EAAQ0L,OAAS,WACb7U,EAAQ,CACJuI,QAAS,SAAC5J,GAAiB,OAAAwK,EAAQ2L,kBAAkBnW,IACrDqJ,SAAUmB,EAAQnB,SAClB+M,KAAM5L,EAAQ6L,gBAGtB7L,EAAQ8L,QAAUhV,EAClBkJ,EAAQ+L,QAAUjV,EAClBkJ,EAAQuF,KAAK4F,QAI7BR,kBAKI,SAAAqB,EAAoB/V,GAAAC,KAAAD,YAAAA,SAEb+V,EAAAzV,UAAA0V,OAAP,SAAcpO,EAAaqO,EAAuB3R,EAAcnD,EAAmBoU,EAAcpM,GAC7F,IAAMd,EAAM,IAAIqM,EAAc9M,EAAK3H,KAAKD,aACnC8U,QAAQmB,EAAe3R,EAAMnD,GAGlC,OAFAG,EAAE8E,QAAQmP,EAAQ,SAACW,EAAGC,GAAM,OAAA9N,EAAI2M,SAASkB,EAAGC,KAC5C7U,EAAE8E,QAAQ+C,EAAS,SAAC+M,EAAGC,GAAM,OAAA9N,EAAI0M,UAAUmB,EAAGC,KACvC9N,EAAI4M,4BAVlBjO,EAAAA,WAAUC,KAAA,CAAC,CAAEC,WAAY,oDAnFjBE,EAAAA,+ICmBL,SAAAgP,EAAoBzF,GAApB,IAAA1O,EAAAhC,KAAoBA,KAAA0Q,IAAAA,EAFZ1Q,KAAAoW,SAAW,GAGfhJ,SAASC,iBAAiB,6BAA8B,SAAApJ,GACpD,IAAMoS,EAAWpS,EAAU,OAAS,QACpCjC,EAAKoU,SAASjQ,QAAQ,SAAAmQ,GAClB,IAAMjN,EAAUiN,GAAWD,EAAQE,QAAQrS,MAAMoS,EAAQE,SACrDnN,GAA4B,EAAjBA,EAAQ7H,QACnB8U,EAAQG,SAASJ,cAc1BF,EAAA9V,UAAAwR,UAAP,SAAiB6E,EAAuBC,GAAxC,IAAA3U,EAAAhC,KACUsW,EAAU,CACZE,QAAU,IAAIvH,OAAOyH,GACrBD,SAAWE,GAGf,OADA3W,KAAKoW,SAAS3Q,KAAK6Q,GACZ,WAAM,OAAAjV,EAAEuV,OAAO5U,EAAKoU,SAAUE,yBA/B5CvP,EAAAA,WAAUC,KAAA,CAAC,CAAEC,WAAY,oDAdjB0M,EAAAA,iIAkDR,SAAU1F,EAAQb,GAGf,SAASyJ,EAAUC,EAAKC,EAAOC,GAE3B,OADAA,EAAMA,EAAM,EAAIC,UAAYD,EACpBF,GAAgB,GAATC,GAAcD,EAAItV,OAASuV,GAASD,EAAIxU,UAAUyU,EAAOC,IAASC,UAErF,SAASxQ,EAAQqQ,EAAKN,GAClB,OAAOM,GAAOA,EAAIrQ,QAAQ+P,GAc9B,SAASU,EAAcvP,GACnB,MAAO,CACH4O,QALR,SAASY,EAAexP,GACpB,OAAOkP,EAAUlP,EAAKlB,EAAQkB,EAAK,OAAS,EAAGlB,EAAQkB,EAAK,MAI7CwP,CAAexP,GAC1ByK,KAfR,SAASgF,EAAYzP,GACjB,IAAMmP,EAAMD,EAAUlP,EAAKlB,EAAQkB,EAAK,KAAO,EAAGlB,EAAQkB,EAAK,MAC3DyK,EAAO,GAKX,OAJA/Q,EAAE8E,QAAQ9E,EAAEE,MAAMuV,EAAK,KAAM,SAAAO,GACzB,IAAMC,EAAUD,EAAM9V,MAAM,KAC5B6Q,EAAKkF,EAAQ,IAAMA,EAAQ,KAExBlF,EAQKgF,CAAYzP,IAG5BsG,EAAsB,cAAI,SAAUtG,GAChC,IAAM4P,EAAgBtJ,EAAsB,cAC5C,GAAIsJ,EAAcC,UAAYnW,EAAE+B,WAAWuE,EAAK,QAAS,CACrD,IAAM0O,EAAUa,EAAcvP,GACxB1D,EAAI,IAAIgK,EAAoB,YAAE,6BAA8B,CAC9DwJ,OAAU,CACNpB,QAAWA,KAGnBjJ,EAASgB,cAAcnK,GAE3BsT,EAAcG,QAAU/P,GAvChC,CAyCEsG,OAAQb","sourcesContent":["import { Injectable } from '@angular/core';\n\nimport { AppVersion } from '@ionic-native/app-version';\nimport { File } from '@ionic-native/file';\n\nimport { isAndroid, noop } from '@wm/core';\n\nimport { IDeviceStartUpService } from './device-start-up-service';\n\ndeclare const _;\ndeclare const cordova;\ndeclare const resolveLocalFileSystemURL;\ndeclare const FileReader;\n\nexport enum FileType {\n    AUDIO = 'AUDIO',\n    DOCUMENT = 'DOCUMENT',\n    IMAGE = 'IMAGE',\n    VIDEO = 'VIDEO'\n}\n\nconst IMAGE_EXTENSIONS = ['gif', 'jpg', 'png', 'svg', 'webp', 'jpeg', 'jif', 'jfif', 'jfi'],\n    VIDEO_EXTENSIONS = ['mp4', 'mpg', 'avi', 'wma', 'mp2', '3gp', '3g2', 'm4p', 'm4v', 'mpg', 'fiv'],\n    AUDIO_EXTENSIONS = ['mp3', 'm4p', 'aiff', 'aa', 'aax', 'wma'];\n\nconst APP_FOLDER_STRUCTURE = [{\n    name : '{APP_NAME}',\n    children : [{\n        name : 'Media',\n        children : [\n            {\n                name : '{APP_NAME} Images',\n                fileType : FileType.IMAGE\n            },\n            {\n                name : '{APP_NAME} Audio',\n                fileType : FileType.AUDIO\n            },\n            {\n                name : '{APP_NAME} Vedios',\n                fileType : FileType.VIDEO\n            },\n            {\n                name : '{APP_NAME} Documents',\n                fileType : FileType.DOCUMENT\n            }\n        ]\n    }]\n}];\n\n@Injectable({ providedIn: 'root' })\nexport class DeviceFileService implements IDeviceStartUpService {\n\n    public serviceName = DeviceFileService.name;\n\n    private _appName: string;\n    private _fileTypeVsPathMap = {\n        'temporary' : {},\n        'persistent' : {}\n    };\n    private _uploadDir: string;\n\n    constructor(private cordovaAppVersion: AppVersion, private cordovaFile: File) {\n\n    }\n\n    public addMediaToGallery(filePath: string): Promise<void> {\n        if (isAndroid() && this.isPersistentType(filePath)) {\n            return new Promise((resolve, reject) => {\n                cordova.plugins.MediaScannerPlugin.scanFile(filePath, resolve, reject);\n            });\n        }\n        return Promise.resolve();\n    }\n\n    public appendToFileName(fileName: string, attachment?: string): string {\n        let splits;\n        attachment = attachment || '_' + _.now();\n        fileName = fileName || 'noname';\n        splits = fileName.split('.');\n        if (splits.length > 1) {\n            splits[splits.length - 2] = splits[splits.length - 2] + attachment;\n            return splits.join('.');\n        }\n        return fileName + attachment;\n    }\n\n    public clearTemporaryStorage(): Promise<any> {\n        return this.cordovaFile.removeRecursively(this.getTemporaryRootPath() + this._appName + '/', 'Media');\n    }\n\n    public copy(persistent: boolean, sourceFilePath: string) {\n        const sourceFilename = sourceFilePath.split('/').pop(),\n            destFolder = this.findFolderPath(persistent, sourceFilename),\n            sourceFolder = sourceFilePath.substring(0, sourceFilePath.lastIndexOf('/'));\n        return this.newFileName(destFolder, sourceFilename)\n            .then( destFilename => this.cordovaFile.copyFile(sourceFolder, sourceFilename, destFolder, destFilename)\n                .then(() => destFolder + destFilename));\n    }\n\n    public findFolderPath(persistent: boolean, fileName: string) {\n        const typeMap = persistent ? this._fileTypeVsPathMap.persistent : this._fileTypeVsPathMap.temporary,\n            fileType = this.findFileType(fileName);\n        return typeMap[fileType] || typeMap[FileType.DOCUMENT];\n    }\n\n    public getPersistentRootPath(): string {\n        return cordova.file.dataDirectory;\n    }\n\n    public getTemporaryRootPath(): string {\n        return cordova.file.cacheDirectory;\n    }\n\n    public getUploadDirectory(): string {\n        return this._uploadDir;\n    }\n\n    public isPersistentType(filePath: string): boolean {\n        return filePath.startsWith(this.getPersistentRootPath());\n    }\n\n    public isValidPath(filePath: string): Promise<string> {\n        let folder, fileName;\n        if (!filePath) {\n            return Promise.reject('File path is required');\n        }\n        folder = filePath.substring(0, filePath.lastIndexOf('/') + 1);\n        fileName = filePath.split('/').pop();\n        return this.cordovaFile.checkFile(folder, fileName)\n            .then(() => filePath);\n    }\n\n    public listFiles(folder: string, search: string | RegExp): Promise<Map<string, any>[]> {\n        return new Promise((resolve, reject) => {\n            resolveLocalFileSystemURL(folder, directory => {\n                if (!directory.files) {\n                    directory.createReader().readEntries(entries => {\n                        if (search) {\n                            entries = entries.filter(e => e.name.match(search));\n                        }\n                        entries = entries.map( e => {\n                            return {\n                                name : e.name,\n                                isDirectory : e.isDirectory,\n                                path : e.nativeURL\n                            };\n                        });\n                        resolve(entries);\n                    }, reject);\n                } else {\n                    resolve([]);\n                }\n            }, reject);\n        });\n    }\n\n    public newFileName(folder: string, fileName: string): Promise<string> {\n        return this.cordovaFile.checkFile(folder, fileName)\n            .then(() => {\n                const extIndex = fileName.lastIndexOf('.');\n                if (extIndex > 0) {\n                    fileName = fileName.substring(0, extIndex) + '_' + _.now() + '.' + fileName.substring(extIndex + 1);\n                } else {\n                    fileName = fileName + '_' + _.now();\n                }\n                return this.newFileName(folder, fileName);\n            }, () => fileName);\n    }\n\n    public removeFile(filePath: string): Promise<any> {\n        const i = filePath.lastIndexOf('/'),\n            dir = filePath.substring(0, i),\n            file = filePath.substring(i + 1);\n        return this.cordovaFile.removeFile(dir, file);\n    }\n\n    /**\n     * removes the directory at the specified location.\n     *\n     * @param dirPath absolute path of directory\n     */\n    public removeDir(dirPath: string): Promise<any> {\n        const i = dirPath.lastIndexOf('/'),\n            parentdir = dirPath.substring(0, i + 1),\n            dir = dirPath.substring(i + 1),\n            movedDir = dir + _.now();\n        return this.cordovaFile.checkDir(parentdir, dir)\n            .then(() => {\n                /**\n                 * If folder is remove directly without moving, then INVALID_MODIFICATION_ERR is thrown in android\n                 * when a copy operation is done with the same directory name. To avoid this, directory will be moved\n                 * first and removed.\n                 */\n                return this.cordovaFile.moveDir(parentdir, dir, parentdir, movedDir)\n                    .then(() => this.cordovaFile.removeDir(parentdir, movedDir));\n            }).catch(noop);\n    }\n\n    public start(): Promise<any> {\n        /**\n         * Default READ_CHUNK_SIZE is 256 Kb. But with that setting readJson method is failing. This is an issue\n         * with cordova file plugin. So, increasing it to 512 Kb to read large database schema files (>256 Kb).\n         */\n        FileReader.READ_CHUNK_SIZE = 512 * 1024;\n        return new Promise((resolve, reject) => {\n            this.cordovaAppVersion.getAppName().then(appName => {\n                const promises = [];\n                this._appName = appName;\n                promises.push(this.createFolderIfNotExists(this.getTemporaryRootPath(),\n                    APP_FOLDER_STRUCTURE,\n                    this._fileTypeVsPathMap.temporary));\n                promises.push(this.createFolderIfNotExists(this.getPersistentRootPath(),\n                    APP_FOLDER_STRUCTURE,\n                    this._fileTypeVsPathMap.persistent));\n                promises.push(this.setupUploadDirectory());\n                return Promise.all(promises);\n            }).then(() => {\n                if (isAndroid()) {\n                    // this is necessary to prevent multiple file permission popup.\n                    return this.cordovaFile.readAsText(cordova.file.externalRootDirectory, 'random-file-for-permission').catch(noop);\n                }\n            }).then(resolve, reject);\n        });\n    }\n\n    private createFolderIfNotExists(parent: string, folders, fileTypeLocationMap) {\n        const childPromises = [];\n        if (folders) {\n            folders.forEach(folder => {\n                let folderPath;\n                folder.name = folder.name.replace('{APP_NAME}', this._appName);\n                folderPath = parent + folder.name + '/';\n                if (folder.fileType && !fileTypeLocationMap[folder.fileType]) {\n                    fileTypeLocationMap[folder.fileType] = folderPath;\n                }\n                const p = this.cordovaFile.createDir(parent, folder.name, false)\n                    .then(() => this.createFolderIfNotExists(folderPath, folder.children, fileTypeLocationMap),\n                        () => this.createFolderIfNotExists(folderPath, folder.children, fileTypeLocationMap));\n                childPromises.push(p);\n            });\n        }\n        if (childPromises.length > 0) {\n            return Promise.all(childPromises);\n        }\n    }\n\n    private findFileType(fileName) {\n        let extension;\n        if (fileName.indexOf('.') > 0) {\n            extension = fileName.split('.').pop().toLowerCase();\n            if (IMAGE_EXTENSIONS.some(a => a === extension)) {\n                return FileType.IMAGE;\n            }\n            if (VIDEO_EXTENSIONS.some(a => a === extension)) {\n                return FileType.VIDEO;\n            }\n            if (AUDIO_EXTENSIONS.some(a => a === extension)) {\n                return FileType.AUDIO;\n            }\n        }\n        return FileType.DOCUMENT;\n    }\n\n    private setupUploadDirectory() {\n        const uploadsDirName = 'uploads',\n            appDir = cordova.file.dataDirectory;\n        return this.cordovaFile.checkDir(appDir, uploadsDirName)\n            .then(() => this._uploadDir = appDir + uploadsDirName,\n                () => this.cordovaFile.createDir(appDir, uploadsDirName, true)\n                    .then(() => this._uploadDir = appDir + uploadsDirName));\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { HttpClient, HttpEvent, HttpEventType, HttpRequest, HttpResponse } from '@angular/common/http';\n\nimport { File } from '@ionic-native/file';\nimport { Observer } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\nimport { FileExtensionFromMimePipe } from '@wm/components';\n\nimport { DeviceFileService } from './device-file.service';\n\nconst MAX_CONCURRENT_DOWNLOADS = 2;\ndeclare const _;\n\n@Injectable({ providedIn: 'root' })\nexport class DeviceFileDownloadService {\n\n    private _downloadQueue = [];\n    private _concurrentDownloads = 0;\n\n    constructor(\n        private cordovaFile: File,\n        private http: HttpClient,\n        private deviceFileService: DeviceFileService,\n        public fileExtensionFromMimePipe: FileExtensionFromMimePipe) {\n\n    }\n\n    public download(url: string, isPersistent: boolean, destFolder?: string, destFile?: string, progressObserver?: Observer<any>): Promise<string> {\n        return this.addToDownloadQueue(url, isPersistent, destFolder, destFile, progressObserver);\n    }\n\n    // Adds to download request queue\n    private addToDownloadQueue(url: string, isPersistent: boolean, destFolder?: string, destFile?: string, progressObserver?: Observer<any>): Promise<string> {\n        return new Promise<string>((resolve, reject) => {\n            this._downloadQueue.push({\n                url: url,\n                isPersistent: isPersistent,\n                destFolder: destFolder,\n                destFile: destFile,\n                resolve: resolve,\n                reject: reject,\n                progressObserver: progressObserver\n            });\n            if (this._concurrentDownloads < MAX_CONCURRENT_DOWNLOADS) {\n                this.downloadNext();\n            }\n        });\n    }\n\n    private downloadNext(): void {\n        if (this._downloadQueue.length > 0) {\n            const req = this._downloadQueue.shift();\n            this.downloadFile(req).then(filePath => {\n                req.resolve(filePath);\n                this.downloadNext();\n            }, () => {\n                req.reject();\n                this.downloadNext();\n            });\n        }\n    }\n\n    // Start processing a download request\n    private downloadFile(req): Promise<string> {\n        let filePath, blob;\n        this._concurrentDownloads++;\n\n        return this.sendHttpRequest(req.url, req.progressObserver).then((e) => {\n            blob = (e as HttpResponse<Blob>).body;\n            return this.getFileName(e, req, blob.type);\n        }).then((fileName) => {\n            if (!req.destFolder) {\n                req.destFolder = this.deviceFileService.findFolderPath(req.isPersistent, fileName);\n            }\n            filePath = req.destFolder + fileName;\n            return this.cordovaFile.writeFile(req.destFolder, fileName, blob);\n        }).then(() => {\n            this._concurrentDownloads--;\n            return filePath;\n        }, (response) => {\n            this._concurrentDownloads--;\n            this.cordovaFile.removeFile(req.destFolder, req.destFile);\n            return Promise.reject(`Failed to downloaded  ${req.url} with error ${JSON.stringify(response)}`);\n        });\n    }\n\n    /**\n     * Returns the filename\n     * 1. if filename exists just return\n     * 2. retrieve the filename from response headers i.e. content-disposition\n     * 3. pick the filename from the end of the url\n     * If filename doesnt contain the extension then extract using mimeType.\n     * Generates newFileName if filename already exists.\n     * @param response, download file response\n     * @param req, download request params\n     * @param mimeType mime type of file\n     * @returns {Promise<string>}\n     */\n    private getFileName(response, req, mimeType) {\n        const disposition = response.headers.get('Content-Disposition');\n        let filename = req.destFile;\n        if (!filename && disposition && disposition.indexOf('attachment') !== -1) {\n            const filenameRegex = /filename[^;=\\n]*=((['\"]).*?\\2|[^;\\n]*)/;\n            const matches = filenameRegex.exec(disposition);\n            if (matches !== null && matches[1]) {\n                filename = matches[1].replace(/['\"]/g, '');\n            }\n        }\n        if (!filename) {\n            filename = req.url.split('?')[0];\n            filename = filename.split('/').pop();\n        }\n\n        let fileExtension;\n        if (mimeType) {\n            fileExtension = this.fileExtensionFromMimePipe.transform(mimeType);\n        }\n        let hasFileExtension;\n        // one or more file extensions can have same mimeType then loop over the file extensions.\n        if (_.isArray(fileExtension)) {\n            hasFileExtension = _.find(fileExtension, extension => _.endsWith(filename, extension));\n        }\n        if (!hasFileExtension && !_.endsWith(filename, fileExtension)) {\n            filename = filename + fileExtension;\n        }\n\n        const folder = req.destFolder || this.deviceFileService.findFolderPath(req.isPersistent, filename);\n        return this.deviceFileService.newFileName(folder, filename);\n    }\n\n    private sendHttpRequest(url: string, progressObserver: Observer<HttpEvent<any>>): Promise<HttpResponse<any>> {\n        const req = new HttpRequest('GET', url, {\n            responseType: 'blob',\n            reportProgress: progressObserver != null\n        });\n        return this.http.request(req)\n            .pipe(\n                map(e => {\n                    if (progressObserver && progressObserver.next && e.type === HttpEventType.DownloadProgress) {\n                        progressObserver.next(e);\n                    }\n                    return e;\n                }),\n                filter(e => e.type === HttpEventType.Response),\n                map( e => {\n                    if (progressObserver && progressObserver.complete) {\n                        progressObserver.complete();\n                    }\n                    return (e as HttpResponse<any>);\n                })\n            )\n            .toPromise();\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { File } from '@ionic-native/file';\n\nimport { noop } from '@wm/core';\n\nimport { IDeviceStartUpService } from './device-start-up-service';\nimport { DeviceFileService } from './device-file.service';\nimport { DeviceFileDownloadService } from './device-file-download.service';\n\ndeclare const cordova;\n\nconst CACHE_FILE_INDEX_NAME = 'appCache.json';\n\n@Injectable({ providedIn: 'root' })\nexport class DeviceFileCacheService implements IDeviceStartUpService {\n\n    public serviceName = DeviceFileCacheService.name;\n\n    private _cacheIndex = {};\n    private _writing;\n    private _saveCache;\n\n    public constructor(private cordovaFile: File,\n       private fileService: DeviceFileService,\n       private downloadService: DeviceFileDownloadService) {\n\n    }\n\n    public addEntry(url, filepath): void {\n        this._cacheIndex[url] = filepath;\n        this.writeCacheIndexToFile();\n    }\n\n    public getLocalPath(url: string, downloadIfNotExists: boolean, isPersistent: boolean): Promise<string> {\n        const filePath = this._cacheIndex[url];\n        return this.fileService.isValidPath(filePath)\n                .catch(() => {\n                    delete this._cacheIndex[url];\n                    if (downloadIfNotExists) {\n                        return this.download(url, isPersistent);\n                    } else {\n                        Promise.reject('No cache entry for ' + url);\n                    }\n                });\n    }\n\n    public invalidateCache(): void {\n        this._cacheIndex = {};\n        this.writeCacheIndexToFile();\n        this.fileService.clearTemporaryStorage();\n    }\n\n    public start(): Promise<void> {\n        return this.cordovaFile.readAsText(cordova.file.dataDirectory, CACHE_FILE_INDEX_NAME)\n            .then(content => {\n                this._cacheIndex = JSON.parse(content);\n            }, noop);\n    }\n\n    private download(url: string, isPersistent: boolean): Promise<string> {\n        return this.downloadService.download(url, isPersistent)\n            .then(filepath => {\n                this._cacheIndex[url] = filepath;\n                this.writeCacheIndexToFile();\n                return filepath;\n            });\n    }\n\n    private writeCacheIndexToFile(): void {\n        if (!this._writing) {\n            this._writing = true;\n            this.cordovaFile.writeFile(cordova.file.dataDirectory, CACHE_FILE_INDEX_NAME, JSON.stringify(this._cacheIndex),\n                {\n                    replace: true\n                })\n                .catch(noop)\n                .then(() => {\n                    if (this._saveCache) {\n                        setTimeout(() => {\n                            this._writing = false;\n                            this._saveCache = false;\n                            this.writeCacheIndexToFile();\n                        }, 5000);\n                    } else {\n                        this._writing = false;\n                    }\n                });\n        } else {\n            this._saveCache = true;\n        }\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { File } from '@ionic-native/file';\nimport { FileOpener } from '@ionic-native/file-opener';\n\nimport { isAndroid, isIos, noop } from '@wm/core';\n\nimport { DeviceFileCacheService } from './device-file-cache.service';\nimport { DeviceFileDownloadService } from './device-file-download.service';\nimport { DeviceFileService } from './device-file.service';\nimport { IDeviceStartUpService } from './device-start-up-service';\n\ndeclare const cordova;\ndeclare const _;\ndeclare const resolveLocalFileSystemURL;\n\n@Injectable({ providedIn: 'root' })\nexport class DeviceFileOpenerService implements IDeviceStartUpService {\n\n    public serviceName = DeviceFileOpenerService.name;\n\n    private _downloadsFolder;\n\n    constructor(private cordovaFile: File,\n                private cordovaFileOpener: FileOpener,\n                private fileService: DeviceFileService,\n                private cacheService: DeviceFileCacheService,\n                private downloadService: DeviceFileDownloadService) {\n\n    }\n\n    // this method returns the mime type of file from the filePath.\n    public getFileMimeType(filePath): Promise<any> {\n        return new Promise<any> ((resolve) => {\n            // Read the file entry from the file URL\n            resolveLocalFileSystemURL(filePath, fileEntry => {\n                fileEntry.file(metadata => {\n                    resolve(metadata.type);\n                });\n            });\n        });\n    }\n\n    public openRemoteFile(url: string, extension: string, fileName?: string): Promise<void> {\n        return this.getLocalPath(url, extension, fileName)\n            .then(filePath => {\n                return this.getFileMimeType(filePath).then(type => {\n                    return this.cordovaFileOpener.open(filePath, type);\n                });\n            });\n    }\n\n    public start(): Promise<void> {\n        let downloadsParent;\n        if (isAndroid()) {\n            downloadsParent = cordova.file.externalCacheDirectory;\n        } else if (isIos()) {\n            downloadsParent = cordova.file.documentsDirectory + 'NoCloud/';\n        } else {\n            downloadsParent = cordova.file.dataDirectory;\n        }\n        return this.cordovaFile.createDir(downloadsParent, 'downloads', false)\n            .catch(noop)\n            .then(() => {\n                this._downloadsFolder = downloadsParent + 'downloads/';\n            });\n    }\n\n    private generateFileName(url: string, extension: string): string {\n        let fileName = url.split('?')[0];\n        fileName = fileName.split('/').pop();\n        fileName = this.fileService.appendToFileName(fileName, '' + _.now());\n        if (extension) {\n            return fileName.split('.')[0] + '.' + extension;\n        }\n        return fileName;\n    }\n\n    private getLocalPath(url: string, extension?: string, filename?: string): Promise<string> {\n        return new Promise( (resolve, reject) => {\n            return this.cacheService.getLocalPath(url, false, false)\n                    .then( filePath => {\n                        let fileName, i, fromDir, fromFile;\n                        // Is it part of downloaded folder.\n                        if (filePath.startsWith(this._downloadsFolder)) {\n                            resolve(filePath);\n                        } else {\n                            fileName = filename || this.generateFileName(url, extension);\n                            i = filePath.lastIndexOf('/');\n                            fromDir = filePath.substring(0, i);\n                            fromFile = filePath.substring(i + 1);\n                            this.cordovaFile.copyFile(fromDir, fromFile, this._downloadsFolder, fileName)\n                                .then(() => {\n                                    const newFilePath = this._downloadsFolder + fileName;\n                                    this.cacheService.addEntry(url, newFilePath);\n                                    resolve(newFilePath);\n                                });\n                        }\n                    }).catch(() => {\n                        this.downloadService.download(url, false, this._downloadsFolder, filename)\n                            .then(filePath => {\n                                this.cacheService.addEntry(url, filePath);\n                                resolve(filePath);\n                            }, reject);\n                    });\n        });\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { File } from '@ionic-native/file';\n\nimport { $appDigest, hasCordova, noop } from '@wm/core';\n\nimport { IDeviceStartUpService } from './device-start-up-service';\n\ndeclare const cordova, _;\n\nconst REGISTRY_FILE_NAME = 'registry.info';\n\n@Injectable({ providedIn: 'root' })\nexport class DeviceService {\n\n    private _registry = {};\n    private _isReady = false;\n    private _whenReadyPromises = [];\n    private _backBtnTapListeners = [];\n    private _startUpServices: IDeviceStartUpService[] = [];\n\n    public constructor(private file: File) {\n        const maxWaitTime = 10;\n        setTimeout(() => {\n            if (!this._isReady) {\n                console.warn(`Device is not ready even after ${maxWaitTime} seconds`);\n                console.warn('Waiting For %O', this._startUpServices.map(i => i.serviceName));\n            }\n        }, maxWaitTime * 1000);\n        document.addEventListener('backbutton', this.executeBackTapListeners.bind(this));\n    }\n\n    public executeBackTapListeners($event) {\n        _.forEach(this._backBtnTapListeners, fn => {\n            return fn($event) !== false;\n        });\n        // explicitly applying the digest cycle as the backbutton listener is not rendering the page content.\n        // This is because zone is not run (there is no change detection)\n        // https://weblogs.thinktecture.com/thomas/2017/02/cordova-vs-zonejs-or-why-is-angulars-document-event-listener-not-in-a-zone.html\n        $appDigest();\n    }\n\n    public addStartUpService(service: IDeviceStartUpService) {\n        this._startUpServices.push(service);\n    }\n\n    public onBackButtonTap(fn: ($event) => boolean) {\n        this._backBtnTapListeners.unshift(fn);\n        return () => {\n            const i = this._backBtnTapListeners.indexOf(fn);\n            if (i >= 0) {\n                this._backBtnTapListeners.splice(i, 1);\n            }\n        };\n    }\n\n    public start() {\n        if (this._isReady || this._startUpServices.length === 0) {\n            this._isReady = true;\n            return Promise.resolve();\n        } else {\n            return new Promise((resolve) => {\n                if (hasCordova()) {\n                    document.addEventListener('deviceready', () => resolve(), false);\n                } else {\n                    resolve();\n                }\n            }).then(() => {\n                if (window['cordova']) {\n                    return this.file.readAsText(cordova.file.dataDirectory, REGISTRY_FILE_NAME)\n                        .then(content =>  this._registry = JSON.parse(content), noop);\n                }\n            }).then(() => {\n                return Promise.all(this._startUpServices.map(s => {\n                    return s.start().catch((error) => {\n                        console.error('%s failed to start due to: %O', s.serviceName, error);\n                        return Promise.reject(error);\n                    });\n                }));\n            }).then(() => {\n                window['wmDeviceReady'] = true;\n                document.dispatchEvent(new CustomEvent('wmDeviceReady'));\n                this._startUpServices.length = 0;\n                this._whenReadyPromises.forEach(fn => fn());\n                this._isReady = true;\n            });\n        }\n    }\n\n    public whenReady(): Promise<void> {\n        if (this._isReady) {\n            return Promise.resolve();\n        } else {\n            return new Promise<void>((resolve) => {\n                this._whenReadyPromises.push(resolve);\n            });\n        }\n    }\n\n    /**\n     * @returns {Promise<number>} promise resolved with the app build time\n     */\n    public getAppBuildTime(): Promise<number> {\n        return this.file.readAsText(cordova.file.applicationDirectory + 'www', 'config.json')\n            .then(appConfig => (JSON.parse(appConfig).buildTime) as number);\n    }\n\n    /**\n     * Stores an entry that survives app restarts and updates.\n     *\n     * @param {string} key\n     * @param {Object} value\n     * @returns {Promise<any>}\n     */\n    public storeEntry(key: string, value: Object): Promise<any> {\n        this._registry[key] = value;\n        return this.file.writeFile(cordova.file.dataDirectory,\n            REGISTRY_FILE_NAME,\n            JSON.stringify(this._registry),\n            { replace: true });\n    }\n\n    /**\n     * @param {string} key\n     * @returns {any} entry corresponding to the key\n     */\n    public getEntry(key: string): any {\n        return this._registry[key];\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\nimport { Network } from '@ionic-native/network';\n\nimport { App, getAbortableDefer, noop, retryIfFails } from '@wm/core';\n\nimport { IDeviceStartUpService } from './device-start-up-service';\n\ndeclare const _, cordova, Connection, navigator;\n\nconst AUTO_CONNECT_KEY = 'WM.NetworkService._autoConnect',\n    IS_CONNECTED_KEY = 'WM.NetworkService.isConnected',\n    excludedList = [new RegExp('/wmProperties.js')],\n    originalXMLHttpRequestOpen = XMLHttpRequest.prototype.open,\n    originalXMLHttpRequestSend = XMLHttpRequest.prototype.send,\n    networkState = {\n        isConnecting : false,\n        isConnected : localStorage.getItem(IS_CONNECTED_KEY) === 'true',\n        isNetworkAvailable : true,\n        isServiceAvailable : true\n    };\n\n/**\n * If server is not connected and url does not match the unblock list of regular expressions,\n * then this function return true. Otherwise, return false.\n * @param url\n * @returns {boolean}\n */\nconst blockUrl = url => {\n    let block = !networkState.isConnected && _.startsWith(url, 'http');\n    if (block) {\n        block = !_.find(excludedList, regExp => regExp.test(url));\n    }\n    return block;\n};\n\n// Intercept all XHR calls\nXMLHttpRequest.prototype.open = function (method: string, url: string, async: boolean = true, user?: string, password?: string) {\n    if (blockUrl(url)) {\n        const urlSplits = url.split('://');\n        const pathIndex = urlSplits[1].indexOf('/');\n        urlSplits[1] = 'localhost' + (pathIndex > 0 ? urlSplits[1].substr(pathIndex) : '/');\n        url = urlSplits.join('://');\n    }\n    return originalXMLHttpRequestOpen.apply(this, [method, url, async, user, password]);\n};\n\n@Injectable({ providedIn: 'root' })\nexport class NetworkService implements IDeviceStartUpService {\n\n    public serviceName = NetworkService.name;\n\n    private _autoConnect = localStorage.getItem(AUTO_CONNECT_KEY) !== 'false';\n    private _lastKnownNetworkState: any;\n    private _isCheckingServer = false;\n\n    constructor(private httpClient: HttpClient, private app: App, private network: Network) {\n    }\n\n    /**\n     * This method attempts to connect app to the server and returns a promise that will be resolved with\n     * a boolean value based on the operation result.\n     *\n     * @returns {object} promise\n     */\n    public connect(): Promise<boolean> {\n        this.setAutoConnect(true);\n        return this.tryToConnect();\n    }\n\n    /**\n     * When the auto connect is enabled, then app is automatically connected  whenever server is available.\n     * Every time when app goes offline, auto connect is enabled. Before app coming to online, one can disable\n     * the auto connection flow using this method.\n     */\n    public disableAutoConnect = () => this.setAutoConnect(false);\n\n    /**\n     * This method disconnects the app from the server and returns a promise that will be resolved with\n     * a boolean value based on the operation result. Use connect method to reconnect.\n     *\n     * @returns {object} promise\n     */\n    public disconnect(): Promise<boolean> {\n        const p = this.tryToDisconnect();\n        this.disableAutoConnect();\n        return p;\n    }\n\n    /**\n     * If pingServer is true, then it returns a promise that will be resolved with boolean based on service availability\n     * check.If pingServer is false, returns a boolean value based on the last known service availability.\n     *\n     * @returns {boolean} if pingServer is true, then a promise is returned. Otherwise, a boolean value.\n     */\n    public isAvailable(pingServer = false): boolean | Promise<boolean> {\n        if (pingServer) {\n            return this.isServiceAvailable().then(() => {\n                this.checkForNetworkStateChange();\n                return networkState.isServiceAvailable;\n            });\n        }\n        return networkState.isServiceAvailable;\n    }\n\n    /**\n     * Returns true, if app is connected to server. Otherwise, returns false.\n     *\n     * @returns {boolean} Returns true, if app is connected to server. Otherwise, returns false.\n     */\n    public isConnected = () => {\n        // checking for connection type.\n        if (_.get(navigator, 'connection') && navigator.connection.type) {\n            networkState.isConnected = networkState.isConnected && (navigator.connection.type !== 'none');\n        }\n        this.checkForNetworkStateChange();\n        return networkState.isConnected;\n    }\n\n    /**\n     * Returns true if app is trying to connect to server. Otherwise, returns false.\n     *\n     * @returns {boolean} Returns true if app is trying to connect to server. Otherwise, returns false.\n     */\n    public isConnecting = () => networkState.isConnecting;\n\n    /**\n     * This method returns a promise that is resolved when connection is established with server.\n     *\n     * @returns {object} promise a promise that is resolved with the returned object of fn\n     */\n    public onConnect() {\n        let defer,\n            cancelSubscription;\n        if (this.isConnected()) {\n            return Promise.resolve();\n        }\n        defer = getAbortableDefer();\n        cancelSubscription = this.app.subscribe('onNetworkStateChange', () => {\n            if (this.isConnected()) {\n                defer.resolve(true);\n                cancelSubscription();\n            }\n        });\n        defer.promise.catch(function () {\n            cancelSubscription();\n        });\n        return defer.promise;\n    }\n\n    /**\n     * This is a util method. If fn cannot execute successfully and network lost connection, then the fn will\n     * be invoked when network is back. The returned can also be aborted.\n     *\n     * @param {function()} fn method to invoke.\n     * @returns {object} promise a promise that is resolved with the returned object of fn\n     */\n    public retryIfNetworkFails(fn) {\n        const defer = getAbortableDefer();\n        retryIfFails(fn, 0, 0, () => {\n            let onConnectPromise;\n            if (!this.isConnected()) {\n                onConnectPromise = this.onConnect();\n                defer.promise.catch(function () {\n                    onConnectPromise.abort();\n                });\n                return onConnectPromise;\n            }\n            return false;\n        }).then(defer.resolve, defer.reject);\n        return defer.promise;\n    }\n\n    public start(): Promise<any> {\n        if (window['cordova']) {\n            // Connection constant will be available only when network plugin is included.\n            if (window['Connection'] && navigator.connection) {\n                networkState.isNetworkAvailable = navigator.connection.type !== 'none';\n                networkState.isConnected = networkState.isNetworkAvailable && networkState.isConnected;\n                /*\n                 * When the device comes online, check is the service is available. If the service is available and auto\n                 * connect flag is true, then app is automatically connected to remote server.\n                 */\n                this.network.onConnect().subscribe(() => {\n                    networkState.isNetworkAvailable = true;\n                    this.tryToConnect().catch(noop);\n                });\n\n                /*\n                 *When device goes offline, then change the network state and emit that notifies about network state change.\n                 */\n                this.network.onDisconnect().subscribe(() => {\n                    networkState.isNetworkAvailable = false;\n                    networkState.isServiceAvailable = false;\n                    this.tryToDisconnect();\n                });\n\n                this.app.subscribe('onNetworkStateChange', (data) => {\n                    /**\n                     * If network is available and server is not available,then\n                     * try to connect when server is available.\n                     */\n                    if (data.isNetworkAvailable && !data.isServiceAvailable && !this._isCheckingServer) {\n                        this._isCheckingServer = true;\n                        this.checkForServiceAvailiblity().then(() => {\n                            this._isCheckingServer = false;\n                            this.connect();\n                        }, () => {\n                            this._isCheckingServer = false;\n                        });\n                    }\n                });\n            }\n        }\n        // to set the default n/w connection values.\n        return this.tryToConnect(true).catch(noop);\n    }\n\n    /**\n     * This function adds the given regular expression to the unblockList. Even app is in offline mode,\n     * the urls matching with the given regular expression are not blocked by NetworkService.\n     *\n     * @param {string} urlRegex regular expression\n     */\n    public unblock(urlRegex: string) {\n        excludedList.push(new RegExp(urlRegex));\n    }\n\n    private checkForNetworkStateChange() {\n        if (!_.isEqual(this._lastKnownNetworkState, networkState)) {\n            this._lastKnownNetworkState = _.clone(networkState);\n            this.app.notify('onNetworkStateChange', this._lastKnownNetworkState);\n        }\n    }\n\n    /**\n     * Returns a promise that is resolved when server is available.\n     * @returns {*}\n     */\n    private checkForServiceAvailiblity(): Promise<void> {\n        const maxTimeout = 4500;\n        return new Promise<void>(resolve => {\n            const intervalId = setInterval(() => {\n                if (networkState.isNetworkAvailable) {\n                    this.isServiceAvailable(maxTimeout).then(available => {\n                        if (available) {\n                            clearInterval(intervalId);\n                            resolve();\n                        }\n                    });\n                }\n            }, 5000);\n        });\n    }\n\n    /**\n     * Pings server to check whether server is available. Based on ping response network state is modified.\n     * @returns {*} a promise that resolved with true, if server responds with valid status.\n     * Otherwise, the promise is resolved with false.\n     */\n    private isServiceAvailable(maxTimeout?: number): Promise<boolean> {\n        return this.pingServer(maxTimeout).then(response => {\n            networkState.isServiceAvailable = response;\n            if (!networkState.isServiceAvailable) {\n                networkState.isConnecting = false;\n                networkState.isConnected = false;\n            }\n            return response;\n        });\n    }\n\n    /**\n     * Pings server\n     * @returns {*} a promise that resolved with true, if server responds with valid status.\n     * Otherwise, the promise is resolved with false.\n     * default timeout value is 1min.\n     */\n    private pingServer(maxTimeout = 60000): Promise<boolean> {\n        return new Promise<boolean>(resolve => {\n            const oReq = new XMLHttpRequest();\n            let baseURL = this.app.deployedUrl;\n            if (baseURL && !_.endsWith(baseURL, '/')) {\n                baseURL += '/';\n            } else {\n                baseURL = baseURL || '';\n            }\n\n            const timer = setTimeout(() => {\n                oReq.abort(); // abort request\n                resolve(false);\n            }, maxTimeout);\n\n            oReq.addEventListener('load', () => {\n                if (oReq.status === 200) {\n                    resolve(true);\n                } else {\n                    resolve(false);\n                }\n                if (timer) {\n                    clearTimeout(timer);\n                }\n            });\n\n            oReq.addEventListener('error', () => resolve(false));\n            oReq.open('GET', baseURL + 'services/application/wmProperties.js?t=' + Date.now());\n            oReq.send();\n        });\n    }\n\n    private setAutoConnect(flag: boolean): void {\n        this._autoConnect = flag;\n        localStorage.setItem(AUTO_CONNECT_KEY, '' + flag);\n    }\n\n    /**\n     * Tries to connect to remote server. Network State will be changed based on the success of connection\n     * operation and emits an event notifying the network state change.\n     *\n     * @param silentMode {boolean} if true and connection is successful, then no event is emitted. Otherwise,\n     * events are emitted for network status change.\n     * @returns {*} a promise\n     */\n    private tryToConnect(silentMode = false): Promise<boolean> {\n        return new Promise<boolean>((resolve, reject) => {\n            this.isServiceAvailable(5000).then(() => {\n                if (networkState.isServiceAvailable && this._autoConnect) {\n                    networkState.isConnecting = true;\n                    if (!silentMode) {\n                        this.checkForNetworkStateChange();\n                    }\n                    setTimeout(() => {\n                        networkState.isConnecting = false;\n                        networkState.isConnected = true;\n                        localStorage.setItem(IS_CONNECTED_KEY, '' + true);\n                        if (!silentMode) {\n                            this.checkForNetworkStateChange();\n                        }\n                        resolve(true);\n                    }, silentMode ? 0 : 5000);\n                } else {\n                    networkState.isConnecting = false;\n                    networkState.isConnected = false;\n                    localStorage.setItem(IS_CONNECTED_KEY, '' + false);\n                    reject();\n                    this.checkForNetworkStateChange();\n                }\n            });\n        });\n    }\n\n    private tryToDisconnect(): Promise<boolean> {\n        networkState.isConnected = false;\n        networkState.isConnecting = false;\n        this.checkForNetworkStateChange();\n        localStorage.setItem(IS_CONNECTED_KEY, '' + networkState.isConnected);\n        return Promise.resolve(networkState.isConnected);\n    }\n}\n","import { NgModule } from '@angular/core';\n\nimport { hasCordova } from '@wm/core';\n\nimport { DeviceFileCacheService } from './services/device-file-cache.service';\nimport { DeviceFileOpenerService } from './services/device-file-opener.service';\nimport { DeviceFileService } from './services/device-file.service';\nimport { DeviceService } from './services/device.service';\nimport { NetworkService } from './services/network.service';\n\n@NgModule({\n    declarations: [],\n    imports: [],\n    providers: [\n        // add providers to mobile-runtime module.\n    ],\n    bootstrap: []\n})\nexport class MobileCoreModule {\n    static initialized = false;\n    // Startup services have to be added only once in the app life-cycle.\n    static addStartupServices(deviceService: DeviceService,\n                      deviceFileService: DeviceFileService,\n                      fileCacheService: DeviceFileCacheService,\n                      fileOpener: DeviceFileOpenerService,\n                      networkService: NetworkService) {\n        if (this.initialized) {\n            return;\n        }\n        deviceService.addStartUpService(networkService);\n        if (hasCordova()) {\n            deviceService.addStartUpService(deviceFileService);\n            deviceService.addStartUpService(fileCacheService);\n            deviceService.addStartUpService(fileOpener);\n        }\n        this.initialized = true;\n    }\n\n    constructor(\n        deviceService: DeviceService,\n        deviceFileService: DeviceFileService,\n        fileCacheService: DeviceFileCacheService,\n        fileOpener: DeviceFileOpenerService,\n        networkService: NetworkService\n    ) {\n        MobileCoreModule.addStartupServices(deviceService, deviceFileService,  fileCacheService, fileOpener, networkService);\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { File } from '@ionic-native/file';\n\nimport { convertToBlob } from '@wm/core';\n\ndeclare const _;\n\nexport interface IUploadResponse {\n    text: string;\n    response: any;\n    headers: (string) => string;\n}\n\nexport class UploadRequest {\n\n    private _files = [];\n    private _params = [];\n    private _headers = [];\n\n    constructor (private url: string, private cordovaFile: File) {\n\n    }\n\n    public addFile(name: string, path: string, filename: string): UploadRequest {\n        this._files.push({\n            name: name,\n            path: path,\n            fileName: filename\n        });\n        return this;\n    }\n\n    public addHeader(name: string, value: string): UploadRequest {\n        this._headers.push({\n            name: name,\n            value: value\n        });\n        return this;\n    }\n\n    public addParam(name: string, value: string): UploadRequest {\n        this._params.push({\n            name: name,\n            value: value\n        });\n        return this;\n    }\n\n    public post(): Promise<IUploadResponse> {\n        const formData = new FormData();\n        this._params.forEach( e => formData.append(e.name, e.value));\n        return Promise.all(this._files.map( e => {\n            if (e.path) {\n                return convertToBlob(e.path)\n                    .then(result => {\n                        return {\n                            name: e.name,\n                            fileName: e.fileName,\n                            blob: result.blob\n                        };\n                    });\n            }\n            return e;\n        })).then(params => {\n            params.forEach(e => formData.append(e.name, e.blob || e.path, e.fileName));\n            return new Promise<IUploadResponse>((resolve, reject) => {\n                const request = new XMLHttpRequest();\n                request.open('POST', this.url);\n                this._headers.forEach(e => request.setRequestHeader(e.name, e.value));\n                request.onload = () => {\n                    resolve({\n                        headers: (name: string) => request.getResponseHeader(name),\n                        response: request.response,\n                        text: request.responseText as string\n                    });\n                };\n                request.onerror = reject;\n                request.onabort = reject;\n                request.send(formData);\n            });\n        });\n    }\n}\n\n@Injectable({ providedIn: 'root' })\nexport class DeviceFileUploadService {\n\n    constructor(private cordovaFile: File) {}\n\n    public upload(url: string, fileParamName: string, path: string, fileName?: string, params?: any, headers?: any): Promise<IUploadResponse> {\n        const req = new UploadRequest(url, this.cordovaFile)\n            .addFile(fileParamName, path, fileName);\n        _.forEach(params, (k, v) => req.addParam(k, v));\n        _.forEach(headers, (k, v) => req.addHeader(k, v));\n        return req.post();\n    }\n\n}\n","import { Injectable } from '@angular/core';\n\nimport { App } from '@wm/core';\n\ndeclare const _;\n\ninterface Message {\n    address: string;\n    data: Map<string, string>;\n}\n\ninterface Handler {\n    pattern: string;\n    callback: (msg: string) => any;\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ExtAppMessageService {\n\n    private handlers = [];\n\n    constructor(private app: App) {\n        document.addEventListener('externalAppMessageReceived', e => {\n            const message = (e['detail'].message) as Message;\n            this.handlers.forEach(handler => {\n                const matches = handler && message.address.match(handler.pattern);\n                if (matches && matches.length > 0) {\n                    handler.callBack(message);\n                }\n            });\n        });\n    }\n\n    /**\n     * adds a listener for a message whose address matches with the given regex pattern.\n     *\n     * @param {string} messageAddressPattern a regex pattern that is used to target messages to listen.\n     * @param {Function} listener function to invoke when message that matches regex is received.\n     *                  message received will be sent as first argument.\n     * @returns {Function} a function which removes the listener when invoked.\n     */\n    public subscribe(messageAddressPattern, listener: (msg: Message) => any) {\n        const handler = {\n            pattern : new RegExp(messageAddressPattern),\n            callBack : listener\n        };\n        this.handlers.push(handler);\n        return () => _.remove(this.handlers, handler);\n    }\n\n}\n\n(function (window, document) {\n    'use strict';\n    // listen app-to-app communication via url schemes\n    function subString(str, begin, end) {\n        end = end < 0 ? undefined : end;\n        return (str && begin >= 0 && str.length > begin && str.substring(begin, end)) || undefined;\n    }\n    function indexOf(str, pattern) {\n        return str && str.indexOf(pattern);\n    }\n    function extractData(url) {\n        const str = subString(url, indexOf(url, '?') + 1, indexOf(url, '#')),\n            data = {};\n        _.forEach(_.split(str, '&'), entry => {\n            const esplits = entry.split('=');\n            data[esplits[0]] = esplits[1];\n        });\n        return data;\n    }\n    function extractAddress(url) {\n        return subString(url, indexOf(url, '://') + 3, indexOf(url, '?'));\n    }\n    function createMessage(url) {\n        return {\n            'address': extractAddress(url),\n            'data': extractData(url)\n        };\n    }\n    window['handleOpenURL'] = function (url) {\n        const handleOpenURL = window['handleOpenURL'];\n        if (handleOpenURL.isReady && !_.startsWith(url, 'http')) {\n            const message = createMessage(url);\n            const e = new window['CustomEvent']('externalAppMessageReceived', {\n                'detail': {\n                    'message': message\n                }\n            });\n            document.dispatchEvent(e);\n        }\n        handleOpenURL.lastURL = url;\n    };\n}(window, document));\n"]}