{"version":3,"sources":["ng://@wm/mobile/offline/models/config.ts","ng://@wm/mobile/offline/services/local-key-value.service.ts","ng://@wm/mobile/offline/utils/utils.ts","ng://@wm/mobile/offline/models/local-db-store.ts","ng://@wm/mobile/offline/services/local-db-management.service.ts","ng://@wm/mobile/offline/services/change-log.service.ts","ng://@wm/mobile/offline/services/local-db.service.ts","ng://@wm/mobile/offline/services/workers/file-handler.ts","ng://@wm/mobile/offline/services/workers/error-blocker.ts","ng://@wm/mobile/offline/services/workers/id-resolver.ts","ng://@wm/mobile/offline/services/workers/multi-part-param-transformer.ts","ng://@wm/mobile/offline/utils/live-variable.utils.ts","ng://@wm/mobile/offline/utils/file-upload.utils.ts","ng://@wm/mobile/offline/utils/query-executor.utils.ts","ng://@wm/mobile/offline/utils/security.utils.ts","ng://@wm/mobile/offline/offline.module.ts","ng://@wm/mobile/offline/services/push.service.ts","ng://@wm/mobile/offline/services/local-db-data-pull.service.ts"],"names":["PullType","LocalKeyValueService","prototype","get","key","this","fetchEntry","then","result","value","length","JSON","parse","init","storeToUse","store","put","_this","stringify","save","id","add","remove","delete","filterCriteria","attributeName","attributeValue","attributeType","filterCondition","filter","Injectable","args","providedIn","WM_LOCAL_OFFLINE_CALL","escapeName","name","replace","generateWherClause","conditions","fieldToColumnMapping","tableName","entitySchema","_","isEmpty","isString","map","filterCriterion","colName","condition","target","operator","join","mapRowDataToObj","schema","dataObj","columns","forEach","col","val","fieldName","foreignRelations","foreignRelation","childEntity","dataMapper","childCol","childFieldName","fieldValue","isDefined","sourceFieldName","sqlType","isNil","getValue","entity","some","targetEntity","targetFieldName","defaultValue","mapObjToRow","row","LocalDBStore","deviceFileService","file","localDbManagementService","sqliteObject","columnNames","placeHolder","primaryKeyField","joins","find","primaryKeyName","undefined","c","targetPath","insertRecordSqlTemplate","push","replaceRecordSqlTemplate","deleteRecordTemplate","selectSqlTemplate","childTableName","childFiledName","targetTable","targetColumn","countQuery","idValue","trim","generatorType","nextIdCount","primaryKeyValue","rowData","params","f","executeSql","insertId","clear","create","createTableSql","count","sql","rows","item","deserialize","deserializeMapToFormData","sort","page","split","field","splits","limit","offset","objArr","rowCount","i","refresh","data","primaryKey","Promise","resolve","toUpperCase","obj","column","saveAll","entities","queries","sqlBatch","serialize","formData","serializeFormDataToMap","saveBlobToFile","blob","fileName","appendToFileName","uploadDir","getUploadDirectory","writeFile","type","lastModified","lastModifiedDate","size","wmLocalPath","blobColumns","promises","append","fieldData","localFile","all","FormData","convertToBlob","SWAGGER_CONSTANTS","WM_DATA_JSON","Blob","fieldStr","reduce","str","DBInfo","isInternal","Map","stores","ColumnInfo","NEXT_ID_COUNT","META_LOCATION","OFFLINE_WAVEMAKER_DATABASE_SCHEMA","version","tables","entityName","LocalDBManagementService","appVersion","deviceService","localKeyValueService","securityService","sqlite","callbacks","_logSql","nextId","systemProperties","USER_ID","getLoggedInUser","userInfo","userId","USER_NAME","userName","DATE_TIME","moment","format","DATE","TIME","close","reject","setTimeout","closePromises","values","databases","db","executeNamedQuery","dbName","queryName","queryData","paramPromises","chain","p","variableType","paramValue","toPromise","v","DataType","DATETIME","LOCALDATETIME","BOOLEAN","convertBoolToInt","formatDate","executeSQLQuery","query","firstRow","needTransform","response","properties","hasOwnProperty","isUndefined","transformedRow","rowWithUpperKeys","k","propType","extractType","fieldType","typeRef","fieldVal","DEFAULT_FORMATS","toUpper","isValid","convertIntToBool","nameInUpperCase","exportDB","zipDirectory","folderToExport","now","folderToExportFullPath","cordova","cacheDirectory","metaInfo","app","OS","createdOn","isIos","documentsDirectory","externalRootDirectory","createDir","copyDir","dbInstallParentDirectory","dbInstallDirectoryName","getAppInfo","appInfo","isAndroid","executePromiseChain","getCallbacksFor","appName","newFileName","rs","re","Zeep","zip","from","to","catch","noop","removeDir","getStore","dataModelName","importDB","zipPath","revertIfFails","zipMeta","importFolder","importFolderFullPath","unzip","readAsText","text","packageName","backupZip","path","dbInstallDirectory","loadDatabases","removeFile","reason","isOperationAllowed","operation","pushConfig","readEnabled","insertEnabled","updateEnabled","deleteEnabled","newDatabasesCreated","applicationStorageDirectory","setUpDatabases","flag","loadDBSchemas","metadata","loadNamedQueries","loadOfflineConfig","dbMetadata","openDatabase","database","normalizeData","disableForeignKeys","getAppBuildTime","dbSeedCreationTime","dbCreatedOn","dbSeedCreatedOn","registerCallback","listener","setLogSQl","cleanAndCopyDatabases","dbSeedFolder","applicationDirectory","listFiles","files","copyFile","compactEntitySchema","transformedSchemas","reqEntity","columnValue","parseInt","relations","r","targetEntitySchema","sourceColumn","mapping","cardinality","t","mappings","table","foreignRelation_1","keyBy","mapValues","compactQueries","queriesByDB","nativeSql","offlineQueryString","queryString","extractQueryParams","paramObj","parameters","compactSchema","dbInfo","bool","toString","int","logOutput","rowsAffected","aliasParams","match","x","test","versionNumber","versionCode","getPackageName","getAppName","getVersionNumber","getVersionCode","event","bind","getMetaInfo","fileNameRegex","folder","$","getJSON","isBundled","pullConfig","pullType","BUNDLED","schemas","isArray","s","queriesByDBs","e","configs","config","entityConfig","assignIn","logSql","logger","console","originalExecuteSql","startTime","call","debug","error","message","normalizeBooleanData","trueTo1Query","exceptNullAnd1to0Query","location","storePromises","buildTime","getEntry","lastBuildTime","storeEntry","AppVersion","DeviceService","DeviceFileService","File","SecurityService","SQLite","PushService","CONTEXT_KEY","LAST_PUSH_INFO_KEY","ChangeLogService","localDBManagementService","pushService","networkService","workers","currentPushInfo","addWorker","FlushTracker","service","change","hasError","getWorkers","worker","clearLog","flush","progressObserver","flushPromise","deferredFlush","getAbortableDefer","createContext","context","flushContext","_flush","onAbort","abort","totalTaskCount","completedTaskCount","complete","failedTaskCount","promise","getChanges","changes","getErrors","getLastPushInfo","info","Date","endTime","getLogLength","isFlushInProgress","isNull","stop","defer","isAborted","getNextChange","flushChange","next","isConnected","connectPromise_1","onConnect","self","errorMessage","reverse","arguments","w","NetworkService","changeLogService","pushInfo","window","onAddCall","preFlush","successfulTaskCount","inProgress","postFlush","stats","preCall","postCallError","postCallSuccess","LocalDbService","searchTableData","readTableData","searchTableDataWithQuery","getDistinctDataByFields","insertTableData","successCallback","failureCallback","insertMultiPartTableData","updateTableData","updateMultiPartTableData","deleteTableData","pkField","filterGroup","filterFields","convertFieldNameToColumnName","totalElements","totalPages","Math","ceil","content","first","last","number","numberOfElements","sorted","unsorted","getColumnName","columnName","indexOf","options","rules","rule","mapKeys","FileHandler","fileStore","remoteUrl","remoteFile","inlinePath","UploadedFilesImportAndExportService","preExport","meta","uploadFullPath","lastIndexOfSep","lastIndexOf","uploadParentDir","substring","uploadDirName","postImport","importedFolder","checkDir","updateChanges","strore","updateDBChange","oldUploadDir","modifiedProperties","mv","isModified","isEqual","isObject","updateChange","ErrorBlocker","errorStore","entityName_1","dataModelName_1","blockCall","entityName_2","dataModelName_2","removeError","entityName_3","dataModelName_3","recordError","checkForPreviousError","IdResolver","idStore","skipLocalDB","transactionLocalId","exchangeIds","relationalPrimaryKeyValue","pushIdToStore","exchangeId","data_1","body","getEntityIdStore","remoteId","logResolution","localId","keyName","entityIdStore","exchangeIdPromises","refStore","MultiPartParamTransformer","transformParamsFromMap","transformParamsToMap","apiConfiguration","saveResponse","isOfflineBehaviorAdded","LiveVariableOfflineBehaviour","httpService","offlineDBService","onlineDBService","LVService","onlineHandler_1","sendCallAsObservable","reqParams","url","clonedParamsUrl","clone","extend","onlyOnline","remoteDBcall","isAllowedInOffline","cascader_1","isCascadingStopped","prepareToCascade","localDBcall","cascade","hasBlob","triggerFn","onlineHandler","subscribe","err","childObjectPromises","childParams","cloneDeep","childPromise","childStore","parent","targetColumns","parentFieldName","object","fn","isOfflineBehaviourAdded","FileUploadOfflineBehaviour","deviceFileUploadService","orig","upload","fileParamName","localPath","headers","uploadLater","soureDir","soureFile","destFile","filePath","ftOptions","fileKey","serverUrl","deleteOnUpload","success","NUMBER_REGEX","NamedQueryExecutionOfflineBehaviour","executeLocally","hasUrlParams","urlParams","getHttpParamMap","dataParams","queryParams","source","start","end","startIndex","endIndex","decodeURIComponent","csplits","SECURITY_FILE","SecurityOfflineBehaviour","saveSecurityConfigLocally","debounce","_saveSecurityConfigLocally","origLoad","load","origAppLogout","appLogout","securityConfig","readLocalSecurityConfig","authenticated","loggedOut","securityEnabled","loggedOutOffline","loginConfig","assign","origin","pathname","isAuthenticated","whenReady","clearLastLoggedInUser","dataDirectory","rootDir","checkFile","readFileAsTxt","folderPath","OfflineModule","localDbService","hasCordova","initialize","initialized","addStartUpService","serviceName","sessionStorage","getItem","setItem","executeLocalSql","disableAutoConnect","NgModule","imports","CommonModule","declarations","exports","providers","entryComponents","App","DeviceFileUploadService","AbstractHttpService","PushServiceImpl","getPromiseFromObs","cb","LAST_PULL_INFO_KEY","$$pullProcessId","pullPromise","pullProcessId","$$isMarkedToAbort","pullProcessManager","LocalDBDataPullService","onDbCreate","totalRecordsToPull","totalPulledRecordCount","addDeltaCriteria","isBundledEntity","deltaFieldName","deltaField","getLastPullInfo","lastPullInfo","lastPullTime","getTime","lastPullDBInfo","lastPullEntityInfo","utc","copyDataFromRemoteDBToLocalDB","clearDataBeforePull","pulledRecordCount","pullComplete","prepareQuery","getTotalRecordsToPull","maxNoOfRecords","pageSize","maxNoOfPages","orderBy","_progressObserver","slice","_pullEntityData","evalIfBind","expression","startsWith","$parseExpr","executeDatabaseCountQuery","countTableDataWithQuery","executeDatabaseSearchQuery","retryIfNetworkFails","totalRecordCount","maxRecordsToPull","maxNumberOfRecords","isNaN","hasNullAttributeValue","sortBy","LiveVariableUtils","getSearchQuery","encodeURIComponent","_pullDbData","datamodelName","APP_START","pullPromises","findIndex","sum","entityPullInfo","currentPage","deferred","cancel","getDb","pullAllDbData","pullInfo","dataPullPromises","dbPullInfo","pullDbData","databaseName","pullEntityData"],"mappings":"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","sourcesContent":["import { SQLiteObject } from '@ionic-native/sqlite';\n\nimport { LocalDBStore } from './local-db-store';\n\nexport class DBInfo {\n    public schema = {\n        name: '',\n        isInternal: false,\n        entities: new Map<string, EntityInfo>()\n    };\n    public stores = new Map<string, LocalDBStore>();\n    public queries = new Map<string, NamedQueryInfo>();\n    public sqliteObject: SQLiteObject;\n}\n\nexport class EntityInfo {\n    public columns = new Array<ColumnInfo>();\n    public pullConfig: PullConfig;\n    public pushConfig: PushConfig;\n\n    constructor(public name: string, public entityName?: string) {\n        this.entityName = this.entityName || this.name;\n    }\n}\n\nexport class ColumnInfo {\n    public generatorType: string;\n    public sqlType: string;\n    public primaryKey = false;\n    public defaultValue: any;\n    public foreignRelations?: ForeignRelationInfo[];\n\n    constructor(public name: string, public fieldName?: string) {\n        this.fieldName = this.fieldName || this.name;\n    }\n}\n\nexport class ForeignRelationInfo {\n    public sourceFieldName: string;\n    public targetEntity: string;\n    public targetTable: string;\n    public targetColumn: string;\n    public targetFieldName: string;\n    public targetPath: string;\n    public dataMapper: Array<ColumnInfo>;\n}\n\nexport class NamedQueryInfo {\n    public params: NamedQueryParamInfo[];\n    public response = {\n        properties: []\n    };\n    constructor(public name: string, public query: string) {\n\n    }\n}\n\nexport class NamedQueryParamInfo {\n    constructor(public name: string, public type?: string, public variableType?: string) {\n\n    }\n}\n\nexport class PullConfig {\n    public size: number;\n    public query: string;\n    public orderBy: string;\n    public maxNoOfRecords: number;\n    public defaultType: string;\n    public pullType: PullType;\n    public filter: OfflineDataFilter[];\n}\n\nexport enum PullType {\n    LIVE = 'LIVE',\n    BUNDLED = 'BUNDLED',\n    APP_START = 'APP_START'\n}\n\nexport class OfflineDataFilter {\n    public attributeName: string;\n    public attributeValue: any;\n    public attributeType: string;\n    public filterCondition: string;\n}\n\nexport class PushConfig {\n    public insertEnabled = false;\n    public updateEnabled = false;\n    public deleteEnabled = false;\n    public readEnabled = true;\n}\n","import { Injectable } from '@angular/core';\n\nimport { LocalDBStore } from '../models/local-db-store';\n\n@Injectable({providedIn: 'root'})\nexport class LocalKeyValueService {\n\n    private store: LocalDBStore;\n\n    /**\n     * retrieves the value mapped to the key.\n     *\n     * @param {string} key key\n     * @returns {object} a promise that is resolved when value is retrieved from store.\n     */\n    public get(key: string): any {\n        return this.fetchEntry(key)\n            .then(result => {\n                let value;\n                if (result && result.length > 0) {\n                    value = result[0].value;\n                    if (value) {\n                        value = JSON.parse(value);\n                    }\n                }\n                return value;\n            });\n    }\n\n    /**\n     * Initializes the service with the given store.\n     *\n     * @param {object} storeToUse a store with id, key, value with fields.\n     * @returns {object} a promise that is resolved when data is persisted.\n     */\n    public init(storeToUse: LocalDBStore) {\n        this.store = storeToUse;\n    }\n\n    /**\n     * clear data in all databases.\n     *\n     * @param {string} key key\n     * @param {string} value value\n     * @returns {object} a promise that is resolved when data is persisted.\n     */\n    public put(key, value) {\n        if (value) {\n            value = JSON.stringify(value);\n        }\n        return this.fetchEntry(key).then(result => {\n            if (result && result.length > 0) {\n                return this.store.save({\n                    'id' : result[0].id,\n                    'key' : key,\n                    'value' : value\n                });\n            }\n            return this.store.add({\n                'key' : key,\n                'value' : value\n            });\n        });\n    }\n\n    /**\n     * clear data in all databases.\n     *\n     * @param {string} key key\n     * @returns {object} a promise that is resolved when respective value is removed from store.\n     */\n    public remove(key) {\n        return this.fetchEntry(key).then(result => {\n            if (result && result.length > 0) {\n                return this.store.delete(result[0].id);\n            }\n        });\n    }\n\n    private fetchEntry(key) {\n        const filterCriteria = [{\n            'attributeName' : 'key',\n            'attributeValue' : key,\n            'attributeType' : 'STRING',\n            'filterCondition' : 'EQUALS'\n        }];\n        return this.store.filter(filterCriteria);\n    }\n}\n","export const WM_LOCAL_OFFLINE_CALL = 'WM_LOCAL_OFFLINE_CALL';\n\nexport const escapeName = (name) => {\n    if (name) {\n        name = name.replace(/\"/g, '\"\"');\n        return '\"' + name + '\"';\n    }\n};\n","import { File } from '@ionic-native/file';\nimport { SQLiteObject } from '@ionic-native/sqlite';\n\nimport { convertToBlob, isDefined } from '@wm/core';\nimport { DeviceFileService } from '@wm/mobile/core';\nimport { SWAGGER_CONSTANTS } from '@wm/variables';\n\nimport { ColumnInfo, EntityInfo } from './config';\nimport { escapeName } from '../utils/utils';\nimport { LocalDBManagementService } from '../services/local-db-management.service';\n\ndeclare const _;\n\nexport interface FilterCriterion {\n    attributeName: string;\n    attributeValue: any;\n    attributeType: string;\n    filterCondition: string;\n}\n\nexport interface Pagination {\n    offset: number;\n    limit: number;\n}\n\nconst insertRecordSqlTemplate = (schema: EntityInfo) => {\n    const columnNames = [],\n        placeHolder = [];\n    _.forEach(schema.columns, col => {\n        columnNames.push(escapeName(col.name));\n        placeHolder.push('?');\n    });\n    return `INSERT INTO ${escapeName(schema.name)} (${columnNames.join(',')}) VALUES (${placeHolder.join(',')})`;\n};\n\nconst replaceRecordSqlTemplate = (schema: EntityInfo) => {\n    const columnNames = [],\n        placeHolder = [];\n    _.forEach(schema.columns, col => {\n        columnNames.push(escapeName(col.name));\n        placeHolder.push('?');\n    });\n    return `REPLACE INTO ${escapeName(schema.name)} (${columnNames.join(',')}) VALUES (${placeHolder.join(',')})`;\n};\n\nconst deleteRecordTemplate = (schema: EntityInfo) => {\n    const primaryKeyField = _.find(schema.columns, 'primaryKey');\n    if (primaryKeyField) {\n        return `DELETE FROM ${escapeName(schema.name)} WHERE ${escapeName(primaryKeyField.name)} = ?`;\n    }\n    return '';\n};\n\nconst selectSqlTemplate = (schema: EntityInfo) => {\n    const columns = [],\n        joins = [];\n    schema.columns.forEach( col => {\n        let childTableName;\n        columns.push(escapeName(schema.name) + '.' + escapeName(col.name) + ' as ' + col.fieldName);\n        if (col.foreignRelations) {\n            col.foreignRelations.forEach(foreignRelation => {\n                childTableName = foreignRelation.sourceFieldName;\n                _.forEach(foreignRelation.dataMapper, (childCol, childFiledName) => {\n                    columns.push(childTableName + '.' + escapeName(childCol.name) + ' as \\'' + childFiledName + '\\'');\n                });\n                joins.push(` LEFT JOIN ${escapeName(foreignRelation.targetTable)} ${childTableName}\n                         ON ${childTableName}.${escapeName(foreignRelation.targetColumn)} = ${escapeName(schema.name)}.${escapeName(col.name)}`);\n            });\n        }\n    });\n    return `SELECT ${columns.join(',')} FROM ${escapeName(schema.name)} ${joins.join(' ')}`;\n};\n\nconst countQueryTemplate = (schema: EntityInfo) => {\n    const joins = [];\n    schema.columns.forEach( col => {\n        let childTableName;\n        if (col.foreignRelations) {\n            col.foreignRelations.forEach(foreignRelation => {\n                childTableName = foreignRelation.sourceFieldName;\n                joins.push(` LEFT JOIN ${escapeName(foreignRelation.targetTable)} ${childTableName}\n                         ON ${childTableName}.${escapeName(foreignRelation.targetColumn)} = ${escapeName(schema.name)}.${escapeName(col.name)}`);\n            });\n        }\n    });\n    return `SELECT count(*) as count FROM ${escapeName(schema.name)} ${joins.join(' ')}`;\n};\n\nconst generateWherClause = (store: LocalDBStore, filterCriteria: FilterCriterion[]) => {\n    let conditions;\n    const fieldToColumnMapping = store.fieldToColumnMapping,\n        tableName = store.entitySchema.name;\n    if (!_.isEmpty(filterCriteria) && _.isString(filterCriteria)) {\n        return ' WHERE ' + filterCriteria;\n    }\n    if (filterCriteria) {\n        conditions = filterCriteria.map(filterCriterion => {\n            const colName = fieldToColumnMapping[filterCriterion.attributeName],\n                condition = filterCriterion.filterCondition;\n            let target = filterCriterion.attributeValue,\n                operator = '=';\n            if (filterCriterion.attributeType === 'STRING') {\n                if (condition === 'STARTING_WITH') {\n                    target = target + '%';\n                    operator = 'like';\n                } else if (condition === 'ENDING_WITH') {\n                    target = '%' + target;\n                    operator = 'like';\n                } else if (condition === 'CONTAINING') {\n                    target = '%' + target + '%';\n                    operator = 'like';\n                }\n                target = `'${target}'`;\n            } else if (filterCriterion.attributeType === 'BOOLEAN') {\n                target = (target === true ? 1 : 0);\n            }\n            return `${escapeName(tableName)}.${escapeName(colName)} ${operator} ${target}`;\n        });\n    }\n    return conditions && conditions.length > 0 ? ' WHERE ' + conditions.join(' AND ') : '';\n};\n\nconst generateOrderByClause = (store: LocalDBStore, sort: string) => {\n    if (sort) {\n        return ' ORDER BY ' + _.map(sort.split(','), field => {\n            const splits =  _.trim(field).split(' ');\n            splits[0] = escapeName(store.entitySchema.name) + '.' + escapeName(store.fieldToColumnMapping[splits[0]]);\n            return splits.join(' ');\n        }).join(',');\n    }\n    return '';\n};\n\nconst geneateLimitClause = page => {\n    page = page || {};\n    return ' LIMIT ' + (page.limit || 100) + ' OFFSET ' + (page.offset || 0);\n};\n\nconst mapRowDataToObj = (schema: EntityInfo, dataObj: any) => {\n    schema.columns.forEach(col => {\n        const val = dataObj[col.fieldName];\n        if (col.foreignRelations) {\n            col.foreignRelations.forEach(foreignRelation => {\n                let childEntity = null;\n                _.forEach(foreignRelation.dataMapper, function (childCol, childFieldName) {\n                    const fieldValue = dataObj[childFieldName];\n                    if (isDefined(fieldValue) && fieldValue !== null && fieldValue !== '') {\n                        childEntity = childEntity || {};\n                        childEntity[childCol.fieldName] = dataObj[childFieldName];\n                    }\n                    delete dataObj[childFieldName];\n                });\n                dataObj[foreignRelation.sourceFieldName] = childEntity;\n            });\n        } else if (col.sqlType === 'boolean' && !_.isNil(val)) {\n            dataObj[col.fieldName] = (val === 1);\n        }\n    });\n    return dataObj;\n};\n\nconst getValue = (entity: any, col: ColumnInfo) => {\n    let value = entity[col.fieldName];\n    if (col.foreignRelations) {\n        col.foreignRelations.some(foreignRelation => {\n            if (foreignRelation.targetEntity && entity[foreignRelation.sourceFieldName]) {\n                value = entity[foreignRelation.sourceFieldName][foreignRelation.targetFieldName];\n                return true;\n            }\n            return false;\n        });\n    }\n    if (_.isNil(value)) {\n        return col.defaultValue;\n    } else if (col.sqlType === 'boolean') {\n        return (value === true ? 1 : 0);\n    } else {\n        return value;\n    }\n};\n\nconst mapObjToRow = (store: LocalDBStore, entity: any) => {\n    const row = {};\n    store.entitySchema.columns.forEach(col => row[col.name] = getValue(entity, col));\n    return row;\n};\n\nexport class LocalDBStore {\n\n    public readonly primaryKeyField: ColumnInfo;\n    public readonly primaryKeyName: string;\n    public readonly fieldToColumnMapping: object = {};\n\n    private insertRecordSqlTemplate: string;\n    private replaceRecordSqlTemplate: string;\n    private deleteRecordTemplate: string;\n    private selectSqlTemplate: string;\n    private countQuery: string;\n\n    constructor(\n        private deviceFileService: DeviceFileService,\n        public readonly entitySchema: EntityInfo,\n        private file: File,\n        private localDbManagementService: LocalDBManagementService,\n        private sqliteObject: SQLiteObject\n    ) {\n        this.primaryKeyField = _.find(this.entitySchema.columns, 'primaryKey');\n        this.primaryKeyName = this.primaryKeyField ? this.primaryKeyField.fieldName : undefined;\n        this.entitySchema.columns.forEach(c => {\n            this.fieldToColumnMapping[c.fieldName] = c.name;\n            if (c.foreignRelations) {\n                c.foreignRelations.forEach( foreignRelation => {\n                    this.fieldToColumnMapping[foreignRelation.targetPath] = c.name;\n                    _.forEach(foreignRelation.dataMapper, (childCol, childFieldName) => {\n                        this.fieldToColumnMapping[childFieldName] = foreignRelation.sourceFieldName + '.' + childCol.name;\n                    });\n                });\n            }\n        });\n\n        this.insertRecordSqlTemplate = insertRecordSqlTemplate(this.entitySchema);\n        this.replaceRecordSqlTemplate = replaceRecordSqlTemplate(this.entitySchema);\n        this.deleteRecordTemplate = deleteRecordTemplate(this.entitySchema);\n        this.selectSqlTemplate = selectSqlTemplate(this.entitySchema);\n        this.countQuery = countQueryTemplate(this.entitySchema);\n    }\n\n    public add(entity: any): Promise<any> {\n        if (this.primaryKeyName) {\n            const idValue = entity[this.primaryKeyName];\n            if (this.primaryKeyField.sqlType === 'number'\n                && (!isDefined(idValue) || (_.isString(idValue) && _.isEmpty(_.trim(idValue))))) {\n                if (this.primaryKeyField.generatorType === 'identity') {\n                    // updating the id with the latest id obtained from nextId.\n                    entity[this.primaryKeyName] = this.localDbManagementService.nextIdCount();\n                } else {\n                    // for assigned type, get the primaryKeyValue from the relatedTableData which is inside the entity\n                    const primaryKeyValue = this.getValue(entity, this.primaryKeyName);\n                    entity[this.primaryKeyName] = primaryKeyValue;\n                }\n            }\n        }\n        const rowData = mapObjToRow(this, entity);\n        const params = this.entitySchema.columns.map(f => rowData[f.name]);\n        return this.sqliteObject.executeSql(this.insertRecordSqlTemplate, params)\n            .then(result => result.insertId);\n    }\n\n    /**\n     * clears all data of this store.\n     * @returns {object} promise\n     */\n    public clear(): Promise<any> {\n        return this.sqliteObject.executeSql('DELETE FROM ' + escapeName(this.entitySchema.name));\n    }\n\n    /**\n     * creates the stores if it does not exist\n     * @returns {Promise<any>}\n     */\n    public create(): Promise<any> {\n        return this.sqliteObject.executeSql(this.createTableSql(this.entitySchema)).then(() => this);\n    }\n\n    /**\n     * counts the number of records that satisfy the given filter criteria.\n     * @param {FilterCriterion[]} filterCriteria\n     * @returns {object} promise that is resolved with count\n     */\n    public count(filterCriteria?: FilterCriterion[]): Promise<number> {\n        const sql = this.countQuery + generateWherClause(this, filterCriteria);\n        return this.sqliteObject.executeSql(sql).then(result => result.rows.item(0)['count']);\n    }\n\n    /**\n     * This function deserializes the given map object to FormData, provided that map object was\n     * serialized by using serialize method of this store.\n     * @param  {object} map object to deserialize\n     * @returns {object} promise that is resolved with the deserialized FormData.\n     */\n    public deserialize(map: any) {\n        return this.deserializeMapToFormData(map);\n    }\n\n    /**\n     * filters data of this store that statisfy the given filter criteria.\n     * @param {FilterCriterion[]} filterCriteria\n     * @param  {string=} sort ex: 'filedname asc/desc'\n     * @param  {object=} page {'offset' : 0, \"limit\" : 20}\n     * @returns {object} promise that is resolved with the filtered data.\n     */\n    public filter(filterCriteria?: FilterCriterion[], sort?: string, page?: Pagination): Promise<any[]> {\n        let sql = this.selectSqlTemplate;\n        sql += generateWherClause(this, filterCriteria);\n        sql += generateOrderByClause(this, sort);\n        sql += geneateLimitClause(page);\n        return this.sqliteObject.executeSql(sql)\n            .then(result => {\n            const objArr = [],\n                rowCount = result.rows.length;\n            for (let i = 0; i < rowCount; i++) {\n                objArr.push(mapRowDataToObj(this.entitySchema, result.rows.item(i)));\n            }\n            return objArr;\n        });\n    }\n\n    // fetches all the data related to the primaryKey\n    public refresh(data) {\n        const primaryKeyName = this.primaryKeyName;\n        const primaryKey = this.getValue(data, primaryKeyName);\n        if (!primaryKey) {\n            return Promise.resolve(data);\n        }\n        return this.get(primaryKey);\n    }\n\n    /**\n     * deletes the record with the given primary key.\n     * @param  {object} primaryKey primary key of the record\n     * @returns {object} promise\n     */\n    public delete(primaryKey: any) {\n        return this.sqliteObject.executeSql(this.deleteRecordTemplate, [primaryKey]);\n    }\n\n    /**\n     * finds the record with the given primary key.\n     * @param  {object} primaryKey primary key of the record\n     * @returns {object} promise that is resolved with entity\n     */\n    public get(primaryKey: any) {\n        const filterCriteria = [{\n            attributeName: this.primaryKeyName,\n            filterCondition: '=',\n            attributeValue: primaryKey,\n            attributeType: this.primaryKeyField.sqlType.toUpperCase() }];\n        return this.filter(filterCriteria).then(function (obj) {\n            return obj && obj.length === 1 ? obj[0] : undefined;\n        });\n    }\n\n    /**\n     * retrieve the value for the given field.\n     *\n     * @param entity\n     * @param {string} fieldName\n     * @returns {undefined | any | number}\n     */\n    public getValue(entity: any, fieldName: string) {\n        const column = this.entitySchema.columns.find( col => col.fieldName === fieldName);\n        return getValue(entity, column);\n    }\n\n    /**\n     * saves the given entity to the store. If the record is not available, then a new record will be created.\n     * @param {object} entity the entity to save\n     * @returns {object} promise\n     */\n    public save(entity) {\n        return this.saveAll([entity]);\n    }\n\n    /**\n     * saves the given entity to the store. If the record is not available, then a new record will be created.\n     * @param {object} entities the entity to save\n     * @returns {object} promise\n     */\n    public saveAll(entities: any[]) {\n        // filtering the null entities\n        entities = _.filter(entities, null);\n        const queries = _.map(entities, entity => {\n            const rowData = mapObjToRow(this, entity);\n            const params = this.entitySchema.columns.map(f => rowData[f.name]);\n            return [this.replaceRecordSqlTemplate, params];\n        });\n        return this.sqliteObject.sqlBatch(queries);\n    }\n\n    /**\n     * Based on this store columns, this function converts the given FormData to a map object.\n     * Multipart file is stored as a local file. If form data cannot be serialized,\n     * then formData is returned back.\n     * @param  {FormData} formData object to serialize\n     * @returns {object} promise that is resolved with a map.\n     */\n    public serialize(formData: any) {\n        return this.serializeFormDataToMap(formData);\n    }\n\n    /**\n     * Save blob to a local file\n     * @param blob\n     * @returns {*}\n     */\n    private saveBlobToFile(blob: any) {\n        const fileName = this.deviceFileService.appendToFileName(blob.name),\n            uploadDir = this.deviceFileService.getUploadDirectory();\n        return this.file.writeFile(uploadDir, fileName, blob).then(function () {\n            return {\n                'name' : blob.name,\n                'type' : blob.type,\n                'lastModified' : blob.lastModified,\n                'lastModifiedDate' : blob.lastModifiedDate,\n                'size' : blob.size,\n                'wmLocalPath' : uploadDir + '/' + fileName\n            };\n        });\n    }\n\n    /**\n     * Converts form data object to map for storing request in local database..\n     */\n    private serializeFormDataToMap(formData) {\n        const blobColumns = _.filter(this.entitySchema.columns, {\n                'sqlType' : 'blob'\n            }),\n            promises = [];\n        let map = {};\n        if (formData && typeof formData.append === 'function' && formData.rowData) {\n            _.forEach(formData.rowData, (fieldData, fieldName) => {\n                if (fieldData && _.find(blobColumns, {'fieldName' : fieldName})) {\n                    promises.push(this.saveBlobToFile(fieldData).then(localFile => {\n                        map[fieldName] = localFile;\n                    }));\n                } else {\n                    map[fieldName] = fieldData;\n                }\n            });\n        } else {\n            map = formData;\n        }\n        return Promise.all(promises).then(() => map);\n    }\n\n    /**\n     * Converts map object back to form data.\n     */\n    private deserializeMapToFormData(map) {\n        const formData = new FormData(),\n            blobColumns = this.entitySchema.columns.filter(c => c.sqlType === 'blob'),\n            promises = [];\n        _.forEach(blobColumns, column => {\n            const value = map[column.fieldName];\n            if (value && value.wmLocalPath) {\n                promises.push(convertToBlob(value.wmLocalPath)\n                    .then(result => formData.append(column.fieldName, result.blob, value.name)));\n                map[column.fieldName] = '';\n            }\n        });\n        formData.append(SWAGGER_CONSTANTS.WM_DATA_JSON, new Blob([JSON.stringify(map)], {\n            type: 'application/json'\n        }));\n        return Promise.all(promises).then(() => formData);\n    }\n\n    private createTableSql(schema) {\n        const fieldStr = _.reduce(schema.columns, (result, f) => {\n            let str = escapeName(f.name);\n            if (f.primaryKey) {\n                if (f.sqlType === 'number' && f.generatorType === 'databaseIdentity') {\n                    str += ' INTEGER PRIMARY KEY AUTOINCREMENT';\n                } else {\n                    str += ' PRIMARY KEY';\n                }\n            }\n            return result ? result + ',' + str : str;\n        }, false);\n        return `CREATE TABLE IF NOT EXISTS ${escapeName(schema.name)} (${fieldStr})`;\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { AppVersion } from '@ionic-native/app-version';\nimport { File } from '@ionic-native/file';\nimport { SQLite, SQLiteObject } from '@ionic-native/sqlite';\n\nimport { DataType, DEFAULT_FORMATS, executePromiseChain, extractType, isAndroid, isArray, isIos, noop, toPromise } from '@wm/core';\nimport { DeviceFileService, DeviceService } from '@wm/mobile/core';\nimport { SecurityService } from '@wm/security';\nimport { formatDate } from '@wm/variables';\n\nimport { LocalKeyValueService } from './local-key-value.service';\nimport { LocalDBStore } from '../models/local-db-store';\nimport { escapeName } from '../utils/utils';\nimport { ColumnInfo, DBInfo, EntityInfo, NamedQueryInfo, PullType } from '../models/config';\n\ndeclare const _;\ndeclare const cordova;\ndeclare const moment;\ndeclare const Zeep;\n\nconst  NEXT_ID_COUNT = 'localDBStore.nextIdCount';\nconst META_LOCATION = 'www/metadata/app';\nconst OFFLINE_WAVEMAKER_DATABASE_SCHEMA = {\n    name: 'wavemaker',\n    version: 1,\n    isInternal: true,\n    tables: [\n        {\n            name: 'key_value',\n            entityName: 'key-value',\n            columns: [{\n                fieldName: 'id',\n                name: 'id',\n                generatorType : 'databaseIdentity',\n                sqlType : 'number',\n                primaryKey: true\n            }, {\n                fieldName: 'key',\n                name: 'key'\n            }, {\n                name: 'value',\n                fieldName: 'value'\n            }]\n        },\n        {\n            name: 'offlineChangeLog',\n            entityName: 'offlineChangeLog',\n            columns: [{\n                fieldName: 'id',\n                name: 'id',\n                generatorType: 'databaseIdentity',\n                sqlType: 'number',\n                primaryKey: true\n            }, {\n                name: 'service',\n                fieldName: 'service'\n            }, {\n                name: 'operation',\n                fieldName: 'operation'\n            }, {\n                name: 'params',\n                fieldName: 'params'\n            }, {\n                name: 'timestamp',\n                fieldName: 'timestamp'\n            }, {\n                name: 'hasError',\n                fieldName: 'hasError'\n            }, {\n                name: 'errorMessage',\n                fieldName: 'errorMessage'\n            }]\n        }\n    ]\n};\n\nexport interface CallBack {\n    onDbCreate?: (info: any) => any;\n    postImport?: (importFolderPath: string, metaInfo: any) => any;\n    preExport?: (folderToExportFullPath: string, metaInfo: any) => any;\n}\n\n@Injectable({providedIn: 'root'})\nexport class LocalDBManagementService {\n\n    private callbacks: CallBack[] = [];\n    private dbInstallDirectory: string;\n    private dbInstallDirectoryName: string;\n    private dbInstallParentDirectory: string;\n    private databases: Map<string, DBInfo>;\n    private _logSql = false;\n    public nextId = 100000000000;\n    private readonly systemProperties = {\n        'USER_ID' : {\n            'name' : 'USER_ID',\n            'value' : () => this.securityService.getLoggedInUser().then( userInfo => userInfo.userId)\n        },\n        'USER_NAME' : {\n            'name' : 'USER_NAME',\n            'value' : () => this.securityService.getLoggedInUser().then( userInfo => userInfo.userName)\n        },\n        'DATE_TIME' : {\n            'name' : 'DATE_TIME',\n            'value' : () => moment().format('YYYY-MM-DDThh:mm:ss')\n        },\n        'DATE' : {\n            'name' : 'CURRENT_DATE',\n            'value' : () => moment().format('YYYY-MM-DD')\n        },\n        'TIME' : {\n            'name' : 'TIME',\n            'value' : () => moment().format('hh:mm:ss')\n        }\n    };\n\n    constructor(\n        private appVersion: AppVersion,\n        private deviceService: DeviceService,\n        private deviceFileService: DeviceFileService,\n        private file: File,\n        private localKeyValueService: LocalKeyValueService,\n        private securityService: SecurityService,\n        private sqlite: SQLite\n    ) {}\n\n    /**\n     * Closes all databases.\n     *\n     * @returns {object} a promise.\n     */\n    public close(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            // Before closing databases, give some time for the pending transactions (if any).\n            setTimeout(() => {\n                const closePromises = _.map(_.values(this.databases), db => db.sqliteObject.close());\n                Promise.all(closePromises).then(resolve, reject);\n            }, 1000);\n        });\n    }\n\n    public nextIdCount() {\n        this.nextId = this.nextId + 1;\n        this.localKeyValueService.put(NEXT_ID_COUNT, this.nextId);\n        return this.nextId;\n    }\n\n    /**\n     * Executes a named query.\n     *\n     * @param {string} dbName name of database on which the named query has to be run\n     * @param {string} queryName name of the query to execute\n     * @param {object} params parameters required for query.\n     * @returns {object} a promise.\n     */\n    public executeNamedQuery(dbName: string, queryName: string, params: any) {\n        let queryData, paramPromises;\n        if (!this.databases[dbName] || !this.databases[dbName].queries[queryName]) {\n            return Promise.reject(`Query by name ' ${queryName} ' Not Found`);\n        }\n        queryData = this.databases[dbName].queries[queryName];\n        paramPromises = _.chain(queryData.params)\n            .filter(p => p.variableType !== 'PROMPT')\n            .forEach(p => {\n                const paramValue = this.systemProperties[p.variableType].value(p.name, params);\n                return toPromise(paramValue).then(v => params[p.name] = v);\n            }).value();\n        return Promise.all(paramPromises).then(() => {\n            params = _.map(queryData.params, p => {\n                // Sqlite will accept DateTime value as below format.\n                if (typeof params[p.name] !== 'string'\n                    && (p.type === DataType.DATETIME || p.type === DataType.LOCALDATETIME)) {\n                    return formatDate(params[p.name], p.type);\n                }\n                // sqlite accepts the bool val as 1,0 hence convert the boolean value to number\n                if (p.type === DataType.BOOLEAN) {\n                    return this.convertBoolToInt(params[p.name]);\n                }\n                return params[p.name];\n            });\n            return this.executeSQLQuery(dbName, queryData.query, params)\n                .then(result => {\n                    let firstRow,\n                        needTransform;\n                    if (!_.isEmpty(result.rows)) {\n                        firstRow = result.rows[0];\n                        needTransform = _.find(queryData.response.properties, p => !firstRow.hasOwnProperty(p.fieldName));\n                        if (!_.isUndefined(needTransform)) {\n                            result.rows = _.map(result.rows, row => {\n                                const transformedRow = {},\n                                    rowWithUpperKeys = {};\n                                // This is to make search for data as case-insensitive\n                                _.forEach(row, (v, k) => rowWithUpperKeys[k.toUpperCase()] = v);\n                                _.forEach(queryData.response.properties, p => {\n                                    // format the value depending on the typeRef specified in properties.\n                                    const propType = extractType(p.fieldType.typeRef);\n                                    const formatValue = DEFAULT_FORMATS[_.toUpper(propType)];\n                                    const fieldVal = row[p.name];\n                                    if (fieldVal && typeof fieldVal !== 'string'\n                                        && (propType === DataType.DATETIME || propType === DataType.LOCALDATETIME || propType === DataType.DATE)) {\n                                        if (moment(fieldVal).isValid()) {\n                                            row[p.name] = formatDate(fieldVal, propType);\n                                        } else if (moment(fieldVal, 'HH:mm').isValid()) {\n                                            // if the value is in HH:mm:ss format, it returns a wrong date. So append the date to the given value to get date\n                                            row[p.name] = moment().format('YYYY-MM-DD') + 'T' + fieldVal;\n                                        }\n                                    }\n                                    if (propType === DataType.BOOLEAN) {\n                                        row[p.name] = this.convertIntToBool(fieldVal);\n                                    }\n                                    rowWithUpperKeys[p.nameInUpperCase] = row[p.name];\n                                    transformedRow[p.name] = row[p.name];\n                                    transformedRow[p.fieldName] = row[p.fieldName] || rowWithUpperKeys[p.nameInUpperCase];\n                                });\n                                return transformedRow;\n                            });\n                        }\n                    }\n                    return result;\n                });\n        });\n    }\n\n    /**\n     * This function will export the databases in a zip format.\n     *\n     * @returns {object} a promise that is resolved when zip is created.\n     */\n    public exportDB(): Promise<string> {\n        return new Promise<string>((resolve, reject) => {\n            const folderToExport = 'offline_temp_' + _.now(),\n                folderToExportFullPath = cordova.file.cacheDirectory + folderToExport + '/',\n                zipFileName = '_offline_data.zip',\n                metaInfo = {\n                    app: null,\n                    OS: '',\n                    createdOn: 0\n                };\n            let zipDirectory;\n            if (isIos()) {\n                // In IOS, save zip to documents directory so that user can export the file from IOS devices using iTUNES.\n                zipDirectory = cordova.file.documentsDirectory;\n            } else {\n                // In Android, save zip to download directory.\n                zipDirectory = cordova.file.externalRootDirectory + 'Download/';\n            }\n            // Create a temporary folder to copy all the content to export\n            this.file.createDir(cordova.file.cacheDirectory, folderToExport, false)\n                .then(() => {\n                    // Copy databases to temporary folder for export\n                    return this.file.copyDir(this.dbInstallParentDirectory, this.dbInstallDirectoryName, folderToExportFullPath, 'databases')\n                        .then(() => {\n                            // Prepare meta info to identify the zip and other info\n                            return this.getAppInfo();\n                        }).then(appInfo => {\n                            metaInfo.app = (appInfo as any);\n                            if (isIos()) {\n                                metaInfo.OS = 'IOS';\n                            } else if (isAndroid()) {\n                                metaInfo.OS = 'ANDROID';\n                            }\n                            metaInfo.createdOn = _.now();\n                            return metaInfo;\n                        }).then(() => executePromiseChain(this.getCallbacksFor('preExport'), [folderToExportFullPath, metaInfo]))\n                        .then(() => {\n                            // Write meta data to META.json\n                            return this.file.writeFile(folderToExportFullPath, 'META.json', JSON.stringify(metaInfo));\n                        });\n                }).then(() => {\n                    // Prepare name to use for the zip.\n                    let appName = metaInfo.app.name;\n                    appName = appName.replace(/\\s+/g, '_');\n                    return this.deviceFileService.newFileName(zipDirectory, appName + zipFileName)\n                        .then(fileName => {\n                            // Zip the temporary folder for export\n                            return new Promise((rs, re) => {\n                                Zeep.zip({\n                                    from : folderToExportFullPath,\n                                    to   : zipDirectory + fileName\n                                }, () => rs(zipDirectory + fileName), re);\n                            });\n                        });\n                }).then(resolve, reject)\n                .catch(noop).then(() => {\n                    // Remove temporary folder for export\n                    return this.deviceFileService.removeDir(cordova.file.cacheDirectory + folderToExport);\n                });\n        });\n    }\n\n    /**\n     *  returns store bound to the dataModelName and entityName.\n     *\n     * @param dataModelName\n     * @param entityName\n     * @returns {*}\n     */\n    public getStore(dataModelName: string, entityName: string): Promise<LocalDBStore> {\n        return new Promise((resolve, reject) => {\n            if (this.databases[dataModelName]) {\n                resolve(this.databases[dataModelName].stores[entityName]);\n            }\n            reject(`store with name'${entityName}' in datamodel '${dataModelName}' is not found`);\n        });\n    }\n\n    /**\n     * This function will replace the databases with the files provided in zip. If import gets failed,\n     * then app reverts back to use old databases.\n     *\n     * @param {string} zipPath location of the zip file.\n     * @param {boolean} revertIfFails If true, then a backup is created and when import fails, backup is reverted back.\n     * @returns {object} a promise that is resolved when zip is created.\n     */\n    public importDB(zipPath: string, revertIfFails: boolean): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            const importFolder = 'offline_temp_' + _.now(),\n                importFolderFullPath = cordova.file.cacheDirectory + importFolder + '/';\n            let zipMeta;\n            // Create a temporary folder to unzip the contents of the zip.\n            this.file.createDir(cordova.file.cacheDirectory, importFolder, false)\n                .then( () => {\n                    return new Promise<void>((rs, re) => {\n                        // Unzip to temporary location\n                        Zeep.unzip({\n                            from: zipPath,\n                            to: importFolderFullPath\n                        }, rs, re);\n                    });\n                }).then(() => {\n                /*\n                 * read meta data and allow import only package name of the app from which this zip is created\n                 * and the package name of this app are same.\n                 */\n                return this.file.readAsText(importFolderFullPath, 'META.json')\n                    .then(text => {\n                    zipMeta = JSON.parse(text);\n                    return this.getAppInfo();\n                }).then(appInfo => {\n                    if (!zipMeta.app) {\n                        return Promise.reject('meta information is not found in zip');\n                    }\n                    if (zipMeta.app.packageName !== appInfo.packageName) {\n                        return Promise.reject('database zip of app with same package name can only be imported');\n                    }\n                });\n            }).then(() => {\n                let backupZip;\n                return this.close()\n                    .then(() => {\n                        if (revertIfFails) {\n                            // create backup\n                            return this.exportDB()\n                                .then(path => backupZip = path);\n                        }\n                    }).then(() => {\n                        // delete existing databases\n                        return this.deviceFileService.removeDir(this.dbInstallDirectory);\n                    }).then(() => {\n                        // copy imported databases\n                        return this.file.copyDir(importFolderFullPath, 'databases', this.dbInstallParentDirectory, this.dbInstallDirectoryName);\n                    }).then(() => {\n                        // reload databases\n                        this.databases = null;\n                        return this.loadDatabases();\n                    }).then(() => executePromiseChain(this.getCallbacksFor('postImport'), [importFolderFullPath, zipMeta]))\n                    .then(() => {\n                        if (backupZip) {\n                            return this.deviceFileService.removeFile(backupZip);\n                        }\n                    }, (reason) => {\n                        if (backupZip) {\n                            return this.importDB(backupZip, false)\n                                .then(() => {\n                                    this.deviceFileService.removeFile(backupZip);\n                                    return Promise.reject(reason);\n                                });\n                        }\n                        return Promise.reject(reason);\n                    });\n            }).then(resolve, reject)\n            .catch(noop)\n            .then(() => {\n                return this.deviceFileService.removeDir(cordova.file.cacheDirectory + importFolder);\n            });\n        });\n    }\n\n    /**\n     * @param {string} dataModelName Name of the data model\n     * @param {string} entityName Name of the entity\n     * @param {string} operation Name of the operation (READ, INSERT, UPDATE, DELETE)\n     * @returns {boolean} returns true, if the given operation can be performed as per configuration.\n     */\n    public isOperationAllowed(dataModelName: string, entityName: string, operation: string): Promise<boolean> {\n        return this.getStore(dataModelName, entityName).then( store => {\n            if (!store) {\n                return false;\n            }\n            if (operation === 'READ') {\n                return store.entitySchema.pushConfig.readEnabled;\n            }\n            if (operation === 'INSERT') {\n                return store.entitySchema.pushConfig.insertEnabled;\n            }\n            if (operation === 'UPDATE') {\n                return store.entitySchema.pushConfig.updateEnabled;\n            }\n            if (operation === 'DELETE') {\n                return store.entitySchema.pushConfig.deleteEnabled;\n            }\n            return false;\n        }).catch(() => {\n            return false;\n        });\n    }\n\n    public loadDatabases(): Promise<any> {\n        let newDatabasesCreated = false;\n        if (this.databases) {\n            return Promise.resolve(this.databases);\n        } else {\n            if (isIos()) {\n                this.dbInstallDirectoryName = 'LocalDatabase';\n                this.dbInstallParentDirectory = cordova.file.applicationStorageDirectory +  'Library/';\n            } else {\n                this.dbInstallDirectoryName = 'databases';\n                this.dbInstallParentDirectory = cordova.file.applicationStorageDirectory;\n            }\n            this.dbInstallDirectory = this.dbInstallParentDirectory + this.dbInstallDirectoryName;\n\n            this.databases = new Map<string, DBInfo>();\n            return this.setUpDatabases()\n                .then( flag => newDatabasesCreated = flag)\n                .then(() => this.loadDBSchemas())\n                .then(metadata => this.loadNamedQueries(metadata))\n                .then(metadata => this.loadOfflineConfig(metadata))\n                .then(metadata => {\n                    return Promise.all(_.map(metadata, dbMetadata => {\n                        return this.openDatabase(dbMetadata)\n                            .then(database => {\n                                this.databases[dbMetadata.schema.name] = database;\n                            });\n                    }));\n                }).then(() => {\n                    return this.getStore('wavemaker', 'key-value').then( store => {\n                        this.localKeyValueService.init(store);\n                        return this.localKeyValueService.get(NEXT_ID_COUNT).then(val => {\n                           this.nextId = val || this.nextId;\n                        });\n                    });\n                }).then(() => {\n                    if (newDatabasesCreated) {\n                        return this.normalizeData()\n                            .then(() => this.disableForeignKeys())\n                            .then(() => this.deviceService.getAppBuildTime())\n                            .then(dbSeedCreationTime => {\n                                return executePromiseChain(_.map(this.callbacks, 'onDbCreate'), [{\n                                    'databases' : this.databases,\n                                    'dbCreatedOn' : _.now(),\n                                    'dbSeedCreatedOn' : dbSeedCreationTime\n                                }]);\n                            }).then(() => this.databases);\n                    } else {\n                        return this.databases;\n                    }\n                });\n        }\n    }\n\n    /**\n     * using this function one can listen events such as onDbCreate, 'preExport' and 'postImport'.\n     *\n     * @param {object} listener an object with functions mapped to event names.\n     */\n    public registerCallback(listener: CallBack) {\n        this.callbacks.push(listener);\n    }\n\n    public setLogSQl(flag: boolean) {\n        this._logSql = flag;\n    }\n\n    /**\n     * Deletes any existing databases (except wavemaker db) and copies the databases that are packaged with the app.\n     *\n     * @returns {*}\n     */\n    private cleanAndCopyDatabases(): Promise<any> {\n        const dbSeedFolder = cordova.file.applicationDirectory + META_LOCATION;\n        return this.file.createDir(this.dbInstallParentDirectory, this.dbInstallDirectoryName, false)\n            .catch(noop)\n            .then(() => this.deviceFileService.listFiles(this.dbInstallDirectory, /.+\\.db$/))\n            .then(files => {\n                if (files && files.length > 0) {\n                    return Promise.all(files.map(f => {\n                        if (f['name'] !== 'wavemaker.db') {\n                            return this.file.removeFile(this.dbInstallDirectory, f['name']);\n                        }\n                    }));\n                }\n            })\n            .then( () => this.deviceFileService.listFiles(dbSeedFolder, /.+\\.db$/))\n            .then(files => {\n                if (files && files.length > 0) {\n                    return this.file.createDir(this.dbInstallParentDirectory, this.dbInstallDirectoryName, false)\n                        .catch(noop)\n                        .then(() => Promise.all(files.map(\n                                f => this.file.copyFile(dbSeedFolder, f['name'], this.dbInstallDirectory, f['name'])\n                            ))\n                        );\n                }\n            });\n    }\n\n    // Picks essential details from the given schema.\n    private compactEntitySchema(schema, entity, transformedSchemas): EntityInfo {\n        const reqEntity = transformedSchemas[entity['entityName']] as EntityInfo;\n        reqEntity.entityName = entity['entityName'];\n        reqEntity.name = entity['name'];\n        reqEntity.columns = [];\n        entity.columns.forEach(col => {\n            let defaultValue = col.columnValue ? col.columnValue.defaultValue : '';\n            const type = col.sqlType;\n            if (type === 'number' && !col.primaryKey) {\n                defaultValue = _.isEmpty(defaultValue) ? null : _.parseInt(defaultValue);\n            } else if (type === 'boolean') {\n                defaultValue = _.isEmpty(defaultValue) ? null : (defaultValue === 'true' ? 1 : 0);\n            } else {\n                defaultValue = _.isEmpty(defaultValue) ? null : defaultValue;\n            }\n            reqEntity.columns.push({\n                name: col['name'],\n                fieldName: col['fieldName'],\n                generatorType: col['generatorType'],\n                sqlType: col['sqlType'],\n                primaryKey: col['primaryKey'],\n                defaultValue: defaultValue\n            });\n        });\n\n        _.forEach(entity.relations, r => {\n            let targetEntitySchema, targetEntity, col, sourceColumn, mapping;\n            if (r.cardinality === 'ManyToOne' || r.cardinality === 'OneToOne') {\n                targetEntity = _.find(schema.tables, t => t.name === r.targetTable);\n                mapping = r.mappings[0];\n                if (targetEntity) {\n                    targetEntity = targetEntity.entityName;\n                    sourceColumn = mapping.sourceColumn;\n                    col = reqEntity.columns.find(column => column.name === sourceColumn);\n                    targetEntitySchema = schema.tables.find(table => table.name === r.targetTable);\n                    const foreignRelation = {\n                        sourceFieldName: r.fieldName,\n                        targetEntity: targetEntity,\n                        targetTable: r.targetTable,\n                        targetColumn: mapping.targetColumn,\n                        targetPath: '',\n                        dataMapper: [],\n                        targetFieldName: targetEntitySchema.columns.find(column => column.name === mapping.targetColumn).fieldName\n                    };\n                    foreignRelation.targetPath = foreignRelation.sourceFieldName + '.' + foreignRelation.targetFieldName;\n                    foreignRelation.dataMapper = _.chain(targetEntitySchema.columns)\n                        .keyBy(childCol => foreignRelation.sourceFieldName + '.' + childCol.fieldName)\n                        .mapValues(childCol => new ColumnInfo(childCol.name, childCol.fieldName)).value();\n                    col.foreignRelations = col.foreignRelations || [];\n                    col.foreignRelations.push(foreignRelation);\n                }\n            }\n        });\n        return reqEntity;\n    }\n\n    // Loads necessary details of queries\n    private compactQueries(queriesByDB): Map<string, NamedQueryInfo> {\n        const queries = new Map<string, NamedQueryInfo>();\n\n        _.forEach(queriesByDB.queries, queryData => {\n            let query, params;\n            if (queryData.nativeSql && queryData.type === 'SELECT') {\n                query = _.isEmpty(queryData.offlineQueryString) ? queryData.queryString : queryData.offlineQueryString;\n                params = _.map(this.extractQueryParams(query), p => {\n                    const paramObj = _.find(queryData.parameters, {'name': p});\n                    return {\n                        name: paramObj.name,\n                        type: paramObj.type,\n                        variableType: paramObj.variableType\n                    };\n                });\n                params.forEach(p => query = _.replace(query, ':' + p.name, '?'));\n                queries[queryData.name] = {\n                    name: queryData.name,\n                    query: query,\n                    params: params,\n                    response: {\n                        properties: _.map(queryData.response.properties, p => {\n                            p.nameInUpperCase = p.name.toUpperCase();\n                            return p;\n                        })\n                    }\n                };\n            }\n        });\n        return queries;\n    }\n\n    // Loads necessary details of remote schema\n    private compactSchema(schema): DBInfo {\n        const dbInfo = new DBInfo();\n        const transformedSchemas = new Map<string, EntityInfo>();\n        schema.tables.forEach(entitySchema => {\n            transformedSchemas[entitySchema.entityName] = {};\n        });\n        schema.tables.forEach(entitySchema => {\n            this.compactEntitySchema(schema, entitySchema, transformedSchemas);\n        });\n        dbInfo.schema.name = schema.name;\n        dbInfo.schema.isInternal = schema.isInternal;\n        dbInfo.schema.entities = transformedSchemas;\n        return dbInfo;\n    }\n\n    private convertBoolToInt(bool: boolean) {\n        return _.toString(bool) === 'true' ? 1 : 0;\n    }\n\n    private convertIntToBool(int: number) {\n        return int ? true : false;\n    }\n\n    /**\n     * Turns off foreign keys\n     * @returns {*}\n     */\n    private disableForeignKeys() {\n        return Promise.all(_.map(this.databases, db =>\n            this.executeSQLQuery(db.schema.name, 'PRAGMA foreign_keys = OFF')\n        ));\n    }\n\n    /**\n     * Executes SQL query;\n     *\n     * @param dbName\n     * @param sql\n     * @param params\n     * @returns {*}\n     */\n    public executeSQLQuery(dbName, sql, params?: any[], logOutput?: boolean) {\n        const db = this.databases[dbName];\n        if (db) {\n            return db.sqliteObject.executeSql(sql, params, logOutput)\n                .then(result => {\n                    const data = [],\n                        rows = result.rows;\n                    for (let i = 0; i < rows.length; i++) {\n                        data.push(rows.item(i));\n                    }\n                    return {\n                        'rowsAffected'  : result.rowsAffected,\n                        'rows'          : data\n                    };\n                });\n        }\n        return Promise.reject(`No Database with name ${dbName} found`);\n    }\n\n    // get the params of the query or procedure.\n    private extractQueryParams(query) {\n        let params, aliasParams;\n        aliasParams = query.match(/[^\"'\\w\\\\]:\\s*\\w+\\s*/g) || [];\n        if (aliasParams.length) {\n            params = aliasParams.map(x => (/[=|\\W]/g.test(x)) ? x.replace(/\\W/g, '').trim() : x.trim());\n        } else {\n            params = null;\n        }\n        return params;\n    }\n\n    /**\n     * Returns a promise that is resolved with application info such as packageName, appName, versionNumber, versionCode.\n     * @returns {*}\n     */\n    private getAppInfo() {\n        const appInfo = {\n            name: '',\n            packageName: '',\n            versionNumber: '',\n            versionCode: null\n        };\n        return this.appVersion.getPackageName()\n            .then(packageName => {\n                appInfo.packageName = packageName;\n                return this.appVersion.getAppName();\n            }).then(appName => {\n                appInfo.name = appName;\n                return this.appVersion.getVersionNumber();\n            }).then(versionNumber => {\n                appInfo.versionNumber = versionNumber;\n                return this.appVersion.getVersionCode();\n            }).then(versionCode => {\n                appInfo.versionCode = (versionCode as any);\n                return appInfo;\n            });\n    }\n\n    private getCallbacksFor(event: string): any[] {\n        return this.callbacks.map(c => {\n            if (c[event]) {\n                return c[event].bind(c);\n            }\n            return null;\n        });\n    }\n\n    /**\n     * Searches for the files with given regex in 'www/metadata/app'and returns an array that contains the JSON\n     * content present in each file.\n     *\n     * @param {string} fileNameRegex regex pattern to search for files.\n     * @returns {*} A promise that is resolved with an array\n     */\n    private getMetaInfo(fileNameRegex: RegExp) {\n        const folder = cordova.file.applicationDirectory + META_LOCATION + '/';\n        return this.deviceFileService.listFiles(folder, fileNameRegex)\n            .then(files => Promise.all(_.map(files, f => {\n                    return new Promise((resolve, reject) => {\n                        // Cordova File reader has buffer issues with large files.\n                        // so, using ajax to retrieve local json\n                        $.getJSON( folder + f['name'], data => resolve(data));\n                    });\n                }))\n            );\n    }\n\n    /**\n     * Returns true, if the given entity's data is bundled along with application installer.\n     * @param dataModelName name of the data model\n     * @param entityName name of the entity\n     * @returns {Promise<any>}\n     */\n    public isBundled(dataModelName, entityName): Promise<any> {\n        return this.getStore(dataModelName, entityName).then(store => {\n            return store.entitySchema.pullConfig.pullType === PullType.BUNDLED;\n        });\n    }\n\n    /**\n     * Loads local database schemas from *_data_model.json.\n     *\n     * @returns {*} A promise that is resolved with metadata.\n     */\n    private loadDBSchemas(): Promise<Map<string, DBInfo>> {\n        return this.getMetaInfo(/.+_dataModel\\.json$/)\n            .then( (schemas: any) => {\n                const metadata = new Map<string, DBInfo>();\n                schemas = isArray(schemas) ? schemas : [schemas];\n                schemas.push(OFFLINE_WAVEMAKER_DATABASE_SCHEMA);\n                schemas.map(s => this.compactSchema(s))\n                    .forEach(s =>  {\n                        metadata[s.schema.name] = s;\n                    });\n                return metadata;\n            });\n    }\n\n    /**\n     * Load named queries from *_query.json.\n     *\n     * @param {*} metadata\n     * @returns {*} A promise that is resolved with metadata\n     */\n    private loadNamedQueries(metadata) {\n        return this.getMetaInfo(/.+_query\\.json$/)\n            .then((queriesByDBs: any) => {\n                queriesByDBs = _.isArray(queriesByDBs) ? queriesByDBs : [queriesByDBs];\n                queriesByDBs.map(e => metadata[e.name].queries = this.compactQueries(e));\n                return metadata;\n            });\n    }\n\n    /**\n     * Load offline configuration from *_offline.json.\n     *\n     * @param {*} metadata\n     * @returns {*} A promise that is resolved with metadata\n     */\n    private loadOfflineConfig(metadata) {\n        return this.getMetaInfo(/.+_offline\\.json$/)\n            .then(configs => {\n                _.forEach(configs, config => {\n                    _.forEach(config.entities, entityConfig => {\n                        const entitySchema = _.find(metadata[config.name].schema.entities, schema => schema.name === entityConfig.name);\n                        _.assignIn(entitySchema, entityConfig);\n                    });\n                });\n                return metadata;\n            });\n    }\n\n    private logSql(sqliteObject: SQLiteObject) {\n        const logger = console,\n            originalExecuteSql = sqliteObject.executeSql;\n        sqliteObject.executeSql = (sql, params, logOutput?: boolean) => {\n            const startTime = _.now();\n            return originalExecuteSql.call(sqliteObject, sql, params).then(result => {\n                if (logOutput || this._logSql) {\n                    const objArr = [],\n                        rowCount = result.rows.length;\n                    for (let i = 0; i < rowCount; i++) {\n                        objArr.push(result.rows.item(i));\n                    }\n                    logger.debug('SQL \"%s\"  with params %O took [%d ms]. And the result is %O', sql, params, _.now() - startTime, objArr);\n                }\n                return result;\n            }, error => {\n                logger.error('SQL \"%s\" with params %O failed with error message %s', sql, params, error.message);\n                return Promise.reject(error);\n            });\n        };\n    }\n\n    /**\n     * SQLite does not support boolean data. Instead of using boolean values, data will be changed to 0 or 1.\n     * If the value is 'true', then 1 is set as value. If value is not 1 nor null, then column value is set as 0.\n     * @param dbName\n     * @param tableName\n     * @param colName\n     * @returns {*}\n     */\n    private normalizeBooleanData(dbName, tableName, colName) {\n        const trueTo1Query = `update ${escapeName(tableName)} set ${escapeName(colName)} = 1 where ${escapeName(colName)} = 'true'`,\n            exceptNullAnd1to0Query = `update ${escapeName(tableName)} set ${escapeName(colName)} = 0\n                                  where ${escapeName(colName)} is not null and ${escapeName(colName)} != 1`;\n        return this.executeSQLQuery(dbName, trueTo1Query)\n            .then(() => this.executeSQLQuery(dbName, exceptNullAnd1to0Query));\n    }\n\n    /**\n     * Converts data to support SQLite.\n     * @returns {*}\n     */\n    private normalizeData() {\n        return Promise.all(_.map(this.databases, database => {\n            return Promise.all(_.map(database.schema.entities, entitySchema => {\n                return Promise.all(_.map(entitySchema.columns, column => {\n                    if (column.sqlType === 'boolean') {\n                        return this.normalizeBooleanData(database.schema.name, entitySchema.name, column.name);\n                    }\n                }));\n            }));\n        }));\n    }\n\n    private openDatabase(database: DBInfo) {\n        return this.sqlite.create({\n                name: database.schema.name + '.db',\n                location: 'default'\n        }).then(sqliteObject => {\n            database.sqliteObject = sqliteObject;\n            this.logSql(sqliteObject);\n            const storePromises = _.map(database.schema.entities, entitySchema => {\n                const store = new LocalDBStore(this.deviceFileService,\n                    entitySchema,\n                    this.file,\n                    this,\n                    sqliteObject\n                    );\n                return store.create();\n            });\n            return Promise.all(storePromises).then(stores => {\n                _.forEach(stores, store => {\n                    database.stores[store.entitySchema.entityName] = store;\n                });\n                return database;\n            });\n        });\n    }\n\n    /**\n     * When app is opened for first time  after a fresh install or update, then old databases are removed and\n     * new databases are created using bundled databases.\n     *\n     * @returns {*} a promise that is resolved with true, if the databases are newly created or resolved with false\n     * if existing databases are being used.\n     */\n    private setUpDatabases(): Promise<boolean> {\n        return this.deviceService.getAppBuildTime()\n            .then((buildTime) => {\n                const dbInfo = this.deviceService.getEntry('database') || {};\n                if (!dbInfo.lastBuildTime || dbInfo.lastBuildTime !== buildTime) {\n                    return this.cleanAndCopyDatabases()\n                        .then(() => {\n                            dbInfo.lastBuildTime = buildTime;\n                            return this.deviceService.storeEntry('database', dbInfo);\n                        }).then(() => true);\n                }\n                return false;\n            });\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { Observer } from 'rxjs/index';\n\nimport { executePromiseChain, getAbortableDefer, isString, noop } from '@wm/core';\nimport { NetworkService } from '@wm/mobile/core';\n\nimport { LocalDBManagementService } from './local-db-management.service';\nimport { LocalKeyValueService } from './local-key-value.service';\nimport { LocalDBStore } from '../models/local-db-store';\n\ndeclare const _;\n\nexport interface Change {\n    id?: number;\n    errorMessage?: string;\n    hasError: number;\n    operation: string;\n    params: any;\n    service: string;\n}\n\nexport interface FlushContext {\n    clear: () => Promise<any>;\n    get: (key: string) => any;\n    save: () => Promise<any>;\n}\n\nexport interface Worker {\n    onAddCall?: (change: Change) => (Promise<any> | void);\n    preFlush?: (context: FlushContext) => (Promise<any> | void);\n    postFlush?: (pushInfo: PushInfo, context: FlushContext) => (Promise<any> | void);\n    preCall?: (change: Change) => (Promise<any> | void);\n    postCallError?: (change: Change, error: any) => (Promise<any> | void);\n    postCallSuccess?: (change: Change, response: any) => (Promise<any> | void);\n    transformParamsToMap?: (change: Change) => (Promise<any> | void);\n    transformParamsFromMap?: (change: Change) => (Promise<any> | void);\n}\n\nexport interface PullInfo {\n    databases: Array<any>;\n    totalRecordsToPull: number;\n    totalPulledRecordCount: number;\n    startTime: Date;\n    endTime: Date;\n}\n\nexport interface PushInfo {\n    completedTaskCount: number;\n    endTime: Date;\n    failedTaskCount: number;\n    inProgress: boolean;\n    startTime: Date;\n    successfulTaskCount: number;\n    totalTaskCount: number;\n}\n\nexport abstract class PushService {\n    public abstract push(change: Change): Promise<any>;\n}\n\nexport const CONTEXT_KEY = 'changeLogService.flushContext';\nexport const LAST_PUSH_INFO_KEY = 'changeLogService.lastPushInfo';\n\n@Injectable({providedIn: 'root'})\nexport class ChangeLogService {\n\n    private workers: Worker[] = [];\n\n    private flushContext: FlushContext;\n\n    private currentPushInfo: PushInfo;\n\n    private deferredFlush;\n\n    constructor(private localDBManagementService: LocalDBManagementService,\n                private localKeyValueService: LocalKeyValueService,\n                private pushService: PushService,\n                private networkService: NetworkService) {\n        this.currentPushInfo = {} as PushInfo;\n        this.addWorker(new FlushTracker(this,  this.localKeyValueService, this.currentPushInfo));\n    }\n\n\n    /**\n     * adds a service call to the log. Call will be invoked in next flush.\n     *\n     * @Param {string} name of service (This should be available through $injector)\n     * @Param {string} name of method to invoke.\n     * @Param {object} params\n     */\n    public add(service: string, operation: string, params: any): Promise<void> {\n        const change: Change = {\n            service: service,\n            operation: operation,\n            params: params,\n            hasError: 0\n        };\n        return executePromiseChain(this.getWorkers('transformParamsToMap'), [change])\n            .then(() => executePromiseChain(this.getWorkers('onAddCall'), [change]))\n            .then(() => {\n                change.params = JSON.stringify(change.params);\n                return this.getStore().then(store => store.add(change)).then(noop);\n            });\n    }\n\n    public addWorker(worker: Worker) {\n        this.workers.push(worker);\n    }\n\n    /**\n     * Clears the current log.\n     */\n    public clearLog() {\n        return this.getStore().then( s => s.clear());\n    }\n\n    /**\n     * Flush the current log. If a flush is already running, then the promise of that flush is returned back.\n     */\n    public flush(progressObserver: Observer<PushInfo>): Promise<PushInfo> {\n        let flushPromise;\n        if (!this.deferredFlush) {\n            this.deferredFlush = getAbortableDefer();\n            this.createContext().then(context => {\n                this.flushContext = context;\n                return executePromiseChain(this.getWorkers('preFlush'), [this.flushContext]);\n            })\n                .then(() => {\n                    flushPromise = this._flush(progressObserver);\n                    this.deferredFlush.onAbort = () => flushPromise.abort();\n                    return flushPromise;\n                })\n                .catch(noop)\n                .then(() => {\n                    Promise.resolve().then(() => {\n                        if (this.currentPushInfo.totalTaskCount === this.currentPushInfo.completedTaskCount) {\n                            return this.flushContext.clear().then(() => this.flushContext = null);\n                        }\n                    }).then(() => {\n                        progressObserver.complete();\n                        if (this.currentPushInfo.failedTaskCount > 0) {\n                            this.deferredFlush.reject(this.currentPushInfo);\n                        } else {\n                            this.deferredFlush.resolve(this.currentPushInfo);\n                        }\n                        this.deferredFlush = null;\n                    }).then(() => {\n                        return executePromiseChain(this.getWorkers('postFlush'), [this.currentPushInfo, this.flushContext]);\n                    });\n                });\n        }\n        return this.deferredFlush.promise;\n    }\n\n    /**\n     * Returns the complete change list\n     */\n    public getChanges() {\n        return this.getStore().then( s => s.filter(undefined, 'id', {\n            offset: 0,\n            limit: 500\n        })).then(changes => {\n            changes.forEach(change => {\n                change.params = JSON.parse(change.params);\n            });\n            return changes;\n        });\n    }\n\n\n    /**\n     * @returns {array} an array of changes that failed with error.\n     */\n    public getErrors(): Promise<Change[]> {\n        return this.getStore().then( s => s.filter([{\n            attributeName: 'hasError',\n            attributeValue: 1,\n            attributeType: 'NUMBER',\n            filterCondition: 'EQUALS'\n        }]));\n    }\n\n\n    public getLastPushInfo(): Promise<PushInfo> {\n        return this.localKeyValueService.get(LAST_PUSH_INFO_KEY)\n            .then(info => {\n                if (isString(info.startTime)) {\n                    info.startTime = new Date(info.startTime);\n                }\n                if (isString(info.endTime)) {\n                    info.endTime = new Date(info.endTime);\n                }\n                return info;\n            });\n    }\n    /**\n     * @returns {number} number of changes that are pending to push.\n     */\n    public getLogLength(): Promise<number> {\n        return this.getStore().then( s => s.count([{\n            attributeName: 'hasError',\n            attributeValue: 0,\n            attributeType: 'NUMBER',\n            filterCondition: 'EQUALS'\n        }]));\n    }\n\n    /*\n    * Retrieves the entity store to use by ChangeLogService.\n    */\n    public getStore(): Promise<LocalDBStore> {\n        return this.localDBManagementService.getStore('wavemaker', 'offlineChangeLog');\n    }\n\n    /**\n     * Returns true, if a flush process is in progress. Otherwise, returns false.\n     *\n     * @returns {boolean} returns true, if a flush process is in progress. Otherwise, returns false.\n     */\n    public isFlushInProgress(): boolean {\n        return !(_.isUndefined(this.deferredFlush) || _.isNull(this.deferredFlush));\n    }\n\n    /**\n     * Stops the ongoing flush process.\n     *\n     * @returns {object} a promise that is resolved when the flush process is stopped.\n     */\n    public stop(): Promise<void> {\n        return new Promise( resolve => {\n            if (this.deferredFlush) {\n                this.deferredFlush.promise.catch().then(resolve);\n                this.deferredFlush.promise.abort();\n            } else {\n                resolve();\n            }\n        });\n    }\n\n    private createContext() {\n        return this.localKeyValueService.get(CONTEXT_KEY)\n            .then(context => {\n                context = context || {};\n                return {\n                    'clear' : () => {\n                        context = {};\n                        return this.localKeyValueService.remove(CONTEXT_KEY);\n                    },\n                    'get' : key => {\n                        let value = context[key];\n                        if (!value) {\n                            value = {};\n                            context[key] = value;\n                        }\n                        return value;\n                    },\n                    'save' : () => this.localKeyValueService.put(CONTEXT_KEY, context)\n                };\n            });\n    }\n\n    // Flushes the complete log one after another.\n    private _flush(progressObserver: Observer<PushInfo>, defer?: any) {\n        defer = defer || getAbortableDefer();\n        if (defer.isAborted) {\n            return Promise.resolve();\n        }\n        this.getNextChange()\n            .then(change => {\n                if (change) {\n                    change.params = JSON.parse(change.params);\n                    return this.flushChange(change);\n                }\n            })\n            .then(change => {\n                progressObserver.next(this.currentPushInfo);\n                if (change) {\n                    return this.getStore()\n                        .then(s => s.delete(change.id))\n                        .then(() => this._flush(progressObserver, defer));\n                } else {\n                    defer.resolve();\n                }\n            }, change => {\n                if (this.networkService.isConnected()) {\n                    change.hasError = 1;\n                    change.params = JSON.stringify(change.params);\n                    this.getStore()\n                        .then(s => s.save(change))\n                        .then(() => this._flush(progressObserver, defer));\n                } else {\n                    let connectPromise = this.networkService.onConnect();\n                    defer.promise.catch(function () {\n                        if (connectPromise) {\n                            connectPromise.abort();\n                        }\n                    });\n                    connectPromise.then(() => {\n                        this._flush(progressObserver, defer);\n                        connectPromise = null;\n                    });\n                }\n            });\n        return defer.promise;\n    }\n\n    private flushChange(change: Change): Promise<Change> {\n        const self = this;\n        return executePromiseChain(this.getWorkers('preCall'), [change])\n            .then(() => change.hasError ? Promise.reject(change.errorMessage) : '')\n            .then(() => executePromiseChain(this.getWorkers('transformParamsFromMap'), [change]))\n            .then(() => this.pushService.push(change))\n            .then(function() {\n                return executePromiseChain(_.reverse(self.getWorkers('postCallSuccess')), [change, arguments])\n                    .then(() => change);\n            }).catch(function() {\n                if (self.networkService.isConnected()) {\n                    return executePromiseChain(_.reverse(self.getWorkers('postCallError')), [change, arguments])\n                        .catch(noop).then(() => Promise.reject(change));\n                }\n                return Promise.reject(change);\n            });\n    }\n\n\n\n    // Flushes the first registered change.\n    private getNextChange(): Promise<Change> {\n        const filterCriteria = [{\n            attributeName: 'hasError',\n            attributeValue: 0,\n            attributeType: 'NUMBER',\n            filterCondition: 'EQUALS'\n        }];\n        return this.getStore().then(s => s.filter(filterCriteria, 'id', {\n            offset: 0,\n            limit: 1\n        })).then((changes: Array<Change>) => {\n            return changes && changes[0];\n        });\n    }\n\n    private getWorkers(type) {\n        return _.map(this.workers, w => w[type] && w[type].bind(w));\n    }\n}\n\nclass FlushTracker {\n\n    private flushContext: FlushContext;\n    private logger: any;\n\n    constructor(private changeLogService: ChangeLogService,\n                private localKeyValueService: LocalKeyValueService,\n                private pushInfo: PushInfo) {\n        this.logger = window.console;\n    }\n\n    public onAddCall(change: Change) {\n        this.logger.debug('Added the following call %o to log.', change);\n    }\n\n    public preFlush(flushContext: FlushContext) {\n        this.pushInfo.totalTaskCount = 0;\n        this.pushInfo.successfulTaskCount = 0;\n        this.pushInfo.failedTaskCount = 0;\n        this.pushInfo.completedTaskCount = 0;\n        this.pushInfo.inProgress = true;\n        this.pushInfo.startTime = new Date();\n        this.flushContext = flushContext;\n        this.logger.debug('Starting flush');\n        return this.changeLogService.getStore().then(store => {\n            return store.count([{\n                attributeName: 'hasError',\n                attributeValue: 0,\n                attributeType: 'NUMBER',\n                filterCondition: 'EQUALS'\n            }]);\n        }).then(count => this.pushInfo.totalTaskCount = count);\n    }\n\n    public postFlush(stats: PushInfo , flushContext: FlushContext) {\n        this.logger.debug('flush completed. {Success : %i , Error : %i , completed : %i, total : %i }.',\n            this.pushInfo.successfulTaskCount, this.pushInfo.failedTaskCount, this.pushInfo.completedTaskCount, this.pushInfo.totalTaskCount);\n        this.pushInfo.inProgress = false;\n        this.pushInfo.endTime = new Date();\n        this.localKeyValueService.put(LAST_PUSH_INFO_KEY, this.pushInfo);\n        this.flushContext = null;\n    }\n\n    public preCall(change: Change) {\n        this.logger.debug('%i. Invoking call %o', (1 + this.pushInfo.completedTaskCount), change);\n    }\n\n    public postCallError(change: Change, response: any) {\n        this.pushInfo.completedTaskCount++;\n        this.pushInfo.failedTaskCount++;\n        this.logger.error('call failed with the response %o.', response);\n        return this.flushContext.save();\n    }\n\n    public postCallSuccess(change: Change, response: any) {\n        this.pushInfo.completedTaskCount++;\n        this.pushInfo.successfulTaskCount++;\n        this.logger.debug('call returned the following response %o.', response);\n        return this.flushContext.save();\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { LocalDBManagementService } from './local-db-management.service';\nimport { LocalDBStore } from '../models/local-db-store';\n\ndeclare const _;\n\n@Injectable({providedIn: 'root'})\nexport class LocalDbService {\n\n    private searchTableData;\n    private searchTableDataWithQuery;\n    private getDistinctDataByFields;\n\n    constructor(private localDBManagementService: LocalDBManagementService) {\n        this.searchTableData = this.readTableData.bind(this);\n        this.searchTableDataWithQuery = this.readTableData.bind(this);\n        this.getDistinctDataByFields = this.readTableData.bind(this);\n    }\n\n    public getStore(params: any): Promise<LocalDBStore> {\n        return this.localDBManagementService.getStore(params.dataModelName, params.entityName);\n    }\n\n    /**\n     * Method to insert data into the specified table. This modification will be added to offline change log.\n     *\n     * @param {object} params\n     *                 Object containing name of the project & table data to be inserted.\n     * @param {function=} successCallback\n     *                    Callback function to be triggered on success.\n     * @param {function=} failureCallback\n     *                    Callback function to be triggered on failure.\n     */\n    public insertTableData(params: any, successCallback?: any, failureCallback?: any) {\n        this.getStore(params).then(store => {\n            const isPKAutoIncremented = (store.primaryKeyField && store.primaryKeyField.generatorType === 'identity');\n            if (isPKAutoIncremented && params.data[store.primaryKeyName]) {\n                delete params.data[store.primaryKeyName];\n            }\n            return store.add(params.data).then(() => {\n                store.refresh(params.data).then(successCallback);\n            });\n        }).catch(failureCallback);\n    }\n\n    /**\n     * Method to insert multi part data into the specified table. This modification will be added to offline change log.\n     *\n     * @param {object} params\n     *                 Object containing name of the project & table data to be inserted.\n     * @param {function=} successCallback\n     *                    Callback function to be triggered on success.\n     * @param {function=} failureCallback\n     *                    Callback function to be triggered on failure.\n     */\n    public insertMultiPartTableData(params: any, successCallback?: any, failureCallback?: any) {\n        this.getStore(params).then(store => {\n            store.serialize(params.data).then(data => {\n                params.data = data;\n                this.insertTableData(params, successCallback, failureCallback);\n            });\n        }).catch(failureCallback);\n    }\n\n    /**\n     * Method to update data in the specified table. This modification will be added to offline change log.\n     *\n     * @param {object} params\n     *                 Object containing name of the project & table data to be updated.\n     * @param {function=} successCallback\n     *                    Callback function to be triggered on success.\n     * @param {function=} failureCallback\n     *                    Callback function to be triggered on failure.\n     */\n    public updateTableData(params: any, successCallback?: any, failureCallback?: any) {\n        this.getStore(params).then(store => {\n            return store.save(params.data)\n                .then(() => {\n                    store.refresh(params.data).then(successCallback);\n                });\n        }).catch(failureCallback);\n    }\n\n    /**\n     * Method to update multi part data in the specified table. This modification will be added to offline change log.\n     *\n     * @param {object} params\n     *                 Object containing name of the project & table data to be updated.\n     * @param {function=} successCallback\n     *                    Callback function to be triggered on success.\n     * @param {function=} failureCallback\n     *                    Callback function to be triggered on failure.\n     */\n    public updateMultiPartTableData(params: any, successCallback?: any, failureCallback?: any)  {\n        const data = (params.data && params.data.rowData) || params.data;\n        this.getStore(params).then(store => {\n            return store.save(data);\n        }).then(() => {\n            if (successCallback) {\n                successCallback(data);\n            }\n        }).catch(failureCallback);\n    }\n\n    /**\n     * Method to delete data in the specified table. This modification will be added to offline change log.\n     *\n     * @param {object} params\n     *                 Object containing name of the project & table data to be inserted.\n     * @param {function=} successCallback\n     *                    Callback function to be triggered on success.\n     * @param {function=} failureCallback\n     *                    Callback function to be triggered on failure.\n     */\n    public deleteTableData(params: any, successCallback?: any, failureCallback?: any) {\n        this.getStore(params).then(store => {\n            const pkField = store.primaryKeyField,\n                id = params[pkField.fieldName] || params[pkField.name] || (params.data && params.data[pkField.fieldName]) || params.id;\n            store.delete(id).then(successCallback);\n        }).catch(failureCallback);\n    }\n\n    /**\n     * Method to read data from a specified table.\n     *\n     * @param {object} params\n     *                 Object containing name of the project & table data to be inserted.\n     * @param {function=} successCallback\n     *                    Callback function to be triggered on success.\n     * @param {function=} failureCallback\n     *                    Callback function to be triggered on failure.\n     */\n    public readTableData(params: any, successCallback?: any, failureCallback?: any) {\n        this.getStore(params).then(store => {\n            let filter = params.filter((filterGroup, filterFields) => {\n                this.convertFieldNameToColumnName(store, filterGroup, filterFields);\n            }, true);\n            // convert wm_bool function with boolean value to 0/1\n            filter = filter.replace(/wm_bool\\('true'\\)/g, 1).replace(/wm_bool\\('false'\\)/g, 0);\n            return store.count(filter).then(totalElements => {\n                const sort = params.sort.split('=')[1];\n                return store.filter(filter, sort, {\n                    offset: (params.page - 1) * params.size,\n                    limit: params.size\n                }).then(data => {\n                    const totalPages = Math.ceil(totalElements / params.size);\n                    successCallback({\n                        'content'         : data,\n                        'first'           : (params.page === 1),\n                        'last'            : (params.page === totalPages),\n                        'number'          : (params.page - 1),\n                        'numberOfElements': data.length,\n                        'size'            : params.size,\n                        'sort'            : {\n                            'sorted' : !!sort,\n                            'unsorted' : !sort\n                        },\n                        'totalElements'   : totalElements,\n                        'totalPages'      : totalPages\n                    });\n                });\n            });\n        }).catch(failureCallback);\n    }\n\n    private escapeName(name: string): string {\n        if (name) {\n            name = name.replace(/\"/g, '\"\"');\n            return '\"' + name.replace(/\\./g, '\".\"') + '\"';\n        }\n        return name;\n    }\n\n    // returns the columnName appending with the schema name.\n    private getColumnName(store, fieldName) {\n        if (store.fieldToColumnMapping[fieldName]) {\n            const columnName = this.escapeName(store.fieldToColumnMapping[fieldName]);\n            if (columnName.indexOf('.') < 0) {\n                return this.escapeName(store.entitySchema.name) + '.' + columnName;\n            }\n            return columnName;\n        }\n        return fieldName;\n    }\n\n    private convertFieldNameToColumnName(store: LocalDBStore, filterGroup: any, options?: any) {\n        _.forEach(filterGroup.rules, rule => {\n            if (rule.rules) {\n                this.convertFieldNameToColumnName(store, rule);\n            } else {\n                rule.target = this.getColumnName(store, rule.target);\n            }\n        });\n        // handling the scenario where variable options can have filterField. For example: search filter query\n        if (options && options.filterFields) {\n            options.filterFields = _.mapKeys(options.filterFields, (v, k) => {\n                return this.getColumnName(store, k);\n            });\n        }\n    }\n}\n","import { File } from '@ionic-native/file';\n\nimport { noop } from '@wm/core';\nimport { DeviceFileService } from '@wm/mobile/core';\n\nimport { Change, ChangeLogService, FlushContext, Worker } from '../change-log.service';\nimport { CallBack, LocalDBManagementService } from '../local-db-management.service';\n\ndeclare const _;\n\nconst STORE_KEY = 'offlineFileUpload';\n\nexport class FileHandler implements Worker {\n\n    private fileStore;\n    private logger = window.console;\n\n    public preFlush(context: FlushContext) {\n        this.fileStore = context.get(STORE_KEY);\n    }\n\n    /**\n     * Replaces all local paths with the remote path using mappings created during 'uploadToServer'.\n     */\n    public preCall(change: Change) {\n        if (change.service === 'DatabaseService') {\n            change.params.data = _.mapValues(change.params.data, v => {\n                const remoteUrl = this.fileStore[v];\n                if (remoteUrl) {\n                    this.logger.debug('swapped file path from %s -> %s', v, remoteUrl);\n                    return remoteUrl;\n                }\n                return v;\n            });\n        }\n    }\n\n    public postCallSuccess(change: Change, response: any) {\n        if (change.service === 'OfflineFileUploadService'\n            && change.operation === 'uploadToServer') {\n            const remoteFile = JSON.parse(response[0].text)[0];\n            /*\n             * A mapping will be created between local path and remote path.\n             * This will be used to resolve local paths in entities.\n             */\n            this.fileStore[change.params.file]             = remoteFile.path;\n            this.fileStore[change.params.file + '?inline'] = remoteFile.inlinePath;\n        }\n    }\n\n}\n\nexport class UploadedFilesImportAndExportService implements CallBack {\n    private uploadDir;\n\n    constructor(\n        private changeLogService: ChangeLogService,\n        private deviceFileService: DeviceFileService,\n        private localDBManagementService: LocalDBManagementService,\n        private file: File\n    ) {\n\n    }\n\n    public preExport(folderToExport: string, meta: any): Promise<any> {\n        // copy offline uploads\n        const uploadFullPath = this.deviceFileService.getUploadDirectory(),\n            lastIndexOfSep = uploadFullPath.lastIndexOf('/'),\n            uploadParentDir = uploadFullPath.substring(0, lastIndexOfSep + 1),\n            uploadDirName = uploadFullPath.substring(lastIndexOfSep + 1);\n        meta.uploadDir = uploadFullPath;\n        return this.file.copyDir(uploadParentDir, uploadDirName, folderToExport, 'uploads');\n    }\n\n    public postImport(importedFolder: string, meta: any): Promise<any> {\n        const uploadFullPath = this.deviceFileService.getUploadDirectory(),\n            lastIndexOfSep = uploadFullPath.lastIndexOf('/'),\n            uploadParentDir = uploadFullPath.substring(0, lastIndexOfSep + 1),\n            uploadDirName = uploadFullPath.substring(lastIndexOfSep + 1);\n        this.uploadDir = uploadFullPath;\n        return this.file.checkDir(importedFolder, 'uploads')\n            .then(() => {\n                return this.deviceFileService.removeDir(uploadFullPath)\n                    .then(() => this.file.copyDir(importedFolder, 'uploads', uploadParentDir, uploadDirName))\n                    .then(() => this.updateChanges(meta));\n            }, noop);\n    }\n\n    /**\n     * returns back the changes that were logged.\n     * @param page page number\n     * @param size size of page\n     * @returns {*}\n     */\n    private getChanges(page: number, size: number): Promise<Change[]> {\n        return this.changeLogService.getStore().then(strore => {\n            return (strore.filter([], 'id', {\n                offset: (page - 1) * size,\n                limit: size\n            })) as Promise<Change[]>;\n        });\n    }\n\n    /**\n     * If this is a database change, then it will replace old upload directory with the current upload directory\n     * and its corresponding owner object, if  it has primary key.\n     *\n     * @param change\n     * @param oldUploadDir\n     * @param uploadDir\n     * @returns {*}\n     */\n    private updateDBChange(change: Change, oldUploadDir: string, uploadDir: string) {\n        const modifiedProperties = {},\n            entityName = change.params.entityName,\n            dataModelName = change.params.dataModelName;\n        change.params.data = _.mapValues(change.params.data, function (v, k) {\n            let mv = v, isModified = false;\n            if (_.isString(v)) {\n                mv = _.replace(v, oldUploadDir, uploadDir);\n                isModified = !_.isEqual(mv, v);\n            } else if (_.isObject(v) && v.wmLocalPath) {\n                // insertMultiPartData and updateMultiPartData\n                mv = _.replace(v.wmLocalPath, oldUploadDir, uploadDir);\n                isModified = !_.isEqual(mv, v.wmLocalPath);\n            }\n            if (isModified) {\n                modifiedProperties[k] = mv;\n            }\n            return mv;\n        });\n        if (!_.isEmpty(modifiedProperties)) {\n            this.localDBManagementService.getStore(dataModelName, entityName)\n                .then(store => {\n                    // If there is a primary for the entity, then update actual row with the modifications\n                    if (store.primaryKeyField && store.primaryKeyField.generatorType === 'identity') {\n                        const primaryKeyName = store.primaryKeyName;\n                        const primaryKey = change.params.data[primaryKeyName];\n                        return store.get(primaryKey)\n                            .then(obj => store.save(_.assignIn(obj, modifiedProperties)));\n                    }\n                }).then(() => {\n                change.params = JSON.stringify(change.params);\n                return this.changeLogService.getStore().then( store => store.save(change));\n            });\n        }\n    }\n\n    /**\n     * This function check this change to update old upload directory path.\n     *\n     * @param change\n     * @param metaInfo\n     * @returns {*}\n     */\n    private updateChange(change: Change, metaInfo: any) {\n        change.params = JSON.parse(change.params);\n        if (change.service === 'OfflineFileUploadService'\n            && change.operation === 'uploadToServer') {\n            change.params.file = _.replace(change.params.file, metaInfo.uploadDir, this.uploadDir);\n            change.params = JSON.stringify(change.params);\n            return this.changeLogService.getStore().then( store => store.save(change));\n        }\n        if (change.service === 'DatabaseService') {\n            return this.updateDBChange(change, metaInfo.uploadDir, this.uploadDir);\n        }\n    }\n\n    /**\n     * This function will visit all the changes and modify them, if necessary.\n     * @param metaInfo\n     * @param page\n     * @returns {*}\n     */\n    private updateChanges(metaInfo: any, page = 1): Promise<any> {\n        const size = 10;\n        return this.getChanges(page, size)\n            .then(changes => {\n                if (changes && changes.length > 0) {\n                    return Promise.all(changes.map(change => this.updateChange(change, metaInfo)));\n                }\n            }).then(result => {\n                if (result && result.length === size) {\n                    return this.updateChanges(metaInfo, page + 1);\n                }\n            });\n    }\n}\n","import { Change, FlushContext, Worker } from '../change-log.service';\nimport { LocalDBStore } from '../../models/local-db-store';\nimport { LocalDBManagementService } from '../local-db-management.service';\n\ndeclare const _;\n\nconst STORE_KEY = 'errorBlockerStore';\n\nexport class ErrorBlocker implements Worker {\n\n    private errorStore;\n\n    constructor(private localDBManagementService: LocalDBManagementService) {\n    }\n\n    public preFlush(context: FlushContext) {\n        this.errorStore = context.get(STORE_KEY);\n    }\n\n    // block all calls related to the error entities\n    public preCall(change: Change) {\n        if (change && change.service === 'DatabaseService') {\n            const entityName = change.params.entityName;\n            const dataModelName = change.params.dataModelName;\n            switch (change.operation) {\n                case 'insertTableData':\n                case 'insertMultiPartTableData':\n                case 'updateTableData':\n                case 'updateMultiPartTableData':\n                    return this.localDBManagementService.getStore(dataModelName, entityName).then( store => {\n                        this.blockCall(store, change, dataModelName, entityName, change.params.data);\n                    });\n                case 'deleteTableData':\n                    return this.localDBManagementService.getStore(dataModelName, entityName).then( store => {\n                        this.blockCall(store, change, dataModelName, entityName, change.params);\n                    });\n            }\n        }\n    }\n\n    // store error entity id\n    public postCallSuccess(change: Change) {\n        if (change && change.service === 'DatabaseService') {\n            const entityName = change.params.entityName;\n            const dataModelName = change.params.dataModelName;\n            return this.localDBManagementService.getStore(dataModelName, entityName).then( store => {\n                const id = change['dataLocalId'] || change.params.data[store.primaryKeyName];\n                if (!(_.isUndefined(id) || _.isNull(id))) {\n                    this.removeError(dataModelName, entityName, id);\n                }\n            });\n        }\n    }\n\n    // store error entity id\n    public postCallError(change: Change) {\n        if (change && change.service === 'DatabaseService') {\n            const entityName = change.params.entityName;\n            const dataModelName = change.params.dataModelName;\n            return this.localDBManagementService.getStore(dataModelName, entityName).then( store => {\n                const id = change['dataLocalId'] || (change.params.data && change.params.data[store.primaryKeyName]) || change.params[store.primaryKeyName] || change.params.id;\n                if (!(_.isUndefined(id) || _.isNull(id))) {\n                    this.recordError(dataModelName, entityName, id);\n                }\n            });\n        }\n    }\n\n    /**\n     * If there is an earlier call of the object or its relations that got failed, then this call will be\n     * marked for discard.\n     *\n     * @param store LocalDBStore\n     * @param change change to block\n     * @param dataModelName\n     * @param entityName\n     * @param data\n     */\n    private blockCall(store: LocalDBStore, change: Change, dataModelName: string, entityName: string, data: any) {\n        if (change.hasError === 0) {\n            this.checkForPreviousError(store, change, dataModelName, entityName, data);\n            store.entitySchema.columns.forEach(col => {\n                if (col.foreignRelations) {\n                    col.foreignRelations.some(foreignRelation => {\n                        if (data[foreignRelation.sourceFieldName]) {\n                            this.blockCall(store, change, dataModelName, foreignRelation.targetEntity, data[foreignRelation.sourceFieldName]);\n                        } else if (data[col.fieldName]) {\n                            this.checkForPreviousError(store, change, dataModelName, foreignRelation.targetEntity, data, col.fieldName);\n                        }\n                        return change.hasError === 1;\n                    });\n                }\n            });\n        }\n    }\n\n    // A helper function to check for earlier failures.\n    private checkForPreviousError(store: LocalDBStore, change: Change, dataModelName: string, entityName: string, data: any, key?: any) {\n        const primaryKey = key || store.primaryKeyName;\n        if (this.hasError(dataModelName, entityName, data[primaryKey])) {\n            change.hasError = 1;\n            change.errorMessage = `Blocked call due to error in previous call of entity [ ${entityName} ] with id [ ${data[primaryKey]} ]`;\n        }\n    }\n\n    private hasError(dataModelName: string, entityName: string, id: any) {\n        if (this.errorStore[dataModelName]\n            && this.errorStore[dataModelName][entityName]\n            && this.errorStore[dataModelName][entityName][id]) {\n            return true;\n        }\n        return false;\n    }\n\n    // Removes entity identifier from error list.\n    private removeError(dataModelName: string, entityName: string, id: any) {\n        if (this.errorStore[dataModelName]\n            && this.errorStore[dataModelName][entityName]\n            && this.errorStore[dataModelName][entityName][id]) {\n            delete this.errorStore[dataModelName][entityName][id];\n        }\n    }\n\n    // Save error entity identifier.\n    private recordError(dataModelName: string, entityName: string, id: any) {\n        this.errorStore[dataModelName] = this.errorStore[dataModelName] || {};\n        this.errorStore[dataModelName][entityName] = this.errorStore[dataModelName][entityName] || {};\n        this.errorStore[dataModelName][entityName][id] = true;\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { isDefined, noop } from '@wm/core';\n\nimport { Change, FlushContext, Worker } from './../change-log.service';\nimport { LocalDBManagementService } from './../local-db-management.service';\nimport { LocalDBStore } from './../../models/local-db-store';\n\nconst STORE_KEY  = 'idConflictResolution';\n\n/**\n * In offline database, a insert could generate the Id of an entity. During flush, id of that entity might get changed.\n * Due to that, relationship inconsistency arises. To prevent that, wherever this entity is referred in the next flush\n * call, Id has to be replaced with that of new one.\n */\n@Injectable()\nexport class IdResolver implements Worker {\n\n    private idStore;\n    private logger;\n    private transactionLocalId;\n\n    constructor(private localDBManagementService: LocalDBManagementService) {\n        this.logger = window.console;\n    }\n\n    public preFlush(context: FlushContext) {\n        this.idStore = context.get(STORE_KEY);\n    }\n\n    // Exchane Ids, Before any database operation.\n    public preCall(change: Change) {\n        if (change && change.service === 'DatabaseService') {\n            const entityName = change.params.entityName;\n            const dataModelName = change.params.dataModelName;\n            switch (change.operation) {\n                case 'insertTableData':\n                case 'insertMultiPartTableData':\n                    change.params.skipLocalDB = true ;\n                    return this.localDBManagementService.getStore(dataModelName, entityName)\n                        .then(store => {\n                            const primaryKeyName = store.primaryKeyName;\n                            if (primaryKeyName) {\n                                this.transactionLocalId = change.params.data[primaryKeyName];\n                                change['dataLocalId'] = this.transactionLocalId;\n                            }\n                            return this.exchangeIds(store, dataModelName, entityName, change.params.data)\n                                .then(() => {\n                                    if (store.primaryKeyField && store.primaryKeyField.generatorType === 'identity') {\n                                        delete change.params.data[primaryKeyName];\n                                    } else {\n                                        const relationalPrimaryKeyValue = store.getValue(change.params.data, store.primaryKeyName);\n                                        // for the data referring to the relational table based on primary key assign the primaryField values to the relationalPrimaryKeyValue\n                                        if (isDefined(relationalPrimaryKeyValue)) {\n                                            change.params.data[primaryKeyName] = relationalPrimaryKeyValue;\n                                            if (this.transactionLocalId !== null) {\n                                                this.pushIdToStore(dataModelName, entityName, this.transactionLocalId, relationalPrimaryKeyValue);\n                                            }\n                                        }\n                                        this.transactionLocalId = null;\n                                    }\n                                });\n                    });\n                case 'updateTableData':\n                case 'updateMultiPartTableData':\n                case 'deleteTableData':\n                    return this.localDBManagementService.getStore(dataModelName, entityName).then(store => {\n                        // on update call, passing id to exchangeId as change.params id(local value 10000000+) is not updated with the latest id from db\n                        this.exchangeId(store, dataModelName, entityName, change.params, 'id');\n                        if (change.params.data) {\n                            return this.exchangeIds(store, dataModelName, entityName, change.params.data);\n                        }\n                    });\n            }\n        }\n    }\n    // After every database insert, track the Id change.\n    public postCallSuccess(change: Change, response: any) {\n        if (change && change.service === 'DatabaseService'\n            && (change.operation === 'insertTableData' || change.operation === 'insertMultiPartTableData')\n            && this.transactionLocalId) {\n            const data = response[0].body;\n            const entityName = change.params.entityName;\n            const dataModelName = change.params.dataModelName;\n            return this.localDBManagementService.getStore(dataModelName, entityName).then(store => {\n                this.pushIdToStore(dataModelName, entityName, this.transactionLocalId, data[store.primaryKeyName]);\n                return store.delete(this.transactionLocalId).catch(noop).then(() => {\n                    this.transactionLocalId = null;\n                    return store.save(data);\n                });\n            });\n        }\n    }\n    // store error entity id\n    public postCallError(change: Change) {\n        if (change && change.service === 'DatabaseService'\n            && (change.operation === 'insertTableData' || change.operation === 'insertMultiPartTableData')\n            && this.transactionLocalId) {\n            const entityName = change.params.entityName;\n            const dataModelName = change.params.dataModelName;\n            return this.localDBManagementService.getStore(dataModelName, entityName).then(store => {\n                change.params.data[store.primaryKeyName] = this.transactionLocalId;\n            });\n        }\n    }\n\n    private getEntityIdStore(dataModelName: string, entityName: string) {\n        this.idStore[dataModelName] = this.idStore[dataModelName] || {};\n        this.idStore[dataModelName][entityName] = this.idStore[dataModelName][entityName] || {};\n        return this.idStore[dataModelName][entityName];\n    }\n\n    // if local id is different, then create a mapping for exchange.\n    private pushIdToStore(dataModelName: string, entityName: string, transactionLocalId: any, remoteId: any) {\n        if (transactionLocalId !== remoteId) {\n            this.getEntityIdStore(dataModelName, entityName)[transactionLocalId] = remoteId;\n            this.logger.debug('Conflict found for entity (%s) with local id (%i) and remote Id (%i)', entityName, transactionLocalId, remoteId);\n        }\n    }\n\n    private logResolution(entityName: string, localId: any, remoteId: any) {\n        this.logger.debug('Conflict resolved found for entity (%s) with local id (%i) and remote Id (%i)', entityName, localId, remoteId);\n    }\n\n    // Exchange primary key  of the given entity\n    private exchangeId(store: LocalDBStore, dataModelName: string, entityName: string, data?: any, keyName?: string) {\n        const primaryKeyName = keyName || store.primaryKeyName;\n        const entityIdStore = this.getEntityIdStore(dataModelName, entityName);\n        if (data && primaryKeyName) {\n            const localId = data[primaryKeyName];\n            let remoteId = localId;\n            while (entityIdStore[remoteId]) {\n                remoteId = entityIdStore[remoteId];\n            }\n            if (remoteId !== localId) {\n                data[primaryKeyName] = remoteId;\n                this.logResolution(entityName, localId, remoteId);\n            }\n        }\n    }\n\n    // Looks primary key changes in the given entity or in the relations\n    private exchangeIds(store: LocalDBStore, dataModelName: string, entityName: string, data: any): Promise<any> {\n        this.exchangeId(store, dataModelName, entityName, data);\n        const exchangeIdPromises = [];\n        store.entitySchema.columns.forEach(col => {\n            if (col.foreignRelations) {\n                col.foreignRelations.forEach( foreignRelation => {\n                    if (data[col.fieldName]) {// if id value\n                        this.exchangeId(store, dataModelName, foreignRelation.targetEntity, data, col.fieldName);\n                    }\n                    if (data[foreignRelation.sourceFieldName]) {// if object reference\n                        exchangeIdPromises.push(this.localDBManagementService.getStore(dataModelName, foreignRelation.targetEntity)\n                            .then(refStore => {\n                                return this.exchangeIds(refStore, dataModelName, foreignRelation.targetEntity, data[foreignRelation.sourceFieldName]);\n                            }));\n                    }\n                });\n            }\n        });\n        return Promise.all(exchangeIdPromises);\n    }\n}\n","import { DeviceFileService } from '@wm/mobile/core';\n\nimport { Change, Worker } from '../change-log.service';\nimport { LocalDBManagementService } from '../local-db-management.service';\n\ndeclare const _;\n\nexport class MultiPartParamTransformer implements Worker {\n\n    constructor(\n        private deviceFileService: DeviceFileService,\n        private localDBManagementService: LocalDBManagementService\n    ) {}\n\n    public postCallSuccess(change: Change) {\n        if (change && change.service === 'DatabaseService') {\n            switch (change.operation) {\n                case 'insertMultiPartTableData':\n                case 'updateMultiPartTableData':\n                    // clean up files\n                    _.forEach(change.params.data, v => {\n                        if (_.isObject(v) && v.wmLocalPath) {\n                            this.deviceFileService.removeFile(v.wmLocalPath);\n                        }\n                    });\n                    break;\n            }\n        }\n    }\n\n    public transformParamsFromMap(change: Change) {\n        if (change && change.service === 'DatabaseService') {\n            switch (change.operation) {\n                case 'insertMultiPartTableData':\n                case 'updateMultiPartTableData':\n                    return this.localDBManagementService.getStore(change.params.dataModelName, change.params.entityName)\n                        .then( store => {\n                            // construct Form data\n                            return store.deserialize(change.params.data).then(function (formData) {\n                                change.params.data = formData;\n                            });\n                        });\n            }\n        }\n    }\n\n    public transformParamsToMap(change: Change) {\n        if (change && change.service === 'DatabaseService') {\n            switch (change.operation) {\n                case 'insertMultiPartTableData':\n                case 'updateMultiPartTableData':\n                    return this.localDBManagementService.getStore(change.params.dataModelName, change.params.entityName)\n                        .then( store => {\n                            return store.serialize(change.params.data).then(function (map) {\n                                change.params.data = map;\n                                /**\n                                 * As save method called with FormData object, empty row is inserted.\n                                 * Since FormData is converted to map, update the record details now.\n                                 */\n                                store.save(_.mapValues(map, function (v) {\n                                    return (_.isObject(v) && v.wmLocalPath) || v;\n                                }));\n                                return map;\n                            });\n                        });\n            }\n        }\n    }\n}\n","import { from } from 'rxjs';\n\nimport { LVService } from '@wm/variables';\n\nimport { NetworkService } from '@wm/mobile/core';\nimport { AbstractHttpService, noop, triggerFn } from '@wm/core';\n\nimport { ColumnInfo, ForeignRelationInfo } from '../models/config';\nimport { LocalDBStore } from '../models/local-db-store';\nimport { ChangeLogService } from '../services/change-log.service';\nimport { LocalDBManagementService } from '../services/local-db-management.service';\nimport { LocalDbService } from '../services/local-db.service';\nimport { WM_LOCAL_OFFLINE_CALL } from './utils';\n\ndeclare const _;\n\nconst apiConfiguration = [{\n        'name' : 'insertTableData',\n        'type' : 'INSERT'\n    }, {\n        'name' : 'insertMultiPartTableData',\n        'type' : 'INSERT'\n    }, {\n        'name' : 'updateTableData',\n        'type' : 'UPDATE'\n    }, {\n        'name' : 'updateMultiPartTableData',\n        'type' : 'UPDATE'\n    }, {\n        'name' : 'deleteTableData',\n        'type' : 'DELETE'\n    }, {\n        'name' : 'readTableData',\n        'type' : 'READ',\n        'saveResponse': true\n    }, {\n        'name' : 'searchTableData',\n        'type' : 'READ',\n        'saveResponse': true\n    }, {\n        'name' : 'searchTableDataWithQuery',\n        'type' : 'READ',\n        'saveResponse': true\n    }, {\n        'name' : 'getDistinctDataByFields',\n        'type' : 'READ',\n        'saveResponse': false\n    }];\n\nlet isOfflineBehaviorAdded = false;\n\nexport class LiveVariableOfflineBehaviour {\n\n    private onlineDBService = LVService;\n\n    constructor(\n        private changeLogService: ChangeLogService,\n        private httpService: AbstractHttpService,\n        private localDBManagementService: LocalDBManagementService,\n        private networkService: NetworkService,\n        private offlineDBService: LocalDbService\n    ) {}\n\n    public add () {\n        if (!isOfflineBehaviorAdded) {\n            isOfflineBehaviorAdded = true;\n            const onlineHandler = this.httpService.sendCallAsObservable;\n            if (onlineHandler) {\n                this.httpService.sendCallAsObservable = (reqParams, params): any => {\n                    if (!params && _.get(reqParams, 'url')) {\n                        params = {url: reqParams.url};\n                    }\n                    // reqParams will contain the full path of insert/update call which will be processed again in parseConfig method\n                    // and will be appended again with '/services/./.' which will result in deployedUrl + '/service/./.' + '/service/./.' which is wrong.\n                    // Hence passing url in params\n                    const clonedParamsUrl = _.clone(params.url);\n                    params = _.extend(params, reqParams);\n                    const operation = _.find(apiConfiguration, {name: _.get(params, 'operation')});\n                    if (this.networkService.isConnected() || params.onlyOnline || !operation || !params.dataModelName) {\n                        return from(this.remoteDBcall(operation, onlineHandler, params));\n                    }\n                    // converting promise to observable as LVService returns a observable\n                    return from(this.localDBManagementService.isOperationAllowed(params.dataModelName, params.entityName, operation.type)\n                        .then(isAllowedInOffline => {\n                            if (!isAllowedInOffline) {\n                                return this.remoteDBcall(operation, onlineHandler, params);\n                            } else {\n                                let cascader;\n                                return Promise.resolve().then(() => {\n                                    if (!params.isCascadingStopped &&\n                                        (operation.name === 'insertTableData'\n                                            || operation.name === 'updateTableData')) {\n                                        return this.prepareToCascade(params).then(c => cascader = c);\n                                    }\n                                }).then(() => {\n                                    return new Promise((resolve, reject) => {\n                                        this.localDBcall(operation, params, resolve, reject, clonedParamsUrl);\n                                    });\n                                }).then( (response: any) => {\n                                    if (cascader) {\n                                        return cascader.cascade().then(() => {\n                                            return this.getStore(params).then(store => {\n                                                return store.refresh(response.body);\n                                            }).then(data => {\n                                                // data includes parent and child data.\n                                                if (response && response.body) {\n                                                    response.body = data;\n                                                }\n                                                return response;\n                                            });\n                                        });\n                                    }\n                                    return response;\n                                });\n                            }\n                        }));\n                };\n            }\n        }\n    }\n\n    public getStore(params: any): Promise<LocalDBStore> {\n        return this.localDBManagementService.getStore(params.dataModelName, params.entityName);\n    }\n\n    // set hasBlob flag on params when blob field is present\n    private hasBlob(store) {\n        const blobColumns = _.filter(store.entitySchema.columns, {\n            'sqlType' : 'blob'\n        });\n        return !!blobColumns.length;\n    }\n\n    /*\n     * During offline, LocalDBService will answer to all the calls. All data modifications will be recorded\n     * and will be reported to DatabaseService when device goes online.\n     */\n    private localDBcall(operation, params, successCallback, failureCallback, clonedParamsUrl): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.offlineDBService[operation.name](params, response => {\n                if (operation.type === 'READ') {\n                    resolve(response);\n                } else {\n                    // add to change log\n                    params.onlyOnline = true;\n                    params.url = clonedParamsUrl;\n                    return this.changeLogService.add('DatabaseService', operation.name, params)\n                        .then(() => resolve(response));\n                }\n            });\n        }).then((response) => {\n            response = {body : response, type: WM_LOCAL_OFFLINE_CALL};\n            triggerFn(successCallback, response);\n            return response;\n        }, failureCallback);\n    }\n\n    /*\n     * During online, all read operations data will be pushed to offline database. Similarly, Update and Delete\n     * operations are synced with the offline database.\n     */\n    private remoteDBcall(operation, onlineHandler, params): Promise<any> {\n        return new Promise((resolve, reject) => {\n            onlineHandler.call(this.httpService, params).subscribe(response => {\n                if (response && response.type) {\n                    if (!params.skipLocalDB) {\n                        this.offlineDBService.getStore(params).then((store) => {\n                            if (operation.type === 'READ' && operation.saveResponse) {\n                                store.saveAll(response.body.content);\n                            } else if (operation.type === 'INSERT') {\n                                params = _.clone(params);\n                                params.data = _.clone(response.body);\n                                this.offlineDBService[operation.name](params, noop, noop);\n                            } else {\n                                this.offlineDBService[operation.name](params, noop, noop);\n                            }\n                        }).catch(noop);\n                    }\n                    resolve(response);\n                }\n            }, (err) => {\n                reject(err);\n            });\n        });\n    }\n\n    /**\n     * Finds out the nested objects to save and prepares a cloned params.\n     */\n    private prepareToCascade(params): Promise<any> {\n        return this.getStore(params).then(store => {\n            const childObjectPromises = [];\n            _.forEach(params.data, (v, k) => {\n                let column: ColumnInfo,\n                    foreignRelation: ForeignRelationInfo,\n                    childParams;\n                // NOTE: Save only one-to-one relations for cascade\n                if (_.isObject(v) && !_.isArray(v)) {\n                    column = store.entitySchema.columns.find(c => {\n                        if (c.primaryKey && c.foreignRelations) {\n                            foreignRelation = c.foreignRelations.find( f => f.sourceFieldName === k);\n                        }\n                        return !!foreignRelation;\n                    });\n                }\n                if (column) {\n                    childParams = _.cloneDeep(params);\n                    childParams.entityName = foreignRelation.targetEntity;\n                    childParams.data = v;\n                    const childPromise = this.getStore(childParams).then(childStore => {\n                        const parent = params.data;\n                        const targetColumns = childStore.entitySchema.columns.find(c => c.name === foreignRelation.targetColumn);\n                        if (targetColumns && targetColumns.foreignRelations) {\n                            const parentFieldName = targetColumns.foreignRelations.find( f => f.targetTable === store.entitySchema.name).sourceFieldName;\n                            childParams.data[parentFieldName] = parent;\n                        }\n                        parent[k] = null;\n                        childParams.onlyOnline = false;\n                        childParams.isCascadingStopped = true;\n                        childParams.hasBlob = this.hasBlob(childStore);\n                        childParams.url = '';\n                        return () => {\n                            return Promise.resolve().then(() => {\n                                    const primaryKeyValue = childStore.getValue(childParams.data, childStore.primaryKeyField.fieldName);\n                                    return primaryKeyValue ? childStore.get(primaryKeyValue) : null;\n                                }).then(object => {\n                                    let operation;\n                                    if (object) {\n                                        operation = childParams.hasBlob ? 'updateMultiPartTableData' : 'updateTableData';\n                                    } else {\n                                        operation = childParams.hasBlob ? 'insertMultiPartTableData' : 'insertTableData';\n                                    }\n                                    return this.onlineDBService[operation](childParams).toPromise();\n                                });\n                        };\n                    });\n                    childObjectPromises.push(childPromise);\n                }\n            });\n            return Promise.all(childObjectPromises).then(result => {\n                return {\n                    cascade: () => Promise.all(result.map(fn => fn()))\n                };\n            });\n        });\n    }\n}\n","import { File } from '@ionic-native/file';\n\nimport { DeviceFileService, DeviceFileUploadService, IUploadResponse, NetworkService, UploadRequest } from '@wm/mobile/core';\n\nimport { ChangeLogService } from '../services/change-log.service';\n\nlet isOfflineBehaviourAdded = false;\n\nexport class FileUploadOfflineBehaviour {\n\n    constructor(\n        private changeLogService: ChangeLogService,\n        private deviceFileService: DeviceFileService,\n        private deviceFileUploadService: DeviceFileUploadService,\n        private file: File,\n        private networkService: NetworkService,\n        private uploadDir: string\n    ) {\n\n    }\n\n    public add() {\n        if (isOfflineBehaviourAdded) {\n            return;\n        }\n        isOfflineBehaviourAdded = true;\n        const orig = this.deviceFileUploadService.upload;\n        this.deviceFileUploadService['uploadToServer'] = orig;\n        this.deviceFileUploadService.upload = (url: string, fileParamName: string, localPath: string, fileName?: string, params?: any, headers?: any): Promise<IUploadResponse> => {\n            if (this.networkService.isConnected()) {\n                return orig.call(this.deviceFileUploadService, url, fileParamName, localPath, fileName, params, headers);\n            } else {\n                return this.uploadLater(url, fileParamName, localPath, fileName, params, headers).then(response => {\n                    return {\n                        text: JSON.stringify(response),\n                        headers: null,\n                        response: response\n                    };\n                });\n            }\n        };\n    }\n\n    public uploadLater(url: string, fileParamName: string, localPath: string, fileName?: string, params?: any, headers?: any): Promise<any> {\n        const i = localPath.lastIndexOf('/'),\n            soureDir = localPath.substring(0, i),\n            soureFile = localPath.substring(i + 1),\n            destFile = this.deviceFileService.appendToFileName(soureFile),\n            filePath = this.uploadDir + '/' + destFile;\n        return this.file.copyFile(soureDir, soureFile, this.uploadDir, destFile)\n            .then(() => {\n                return this.changeLogService.add('OfflineFileUploadService', 'uploadToServer', {\n                    file: filePath,\n                    ftOptions: {\n                        fileKey: fileParamName,\n                        fileName: fileName\n                    },\n                    params: params,\n                    headers: headers,\n                    serverUrl: url,\n                    deleteOnUpload: true\n                });\n            }).then(() => {\n                return [{\n                    fileName: soureFile,\n                    path: filePath,\n                    length: 0,\n                    success: true,\n                    inlinePath: filePath + '?inline'\n                }];\n            });\n    }\n}\n","import { from, Observable } from 'rxjs';\n\nimport { AbstractHttpService } from '@wm/core';\nimport { NetworkService } from '@wm/mobile/core';\n\nimport { ChangeLogService } from '../services/change-log.service';\nimport { LocalDBManagementService } from '../services/local-db-management.service';\nimport { WM_LOCAL_OFFLINE_CALL } from './utils';\n\ndeclare const _;\nconst NUMBER_REGEX = /^\\d+(\\.\\d+)?$/;\nlet isOfflineBehaviourAdded = false;\nexport class NamedQueryExecutionOfflineBehaviour {\n\n    constructor(\n        private changeLogService: ChangeLogService,\n        private httpService: AbstractHttpService,\n        private localDBManagementService: LocalDBManagementService,\n        private networkService: NetworkService\n    ) {\n\n    }\n\n    public add () {\n        if (isOfflineBehaviourAdded) {\n            return;\n        }\n        isOfflineBehaviourAdded = true;\n        const orig = this.httpService.sendCallAsObservable;\n        this.httpService.sendCallAsObservable = (reqParams: any, params?: any): Observable<any> => {\n            if (!params && _.get(reqParams, 'url')) {\n                params = {url: reqParams.url};\n            }\n            if (!this.networkService.isConnected() && params.url.indexOf('/queryExecutor/') > 0) {\n                return from(this.executeLocally(params));\n            } else {\n                return orig.call(this.httpService, reqParams, params);\n            }\n        };\n    }\n\n    private executeLocally(params: any): Promise<any> {\n        const url = params.url,\n            hasUrlParams = url.indexOf('?') > 0,\n            dbName = this.substring(url, 'services/', '/queryExecutor'),\n            queryName = this.substring(url, 'queries/', hasUrlParams ? '?' : undefined),\n            urlParams = hasUrlParams ? this.getHttpParamMap(this.substring(url, '?', undefined)) : {},\n            dataParams = this.getHttpParamMap(params.dataParams),\n            queryParams = _.extend(urlParams, dataParams);\n        return this.localDBManagementService.executeNamedQuery(dbName, queryName, queryParams)\n            .then(result => {\n                const rows = result.rows;\n                if (result.rowsAffected) {\n                    return this.changeLogService.add('WebService', 'invokeJavaService', params)\n                        .then(() => result.rowsAffected);\n                } else {\n                    return {\n                        type: WM_LOCAL_OFFLINE_CALL,\n                        body: {\n                            totalPages: rows && rows.length > 0 ? 1 : 0,\n                            totalElements: rows.length,\n                            first: true,\n                            sort: null,\n                            numberOfElements: rows.length,\n                            last: true,\n                            size: params.size,\n                            number: 0,\n                            content: rows\n                        }\n                    };\n                }\n            });\n    }\n\n    private substring(source: string, start: string, end: string): string {\n        if (start) {\n            const startIndex = source.indexOf(start) + start.length,\n                endIndex = end ? source.indexOf(end) : undefined;\n            return source.substring(startIndex, endIndex);\n        }\n        return undefined;\n    }\n\n    private getHttpParamMap(str: string): any {\n        const result = {};\n        if (str) {\n            str = decodeURIComponent(str);\n            str.split('&').forEach(c => {\n                const csplits = c.split('=');\n                if (_.isEmpty(_.trim(csplits[1])) || !NUMBER_REGEX.test(csplits[1])) {\n                    result[csplits[0]] = csplits[1];\n                } else {\n                    result[csplits[0]] = parseInt(csplits[1], 10);\n                }\n            });\n        }\n        return result;\n    }\n}\n","import { File } from '@ionic-native/file';\n\nimport { App, noop, triggerFn } from '@wm/core';\nimport { DeviceService, NetworkService } from '@wm/mobile/core';\nimport { SecurityService } from '@wm/security';\n\ndeclare const _;\ndeclare const cordova;\nconst SECURITY_FILE = 'logged-in-user.info';\ndeclare const resolveLocalFileSystemURL;\n\nlet isOfflineBehaviourAdded = false;\n\nexport class SecurityOfflineBehaviour {\n\n    private saveSecurityConfigLocally;\n    private securityConfig: any;\n\n    constructor(\n        private app: App,\n        private file: File,\n        private deviceService: DeviceService,\n        private networkService: NetworkService,\n        private securityService: SecurityService\n    ) {\n        this.saveSecurityConfigLocally = _.debounce((config: any) => {\n            this._saveSecurityConfigLocally(config);\n        }, 1000);\n    }\n\n    public add() {\n        if (isOfflineBehaviourAdded) {\n            return;\n        }\n        isOfflineBehaviourAdded = true;\n        const origLoad = this.securityService.load;\n        const origAppLogout = this.securityService.appLogout;\n        /**\n         * Add offline behaviour to SecurityService.getConfig. When offline, this funcation returns security\n         * config of last logged-in user will be returned, provided the user did not logout last time.\n         *\n         * @param successCallback\n         * @param failureCallback\n         */\n        this.securityService.load = () => {\n            return new Promise((resolve, reject) => {\n                if (this.networkService.isConnected()) {\n                    origLoad.call(this.securityService).then(config => {\n                        this.securityConfig = config;\n                        this.saveSecurityConfigLocally(config);\n                        resolve(this.securityConfig);\n                    }, reject);\n                } else {\n                    this.readLocalSecurityConfig().then((config = {}) => {\n                        this.securityConfig = config;\n                        this.securityService.config = config;\n                        return config;\n                    }, () => origLoad.call(this.securityConfig)).then(resolve, reject);\n                }\n            });\n        };\n\n        /**\n         * When users logs out, local config will be removed. If the user is offline and logs out, then user\n         * will be logged out from the app and cookies are invalidated when app goes online next time.\n         *\n         * @param successCallback\n         * @param failureCallback\n         */\n        this.securityService.appLogout = (successCallback, failureCallback) => {\n            this.securityConfig = {\n                authenticated: false,\n                loggedOut: true,\n                securityEnabled: this.securityConfig && this.securityConfig.securityEnabled,\n                loggedOutOffline: !this.networkService.isConnected(),\n                loginConfig: this.securityConfig && this.securityConfig.loginConfig,\n                userInfo: null\n            };\n            this._saveSecurityConfigLocally(this.securityConfig).catch(noop).then(() => {\n                if (this.networkService.isConnected()) {\n                    origAppLogout.call(this.securityService, successCallback, failureCallback);\n                } else {\n                    location.assign(window.location.origin + window.location.pathname);\n                }\n            });\n        };\n        /**\n         * @param successCallback\n         */\n        this.securityService.isAuthenticated = successCallback => {\n            triggerFn(successCallback, this.securityConfig.authenticated === true);\n        };\n        this.deviceService.whenReady().then(() => this.clearLastLoggedInUser());\n        /**\n         * If the user has chosen to logout while app is offline, then invalidation of cookies happens when\n         * app comes online next time.\n         */\n        this.app.subscribe('onNetworkStateChange', data => {\n            if (data.isConnected) {\n                this.clearLastLoggedInUser();\n            }\n        });\n    }\n\n    private _saveSecurityConfigLocally(config: any): Promise<any> {\n        return this.file.writeFile(cordova.file.dataDirectory, SECURITY_FILE, JSON.stringify(config), { replace : true });\n    }\n\n    private clearLastLoggedInUser() {\n        return this.readLocalSecurityConfig().then(config => {\n            if (config && config.loggedOutOffline) {\n                this.securityService.appLogout(null, null);\n            } else if (!this.networkService.isConnected()) {\n                this.securityConfig = config || {};\n            }\n        });\n    }\n\n    private readLocalSecurityConfig(): Promise<any> {\n        // reading the security info from file in dataDirectory but when this file is not available then fetching the config from the app directory\n        return new Promise((resolve, reject) => {\n            const rootDir = cordova.file.dataDirectory;\n            this.file.checkFile(rootDir, SECURITY_FILE).then(() => {\n                return this.readFileAsTxt(rootDir, SECURITY_FILE).then(resolve, reject);\n            }, () => {\n                const folderPath = cordova.file.applicationDirectory + 'www/metadata/app',\n                    fileName = 'security-config.json';\n                return this.readFileAsTxt(folderPath, fileName).then(resolve, reject);\n            });\n        });\n    }\n\n    private readFileAsTxt(folderPath, fileName): Promise<any> {\n        return this.file.readAsText(folderPath, fileName).then(JSON.parse).catch(noop);\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { File } from '@ionic-native/file';\n\nimport { AbstractHttpService, App, hasCordova, noop } from '@wm/core';\nimport { DeviceFileService, DeviceFileUploadService, DeviceService, NetworkService } from '@wm/mobile/core';\nimport { SecurityService } from '@wm/security';\n\nimport { ChangeLogService } from './services/change-log.service';\nimport { LocalDBManagementService } from './services/local-db-management.service';\nimport { LocalDbService } from './services/local-db.service';\nimport { FileHandler, UploadedFilesImportAndExportService } from './services/workers/file-handler';\nimport { ErrorBlocker } from './services/workers/error-blocker';\nimport { IdResolver } from './services/workers/id-resolver';\nimport { MultiPartParamTransformer } from './services/workers/multi-part-param-transformer';\nimport { LiveVariableOfflineBehaviour } from './utils/live-variable.utils';\nimport { FileUploadOfflineBehaviour } from './utils/file-upload.utils';\nimport { NamedQueryExecutionOfflineBehaviour } from './utils/query-executor.utils';\nimport { SecurityOfflineBehaviour } from './utils/security.utils';\n\n@NgModule({\n    imports: [\n        CommonModule\n    ],\n    declarations: [],\n    exports: [],\n    providers: [\n        // add providers to mobile-runtime module.\n    ],\n    entryComponents: []\n})\nexport class OfflineModule {\n    static initialized = false;\n    // Startup services have to be added only once in the app life-cycle.\n    static initialize(app: App,\n                      changeLogService: ChangeLogService,\n                      deviceService: DeviceService,\n                      deviceFileService: DeviceFileService,\n                      deviceFileUploadService: DeviceFileUploadService,\n                      file: File,\n                      httpService: AbstractHttpService,\n                      localDBManagementService: LocalDBManagementService,\n                      localDbService: LocalDbService,\n                      networkService: NetworkService,\n                      securityService: SecurityService) {\n        if (this.initialized) {\n            return;\n        }\n\n        deviceService.addStartUpService({\n            serviceName: 'OfflineStartupService',\n            start: () => {\n                if (window['SQLitePlugin']) {\n                    localDBManagementService.setLogSQl((sessionStorage.getItem('wm.logSql') === 'true') || (sessionStorage.getItem('debugMode') === 'true'));\n                    (window as any).logSql = (flag = true) => {\n                        localDBManagementService.setLogSQl(flag);\n                        sessionStorage.setItem('wm.logSql', flag ? 'true' : 'false');\n                    };\n                    (window as any).executeLocalSql = (dbName, query, params?) => {\n                        localDBManagementService.executeSQLQuery(dbName, query, params, true);\n                    };\n                    return localDBManagementService.loadDatabases().then(() => {\n                        changeLogService.addWorker(new IdResolver(localDBManagementService));\n                        changeLogService.addWorker(new ErrorBlocker(localDBManagementService));\n                        changeLogService.addWorker(new FileHandler());\n                        changeLogService.addWorker(new MultiPartParamTransformer(deviceFileService, localDBManagementService));\n                        new LiveVariableOfflineBehaviour(changeLogService, httpService, localDBManagementService, networkService, localDbService).add();\n                        new FileUploadOfflineBehaviour(changeLogService, deviceFileService, deviceFileUploadService, file, networkService, deviceFileService.getUploadDirectory()).add();\n                        new NamedQueryExecutionOfflineBehaviour(changeLogService, httpService, localDBManagementService, networkService).add();\n                        localDBManagementService.registerCallback(new UploadedFilesImportAndExportService(changeLogService, deviceFileService, localDBManagementService, file));\n                        changeLogService.addWorker({\n                            onAddCall: () => {\n                                if (!networkService.isConnected()) {\n                                    networkService.disableAutoConnect();\n                                }\n                            },\n                            postFlush: stats => {\n                                if (stats.totalTaskCount > 0) {\n                                    localDBManagementService.close()\n                                        .catch(noop)\n                                        .then(() => {\n                                            location.assign(window.location.origin + window.location.pathname);\n                                        });\n                                }\n                            }\n                        });\n                    });\n                }\n                return Promise.resolve();\n            }\n        });\n        new SecurityOfflineBehaviour(app, file, deviceService, networkService, securityService).add();\n    }\n\n\n    constructor(\n        app: App,\n        changeLogService: ChangeLogService,\n        deviceService: DeviceService,\n        deviceFileService: DeviceFileService,\n        deviceFileUploadService: DeviceFileUploadService,\n        file: File,\n        httpService: AbstractHttpService,\n        localDBManagementService: LocalDBManagementService,\n        localDbService: LocalDbService,\n        networkService: NetworkService,\n        securityService: SecurityService\n    ) {\n        if (hasCordova()) {\n            OfflineModule.initialize(app,\n                changeLogService,\n                deviceService,\n                deviceFileService,\n                deviceFileUploadService,\n                file,\n                httpService,\n                localDBManagementService,\n                localDbService,\n                networkService,\n                securityService);\n        }\n    }\n}\n","import { Injectable } from '@angular/core';\n\n\nimport { DeviceFileUploadService } from '@wm/mobile/core';\nimport { LVService } from '@wm/variables';\n\nimport { Change, PushService } from './change-log.service';\n\n@Injectable()\nexport class PushServiceImpl implements PushService {\n\n    constructor(\n        private deviceFileUploadService: DeviceFileUploadService\n    ) {}\n\n    // Returns a promise from the observable.\n    private getPromiseFromObs(cb) {\n        return new Promise((resolve, reject) => {\n            cb.subscribe(response => {\n                if (response && response.type) {\n                    resolve(response);\n                }\n            }, reject);\n        });\n    }\n\n    public push(change: Change): Promise<any> {\n        const params = change.params;\n        switch (change.service) {\n            case 'DatabaseService':\n                switch (change.operation) {\n                    case 'insertTableData':\n                        return this.getPromiseFromObs(LVService.insertTableData(change.params, null, null));\n                    case 'insertMultiPartTableData':\n                        return this.getPromiseFromObs(LVService.insertMultiPartTableData(change.params, null, null));\n                    case 'updateTableData':\n                        return this.getPromiseFromObs(LVService.updateTableData(change.params, null, null));\n                    case 'updateMultiPartTableData':\n                        return this.getPromiseFromObs(LVService.updateMultiPartTableData(change.params, null, null));\n                    case 'deleteTableData':\n                        return this.getPromiseFromObs(LVService.deleteTableData(change.params, null, null));\n                }\n            case 'OfflineFileUploadService':\n                if (change.operation === 'uploadToServer') {\n                    return this.deviceFileUploadService['uploadToServer'].call(\n                        this.deviceFileUploadService,\n                        params.serverUrl,\n                        params.ftOptions.fileKey,\n                        params.file,\n                        params.ftOptions.fileName,\n                        params.params,\n                        params.headers);\n                }\n        }\n        return Promise.reject( `${change.service} service with operation ${change.operation} is not supported for push.`);\n    }\n}\n","import { Injectable } from '@angular/core';\n\nimport { Observer } from 'rxjs/Observer';\n\nimport { $parseExpr, App, defer, getAbortableDefer, noop } from '@wm/core';\nimport { NetworkService } from '@wm/mobile/core';\n\nimport { LiveVariableUtils, LVService } from '@wm/variables';\n\nimport { LocalDBManagementService } from './local-db-management.service';\nimport { PullInfo } from './change-log.service';\nimport { LocalKeyValueService } from './local-key-value.service';\nimport { DBInfo, EntityInfo, PullType } from '../models/config';\n\ndeclare const _, moment;\nconst  LAST_PULL_INFO_KEY = 'localDBManager.lastPullInfo';\n\n/**\n * a utility api to abort pull process.\n *\n * @type {{start, add, remove, abort}}\n */\nconst pullProcessManager = (() => {\n    const promises = {};\n    return {\n        start: promise => {\n            promise.$$pullProcessId = 'PULL_' + _.now();\n        },\n        add: (pullPromise: Promise<PullInfo>, promise: Promise<any>) => {\n            const pullProcessId = (pullPromise as any).$$pullProcessId;\n            if (!promises[pullProcessId]) {\n                promises[pullProcessId] = [];\n            }\n            promises[pullProcessId].push(promise);\n        },\n        remove: (pullPromise: Promise<PullInfo>, promise: Promise<any>) => {\n            const pullProcessId = (pullPromise as any).$$pullProcessId;\n            _.remove(promises[pullProcessId], promise);\n            if (_.isEmpty(promises[pullProcessId])) {\n                delete promises[pullProcessId];\n            }\n        },\n        abort: (pullPromise: Promise<PullInfo>) => {\n            const pullProcessId = (pullPromise as any).$$pullProcessId;\n            if (promises[pullProcessId]) {\n                _.forEach(promises[pullProcessId], function (p) {\n                    if (p && p.abort) {\n                        p.abort();\n                    }\n                });\n                delete promises[pullProcessId];\n            }\n            (pullPromise as any).$$isMarkedToAbort = true;\n            return pullPromise.catch(function () {\n                return 'cancelled';\n            });\n        }\n    };\n})();\n\n/**\n * LocalDBDataPullService has API to pull data from remote Server to local Database.\n */\n@Injectable({providedIn: 'root'})\nexport class LocalDBDataPullService {\n\n    constructor(\n        private app: App,\n        private localDBManagementService: LocalDBManagementService,\n        private localKeyValueService: LocalKeyValueService,\n        private networkService: NetworkService\n    ) {\n        // Listen for db creation. When db is created, then initialize last pull info.\n        this.localDBManagementService.registerCallback({\n            onDbCreate: (info) => {\n                this.localKeyValueService.put(LAST_PULL_INFO_KEY, {\n                    databases: [],\n                    totalRecordsToPull: 0,\n                    totalPulledRecordCount: 0,\n                    startTime: new Date(0),\n                    endTime: new Date(info.dbSeedCreatedOn)\n                });\n            }\n        });\n    }\n\n    /**\n     * If deltaFieldName is set,last pull time is greater than zero and query used in last pull is same as the\n     * query for the current pull, then delta criteria is attached to the query.\n     *\n     * @param db\n     * @param entityName\n     * @param query\n     * @returns {any}\n     */\n    private addDeltaCriteria(db: DBInfo, entityName: string, query: string): Promise<string> {\n        const entitySchema = db.schema.entities[entityName],\n            deltaFieldName = entitySchema.pullConfig.deltaFieldName,\n            deltaField = _.find(entitySchema.columns, {'fieldName' : deltaFieldName}) || {};\n\n        let isBundledEntity;\n\n        if (!_.isEmpty(deltaFieldName)) {\n            return this.localDBManagementService.isBundled(db.schema.name, entityName)\n                .then(flag => isBundledEntity = flag)\n                .then(() => this.getLastPullInfo())\n                .then(lastPullInfo => {\n                    let lastPullTime = (lastPullInfo && lastPullInfo.startTime && lastPullInfo.startTime.getTime());\n                    const lastPullDBInfo = _.find(lastPullInfo && lastPullInfo.databases, {'name' : db.schema.name}),\n                        lastPullEntityInfo = _.find(lastPullDBInfo && lastPullDBInfo.entities, {'entityName' : entityName}) || {};\n\n                    if (!lastPullTime && isBundledEntity) {\n                        // For bundled entity when there is no last pull, fetch records that got modified after db creation.\n                        lastPullTime = (lastPullInfo && lastPullInfo.endTime && lastPullInfo.endTime.getTime());\n                        lastPullEntityInfo.query = query;\n                    }\n                    if (lastPullEntityInfo.query === query && lastPullTime > 0) {\n                        if (_.isEmpty(query)) {\n                            query = '';\n                        } else {\n                            query += ' AND ';\n                        }\n                        if (deltaField.sqlType === 'datetime') {\n                            query += deltaFieldName + ' > wm_dt(\\'' + moment(lastPullTime).utc().format('YYYY-MM-DDTHH:mm:ss') + '\\')';\n                        } else {\n                            query += deltaFieldName + ' > wm_ts(\\'' + lastPullTime + '\\')';\n                        }\n                    }\n                    return query;\n                }, () => Promise.resolve(query));\n        }\n        return Promise.resolve(query);\n    }\n\n    /**\n     * copies the data from remote db to local db\n     * @param {DBInfo} db\n     * @param {string} entityName\n     * @param {boolean} clearDataBeforePull\n     * @param pullPromise\n     * @param {Observer<any>} progressObserver\n     * @returns {Promise<any>}\n     */\n    private copyDataFromRemoteDBToLocalDB(db: DBInfo, entityName: string, clearDataBeforePull: boolean, pullPromise: Promise<PullInfo>, progressObserver: Observer<any>) {\n        const store = (db as any).stores[entityName],\n            entitySchema = db.schema.entities[entityName],\n            result = {\n                entityName: entityName,\n                totalRecordsToPull: 0,\n                pulledRecordCount: 0\n            };\n\n        let inProgress = 0,\n            pullComplete = false,\n            filter;\n\n        return new Promise((resolve, reject) => {\n            this.prepareQuery(db, entityName)\n                .then(query => {\n                    (result as any).query = query;\n                    return this.addDeltaCriteria(db, entityName, query);\n                }).then(query => {\n                    // Clear if clearDataBeforePull is true and delta query is not used\n                    if (clearDataBeforePull && (result as any).query === query) {\n                        return store.clear()\n                            .then(() => {\n                                return query;\n                            });\n                    }\n                    return query;\n                }).then(query => {\n                    filter = _.isEmpty(query) ? '' : 'q=' + query;\n                    return this.getTotalRecordsToPull(db, entitySchema, filter, pullPromise);\n                }).then(maxNoOfRecords => {\n                    const pageSize = entitySchema.pullConfig.size || 100,\n                        maxNoOfPages = Math.ceil(maxNoOfRecords / pageSize);\n\n                    result.totalRecordsToPull = maxNoOfRecords;\n\n                    let sort = entitySchema.pullConfig.orderBy;\n                    sort = (_.isEmpty(sort) ? '' : sort + ',') + store.primaryKeyName;\n\n                    progressObserver.next(result);\n\n                    const _progressObserver = { next: data => {\n                            inProgress++;\n                            data = _.slice(data, 0, result.totalRecordsToPull - result.pulledRecordCount);\n                            store.saveAll(data).then(() => {\n                                result.pulledRecordCount += data ? data.length : 0;\n                                progressObserver.next(result);\n                            }).catch(noop)\n                                .then(() => {\n                                    inProgress--;\n                                    if (inProgress === 0 && pullComplete) {\n                                        resolve(result);\n                                    }\n                                });\n                        }, error: null, complete: null\n                    };\n\n                return this._pullEntityData(db, entityName, filter, sort, maxNoOfPages, pageSize, 1, pullPromise, undefined, _progressObserver);\n                }).then(null, reject)\n                    .catch(noop)\n                    .then(() => {\n                        pullComplete = true;\n                        if (inProgress === 0) {\n                            resolve(result);\n                        }\n                    });\n            });\n    }\n\n    // If expression starts with 'bind:', then expression is evaluated and result is returned.\n    private evalIfBind(expression: string) {\n        if (_.startsWith(expression, 'bind:')) {\n            expression = expression.replace(/\\[\\$\\i\\]/g, '[0]');\n            return $parseExpr(expression.replace('bind:', ''))(this.app);\n        }\n        return expression;\n    }\n\n    /**\n     * Executes DatabaseService.countTableDataWithQuery as a promise API.\n     * @param params\n     * @returns Promise\n     */\n    private executeDatabaseCountQuery(params: Object): Promise<any> {\n        return new Promise((resolve, reject) => {\n            LVService.countTableDataWithQuery(params, null, null).subscribe(response => resolve(response.body), reject);\n        });\n    }\n\n    /**\n     * Executes DatabaseService.searchTableDataWithQuery as a promise API.\n     * @param params\n     * @returns Promise\n     */\n    private executeDatabaseSearchQuery(params: Object): Promise<any> {\n        return new Promise((resolve, reject) => {\n            return LVService.searchTableDataWithQuery(params, null, null).subscribe(response => resolve(response && response.body && response.body.content), reject);\n        });\n    }\n\n    /**\n     * Computes the maximum number of records to pull.\n     *\n     * @param db\n     * @param entitySchema\n     * @param filter\n     * @param pullPromise\n     * @returns {*}\n     */\n    private getTotalRecordsToPull(db: DBInfo, entitySchema: EntityInfo, filter: string, pullPromise: Promise<PullInfo>): Promise<number> {\n        const params = {\n            dataModelName: db.schema.name,\n            entityName: entitySchema.entityName,\n            data: filter\n        };\n        return this.retryIfNetworkFails(() => {\n            return this.executeDatabaseCountQuery(params).then(function (response) {\n                const totalRecordCount = response,\n                    maxRecordsToPull = _.parseInt((entitySchema.pullConfig as any).maxNumberOfRecords);\n                if (_.isNaN(maxRecordsToPull) || maxRecordsToPull <= 0 || totalRecordCount < maxRecordsToPull) {\n                    return totalRecordCount;\n                }\n                return maxRecordsToPull;\n            });\n        }, pullPromise);\n    }\n\n    private prepareQuery(db: DBInfo, entityName: string): Promise<string> {\n        let query;\n        const entitySchema = db.schema.entities[entityName];\n\n        return this.localDBManagementService.isBundled(db.schema.name, entityName)\n            .then(isBundledEntity => {\n                let hasNullAttributeValue = false;\n                if (isBundledEntity || _.isEmpty(entitySchema.pullConfig.query)) {\n                    query = _.cloneDeep(entitySchema.pullConfig.filter);\n                    query = _.map(query, v => {\n                        v.attributeValue = this.evalIfBind(v.attributeValue);\n                        hasNullAttributeValue = hasNullAttributeValue || _.isNil(v.attributeValue);\n                        return v;\n                    });\n                    if (hasNullAttributeValue) {\n                        return Promise.reject('Null criteria values are present');\n                    }\n                    query = _.sortBy(query, 'attributeName');\n                    query = LiveVariableUtils.getSearchQuery(query, ' AND ', true);\n                } else {\n                    query = this.evalIfBind(entitySchema.pullConfig.query);\n                }\n                if (_.isNil(query)) {\n                    return Promise.resolve(null);\n                }\n\n                return Promise.resolve(encodeURIComponent(query));\n        });\n    }\n\n    /**\n     *\n     * @param db\n     * @param clearDataBeforePull\n     * @param pullPromise\n     * @param progressObserver\n     * @returns {*}\n     */\n    private _pullDbData(db: DBInfo, clearDataBeforePull: boolean, pullPromise: Promise<PullInfo>, progressObserver: Observer<any>): Promise<any> {\n        const datamodelName = db.schema.name,\n            result = {\n                name: db.schema.name,\n                entities: [],\n                totalRecordsToPull: 0,\n                pulledRecordCount: 0,\n                completedTaskCount: 0,\n                totalTaskCount: 0\n            };\n\n        const storePromises = [];\n\n        _.forEach(db.schema.entities, entity => {\n            storePromises.push(this.localDBManagementService.getStore(datamodelName, entity.entityName));\n        });\n\n        return new Promise((resolve, reject) => {\n            Promise.all(storePromises)\n                .then((stores) => {\n                    const entities = [];\n                    stores.forEach(store => {\n                        const pullConfig = store.entitySchema.pullConfig;\n                        const pullType = pullConfig.pullType;\n                        if (pullType === PullType.APP_START || (pullType === PullType.BUNDLED && (pullConfig as any).deltaFieldName)) {\n                            entities.push(store.entitySchema);\n                        }\n                    });\n                    const pullPromises = _.chain(entities)\n                        .map(entity => {\n                        const _progressObserver = {\n                            next: info => {\n                                const i = _.findIndex(result.entities, {'entityName': info.entityName});\n                                if (i >= 0) {\n                                    result.entities[i] = info;\n                                } else {\n                                    result.entities.push(info);\n                                }\n                                result.pulledRecordCount = _.reduce(result.entities, function (sum, entityPullInfo) {\n                                    return sum + entityPullInfo.pulledRecordCount;\n                                }, 0);\n                                result.totalRecordsToPull = _.reduce(result.entities, function (sum, entityPullInfo) {\n                                    return sum + entityPullInfo.totalRecordsToPull;\n                                }, 0);\n                                progressObserver.next(result);\n                            }, error: null, complete: null\n                        };\n                        return this.copyDataFromRemoteDBToLocalDB(db, entity.entityName, clearDataBeforePull, pullPromise, _progressObserver)\n                            .then(function (info) {\n                                result.completedTaskCount++;\n                                progressObserver.next(result);\n                                return info;\n                            }, null);\n                    }).value();\n\n                result.totalTaskCount = pullPromises.length;\n                progressObserver.next(result);\n\n                Promise.all(pullPromises).then(resolve, reject);\n            });\n        });\n    }\n\n    /**\n     * Pulls data of the given entity from remote server.\n     * @param db\n     * @param entityName\n     * @param sort\n     * @param maxNoOfPages\n     * @param pageSize\n     * @param currentPage\n     * @param filter\n     * @param pullPromise\n     * @param promise\n     * @returns {*}\n     */\n    private _pullEntityData(db: DBInfo, entityName: string, filter: string, sort, maxNoOfPages: number, pageSize: number, currentPage: number, pullPromise: Promise<PullInfo>, deferred: any, progressObserver?: Observer<any>) {\n        const dataModelName = db.schema.name;\n\n        if (!deferred) {\n            deferred = defer();\n        }\n\n        if (currentPage > maxNoOfPages) {\n            return deferred.resolve();\n        }\n        const params = {\n            dataModelName: dataModelName,\n            entityName: entityName,\n            page: currentPage,\n            size: pageSize,\n            data: filter,\n            sort: sort,\n            onlyOnline: true,\n            skipLocalDB: true\n        };\n        this.retryIfNetworkFails(() => {\n            return this.executeDatabaseSearchQuery(params);\n        }, pullPromise).then(response => {\n            progressObserver.next(response);\n            this._pullEntityData(db, entityName, filter, sort, maxNoOfPages, pageSize, currentPage + 1, pullPromise, deferred, progressObserver);\n        }, deferred.reject);\n\n        return deferred.promise;\n    }\n\n\n    /**\n     * If fn fails and network is not there\n     * @param fn\n     * @param pullPromise\n     * @returns {*}\n     */\n    private retryIfNetworkFails(fn: Function, pullPromise: Promise<PullInfo>) {\n        if ((pullPromise as any).$$isMarkedToAbort) {\n            return Promise.reject('aborted');\n        }\n        const promise = this.networkService.retryIfNetworkFails(fn);\n        pullProcessManager.add(pullPromise, promise);\n        promise.catch(noop)\n            .then(() => {\n            pullProcessManager.remove(pullPromise, promise);\n        });\n        return promise;\n    }\n\n    /**\n     * Tries to cancel the corresponding pull process that gave the given promise.\n     * @param promise\n     * @returns {any}\n     */\n    public cancel(promise: Promise<any>) {\n        return pullProcessManager.abort(promise);\n    }\n\n    /**\n     * fetches the database from the dbName.\n     * @param dbName\n     * @returns {Promise<any>}\n     */\n    public getDb(dbName: string) {\n        return this.localDBManagementService.loadDatabases()\n            .then(databases => {\n                const db = _.find(databases, {'name' : dbName});\n                return db || Promise.reject('Local database (' + dbName + ') not found');\n            });\n    }\n\n    /**\n     * @returns {any} that has total no of records fetched, start and end timestamps of last successful pull\n     * of data from remote server.\n     */\n    public getLastPullInfo(): Promise<PullInfo> {\n        return this.localKeyValueService.get(LAST_PULL_INFO_KEY).then(info => {\n            if (_.isString(info.startTime)) {\n                info.startTime = new Date(info.startTime);\n            }\n            if (_.isString(info.endTime)) {\n                info.endTime = new Date(info.endTime);\n            }\n            return info;\n        });\n    }\n\n    /**\n     * Clears (based on parameter) and pulls data ('BUNDLED' data based on parameter) from server using the\n     * configured rules in offline configuration.\n     *\n     * @param clearDataBeforePull boolean\n     * @param {Observer<any>} progressObserver\n     * @returns {any}\n     */\n    public pullAllDbData(clearDataBeforePull: boolean, progressObserver: Observer<any>): Promise<PullInfo> {\n        const deferred = getAbortableDefer(),\n            pullInfo = {\n            completedTaskCount: 0,\n            totalTaskCount: 0,\n            inProgress: true,\n            databases: [],\n            totalRecordsToPull: 0,\n            totalPulledRecordCount: 0,\n            startTime: new Date(),\n            endTime: new Date()\n        };\n\n        this.localDBManagementService.loadDatabases()\n            .then(databases => {\n                const dataPullPromises = _.chain(databases).filter(function (db) {\n                    return !db.schema.isInternal;\n                }).map(db => {\n                    pullProcessManager.start(deferred.promise);\n\n                    const _progressObserver: Observer<any> = {next: data => {\n                                const i = _.findIndex(pullInfo.databases, {'name' : data.name});\n                                if (i >= 0) {\n                                    pullInfo.databases[i] = data;\n                                } else {\n                                    pullInfo.databases.push(data);\n                                }\n                                pullInfo.totalTaskCount = _.reduce(pullInfo.databases, function (sum, dbPullInfo) {\n                                    return sum + dbPullInfo.totalTaskCount;\n                                }, 0);\n                                pullInfo.completedTaskCount = _.reduce(pullInfo.databases, function (sum, dbPullInfo) {\n                                    return sum + dbPullInfo.completedTaskCount;\n                                }, 0);\n                                pullInfo.totalPulledRecordCount = _.reduce(pullInfo.databases, function (sum, dbPullInfo) {\n                                    return sum + dbPullInfo.pulledRecordCount;\n                                }, 0);\n                                pullInfo.totalRecordsToPull = _.reduce(pullInfo.databases, function (sum, dbPullInfo) {\n                                    return sum + dbPullInfo.totalRecordsToPull;\n                                }, 0);\n                                progressObserver.next(pullInfo);\n                            }, error: null, complete: null\n                        };\n\n                    return this._pullDbData(db, clearDataBeforePull, deferred.promise, _progressObserver);\n                }).value();\n                return Promise.all(dataPullPromises);\n            }).then(() => {\n                pullInfo.endTime = new Date();\n                pullInfo.inProgress = false;\n                this.localKeyValueService.put(LAST_PULL_INFO_KEY, pullInfo);\n                deferred.resolve(pullInfo);\n        }, deferred.reject);\n\n        return deferred.promise;\n    }\n\n    /**\n     * Clears (based on parameter) and pulls data ('BUNDLED' data based on parameter) of the given database from server using\n     * the configured rules in offline configuration.\n     *\n     * @param {string} databaseName\n     * @param {boolean} clearDataBeforePull\n     * @param {Observer<any>} progressObserver\n     * @returns {Promise}\n     */\n    public pullDbData(databaseName: string, clearDataBeforePull: boolean, progressObserver: Observer<any>): Promise<any> {\n        const deferred = getAbortableDefer();\n\n        this.getDb(databaseName).then(db => {\n            return this._pullDbData(db, clearDataBeforePull, deferred.promise, progressObserver);\n        }).then(deferred.resolve, deferred.reject);\n\n        return deferred.promise;\n    }\n\n    /**\n     * Clears (based on parameter) and pulls data of the given entity and database from\n     * server using the configured rules in offline configuration.\n     * @param databaseName, name of the database from which data has to be pulled.\n     * @param entityName, name of the entity from which data has to be pulled\n     * @param clearDataBeforePull, if set to true, then data of the entity will be deleted.\n     * @param progressObserver, observer the progress values\n     */\n    public pullEntityData(databaseName: string, entityName: string, clearDataBeforePull: boolean, progressObserver: Observer<any>): Promise<any> {\n        const deferred = getAbortableDefer();\n\n        this.getDb(databaseName)\n            .then((db) => {\n                return this.copyDataFromRemoteDBToLocalDB(db, entityName, clearDataBeforePull, deferred.promise, progressObserver);\n        }).then(deferred.resolve, deferred.reject);\n\n        return deferred.promise;\n    }\n}\n"]}