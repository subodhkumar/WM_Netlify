{"version":3,"sources":["ng://@wm/security/security.service.ts","ng://@wm/security/security.module.ts"],"names":["XSRF_COOKIE_NAME","SecurityService","injector","$http","routerService","activatedRoute","_location","this","requestQueue","prototype","isLoaded","config","get","load","_this","loadPromise","Promise","resolve","reject","send","url","method","then","response","body","lastLoggedInUser","getClonedObject","loggedInUser","userInfo","catch","err","finally","getWebConfig","success","error","triggerFn","getConfig","successCallback","failureCallback","invokeQueuedCallbacks","id","data","_","forEach","fn","push","length","hasCordova","onSuccess","homePage","getWmProjectProperties","call","bind","onError","getLastLoggedInUsername","userName","getCurrentRoutePage","p","path","lIndex","indexOf","substr","getCurrentRouteQueryParam","paramName","paramVal","queryParams","subscribe","params","isNoPageLoaded","isEmpty","getPageByLoggedInUser","that","page","securityEnabled","authenticated","landingPage","isXsrfEnabled","loadPageByUserRole","forcePageLoad","window","location","reload","navigate","navigateOnLogin","getRedirectPage","prevRedirectPage","loginPage","redirectPage","undefined","getRedirectedRouteQueryParams","val","key","getQueryString","queryObject","value","join","appLogin","payload","each","name","encodeURIComponent","headers","Content-Type","xsrfCookieValue","localStorage","setItem","App","notify","isAuthenticated","appLogout","target","responseType","byPassResult","set","getCookieByName","getItem","onUserLogin","unsubscribe_1","getLoggedInUser","authInBrowser","Injectable","Injector","AbstractHttpService","Router","ActivatedRoute","Location","SecurityModule","forRoot","ngModule","providers","NgModule","args"],"mappings":"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","sourcesContent":["import { Injectable, Injector } from '@angular/core';\nimport { Location } from '@angular/common';\nimport { ActivatedRoute, Router } from '@angular/router';\n\nimport { AbstractHttpService, App, getClonedObject, getWmProjectProperties, hasCordova, triggerFn } from '@wm/core';\n\ndeclare const _;\n\n// Todo[Shubham]: Move below constants to a common file\nconst XSRF_COOKIE_NAME = 'wm_xsrf_token',\n    isApplicationType = true;\n\n@Injectable()\nexport class SecurityService {\n    config;\n    lastLoggedInUser;\n    loggedInUser;\n    loadPromise: Promise<any>;\n    requestQueue: any = {};\n\n    constructor(\n        private injector: Injector,\n        private $http: AbstractHttpService,\n        private routerService: Router,\n        private activatedRoute: ActivatedRoute,\n        private _location: Location\n    ) {}\n\n    isLoaded() {\n        return this.config;\n    }\n\n    get() {\n        return this.config;\n    }\n\n    load() {\n        if(this.loadPromise) {return this.loadPromise;}\n        this.loadPromise = new Promise((resolve, reject) => {\n                this.$http.send({'url': './services/security/info', 'method': 'GET'}).then((response) => {\n                    this.config = response.body;\n                    this.lastLoggedInUser = getClonedObject(this.loggedInUser);\n                    this.loggedInUser = this.config.userInfo;\n                    resolve(response.body);\n                }).catch((err)=>{\n                    reject(err);\n                }).finally(()=>{\n                    this.loadPromise = null;\n                });\n        });\n        return this.loadPromise;\n    }\n\n    /**\n     * gets the security config from the deployed app (backend call)\n     * @param success\n     * @param error\n     */\n    getWebConfig(success, error) {\n        if (this.get()) {\n            // if already fetched, return it\n            triggerFn(success, this.get());\n            return;\n        }\n        this.load()\n            .then(config => {\n                triggerFn(success, config);\n            }, error);\n    }\n\n    /**\n     * Returns security config\n     * @param successCallback\n     * @param failureCallback\n     */\n    getConfig(successCallback, failureCallback) {\n        function invokeQueuedCallbacks(id, method, data) {\n            _.forEach(this.requestQueue[id], fn => triggerFn(fn[method], data));\n            this.requestQueue[id] = null;\n        }\n\n        function onSuccess(config) {\n            config.homePage = getWmProjectProperties().homePage;\n            if (config.userInfo) {\n                // Backend returns landingPage instead of homePage, hence this statement(for consistency)\n                // config.userInfo.homePage = config.userInfo.landingPage;\n            }\n            this.config = config;\n            this.lastLoggedInUser = getClonedObject(this.loggedInUser);\n            this.loggedInUser = config.userInfo;\n            invokeQueuedCallbacks.call(this, 'config', 'success', this.get());\n        }\n\n        function onError(error) {\n            /*if ($rootScope.isMobileApplicationType) {\n             this.config = {\n             'securityEnabled': false,\n             'authenticated': false,\n             'homePage': _WM_APP_PROPERTIES.homePage,\n             'userInfo': null,\n             'login': null\n             };\n             invokeQueuedCallbacks('config', 'success', this.get());\n             } else {*/\n            invokeQueuedCallbacks.call(this, 'config', 'error', error);\n            // }\n        }\n\n        if (this.get()) {\n            // if already fetched, return it\n            triggerFn(successCallback, this.get());\n            return;\n        }\n\n        // Queue check, if same queue is already in progress, do not send another request\n        this.requestQueue.config = this.requestQueue.config || [];\n        this.requestQueue.config.push({\n            success: successCallback,\n            error: failureCallback\n        });\n        if (this.requestQueue.config.length > 1) {\n            return;\n        }\n\n        if (!hasCordova()) {\n            // for web project, return config returned from backend API call.\n            this.getWebConfig(onSuccess.bind(this), onError.bind(this));\n        }\n        /* else {\n         /!*\n         * for mobile app, first get the mobile config (saved in the apk)\n         * - if security not enabled, just return mobile config (no backend call required)\n         * - else, get Web config (will be  the same API hit for login) and merge the config with _mobileconfig\n         *!/\n         getMobileConfig(function (mobileconfig) {\n         if (!mobileconfig.securityEnabled) {\n         onSuccess(mobileconfig);\n         } else {\n         getWebConfig(function (config) {\n         config = mergeWebAndMobileConfig(config);\n         onSuccess(config);\n         }, function () {onSuccess(mobileconfig); });\n         }\n         }, onError);\n         }*/\n    }\n\n    getLastLoggedInUsername() {\n        return this.lastLoggedInUser && this.lastLoggedInUser.userName;\n    }\n\n    /**\n     * Returns the current page name\n     * @returns {string}\n     */\n    getCurrentRoutePage() {\n        const p = this._location.path();\n        let lIndex = p.indexOf('?');\n        lIndex = lIndex === -1 ? p.length : lIndex - 1;\n        return p.substr(1, lIndex); // ignore the query params\n    }\n\n    /**\n     * Returns Query params for specified param name in current Route\n     * @param paramName, the param name whose query param value is to be retrieved\n     * @returns {any}\n     */\n    getCurrentRouteQueryParam(paramName) {\n        let paramVal;\n        this.activatedRoute.queryParams.subscribe(params => {\n            paramVal = params[paramName];\n        });\n        return paramVal;\n    }\n\n    isNoPageLoaded() {\n        return !_.isEmpty(this.getCurrentRoutePage());\n    }\n\n    getPageByLoggedInUser() {\n        const that = this;\n        return new Promise((resolve) => {\n            let page;\n            if (!isApplicationType) {\n                if (that.isNoPageLoaded()) {\n                    page = getWmProjectProperties().homePage;\n                    resolve(page);\n                }\n            } else {\n                that.getConfig((config) => {\n                    if (config.securityEnabled && config.authenticated) {\n                        page = config.userInfo.landingPage || getWmProjectProperties().homePage;\n                        // override the default xsrf cookie name and xsrf header names with WaveMaker specific values\n                        if (that.isXsrfEnabled()) {\n                            // this.$http.defaults.xsrfCookieName = XSRF_COOKIE;\n                            // this.$http.defaults.xsrfHeaderName = config.csrfHeaderName;\n                        }\n                    } else {\n                        page = getWmProjectProperties().homePage;\n                    }\n                    resolve(page);\n                }, function () {\n                    resolve(getWmProjectProperties().homePage);\n                });\n            }\n        });\n    }\n\n    /**\n     * Loads the App page as follows:\n     * Security disabled:\n     *      - Home page\n     * Security enabled:\n     *      - User is logged in, respective landing page is loaded\n     *      - Not logged in:\n     *          - Home page is public, loads the home page\n     *          - Home page not public, Login page(in config) is loaded\n     * @param forcePageLoad\n     * @returns {Promise<T>}\n     */\n    loadPageByUserRole(forcePageLoad?) {\n        const that = this;\n        return this.getPageByLoggedInUser().then(page => {\n            if (that.isNoPageLoaded() || forcePageLoad) {\n                // Reload the page when current page and post login landing page are same\n                if (that.getCurrentRoutePage() === page) {\n                    (window.location as any).reload();\n                } else {\n                    that.routerService.navigate([`/${page}`]);\n                }\n            }\n        });\n    }\n\n    /**\n     * Navigates to the current user's homePage based on the config in SecurityService\n     * Assumption is the SecurityService is updated with the latest security config before making call to this function\n     */\n    navigateOnLogin() {\n        this.loadPageByUserRole(true);\n    }\n\n    /**\n     * Gets the page which needs to be redirected to on successful login\n     * @param config,\n     * @param page, page name for redirection\n     * @returns {any|string}\n     */\n    getRedirectPage(config, page?) {\n        const homePage = getWmProjectProperties().homePage,\n            loginPage = _.get(config, 'loginConfig.pageName');\n        let prevRedirectPage,\n            redirectPage = page || this.getCurrentRoutePage();\n\n        // if user is already on Home page or Login page, they should not be redirected to that page, hence return undefined\n        if (redirectPage === homePage || redirectPage === loginPage) {\n            /*\n             * find previous redirect page from URL, if exists, user should redirect to that page.\n             * USE CASE:\n             *  user is on http://localhost:8080/app/#/Login?redirectTo=page\n             *  a variable call fails resulting 401\n             *  in this case, redirectTo page should be 'page' and not undefined\n             */\n            prevRedirectPage = this.getCurrentRouteQueryParam('redirectTo');\n            redirectPage = !_.isEmpty(prevRedirectPage) ? prevRedirectPage : undefined;\n        }\n\n        return redirectPage;\n    }\n\n    /**\n     * Returns all the query params(including page params and redirect to params) associated with redirected page\n     */\n    getRedirectedRouteQueryParams() {\n        let queryParams = {};\n        this.activatedRoute.queryParams.subscribe((paramVal) => {\n            _.forEach(paramVal, (val, key) => {\n                queryParams[key] = val;\n            });\n        });\n        return queryParams;\n    }\n\n    // accepts query object like {a:1, b:2} and returns a=1&b=2 string\n    getQueryString(queryObject) {\n        const params = [];\n        _.forEach(queryObject, function (value, key) {\n            params.push(key + '=' + value);\n        });\n        return _.join(params, '&');\n    }\n\n    appLogin(params, successCallback, failureCallback) {\n        let payload = '';\n\n        // encode all parameters\n        _.each(params, function (value, name) {\n            payload += (payload ? '&' : '') + encodeURIComponent(name) + '=' + encodeURIComponent(value);\n        });\n\n        return this.$http.send({\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            url: 'j_spring_security_check',\n            'data': payload\n        }).then((response) => {\n            const xsrfCookieValue = response.body ? response.body[XSRF_COOKIE_NAME] : '';\n\n            // override the default xsrf cookie name and xsrf header names with WaveMaker specific values\n            if (xsrfCookieValue) {\n                if (hasCordova()) {\n                    localStorage.setItem(XSRF_COOKIE_NAME, xsrfCookieValue || '');\n                }\n            }\n            // After the successful login in device, this function triggers the pending onLoginCallbacks.\n            this.injector.get(App).notify('userLoggedIn', {});\n            triggerFn(successCallback, response);\n        }, failureCallback);\n    }\n\n    /**\n     * The API is used to check if the user is authenticated in the RUN mode.\n     *\n     * @param {function} successCallback to be called on success\n     * @param {function} failureCallback to be called on failure\n     */\n    isAuthenticated(successCallback, failureCallback) {\n        this.getConfig(function (config) {\n            triggerFn(successCallback, config.authenticated);\n        }, failureCallback);\n    }\n\n    /**\n     * The API is used to logout of the app.\n     *\n     * @param {function} successCallback to be called on success\n     * @param {function} failureCallback to be called on failure\n     */\n    appLogout(successCallback, failureCallback) {\n        return this.$http.send({\n            target: 'Security',\n            url: 'j_spring_security_logout',\n            method: 'POST',\n            responseType: 'text',\n            byPassResult: true\n        }).then((response) => {\n            _.set(this.get(), 'authenticated', false);\n            _.set(this.get(), 'userInfo', null);\n            /*if (CONSTANTS.hasCordova) {\n                localStorage.setItem(CONSTANTS.XSRF_COOKIE_NAME, '');\n            }*/\n            this.injector.get(App).notify('userLoggedOut', {});\n            triggerFn(successCallback, response);\n        }, failureCallback);\n    }\n\n    /**\n     * Checks and return the cookie\n     * @param name, cookie key\n     * @returns {string}\n     */\n    getCookieByName(name) {\n        // Todo: Shubham Implement cookie native js\n        return 'cookie';\n    }\n\n    /**\n     * This function returns the cookieValue if xsrf is enabled.\n     * In device, xsrf cookie is stored in localStorage.\n     * @returns xsrf cookie value\n     */\n    isXsrfEnabled() {\n        if (hasCordova()) {\n            return localStorage.getItem(XSRF_COOKIE_NAME);\n        }\n        return this.getCookieByName(XSRF_COOKIE_NAME);\n    }\n\n    /**\n     * This function returns a promise. Promise is resolved when security is\n     * 1. disabled\n     * 2. enabled and user is authenticated\n     * 3. enabled and user is not authenticated, then promise is resolved on user login\n     * @returns {*} promise\n     */\n    public onUserLogin(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.getConfig(config => {\n                if (config.securityEnabled) {\n                    if (config.authenticated) {\n                        resolve();\n                    } else {\n                        const unsubscribe = this.injector.get(App).subscribe('userLoggedIn', () => {\n                            resolve();\n                            unsubscribe();\n                        });\n                    }\n                } else {\n                    resolve();\n                }\n            }, reject);\n        });\n    }\n\n    /**\n     * @returns a promise that is resolved with logged-in-user\n     */\n    getLoggedInUser() {\n        return new Promise<any>((resolve, reject) => {\n            this.getConfig((config) => {\n                if (config && config.userInfo) {\n                    resolve(config.userInfo);\n                } else {\n                    reject();\n                }\n            }, reject);\n        });\n    }\n\n    /**\n     * This is for mobile apps to authenticate via browser.\n     *\n     * @returns a promise that is resolved after login\n     */\n    authInBrowser(): Promise<any> {\n        return Promise.reject('This authInBrowser should not be called');\n    }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\n\nimport { SecurityService } from './security.service';\n\n@NgModule({})\nexport class SecurityModule {\n    static forRoot(): ModuleWithProviders {\n        return {\n            ngModule: SecurityModule,\n            providers: [SecurityService]\n        };\n    }\n}\n"]}