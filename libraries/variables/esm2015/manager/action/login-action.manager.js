import { getClonedObject, triggerFn } from '@wm/core';
import { BaseActionManager } from './base-action.manager';
import { CONSTANTS, VARIABLE_CONSTANTS } from '../../constants/variables.constants';
import { appManager, dialogService, initiateCallback, routerService, securityService } from '../../util/variable/variables.utils';
export class LoginActionManager extends BaseActionManager {
    validate(params) {
        let err, paramKey, remembermeKey;
        const LOGIN_PARAM_REMEMBER_ME = 'j_rememberme';
        const LOGIN_PARAM_REMEMBER_ME_OLD = ['rememberme', 'remembermecheck'];
        // for older projects
        LOGIN_PARAM_REMEMBER_ME_OLD.forEach((old_key) => {
            if (_.isBoolean(params[old_key])) {
                remembermeKey = old_key;
            }
        });
        remembermeKey = remembermeKey || LOGIN_PARAM_REMEMBER_ME;
        // check remember me
        params[remembermeKey] = _.isBoolean(params[remembermeKey]) ? params[remembermeKey] : false;
        for (paramKey in params) {
            if (params.hasOwnProperty(paramKey) &&
                (params[paramKey] === '' || params[paramKey] === undefined)) {
                err = 'Please provide required credentials';
                break;
            }
        }
        return err;
    }
    migrateOldParams(params) {
        const loginParams = {}, paramMigrationMap = {
            'usernametext': 'j_username',
            'username': 'j_username',
            'passwordtext': 'j_password',
            'password': 'j_password',
            'remembermecheck': 'j_rememberme',
            'rememberme': 'j_rememberme'
        };
        _.each(params, function (value, key) {
            if (paramMigrationMap[key]) {
                loginParams[paramMigrationMap[key]] = value;
            }
            else {
                loginParams[key] = value;
            }
        });
        return loginParams;
    }
    login(variable, options, success, error) {
        let newDataSet;
        options = options || {};
        // If login info provided along explicitly with options, don't look into the variable bindings for the same
        const loginInfo = options.loginInfo || options.input || variable.dataBinding;
        // client side validation
        const errMsg = this.validate(loginInfo);
        /* if error message initialized, return error */
        if (errMsg) {
            triggerFn(error, errMsg);
            initiateCallback('onError', variable, errMsg);
            return;
        }
        // Triggering 'onBeforeUpdate' and considering
        let params = getClonedObject(loginInfo);
        const output = initiateCallback(VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE, variable, params);
        if (_.isObject(output)) {
            params = output;
        }
        else if (output === false) {
            triggerFn(error);
            return;
        }
        // migrate old params to new
        params = this.migrateOldParams(params);
        // get previously loggedInUser name (if any)
        const lastLoggedInUsername = _.get(securityService.get(), 'userInfo.userName');
        this.notifyInflight(variable, true);
        variable.promise = securityService.appLogin(params, (response) => {
            // Closing login dialog after successful login
            dialogService.close('CommonLoginDialog');
            /*
             * Get fresh security config
             * Get App variables. if not loaded
             * Update loggedInUser variable with new user details
             */
            appManager.reloadAppData().
                then((config) => {
                // EVENT: ON_RESULT
                initiateCallback(VARIABLE_CONSTANTS.EVENT.RESULT, variable, _.get(config, 'userInfo'));
                // EVENT: ON_PREPARESETDATA
                newDataSet = initiateCallback(VARIABLE_CONSTANTS.EVENT.PREPARE_SETDATA, variable, _.get(config, 'userInfo'));
                if (newDataSet) {
                    // setting newDataSet as the response to service variable onPrepareSetData
                    _.set(config, 'userInfo', newDataSet);
                }
                // hide the spinner after all the n/w calls are completed
                this.notifyInflight(variable, false, response);
                triggerFn(success);
                setTimeout(() => {
                    // EVENT: ON_SUCCESS
                    initiateCallback(VARIABLE_CONSTANTS.EVENT.SUCCESS, variable, _.get(config, 'userInfo'));
                    /* handle navigation if defaultSuccessHandler on variable is true */
                    if (variable.useDefaultSuccessHandler) {
                        const isSameUserReloggedIn = lastLoggedInUsername === params['j_username'];
                        // if first time user logging in or same user re-logging in, execute n/w calls failed before logging in
                        if (!lastLoggedInUsername || isSameUserReloggedIn) {
                            appManager.executeSessionFailureRequests();
                        }
                        // get redirectTo page from URL and remove it from URL
                        const redirectPage = securityService.getCurrentRouteQueryParam('redirectTo'), noRedirect = appManager.noRedirect();
                        // Get query params(page params of page being redirected to) and append to the URL after login.
                        const queryParamsObj = securityService.getRedirectedRouteQueryParams();
                        // The redirectTo param isn't required after login
                        if (queryParamsObj.redirectTo) {
                            delete queryParamsObj.redirectTo;
                        }
                        appManager.noRedirect(false);
                        // first time login
                        if (!lastLoggedInUsername) {
                            // if redirect page found, navigate to it.
                            if (!_.isEmpty(redirectPage)) {
                                routerService.navigate([`/${redirectPage}`], { queryParams: queryParamsObj });
                            }
                            else if (!noRedirect) {
                                // simply reset the URL, route handling will take care of page redirection
                                routerService.navigate([`/`]);
                            }
                        }
                        else {
                            // login after a session timeout
                            // if redirect page found and same user logs in again, just navigate to redirect page
                            if (!_.isEmpty(redirectPage)) {
                                // same user logs in again, just redirect to the redirectPage
                                if (lastLoggedInUsername === params['j_username']) {
                                    routerService.navigate([`/${redirectPage}`], { queryParams: queryParamsObj });
                                }
                                else {
                                    // different user logs in, reload the app and discard the redirectPage
                                    routerService.navigate([`/`]);
                                    window.location.reload();
                                }
                            }
                            else {
                                const securityConfig = securityService.get(), sessionTimeoutLoginMode = _.get(securityConfig, 'loginConfig.sessionTimeout.type') || 'PAGE';
                                // if in dialog mode and a new user logs in OR login happening through page, reload the app
                                if (!isSameUserReloggedIn || sessionTimeoutLoginMode !== 'DIALOG') {
                                    routerService.navigate([`/`]);
                                    window.location.reload();
                                }
                            }
                        }
                    }
                    // EVENT: ON_CAN_UPDATE
                    initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, _.get(config, 'userInfo'));
                });
            });
        }, (e) => {
            // EVENT: ON_RESULT
            initiateCallback(VARIABLE_CONSTANTS.EVENT.RESULT, variable, e);
            this.notifyInflight(variable, false, e);
            const errorMsg = e.error || 'Invalid credentials.';
            const xhrObj = e.details;
            /* if in RUN mode, trigger error events associated with the variable */
            if (CONSTANTS.isRunMode) {
                initiateCallback('onError', variable, errorMsg, xhrObj, true);
            }
            triggerFn(error, errorMsg, xhrObj);
            // EVENT: ON_CAN_UPDATE
            initiateCallback(VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, e);
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9naW4tYWN0aW9uLm1hbmFnZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ad20vdmFyaWFibGVzLyIsInNvdXJjZXMiOlsibWFuYWdlci9hY3Rpb24vbG9naW4tYWN0aW9uLm1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFFdEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQ3BGLE9BQU8sRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUlsSSxNQUFNLE9BQU8sa0JBQW1CLFNBQVEsaUJBQWlCO0lBRTdDLFFBQVEsQ0FBQyxNQUFXO1FBQ3hCLElBQUksR0FBRyxFQUFFLFFBQVEsRUFBRSxhQUFhLENBQUM7UUFDakMsTUFBTSx1QkFBdUIsR0FBRyxjQUFjLENBQUM7UUFDL0MsTUFBTSwyQkFBMkIsR0FBRyxDQUFDLFlBQVksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBRXRFLHFCQUFxQjtRQUNyQiwyQkFBMkIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUM1QyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7Z0JBQzlCLGFBQWEsR0FBRyxPQUFPLENBQUM7YUFDM0I7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILGFBQWEsR0FBSSxhQUFhLElBQUksdUJBQXVCLENBQUM7UUFFMUQsb0JBQW9CO1FBQ3BCLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENB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QUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ2pFO1lBQ0QsU0FBUyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDbkMsdUJBQXVCO1lBQ3ZCLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0Q2xvbmVkT2JqZWN0LCB0cmlnZ2VyRm4gfSBmcm9tICdAd20vY29yZSc7XG5cbmltcG9ydCB7IEJhc2VBY3Rpb25NYW5hZ2VyIH0gZnJvbSAnLi9iYXNlLWFjdGlvbi5tYW5hZ2VyJztcbmltcG9ydCB7IENPTlNUQU5UUywgVkFSSUFCTEVfQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3ZhcmlhYmxlcy5jb25zdGFudHMnO1xuaW1wb3J0IHsgYXBwTWFuYWdlciwgZGlhbG9nU2VydmljZSwgaW5pdGlhdGVDYWxsYmFjaywgcm91dGVyU2VydmljZSwgc2VjdXJpdHlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbC92YXJpYWJsZS92YXJpYWJsZXMudXRpbHMnO1xuXG5kZWNsYXJlIGNvbnN0IF87XG5cbmV4cG9ydCBjbGFzcyBMb2dpbkFjdGlvbk1hbmFnZXIgZXh0ZW5kcyBCYXNlQWN0aW9uTWFuYWdlciB7XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlKHBhcmFtczogYW55KSB7XG4gICAgICAgIGxldCBlcnIsIHBhcmFtS2V5LCByZW1lbWJlcm1lS2V5O1xuICAgICAgICBjb25zdCBMT0dJTl9QQVJBTV9SRU1FTUJFUl9NRSA9ICdqX3JlbWVtYmVybWUnO1xuICAgICAgICBjb25zdCBMT0dJTl9QQVJBTV9SRU1FTUJFUl9NRV9PTEQgPSBbJ3JlbWVtYmVybWUnLCAncmVtZW1iZXJtZWNoZWNrJ107XG5cbiAgICAgICAgLy8gZm9yIG9sZGVyIHByb2plY3RzXG4gICAgICAgIExPR0lOX1BBUkFNX1JFTUVNQkVSX01FX09MRC5mb3JFYWNoKChvbGRfa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoXy5pc0Jvb2xlYW4ocGFyYW1zW29sZF9rZXldKSkge1xuICAgICAgICAgICAgICAgIHJlbWVtYmVybWVLZXkgPSBvbGRfa2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZW1lbWJlcm1lS2V5ID0gIHJlbWVtYmVybWVLZXkgfHwgTE9HSU5fUEFSQU1fUkVNRU1CRVJfTUU7XG5cbiAgICAgICAgLy8gY2hlY2sgcmVtZW1iZXIgbWVcbiAgICAgICAgcGFyYW1zW3JlbWVtYmVybWVLZXldID0gXy5pc0Jvb2xlYW4ocGFyYW1zW3JlbWVtYmVybWVLZXldKSA/IHBhcmFtc1tyZW1lbWJlcm1lS2V5XSA6IGZhbHNlO1xuXG4gICAgICAgIGZvciAocGFyYW1LZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtS2V5KSAmJlxuICAgICAgICAgICAgICAgIChwYXJhbXNbcGFyYW1LZXldID09PSAnJyB8fCBwYXJhbXNbcGFyYW1LZXldID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gJ1BsZWFzZSBwcm92aWRlIHJlcXVpcmVkIGNyZWRlbnRpYWxzJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtaWdyYXRlT2xkUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBjb25zdCBsb2dpblBhcmFtcyA9IHt9LFxuICAgICAgICAgICAgcGFyYW1NaWdyYXRpb25NYXAgPSB7XG4gICAgICAgICAgICAndXNlcm5hbWV0ZXh0JzogJ2pfdXNlcm5hbWUnLFxuICAgICAgICAgICAgJ3VzZXJuYW1lJzogJ2pfdXNlcm5hbWUnLFxuICAgICAgICAgICAgJ3Bhc3N3b3JkdGV4dCc6ICdqX3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICdwYXNzd29yZCc6ICdqX3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICdyZW1lbWJlcm1lY2hlY2snOiAnal9yZW1lbWJlcm1lJyxcbiAgICAgICAgICAgICdyZW1lbWJlcm1lJzogJ2pfcmVtZW1iZXJtZSdcbiAgICAgICAgfTtcblxuICAgICAgICBfLmVhY2gocGFyYW1zLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAocGFyYW1NaWdyYXRpb25NYXBba2V5XSkge1xuICAgICAgICAgICAgICAgIGxvZ2luUGFyYW1zW3BhcmFtTWlncmF0aW9uTWFwW2tleV1dID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2luUGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsb2dpblBhcmFtcztcbiAgICB9XG5cbiAgICBsb2dpbih2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgbGV0IG5ld0RhdGFTZXQ7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIElmIGxvZ2luIGluZm8gcHJvdmlkZWQgYWxvbmcgZXhwbGljaXRseSB3aXRoIG9wdGlvbnMsIGRvbid0IGxvb2sgaW50byB0aGUgdmFyaWFibGUgYmluZGluZ3MgZm9yIHRoZSBzYW1lXG4gICAgICAgIGNvbnN0IGxvZ2luSW5mbzogYW55ID0gb3B0aW9ucy5sb2dpbkluZm8gfHwgb3B0aW9ucy5pbnB1dCB8fCB2YXJpYWJsZS5kYXRhQmluZGluZztcblxuICAgICAgICAvLyBjbGllbnQgc2lkZSB2YWxpZGF0aW9uXG4gICAgICAgIGNvbnN0IGVyck1zZyA9IHRoaXMudmFsaWRhdGUobG9naW5JbmZvKTtcblxuICAgICAgICAvKiBpZiBlcnJvciBtZXNzYWdlIGluaXRpYWxpemVkLCByZXR1cm4gZXJyb3IgKi9cbiAgICAgICAgaWYgKGVyck1zZykge1xuICAgICAgICAgICAgdHJpZ2dlckZuKGVycm9yLCBlcnJNc2cpO1xuICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjaygnb25FcnJvcicsIHZhcmlhYmxlLCBlcnJNc2cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpZ2dlcmluZyAnb25CZWZvcmVVcGRhdGUnIGFuZCBjb25zaWRlcmluZ1xuICAgICAgICBsZXQgcGFyYW1zOiBhbnkgPSBnZXRDbG9uZWRPYmplY3QobG9naW5JbmZvKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0OiBhbnkgPSBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5CRUZPUkVfVVBEQVRFLCB2YXJpYWJsZSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3Qob3V0cHV0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gb3V0cHV0O1xuICAgICAgICB9IGVsc2UgaWYgKG91dHB1dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaWdyYXRlIG9sZCBwYXJhbXMgdG8gbmV3XG4gICAgICAgIHBhcmFtcyA9IHRoaXMubWlncmF0ZU9sZFBhcmFtcyhwYXJhbXMpO1xuXG4gICAgICAgIC8vIGdldCBwcmV2aW91c2x5IGxvZ2dlZEluVXNlciBuYW1lIChpZiBhbnkpXG4gICAgICAgIGNvbnN0IGxhc3RMb2dnZWRJblVzZXJuYW1lID0gXy5nZXQoc2VjdXJpdHlTZXJ2aWNlLmdldCgpLCAndXNlckluZm8udXNlck5hbWUnKTtcblxuICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCB0cnVlKTtcbiAgICAgICAgdmFyaWFibGUucHJvbWlzZSA9IHNlY3VyaXR5U2VydmljZS5hcHBMb2dpbihwYXJhbXMsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gQ2xvc2luZyBsb2dpbiBkaWFsb2cgYWZ0ZXIgc3VjY2Vzc2Z1bCBsb2dpblxuICAgICAgICAgICAgZGlhbG9nU2VydmljZS5jbG9zZSgnQ29tbW9uTG9naW5EaWFsb2cnKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldCBmcmVzaCBzZWN1cml0eSBjb25maWdcbiAgICAgICAgICAgICAqIEdldCBBcHAgdmFyaWFibGVzLiBpZiBub3QgbG9hZGVkXG4gICAgICAgICAgICAgKiBVcGRhdGUgbG9nZ2VkSW5Vc2VyIHZhcmlhYmxlIHdpdGggbmV3IHVzZXIgZGV0YWlsc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhcHBNYW5hZ2VyLnJlbG9hZEFwcERhdGEoKS5cbiAgICAgICAgICAgIHRoZW4oKGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEVWRU5UOiBPTl9SRVNVTFRcbiAgICAgICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5SRVNVTFQsIHZhcmlhYmxlLCBfLmdldChjb25maWcsICd1c2VySW5mbycpKTtcbiAgICAgICAgICAgICAgICAvLyBFVkVOVDogT05fUFJFUEFSRVNFVERBVEFcbiAgICAgICAgICAgICAgICBuZXdEYXRhU2V0ID0gaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuUFJFUEFSRV9TRVREQVRBLCB2YXJpYWJsZSwgXy5nZXQoY29uZmlnLCAndXNlckluZm8nKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGFTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgbmV3RGF0YVNldCBhcyB0aGUgcmVzcG9uc2UgdG8gc2VydmljZSB2YXJpYWJsZSBvblByZXBhcmVTZXREYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnNldChjb25maWcsICd1c2VySW5mbycsbmV3RGF0YVNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGhpZGUgdGhlIHNwaW5uZXIgYWZ0ZXIgYWxsIHRoZSBuL3cgY2FsbHMgYXJlIGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5SW5mbGlnaHQodmFyaWFibGUsIGZhbHNlLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckZuKHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gRVZFTlQ6IE9OX1NVQ0NFU1NcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuU1VDQ0VTUywgdmFyaWFibGUsIF8uZ2V0KGNvbmZpZywgJ3VzZXJJbmZvJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIGhhbmRsZSBuYXZpZ2F0aW9uIGlmIGRlZmF1bHRTdWNjZXNzSGFuZGxlciBvbiB2YXJpYWJsZSBpcyB0cnVlICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS51c2VEZWZhdWx0U3VjY2Vzc0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU2FtZVVzZXJSZWxvZ2dlZEluID0gbGFzdExvZ2dlZEluVXNlcm5hbWUgPT09IHBhcmFtc1snal91c2VybmFtZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmlyc3QgdGltZSB1c2VyIGxvZ2dpbmcgaW4gb3Igc2FtZSB1c2VyIHJlLWxvZ2dpbmcgaW4sIGV4ZWN1dGUgbi93IGNhbGxzIGZhaWxlZCBiZWZvcmUgbG9nZ2luZyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXN0TG9nZ2VkSW5Vc2VybmFtZSB8fCBpc1NhbWVVc2VyUmVsb2dnZWRJbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcE1hbmFnZXIuZXhlY3V0ZVNlc3Npb25GYWlsdXJlUmVxdWVzdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCByZWRpcmVjdFRvIHBhZ2UgZnJvbSBVUkwgYW5kIHJlbW92ZSBpdCBmcm9tIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RQYWdlID0gc2VjdXJpdHlTZXJ2aWNlLmdldEN1cnJlbnRSb3V0ZVF1ZXJ5UGFyYW0oJ3JlZGlyZWN0VG8nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub1JlZGlyZWN0ID0gYXBwTWFuYWdlci5ub1JlZGlyZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgcXVlcnkgcGFyYW1zKHBhZ2UgcGFyYW1zIG9mIHBhZ2UgYmVpbmcgcmVkaXJlY3RlZCB0bykgYW5kIGFwcGVuZCB0byB0aGUgVVJMIGFmdGVyIGxvZ2luLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbXNPYmogPSBzZWN1cml0eVNlcnZpY2UuZ2V0UmVkaXJlY3RlZFJvdXRlUXVlcnlQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWRpcmVjdFRvIHBhcmFtIGlzbid0IHJlcXVpcmVkIGFmdGVyIGxvZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlQYXJhbXNPYmoucmVkaXJlY3RUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVBhcmFtc09iai5yZWRpcmVjdFRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTWFuYWdlci5ub1JlZGlyZWN0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgbG9naW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFzdExvZ2dlZEluVXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiByZWRpcmVjdCBwYWdlIGZvdW5kLCBuYXZpZ2F0ZSB0byBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShyZWRpcmVjdFBhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlclNlcnZpY2UubmF2aWdhdGUoW2AvJHtyZWRpcmVjdFBhZ2V9YF0sIHsgcXVlcnlQYXJhbXMgOiBxdWVyeVBhcmFtc09ian0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5vUmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGx5IHJlc2V0IHRoZSBVUkwsIHJvdXRlIGhhbmRsaW5nIHdpbGwgdGFrZSBjYXJlIG9mIHBhZ2UgcmVkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyU2VydmljZS5uYXZpZ2F0ZShbYC9gXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZ2luIGFmdGVyIGEgc2Vzc2lvbiB0aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgcmVkaXJlY3QgcGFnZSBmb3VuZCBhbmQgc2FtZSB1c2VyIGxvZ3MgaW4gYWdhaW4sIGp1c3QgbmF2aWdhdGUgdG8gcmVkaXJlY3QgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghXy5pc0VtcHR5KHJlZGlyZWN0UGFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSB1c2VyIGxvZ3MgaW4gYWdhaW4sIGp1c3QgcmVkaXJlY3QgdG8gdGhlIHJlZGlyZWN0UGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdExvZ2dlZEluVXNlcm5hbWUgPT09IHBhcmFtc1snal91c2VybmFtZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXJTZXJ2aWNlLm5hdmlnYXRlKFtgLyR7cmVkaXJlY3RQYWdlfWBdLCB7IHF1ZXJ5UGFyYW1zIDogcXVlcnlQYXJhbXNPYmp9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCB1c2VyIGxvZ3MgaW4sIHJlbG9hZCB0aGUgYXBwIGFuZCBkaXNjYXJkIHRoZSByZWRpcmVjdFBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlclNlcnZpY2UubmF2aWdhdGUoW2AvYF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VjdXJpdHlDb25maWcgPSBzZWN1cml0eVNlcnZpY2UuZ2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uVGltZW91dExvZ2luTW9kZSA9IF8uZ2V0KHNlY3VyaXR5Q29uZmlnLCAnbG9naW5Db25maWcuc2Vzc2lvblRpbWVvdXQudHlwZScpIHx8ICdQQUdFJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaW4gZGlhbG9nIG1vZGUgYW5kIGEgbmV3IHVzZXIgbG9ncyBpbiBPUiBsb2dpbiBoYXBwZW5pbmcgdGhyb3VnaCBwYWdlLCByZWxvYWQgdGhlIGFwcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZVVzZXJSZWxvZ2dlZEluIHx8IHNlc3Npb25UaW1lb3V0TG9naW5Nb2RlICE9PSAnRElBTE9HJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyU2VydmljZS5uYXZpZ2F0ZShbYC9gXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFVkVOVDogT05fQ0FOX1VQREFURVxuICAgICAgICAgICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5DQU5fVVBEQVRFLCB2YXJpYWJsZSwgXy5nZXQoY29uZmlnLCAndXNlckluZm8nKSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gRVZFTlQ6IE9OX1JFU1VMVFxuICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuUkVTVUxULCB2YXJpYWJsZSwgZSk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCBmYWxzZSwgZSk7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9IGUuZXJyb3IgfHwgJ0ludmFsaWQgY3JlZGVudGlhbHMuJztcbiAgICAgICAgICAgIGNvbnN0IHhock9iaiA9IGUuZGV0YWlscztcbiAgICAgICAgICAgIC8qIGlmIGluIFJVTiBtb2RlLCB0cmlnZ2VyIGVycm9yIGV2ZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHZhcmlhYmxlICovXG4gICAgICAgICAgICBpZiAoQ09OU1RBTlRTLmlzUnVuTW9kZSkge1xuICAgICAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soJ29uRXJyb3InLCB2YXJpYWJsZSwgZXJyb3JNc2csIHhock9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRm4oZXJyb3IsIGVycm9yTXNnLCB4aHJPYmopO1xuICAgICAgICAgICAgLy8gRVZFTlQ6IE9OX0NBTl9VUERBVEVcbiAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULkNBTl9VUERBVEUsIHZhcmlhYmxlLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19