import { DataSource } from '@wm/core';
import { LocalDataProvider } from './local-data-provider';
import { RemoteDataProvider } from './remote-data-provider';
var DataProvider = /** @class */ (function () {
    function DataProvider() {
    }
    DataProvider.prototype.filter = function (config) {
        var _this = this;
        var promise;
        /**
         * Make call to remoteDataProvider when searchkey is available and data is not from local / model variable.
         * Otherwise use localDataProvider
         * If datasource is a serviceVariable with no input params, then perform local search.
         * when there is no dataset on the datasource when first time make a remote call to set the dataset for service variable.
         */
        var hasNoVariableDataset = config.datasource && config.datasource.execute(DataSource.Operation.IS_UPDATE_REQUIRED, config.hasData);
        if (!config.isLocalFilter && (config.dataoptions || ((config.datasource && config.datasource.execute(DataSource.Operation.IS_API_AWARE))
            && config.searchKey
            && hasNoVariableDataset))) {
            promise = DataProvider.remoteDataProvider.filter(config);
        }
        else {
            promise = DataProvider.localDataProvider.filter(config);
        }
        return promise.then(function (response) {
            _this.updateDataset = config.datasource && !config.datasource.execute(DataSource.Operation.SUPPORTS_CRUD) && hasNoVariableDataset;
            _this.hasMoreData = response.hasMoreData;
            _this.isLastPage = response.isLastPage;
            _this.page = response.page;
            _this.isPaginatedData = response.isPaginatedData;
            return response;
        });
    };
    DataProvider.remoteDataProvider = new RemoteDataProvider();
    DataProvider.localDataProvider = new LocalDataProvider();
    return DataProvider;
}());
export { DataProvider };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B3bS9jb21wb25lbnRzLyIsInNvdXJjZXMiOlsid2lkZ2V0cy9jb21tb24vc2VhcmNoL2RhdGEtcHJvdmlkZXIvZGF0YS1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRXRDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzFELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBcUM1RDtJQUFBO0lBd0NBLENBQUM7SUE3QlUsNkJBQU0sR0FBYixVQUFjLE1BQTJCO1FBQXpDLGlCQTRCQztRQTFCRyxJQUFJLE9BQXFCLENBQUM7UUFFMUI7Ozs7O1dBS0c7UUFDSCxJQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxVQUFVLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDckksSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7ZUFDakksTUFBTSxDQUFDLFNBQVM7ZUFDaEIsb0JBQW9CLENBQUMsQ0FBQyxFQUFFO1lBQzNCLE9BQU8sR0FBRyxZQUFZLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzVEO2FBQU07WUFDSCxPQUFPLEdBQUcsWUFBWSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMzRDtRQUVELE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFBLFFBQVE7WUFDeEIsS0FBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsVUFBVSxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsSUFBSSxvQkFBb0IsQ0FBQztZQUNqSSxLQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7WUFDeEMsS0FBSSxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDO1lBQ3RDLEtBQUksQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQztZQUMxQixLQUFJLENBQUMsZUFBZSxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUM7WUFFaEQsT0FBTyxRQUFRLENBQUM7UUFDcEIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBL0JNLCtCQUFrQixHQUFHLElBQUksa0JBQWtCLEVBQUUsQ0FBQztJQUM5Qyw4QkFBaUIsR0FBRyxJQUFJLGlCQUFpQixFQUFFLENBQUM7SUErQnZELG1CQUFDO0NBQUEsQUF4Q0QsSUF3Q0M7U0F4Q1ksWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFTb3VyY2UgfSBmcm9tICdAd20vY29yZSc7XG5cbmltcG9ydCB7IExvY2FsRGF0YVByb3ZpZGVyIH0gZnJvbSAnLi9sb2NhbC1kYXRhLXByb3ZpZGVyJztcbmltcG9ydCB7IFJlbW90ZURhdGFQcm92aWRlciB9IGZyb20gJy4vcmVtb3RlLWRhdGEtcHJvdmlkZXInO1xuXG5kZWNsYXJlIGNvbnN0IF87XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURhdGFQcm92aWRlckNvbmZpZyB7XG4gICAgZGF0YW9wdGlvbnM/OiBhbnk7XG4gICAgdmlld1BhcmVudD86IGFueTtcbiAgICBkYXRhc2V0OiBhbnk7XG4gICAgZGF0YWZpZWxkOiBzdHJpbmc7XG4gICAgYmluZGRhdGFzZXQ/OiBzdHJpbmc7XG4gICAgZGF0YXNvdXJjZT86IGFueTtcbiAgICBoYXNEYXRhOiBib29sZWFuO1xuICAgIHF1ZXJ5OiBBcnJheTxzdHJpbmc+IHwgc3RyaW5nO1xuICAgIGlzTG9jYWxGaWx0ZXI6IGJvb2xlYW47XG4gICAgc2VhcmNoS2V5Pzogc3RyaW5nO1xuICAgIG1hdGNoTW9kZT86IHN0cmluZztcbiAgICBjYXNlc2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgICBpc2Zvcm1maWVsZD86IGJvb2xlYW47XG4gICAgb3JkZXJieT86IHN0cmluZztcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICBwYWdlc2l6ZT86IG51bWJlcjtcbiAgICBwYWdlOiBudW1iZXI7XG4gICAgbm9Nb3JlZGF0YT86IGJvb2xlYW47XG4gICAgb25CZWZvcmVzZXJ2aWNlY2FsbD86IEZ1bmN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEYXRhUHJvdmlkZXIge1xuICAgIGhhc01vcmVEYXRhPzogYm9vbGVhbjtcbiAgICBpc0xhc3RQYWdlPzogYm9vbGVhbjtcbiAgICBoYXNOb01vcmVEYXRhPzogYm9vbGVhbjtcbiAgICBpc1BhZ2luYXRlZERhdGE/OiBib29sZWFuO1xuICAgIHBhZ2U/OiBudW1iZXI7XG4gICAgdXBkYXRlRGF0YXNldD86IGJvb2xlYW47XG5cbiAgICBmaWx0ZXIoY29uZmlnOiBJRGF0YVByb3ZpZGVyQ29uZmlnKTogUHJvbWlzZTxhbnk+O1xufVxuXG5leHBvcnQgY2xhc3MgRGF0YVByb3ZpZGVyIGltcGxlbWVudHMgSURhdGFQcm92aWRlciB7XG5cbiAgICBwdWJsaWMgaGFzTW9yZURhdGE6IGJvb2xlYW47XG4gICAgcHVibGljIGlzTGFzdFBhZ2U6IGJvb2xlYW47XG4gICAgcHVibGljIHBhZ2U6IG51bWJlcjtcbiAgICBwdWJsaWMgaXNQYWdpbmF0ZWREYXRhOiBib29sZWFuO1xuICAgIHB1YmxpYyB1cGRhdGVEYXRhc2V0OiBib29sZWFuO1xuXG4gICAgc3RhdGljIHJlbW90ZURhdGFQcm92aWRlciA9IG5ldyBSZW1vdGVEYXRhUHJvdmlkZXIoKTtcbiAgICBzdGF0aWMgbG9jYWxEYXRhUHJvdmlkZXIgPSBuZXcgTG9jYWxEYXRhUHJvdmlkZXIoKTtcblxuICAgIHB1YmxpYyBmaWx0ZXIoY29uZmlnOiBJRGF0YVByb3ZpZGVyQ29uZmlnKTogUHJvbWlzZTxhbnk+IHtcblxuICAgICAgICBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIGNhbGwgdG8gcmVtb3RlRGF0YVByb3ZpZGVyIHdoZW4gc2VhcmNoa2V5IGlzIGF2YWlsYWJsZSBhbmQgZGF0YSBpcyBub3QgZnJvbSBsb2NhbCAvIG1vZGVsIHZhcmlhYmxlLlxuICAgICAgICAgKiBPdGhlcndpc2UgdXNlIGxvY2FsRGF0YVByb3ZpZGVyXG4gICAgICAgICAqIElmIGRhdGFzb3VyY2UgaXMgYSBzZXJ2aWNlVmFyaWFibGUgd2l0aCBubyBpbnB1dCBwYXJhbXMsIHRoZW4gcGVyZm9ybSBsb2NhbCBzZWFyY2guXG4gICAgICAgICAqIHdoZW4gdGhlcmUgaXMgbm8gZGF0YXNldCBvbiB0aGUgZGF0YXNvdXJjZSB3aGVuIGZpcnN0IHRpbWUgbWFrZSBhIHJlbW90ZSBjYWxsIHRvIHNldCB0aGUgZGF0YXNldCBmb3Igc2VydmljZSB2YXJpYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhhc05vVmFyaWFibGVEYXRhc2V0ID0gY29uZmlnLmRhdGFzb3VyY2UgJiYgY29uZmlnLmRhdGFzb3VyY2UuZXhlY3V0ZShEYXRhU291cmNlLk9wZXJhdGlvbi5JU19VUERBVEVfUkVRVUlSRUQsIGNvbmZpZy5oYXNEYXRhKTtcbiAgICAgICAgaWYgKCFjb25maWcuaXNMb2NhbEZpbHRlciAmJiAoY29uZmlnLmRhdGFvcHRpb25zIHx8ICgoY29uZmlnLmRhdGFzb3VyY2UgJiYgY29uZmlnLmRhdGFzb3VyY2UuZXhlY3V0ZShEYXRhU291cmNlLk9wZXJhdGlvbi5JU19BUElfQVdBUkUpKVxuICAgICAgICAgICAgJiYgY29uZmlnLnNlYXJjaEtleVxuICAgICAgICAgICAgJiYgaGFzTm9WYXJpYWJsZURhdGFzZXQpKSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IERhdGFQcm92aWRlci5yZW1vdGVEYXRhUHJvdmlkZXIuZmlsdGVyKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gRGF0YVByb3ZpZGVyLmxvY2FsRGF0YVByb3ZpZGVyLmZpbHRlcihjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURhdGFzZXQgPSBjb25maWcuZGF0YXNvdXJjZSAmJiAhY29uZmlnLmRhdGFzb3VyY2UuZXhlY3V0ZShEYXRhU291cmNlLk9wZXJhdGlvbi5TVVBQT1JUU19DUlVEKSAmJiBoYXNOb1ZhcmlhYmxlRGF0YXNldDtcbiAgICAgICAgICAgIHRoaXMuaGFzTW9yZURhdGEgPSByZXNwb25zZS5oYXNNb3JlRGF0YTtcbiAgICAgICAgICAgIHRoaXMuaXNMYXN0UGFnZSA9IHJlc3BvbnNlLmlzTGFzdFBhZ2U7XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSByZXNwb25zZS5wYWdlO1xuICAgICAgICAgICAgdGhpcy5pc1BhZ2luYXRlZERhdGEgPSByZXNwb25zZS5pc1BhZ2luYXRlZERhdGE7XG5cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19