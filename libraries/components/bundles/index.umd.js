(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('ngx-bootstrap/pagination'), require('ngx-color-picker'), require('angular2-text-mask'), require('ng-circle-progress'), require('@wm/security'), require('@angular/router'), require('rxjs/operators'), require('@angular/common'), require('@swipey'), require('@angular/platform-browser'), require('ngx-bootstrap'), require('@angular/forms'), require('rxjs'), require('@wm/core'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@wm/components', ['exports', 'ngx-bootstrap/pagination', 'ngx-color-picker', 'angular2-text-mask', 'ng-circle-progress', '@wm/security', '@angular/router', 'rxjs/operators', '@angular/common', '@swipey', '@angular/platform-browser', 'ngx-bootstrap', '@angular/forms', 'rxjs', '@wm/core', '@angular/core'], factory) :
    (factory((global.wm = global.wm || {}, global.wm.components = {}),global.ngxBootstrap,global.zef.ngxColorPicker,global.angular2TextMask,global.ngCircleProgress,global.wm.security,global.ng.router,global.rxjs.operators,global.ng.common,global.swipey,global.ng.platformBrowser,global.ngxBootstrap,global.ng.forms,global.rxjs,global.wm.core,global.ng.core));
}(this, (function (exports,pagination,ngxColorPicker,angular2TextMask,ngCircleProgress,security,router,operators,common,_swipey,platformBrowser,ngxBootstrap,forms,rxjs,core,core$1) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [0, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var TabsAnimator = /** @class */ (function (_super) {
        __extends(TabsAnimator, _super);
        function TabsAnimator(tabs) {
            var e_1, _a;
            var _this = _super.call(this) || this;
            _this.tabs = tabs;
            _this._$el = $(_this.tabs.getNativeElement()).find('>.tab-content');
            var childEls = _this._$el.find('>[wmTabPane]');
            _this._noOfTabs = childEls.length;
            var maxWidth = _this._noOfTabs * 100 + "%";
            core.addClass(_this.tabs.getNativeElement(), 'has-transition');
            core.setCSSFromObj(_this._$el[0], { maxWidth: maxWidth, width: maxWidth });
            var width = 100 / _this._noOfTabs + "%";
            try {
                for (var _b = __values(Array.from(childEls)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    core.setCSS(child, 'width', width);
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
            _this.init(_this._$el);
            return _this;
        }
        TabsAnimator.prototype.bounds = function () {
            var activeTabIndex = this.tabs.getActiveTabIndex(), w = this._$el.find('>.tab-pane:first').width(), noOfTabs = this._$el.find('>.tab-pane:visible').length, centerVal = -1 * activeTabIndex * w;
            return {
                strict: false,
                lower: activeTabIndex === noOfTabs - 1 ? 0 : -w,
                center: centerVal,
                upper: activeTabIndex === 0 ? centerVal : w
            };
        };
        TabsAnimator.prototype.context = function () {
            return {
                'w': this._$el.width()
            };
        };
        TabsAnimator.prototype.animation = function () {
            return {
                'transform': 'translate3d(${{ ($D + $d)/w * 100 + \'%\'}}, 0, 0)',
                '-webkit-transform': 'translate3d(${{ ($D + $d)/w * 100 + \'%\'}}, 0, 0)'
            };
        };
        TabsAnimator.prototype.transitionTabIntoView = function () {
            var activeTabIndex = this.tabs.getActiveTabIndex();
            core.setCSS(this._$el[0], 'transform', "translate3d(" + -1 * activeTabIndex / this._noOfTabs * 100 + "%, 0, 0)");
        };
        TabsAnimator.prototype.onUpper = function () {
            this.tabs.prev();
            core.$appDigest();
        };
        TabsAnimator.prototype.onLower = function () {
            this.tabs.next();
            core.$appDigest();
        };
        TabsAnimator.prototype.threshold = function () {
            return 5;
        };
        return TabsAnimator;
    }(_swipey.SwipeAnimation));

    var WidgetRef = /** @class */ (function () {
        function WidgetRef() {
        }
        return WidgetRef;
    }());
    var DialogRef = /** @class */ (function () {
        function DialogRef() {
        }
        return DialogRef;
    }());
    var Context = new core$1.InjectionToken('Context Provider Reference');

    var DATASET_WIDGETS = new Set([core.FormWidgetType.SELECT, core.FormWidgetType.CHECKBOXSET, core.FormWidgetType.RADIOSET,
        core.FormWidgetType.SWITCH, core.FormWidgetType.AUTOCOMPLETE, core.FormWidgetType.CHIPS, core.FormWidgetType.TYPEAHEAD, core.FormWidgetType.RATING]);
    /**
     * Returns the parsed, updated bound expression
     * if the expression is $[data[$i][firstName]] + '--' + $[lastName] + '--' + $['@ID@']
     * returns __1.firstName + '--' + lastName + '--' + __1['@ID@']
     */
    var getUpdatedExpr = function (expr) {
        var updated = '', ch, next, i, j, matchCh, matchCount, isQuotedStr, subStr, isQuotedStrEvaluated;
        expr = expr.replace(/\$\[data\[\$i\]/g, '$[__1');
        for (i = 0; i < expr.length; i++) {
            ch = expr[i];
            next = expr[i + 1];
            /**
             * if the expression starts with $[, check the next(ch) character,
             *    if ch is a quote(', ") change the expr to __[
             *    if ch is a whiteSpace, remove it
             *    else remove $[
             */
            if (ch === '$' && next === '[') {
                matchCount = 1;
                isQuotedStrEvaluated = false;
                isQuotedStr = false;
                for (j = i + 2; j < expr.length; j++) {
                    matchCh = expr[j];
                    if (matchCh === ' ') {
                        continue;
                    }
                    if (!isQuotedStrEvaluated) {
                        isQuotedStr = expr[j] === '"' || expr[j] === '\'';
                        isQuotedStrEvaluated = true;
                    }
                    if (matchCh === '[') {
                        matchCount++;
                    }
                    else if (matchCh === ']') {
                        matchCount--;
                    }
                    if (!matchCount) {
                        subStr = expr.substring(i + 2, j);
                        if (isQuotedStr) {
                            updated += '__1[' + subStr + ']';
                        }
                        else {
                            updated += subStr;
                        }
                        break;
                    }
                }
                i = j;
            }
            else {
                updated += ch;
            }
        }
        return updated;
    };
    var ɵ0 = getUpdatedExpr;
    /**
     * Returns the value for the provided key in the object
     */
    var getObjValueByKey = function (obj, strKey) {
        /* check for the key-string */
        if (strKey) {
            var val_1;
            /* convert indexes to properties, so as to work for even 'key1[0].child1'*/
            strKey.replace(/\[(\w+)\]/g, '.$1').split('.').forEach(function (key) {
                // If obj is null, then assign val to null.
                val_1 = (val_1 && val_1[key]) || (_.isNull(obj) ? obj : obj[key]);
            });
            return val_1;
        }
        return obj;
    };
    /**
     * returns the display field data for any dataset widgets
     * Based on the bind display expression or display expression or display name,
     * data is extracted and formatted from the passed option object
     * If there is field is specified, field value is obtained from the dataObj.
     * If expression is given, evaluates the expression value.
     * else check for bindExpression, extract the value from the dataObj
     */
    var getEvaluatedData = function (dataObj, options, context) {
        var expressionValue;
        var field = options.field, expr = options.expression, bindExpr = options.bindExpression;
        // if key is bound expression
        if (bindExpr) {
            // remove 'bind:' prefix from the boundExpressionName
            expressionValue = bindExpr.replace('bind:', '');
            // parse the expressionValue for replacing all the expressions with values in the object
            expressionValue = getUpdatedExpr(expressionValue);
        }
        else {
            expressionValue = expr ? expr : field;
        }
        // Handling field name with special charecters
        // Ex: field = "f name"
        if (!bindExpr && !expr) {
            return _.get(dataObj, field);
        }
        return core.$parseExpr(expressionValue)(context, Object.assign({}, dataObj, { __1: dataObj }));
    };
    var isActiveNavItem = function (link, routeName) {
        if (!link || !routeName) {
            return false;
        }
        routeName = routeName.indexOf('?') === -1 ? routeName : routeName.substring(0, routeName.indexOf('?'));
        link = link.indexOf('?') === -1 ? link : link.substring(0, link.indexOf('?'));
        var routeRegex = new RegExp('^(#\/|#)' + routeName + '$');
        return routeRegex.test(link);
    };
    /**
     * Returns the orderBy Expression based on the 'sort 'option in pageable object
     * returned by backend
     * @param pageableObj
     * @returns {string}
     */
    var getOrderByExpr = function (pageableObj) {
        pageableObj = pageableObj || [];
        var expressions = [], KEY_VAL_SEPARATOR = ' ', FIELD_SEPARATOR = ',';
        _.forEach(pageableObj, function (obj) {
            expressions.push(obj.property + KEY_VAL_SEPARATOR + obj.direction.toLowerCase());
        });
        return _.join(expressions, FIELD_SEPARATOR);
    };
    var isDataSetWidget = function (widget) {
        return DATASET_WIDGETS.has(widget);
    };
    /*This function returns the url to the image after checking the validity of url*/
    var getImageUrl = function (urlString, shouldEncode, defaultUrl) {
        /*In studio mode before setting picturesource, check if the studioController is loaded and new picturesource is in 'styles/images/' path or not.
         * When page is refreshed, loader.gif will be loaded first and it will be in 'style/images/'.
         * Prepend 'services/projects/' + $rootScope.project.id + '/web/resources/images/imagelists/'  if the image url is just image name in the project root,
         * and if the url pointing to resources/images/ then 'services/projects/' + $rootScope.project.id + '/web/'*/
        if (core.isValidWebURL(urlString)) {
            return urlString;
        }
        // If no value is provided for picturesource assign pictureplaceholder or default-image
        if (!urlString) {
            urlString = defaultUrl || 'resources/images/imagelists/default-image.png';
        }
        urlString = shouldEncode ? core.encodeUrl(urlString) : urlString;
        // if the resource to be loaded is inside a prefab
        if (core.stringStartsWith(urlString, 'services/prefabs')) {
            return urlString;
        }
        return urlString;
    };
    /*This method returns the url to the backgroundImage*/
    var getBackGroundImageUrl = function (urlString) {
        if (urlString === '' || urlString === 'none') {
            return urlString;
        }
        return 'url(' + getImageUrl(urlString) + ')';
    };
    function provideAs(reference, key, multi) {
        return {
            provide: key,
            useExisting: core$1.forwardRef(function () { return reference; }),
            multi: multi
        };
    }
    function provideAsNgValidators(reference) {
        return provideAs(reference, forms.NG_VALIDATORS, true);
    }
    function provideAsNgValueAccessor(reference) {
        return provideAs(reference, forms.NG_VALUE_ACCESSOR, true);
    }
    function provideAsWidgetRef(reference) {
        return provideAs(reference, WidgetRef);
    }
    function provideAsDialogRef(reference) {
        return provideAs(reference, DialogRef);
    }
    var NAVIGATION_TYPE = {
        ADVANCED: 'Advanced',
        BASIC: 'Basic',
        CLASSIC: 'Classic',
        INLINE: 'Inline',
        NONE: 'None',
        ONDEMAND: 'On-Demand',
        PAGER: 'Pager',
        SCROLL: 'Scroll'
    };
    var getWatchIdentifier = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args.join('_');
    };
    var typesMap = {
        number: ['number', 'integer', 'big_integer', 'short', 'float', 'big_decimal', 'double', 'long', 'byte'],
        string: ['string', 'text'],
        character: ['character'],
        date: ['date', 'time', 'timestamp', 'datetime']
    };
    var modes = {
        number: ['exact', 'notequals', 'lessthan', 'lessthanequal', 'greaterthan', 'greaterthanequal', 'null', 'isnotnull'],
        string: ['anywhereignorecase', 'anywhere', 'startignorecase', 'start', 'endignorecase', 'end', 'exactignorecase', 'exact', 'notequalsignorecase', 'notequals', 'null', 'isnotnull', 'empty', 'isnotempty', 'nullorempty'],
        character: ['exactignorecase', 'exact', 'notequalsignorecase', 'notequals', 'null', 'isnotnull', 'empty', 'isnotempty', 'nullorempty'],
        date: ['exact', 'lessthan', 'lessthanequal', 'greaterthan', 'greaterthanequal', 'null', 'notequals', 'isnotnull']
    };
    var matchModeTypesMap = {
        boolean: ['exact', 'null', 'isnotnull'],
        clob: [],
        blob: []
    };
    var getMatchModeTypesMap = function (multiMode) {
        if (multiMode) {
            modes.number.push('in', 'notin', 'between');
            modes.date.push('between');
            modes.string.push('in', 'notin');
            modes.character.push('in', 'notin');
        }
        _.forEach(typesMap, function (types, primType) {
            _.forEach(types, function (type) {
                matchModeTypesMap[type] = modes[primType];
            });
        });
        // this is used in filter criteria when the user types the column name manually and where we dont know the type of the column
        matchModeTypesMap['default'] = _.union(modes['number'], modes['string'], modes['character'], modes['date'], modes['date']);
        return matchModeTypesMap;
    };
    var getMatchModeMsgs = function (appLocale) {
        return {
            start: appLocale.LABEL_STARTS_WITH,
            startignorecase: appLocale.LABEL_STARTS_WITH_IGNORECASE,
            end: appLocale.LABEL_ENDS_WITH,
            endignorecase: appLocale.LABEL_ENDS_WITH_IGNORECASE,
            anywhere: appLocale.LABEL_CONTAINS,
            anywhereignorecase: appLocale.LABEL_CONTAINS_IGNORECASE,
            exact: appLocale.LABEL_IS_EQUAL_TO,
            exactignorecase: appLocale.LABEL_IS_EQUAL_TO_IGNORECASE,
            notequals: appLocale.LABEL_IS_NOT_EQUAL_TO,
            notequalsignorecase: appLocale.LABEL_IS_NOT_EQUAL_TO_IGNORECASE,
            lessthan: appLocale.LABEL_LESS_THAN,
            lessthanequal: appLocale.LABEL_LESS_THAN_OR_EQUALS_TO,
            greaterthan: appLocale.LABEL_GREATER_THAN,
            greaterthanequal: appLocale.LABEL_GREATER_THAN_OR_EQUALS_TO,
            null: appLocale.LABEL_IS_NULL,
            isnotnull: appLocale.LABEL_IS_NOT_NULL,
            empty: appLocale.LABEL_IS_EMPTY,
            isnotempty: appLocale.LABEL_IS_NOT_EMPTY,
            nullorempty: appLocale.LABEL_IS_NULL_OR_EMPTY,
            in: appLocale.LABEL_IN,
            notin: appLocale.LABEL_NOT_IN,
            between: appLocale.LABEL_BETWEEN
        };
    };
    // Returns array of classes that are evaluated true for given object or array
    var getClassesArray = function (classVal) {
        var classes = [];
        if (_.isArray(classVal)) {
            classVal.forEach(function (v) {
                classes = classes.concat(getClassesArray(v));
            });
            return classes;
        }
        if (_.isObject(classVal)) {
            _.forEach(classVal, function (val, key) {
                if (val) {
                    classes = classes.concat(key.split(' '));
                }
            });
            return classes;
        }
    };
    var ɵ1 = getClassesArray;
    var getConditionalClasses = function (nv, ov) {
        var toAdd;
        var toRemove;
        // if the conditional class property has already toAdd and toRemove arrays then take that otherwise build those arrays
        var classToAdd = nv.toAdd || nv;
        var classToRemove = nv.toRemove || ov;
        if (_.isObject(nv)) {
            toAdd = _.isArray(classToAdd) ? classToAdd : getClassesArray(classToAdd || []);
            toRemove = classToRemove ? (_.isArray(classToRemove) ? classToRemove : getClassesArray(classToRemove)) : [];
        }
        else {
            toAdd = classToAdd ? [classToAdd] : [];
            toRemove = classToRemove ? [classToRemove] : [];
        }
        return { toAdd: toAdd, toRemove: toRemove };
    };
    /*helper function for prepareFieldDefs*/
    var pushFieldDef = function (dataObject, columnDefObj, namePrefix, options) {
        /*loop over the fields in the dataObject to process them*/
        var modifiedTitle, relatedTable, relatedField, relatedInfo, fieldName, isRelated;
        if (!options) {
            options = {};
        }
        _.forEach(dataObject, function (value, title) {
            if (_.includes(title, '.')) {
                relatedInfo = _.split(title, '.');
                relatedTable = relatedInfo[0];
                relatedField = relatedInfo[1];
                isRelated = true;
            }
            if (options.noModifyTitle) {
                modifiedTitle = title;
            }
            else {
                if (_.isString(title)) {
                    modifiedTitle = core.prettifyLabel(title);
                    modifiedTitle = core.deHyphenate(modifiedTitle);
                    modifiedTitle = namePrefix ? core.initCaps(namePrefix) + ' ' + modifiedTitle : modifiedTitle;
                }
                else {
                    modifiedTitle = title;
                }
            }
            title = namePrefix ? namePrefix + '.' + title : title;
            if (isRelated) {
                // For related columns, shorten the title to last two words
                fieldName = _.split(modifiedTitle, ' ');
                fieldName = fieldName.length > 1 ? fieldName[fieldName.length - 2] + ' ' + fieldName[fieldName.length - 1] : fieldName[0];
            }
            else {
                fieldName = modifiedTitle;
            }
            var defObj = options.setBindingField ? { 'displayName': fieldName, 'field': title, 'relatedTable': relatedTable, 'relatedField': relatedField || modifiedTitle }
                : { 'displayName': fieldName, 'relatedTable': relatedTable, 'relatedField': relatedField || modifiedTitle };
            /*if field is a leaf node, push it in the columnDefs*/
            if (!_.isObject(value) || (_.isArray(value) && !value[0])) {
                /*if the column counter has reached upperBound return*/
                if (options.upperBound && options.columnCount === options.upperBound) {
                    return;
                }
                columnDefObj.terminals.push(defObj);
                /*increment the column counter*/
                options.columnCount += 1;
            }
            else {
                /*else field is an object, process it recursively*/
                /* if parent node to be included, include it */
                if (options.columnCount !== options.upperBound) {
                    columnDefObj.objects.push(defObj);
                }
                /* if field is an array node, process its first child */
                if (_.isArray(value) && value[0]) {
                    pushFieldDef(value[0], columnDefObj, title + '[0]', options);
                }
                else {
                    pushFieldDef(value, columnDefObj, title, options);
                }
            }
        });
    };
    var ɵ2 = pushFieldDef;
    var getMetaDataFromData = function (data) {
        var dataObject;
        if (_.isArray(data)) {
            if (_.isObject(data[0])) {
                dataObject = core.getClonedObject(data[0]);
                /*Loop over the object to find out any null values. If any null values are present in the first row, check and assign the values from other row.
                 * As column generation is dependent on data, for related fields if first row value is null, columns are not generated.
                 * To prevent this, check the data in other rows and generate the columns. New keys from others rows are also added*/
                _.forEach(data, function (row, index) {
                    if ((index + 1) >= 10) { // Limit the data search to first 10 records
                        return false;
                    }
                    _.assignWith(dataObject, row, function (objValue, srcValue) {
                        return (objValue === null || objValue === undefined) ? srcValue : objValue;
                    });
                });
            }
            else {
                dataObject = data[0];
            }
        }
        else {
            dataObject = data;
        }
        return dataObject;
    };
    var ɵ3 = getMetaDataFromData;
    var prepareFieldDefs = function (data, options) {
        var dataObject;
        var columnDef = {
            'objects': [],
            'terminals': []
        };
        /*if no data provided, initialize default column definitions*/
        if (!data) {
            data = [];
        }
        if (!options) {
            options = {};
        }
        options.setBindingField = true;
        options.columnCount = 0;
        dataObject = getMetaDataFromData(data);
        /*first of the many data objects from grid data*/
        pushFieldDef(dataObject, columnDef, '', options);
        if (!options || (options && !options.filter)) {
            return columnDef.terminals;
        }
        switch (options.filter) {
            case 'all':
                return columnDef;
            case 'objects':
                return columnDef.objects;
            case 'terminals':
                return columnDef.terminals;
        }
        return columnDef;
    };

    (function (APPLY_STYLES_TYPE) {
        APPLY_STYLES_TYPE[APPLY_STYLES_TYPE["CONTAINER"] = 0] = "CONTAINER";
        APPLY_STYLES_TYPE[APPLY_STYLES_TYPE["SCROLLABLE_CONTAINER"] = 1] = "SCROLLABLE_CONTAINER";
        APPLY_STYLES_TYPE[APPLY_STYLES_TYPE["INNER_SHELL"] = 2] = "INNER_SHELL";
        APPLY_STYLES_TYPE[APPLY_STYLES_TYPE["SHELL"] = 3] = "SHELL";
    })(exports.APPLY_STYLES_TYPE || (exports.APPLY_STYLES_TYPE = {}));
    var propNameCSSKeyMap = {
        'backgroundattachment': 'backgroundAttachment',
        'backgroundcolor': 'backgroundColor',
        'backgroundgradient': 'backgroundGradient',
        'backgroundimage': 'backgroundImage',
        'backgroundposition': 'backgroundPosition',
        'backgroundrepeat': 'backgroundRepeat',
        'backgroundsize': 'backgroundSize',
        'bordercolor': 'borderColor',
        'borderradius': 'borderRadius',
        'borderstyle': 'borderStyle',
        'borderwidth': 'borderWidth',
        'borderbottomwidth': 'borderBottomWidth',
        'borderleftwidth': 'borderLeftWidth',
        'borderrightwidth': 'borderRightWidth',
        'bordertopwidth': 'borderTopWidth',
        'color': 'color',
        'cursor': 'cursor',
        'display': 'display',
        'fontsize': 'fontSize',
        'fontfamily': 'fontFamily',
        'fontstyle': 'fontStyle',
        'fontunit': 'fontunit',
        'fontvariant': 'fontVariant',
        'fontweight': 'fontWeight',
        'height': 'height',
        'horizontalalign': 'textAlign',
        'lineheight': 'lineHeight',
        'margin': 'margin',
        'marginbottom': 'marginBottom',
        'marginleft': 'marginLeft',
        'marginright': 'marginRight',
        'margintop': 'marginTop',
        'opacity': 'opacity',
        'overflow': 'overflow',
        'padding': 'padding',
        'paddingbottom': 'paddingBottom',
        'paddingleft': 'paddingLeft',
        'paddingright': 'paddingRight',
        'paddingtop': 'paddingTop',
        'picturesource': 'backgroundImage',
        'textalign': 'textAlign',
        'textdecoration': 'textDecoration',
        'verticalalign': 'verticalAlign',
        'visibility': 'visibility',
        'whitespace': 'whiteSpace',
        'width': 'width',
        'wordbreak': 'wordbreak',
        'zindex': 'zIndex'
    };
    var isStyle = function (key) { return !!propNameCSSKeyMap[key]; };
    var MAP_SHELL_TYPE_IGNORE_LIST = {
        height: true,
        overflow: true,
        padding: true,
        paddingbottom: true,
        paddingleft: true,
        paddingright: true,
        paddingtop: true
    };
    var MAP_CONTAINER_TYPE_IGNORE_LIST = {
        textalign: true
    };
    var MAP_SCROLLABLE_CONTAINER_TYPE_IGNORE_LIST = {
        textalign: true,
        width: true
    };
    function styler($node, component, type, skipList) {
        // apply init styles;
        var skipListMap = Object.create(null);
        if (skipList) {
            skipList.forEach(function (k) { return skipListMap[k] = true; });
        }
        component.registerStyleChangeListener(function (key, nv) {
            if (skipListMap[key]) {
                return;
            }
            // if the type is `shell` and the key is in the SHELL_TYPE_IGNORE_LIST, return
            if (type === exports.APPLY_STYLES_TYPE.SHELL && MAP_SHELL_TYPE_IGNORE_LIST[key]) {
                return;
            }
            // if the type is `inner-shell` and the key is NOT in the SHELL_TYPE_IGNORE_LIST, return
            if (type === exports.APPLY_STYLES_TYPE.INNER_SHELL) {
                if (!MAP_SHELL_TYPE_IGNORE_LIST[key]) {
                    return;
                }
                if (key === 'height') {
                    core.setCSS($node, 'overflow', nv ? 'auto' : '');
                }
            }
            // if the type is `container` and the key is in the CONTAINER_TYPE_IGNORE_LIST, return
            if (type === exports.APPLY_STYLES_TYPE.CONTAINER && MAP_CONTAINER_TYPE_IGNORE_LIST[key]) {
                return;
            }
            if (type === exports.APPLY_STYLES_TYPE.SCROLLABLE_CONTAINER) {
                if (MAP_SCROLLABLE_CONTAINER_TYPE_IGNORE_LIST[key]) {
                    return;
                }
                if (key === 'height') {
                    core.setCSS($node, 'overflow', nv ? 'auto' : '');
                }
            }
            if (key === 'fontsize' || key === 'fontunit') {
                core.setCSS($node, 'fontSize', component.fontsize === '' ? '' : component.fontsize + (component.fontunit || 'px'));
            }
            else if (key === 'backgroundimage') {
                core.setCSS($node, 'backgroundImage', component.picturesource || getBackGroundImageUrl(nv));
            }
            else if (propNameCSSKeyMap[key]) {
                core.setCSS($node, propNameCSSKeyMap[key], nv);
            }
        });
    }

    // map of widgetSubType vs WidgetProps
    var widgetProps = new Map();
    // returns the widgetPropsMap associated with the given identifier
    var getWidgetPropsByType = function (identifier) { return widgetProps.get(identifier); };
    // register the widgetProps with the given identifier
    var register = function (identifier, props) {
        widgetProps.set(identifier, props);
        window.WM_LOADED_COMPONENTS = __spread(window.WM_LOADED_COMPONENTS || [], [identifier]);
    };
    (function (PROP_TYPE) {
        PROP_TYPE[PROP_TYPE["BOOLEAN"] = 1] = "BOOLEAN";
        PROP_TYPE[PROP_TYPE["NUMBER"] = 2] = "NUMBER";
        PROP_TYPE[PROP_TYPE["STRING"] = 3] = "STRING";
    })(exports.PROP_TYPE || (exports.PROP_TYPE = {}));
    var PROP_STRING = { type: exports.PROP_TYPE.STRING };
    var PROP_NUMBER = { type: exports.PROP_TYPE.NUMBER };
    var PROP_BOOLEAN = { type: exports.PROP_TYPE.BOOLEAN };
    var PROP_ANY = {};

    var registerProps = function () {
        var props = new Map([
            ['class', PROP_STRING],
            ['defaultpaneindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['justified', PROP_BOOLEAN],
            ['tabsposition', __assign({ value: 'top' }, PROP_STRING)],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['transition', PROP_STRING]
        ]);
        if (core.isMobileApp()) {
            props.set('transition', __assign({ value: 'slide' }, PROP_STRING));
        }
        register('wm-tabs', props);
    };

    /**
     * Widget Registry
     */
    var registryById = new Map();
    /**
     * Registers the Widget with the given id and name
     * Makes the Widget available with the viewParent
     * returns unRegister method
     */
    var register$1 = function (widget, viewParent, widgetId, name) {
        var registered = false;
        registryById.set(widgetId, widget);
        if (name) {
            if (core.isDefined(viewParent.Widgets)) {
                registered = true;
                viewParent.Widgets[name] = widget;
            }
        }
        // Unregister method.
        return function () {
            registryById.delete(widgetId);
            if (registered) {
                viewParent.Widgets[name] = undefined;
            }
        };
    };
    /**
     * Deregisters the oldname in widgets registry and sets new name
     */
    var renameWidget = function (viewParent, widget, nv, ov) {
        if (!core.isDefined(viewParent.Widgets)) {
            return;
        }
        if (ov) {
            viewParent.Widgets[ov] = undefined;
        }
        if (nv) {
            viewParent.Widgets[nv] = widget;
        }
    };

    var widgetIdGenerator = new core.IDGenerator('widget-id');

    var EVENTS_MAP = new Map([
        // ['enterkeypress', 'keypress.enter']
        ['tap', 'click']
    ]);
    // TODO: Implement touch events for the mobile
    var DISPLAY_TYPE = {
        BLOCK: 'block',
        INLINE_BLOCK: 'inline-block',
        INLINE: 'inline'
    };
    // set of boolean attrs
    var BOOLEAN_ATTRS = new Set([
        'readonly', 'autofocus', 'disabled', 'startchecked', 'multiple',
        'selected', 'required', 'controls', 'autoplay', 'loop', 'muted', 'show'
    ]);
    /**
     * Returns true if the provided key is a boolean attribute
     * @param {string} key
     * @returns {boolean}
     */
    var isBooleanAttr = function (key) { return BOOLEAN_ATTRS.has(key); };
    var DIMENSION_PROPS = new Set([
        'width',
        'height',
        'iconheight',
        'iconwidth',
        'popoverwidth',
        'popoverheight',
        'imagewidth',
        'imageheight'
    ]);
    var isDimensionProp = function (key) { return DIMENSION_PROPS.has(key); };
    var DEBOUNCE_TIMES = {
        PAGINATION_DEBOUNCE_TIME: 250
    };

    /**
     * Returns the parsed value based on the provided type
     * if the type is PROP_TYPE.NUMBER returns a number/NaN
     * if the type is PROP_BOOLEAN returns true/false
     * else returns the same value without any type conversion
     *
     * @param {string} key
     * @param value
     * @param {PROP_TYPE} type
     * @returns {any}
     */
    var parseValue = function (key, value, type) {
        if (type === exports.PROP_TYPE.BOOLEAN) {
            return core.toBoolean(value, isBooleanAttr(key) && key);
        }
        if (type === exports.PROP_TYPE.NUMBER) {
            return +value;
        }
        return value;
    };
    /**
     * Whenever a property on a component changes through a proxy this method will be triggered
     * If the new value is not from a watch, the existing watch on that particular property will be removed
     * This method invokes the defaultPropertyChange handler where the common widget properties like name, class are handled
     * Notifies the component about the style/property change
     */
    var globalPropertyChangeHandler = function (component, key, nv) {
        var widgetId = component.widgetId;
        var ov = component[key];
        // if the change is not from the bound watch, remove the existing watch
        if (!core.isChangeFromWatch()) {
            core.$unwatch(getWatchIdentifier(widgetId, key));
        }
        core.resetChangeFromWatch();
        var widgetProps = getWidgetPropsByType(component.getWidgetSubType());
        var propInfo = widgetProps.get(key);
        if (propInfo) {
            var type = propInfo.type;
            if (type) {
                nv = parseValue(key, nv, type);
            }
        }
        // Set the value in the component and trigger appDigest when there is a change in the value
        if (nv !== ov || core.isObject(nv) || core.isObject(ov)) {
            if (isDimensionProp(key)) {
                nv = core.toDimension(nv);
            }
            else if (_.startsWith(nv, 'resources/')) {
                var ref = component;
                if (ref._parentPrefab_ === undefined) {
                    ref._parentPrefab_ = component.$element.closest('[prefabname][prefabname!="__self__"]').attr('prefabname') || '';
                }
                if (ref._parentPrefab_) {
                    nv = "./app/prefabs/" + ref._parentPrefab_ + "/" + nv;
                }
            }
            component[key] = nv;
            if (isStyle(key)) {
                component.notifyStyleChange(key, nv, ov);
            }
            else {
                if (key === 'conditionalclass') {
                    nv = getConditionalClasses(nv, ov);
                }
                if (propInfo) {
                    component.notifyPropertyChange(key, nv, ov);
                }
            }
            core.$appDigest();
        }
    };

    /**
     * Proxy Provider - Creates a JS proxy for the given object
     */
    /**
     *  proxy handler for the components
     */
    var proxyHandler = {
        set: function (target, key, value) {
            globalPropertyChangeHandler(target, key, value);
            return true;
        },
        get: function (target, key) {
            var v = target[key];
            if (_.isFunction(v)) { // bind the proper context for the methods
                return v.bind(target);
            }
            return v;
        }
    };
    var $RAF = window.requestAnimationFrame;
    var $RAFQueue = [];
    var invokeLater = function (fn) {
        if (!$RAFQueue.length) {
            $RAF(function () {
                $RAFQueue.forEach(function (f) { return f(); });
                $RAFQueue.length = 0;
            });
        }
        $RAFQueue.push(fn);
    };
    var WidgetProxyProvider = /** @class */ (function () {
        function WidgetProxyProvider() {
        }
        WidgetProxyProvider.create = function (instance, widgetSubType, propsByWidgetSubType) {
            // If the native Proxy is supported
            if (window.Proxy) {
                return new Proxy(instance, proxyHandler);
            }
            else {
                // If the native Proxy is not supported, IE11
                var widget_1 = Object.create(instance);
                // bind proper context for the methods
                invokeLater(function () {
                    for (var key in instance) {
                        if (_.isFunction(instance[key]) && key !== 'constructor' && key !== 'super' && !_.startsWith(key, 'ng')) {
                            instance[key] = instance[key].bind(instance);
                        }
                    }
                });
                // define setters and getters for styles
                Object.keys(propNameCSSKeyMap)
                    .forEach(function (key) {
                    Object.defineProperty(widget_1, key, {
                        get: function () { return instance[key]; },
                        set: function (nv) { return globalPropertyChangeHandler(instance, key, nv); }
                    });
                });
                // define the setters and getters for Props
                if (propsByWidgetSubType) {
                    propsByWidgetSubType
                        .forEach(function (value, key) {
                        Object.defineProperty(widget_1, key, {
                            get: function () { return instance[key]; },
                            set: function (nv) { return globalPropertyChangeHandler(instance, key, nv); }
                        });
                    });
                }
                return widget_1;
            }
        };
        return WidgetProxyProvider;
    }());

    // Gets list of classes to add and remove and applies on the $el
    var updateClasses = function (toAdd, toRemove, el) {
        if (toRemove && toRemove.length) {
            core.removeClass(el, _.join(toRemove, ' '));
        }
        if (toAdd && toAdd.length) {
            core.addClass(el, _.join(toAdd, ' '));
        }
    };
    // To add and remove styles on the $el
    var updateStyles = function (nv, ov, el) {
        if (ov && _.isObject(ov)) {
            var keys = Object.keys(ov || {});
            keys.forEach(function (key) {
                core.setCSS(el, key, '');
            });
        }
        if (nv && _.isObject(nv)) {
            core.setCSSFromObj(el, nv);
        }
    };
    var BaseComponent = /** @class */ (function () {
        function BaseComponent(inj, config, initPromise // Promise on which the initialization has to wait
        ) {
            var _this = this;
            this.inj = inj;
            /**
             * Style change subject and observable
             */
            this.styleChange = new rxjs.ReplaySubject();
            /**
             * Property change subject and observable
             */
            this.propertyChange = new rxjs.Subject();
            /**
             * On Ready State change subject and observable
             */
            this.readyState = new rxjs.Subject();
            /**
             * Component destroy subject and observable
             */
            this.destroy = new rxjs.Subject();
            /**
             * Map of event handler callbacks
             */
            this.eventHandlers = new Map();
            /**
             * Holds the event registration functions.
             * these functions needs to be executed after onViewInit
             */
            this.toBeSetupEventsQueue = [];
            this.__cloneable__ = false;
            this.$attrs = new Map();
            var elementRef = inj.get(core$1.ElementRef);
            this.nativeElement = elementRef.nativeElement;
            this.widgetType = config.widgetType;
            this.widgetSubType = config.widgetSubType || config.widgetType;
            this.viewParent = inj.view.component;
            this.displayType = config.displayType || DISPLAY_TYPE.BLOCK;
            this.context = inj.view.context;
            this.widget = this.createProxy();
            this.eventManager = inj.get(platformBrowser.EventManager);
            this.nativeElement.widget = this.widget;
            this.appLocale = inj.get(core.App).appLocale || {};
            this.initContext();
            if (config.hostClass) {
                core.addClass(this.nativeElement, config.hostClass);
            }
            this.widgetId = this.generateWidgetId();
            core.setAttr(this.nativeElement, 'widget-id', this.widgetId, true);
            // register default property change handler and style change handler
            this.registerStyleChangeListener(this.onStyleChange, this);
            this.registerPropertyChangeListener(this.onPropertyChange, this);
            // if the initPromise is provided, wait till the promise is resolved to proceed with the widget initialization
            if (!initPromise) {
                this.initWidget();
            }
            else {
                this.delayedInit = true;
                initPromise.then(function () {
                    _this.initWidget();
                    _this.setInitProps();
                });
            }
        }
        Object.defineProperty(BaseComponent.prototype, "$element", {
            /**
             * jQuery nativeElement reference of the component root
             */
            get: function () {
                return $(this.nativeElement);
            },
            enumerable: true,
            configurable: true
        });
        BaseComponent.prototype.getNativeElement = function () {
            return this.nativeElement;
        };
        BaseComponent.prototype.getWidgetType = function () {
            return this.widgetType;
        };
        BaseComponent.prototype.getWidgetSubType = function () {
            return this.widgetSubType;
        };
        BaseComponent.prototype.getWidget = function () {
            return this.widget;
        };
        BaseComponent.prototype.getViewParent = function () {
            return this.viewParent;
        };
        BaseComponent.prototype.notifyStyleChange = function (key, nv, ov) {
            this.styleChange.next({ key: key, nv: nv, ov: ov });
        };
        BaseComponent.prototype.notifyPropertyChange = function (key, nv, ov) {
            this.propertyChange.next({ key: key, nv: nv, ov: ov });
        };
        BaseComponent.prototype.registerStyleChangeListener = function (fn, ctx) {
            if (ctx) {
                fn = fn.bind(ctx);
            }
            this.styleChange.subscribe(function (_a) {
                var key = _a.key, nv = _a.nv, ov = _a.ov;
                return fn(key, nv, ov);
            });
        };
        BaseComponent.prototype.registerReadyStateListener = function (fn, ctx) {
            if (ctx) {
                fn = fn.bind(ctx);
            }
            if (this.readyState.isStopped) {
                fn();
                return;
            }
            this.readyState.subscribe(function () { return fn(); });
        };
        BaseComponent.prototype.registerPropertyChangeListener = function (fn, ctx) {
            if (ctx) {
                fn = fn.bind(ctx);
            }
            this.propertyChange.subscribe(function (_a) {
                var key = _a.key, nv = _a.nv, ov = _a.ov;
                return fn(key, nv, ov);
            });
        };
        BaseComponent.prototype.registerDestroyListener = function (fn, ctx) {
            if (ctx) {
                fn = fn.bind(ctx);
            }
            this.destroy.subscribe(function () { }, function () { }, function () { return fn(); });
        };
        BaseComponent.prototype.getDisplayType = function () {
            return this.displayType;
        };
        BaseComponent.prototype.createProxy = function () {
            return WidgetProxyProvider.create(this, this.widgetSubType, getWidgetPropsByType(this.widgetSubType));
        };
        BaseComponent.prototype.initContext = function () {
            var context = this.inj.view.context;
            var parentContexts = this.inj.get(Context, {});
            // assign the context property accordingly
            if (this.viewParent !== context) {
                this.context = context;
            }
            else {
                this.context = {};
            }
            if (parentContexts) {
                this.context = Object.assign.apply(Object, __spread([{}], parentContexts, [this.context]));
            }
        };
        /**
         * set the value on the proxy object ie, widget
         * setting the property on the proxy will invoke the change listeners
         * @param {string} key
         * @param value
         */
        BaseComponent.prototype.setWidgetProperty = function (key, value) {
            this.widget[key] = value;
        };
        BaseComponent.prototype.getAttr = function (attrName) {
            return this.$attrs.get(attrName);
        };
        /**
         * returns app instance
         * @returns {App}
         */
        BaseComponent.prototype.getAppInstance = function () {
            return this.inj.get(core.App);
        };
        /**
         * Generates a unique id
         * Default pattern is `widget-id-${id}`
         * Components can override this method to generate a different id eg, bar-chart-1
         */
        BaseComponent.prototype.generateWidgetId = function () {
            return widgetIdGenerator.nextUid();
        };
        /**
         * Handles the common functionality across the components
         * eg,
         *  1. value of the class property will be applied on the host element
         *  2. based on the value of show property component is shown/hidden
         *
         * @param {string} key
         * @param nv
         * @param ov
         */
        BaseComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'show') {
                this.nativeElement.hidden = !nv;
            }
            else if (key === 'hint') {
                core.setAttr(this.nativeElement, 'title', nv);
            }
            else if (key === 'class') {
                core.switchClass(this.nativeElement, nv, ov);
            }
            else if (key === 'name' || key === 'tabindex') {
                core.setAttr(this.nativeElement, key, nv);
                if (key === 'name' && nv) {
                    renameWidget(this.viewParent, this.widget, nv, ov);
                }
            }
            else if (key === 'conditionalclass') {
                // update classes if old and nv value are different
                updateClasses(nv.toAdd, nv.toRemove, this.nativeElement);
            }
            else if (key === 'autoplay') {
                var tagName = this.widgetType === 'wm-audio' ? 'audio' : 'video';
                // Trigger media(audio/video) element load method after changing autoplay property
                this.nativeElement.querySelector(tagName).load();
            }
            else if (key === 'conditionalstyle') {
                // update styles if old and nv value are different
                updateStyles(nv, ov, this.nativeElement);
            }
        };
        /**
         * Default style change handler
         */
        BaseComponent.prototype.onStyleChange = function (k, nv, ov) { };
        /**
         * Register the widget with the widgetRegistry
         */
        BaseComponent.prototype.registerWidget = function (widgetName) {
            this.registerDestroyListener(register$1(this.widget, this.viewParent, this.widgetId, widgetName));
        };
        /**
         * override the
         */
        BaseComponent.prototype.getMappedEventName = function (eventName) {
            return EVENTS_MAP.get(eventName) || eventName;
        };
        /**
         * invoke the event handler
         * Components can override this method to execute custom logic before invoking the user callback
         */
        BaseComponent.prototype.handleEvent = function (node, eventName, eventCallback, locals, meta) {
            this.eventManager.addEventListener(node, eventName, function (e) {
                locals.$event = e;
                if (meta === 'delayed') {
                    setTimeout(function () { return eventCallback(); }, 150);
                }
                else {
                    return eventCallback();
                }
            });
        };
        /**
         * parse the event expression and save reference to the function inside eventHandlers map
         * If the component provides a override for an event through @Event decorator invoke that
         * else invoke the resolved function
         *
         * @param {string} eventName
         * @param {string} expr
         */
        BaseComponent.prototype.processEventAttr = function (eventName, expr, meta) {
            var _this = this;
            var fn = core.$parseEvent(expr);
            var locals = this.context;
            locals.widget = this.widget;
            var boundFn = fn.bind(undefined, this.viewParent, locals);
            var eventCallback = function () {
                var boundFnVal;
                core.$invokeWatchers(true);
                try {
                    // If the event is bound directly to the variable then we need to internally handle
                    // the promise returned by the variable call.
                    boundFnVal = boundFn();
                    if (boundFnVal instanceof Promise) {
                        boundFnVal.then(function (response) { return response; }, function (err) { return err; });
                    }
                    else {
                        return boundFnVal;
                    }
                }
                catch (e) {
                    console.error(e);
                }
            };
            this.eventHandlers.set(this.getMappedEventName(eventName), { callback: eventCallback, locals: locals });
            // prepend eventName with on and convert it to camelcase.
            // eg, "click" ---> onClick
            var onEventName = _.camelCase("on-" + eventName);
            // save the eventCallback in widgetScope.
            this[onEventName] = eventCallback;
            // events needs to be setup after viewInit
            this.toBeSetupEventsQueue.push(function () {
                _this.handleEvent(_this.nativeElement, _this.getMappedEventName(eventName), eventCallback, locals, meta);
            });
        };
        /**
         * Process the bound property
         * Register a watch on the bound expression
         */
        BaseComponent.prototype.processBindAttr = function (propName, expr) {
            var _this = this;
            this.initState.delete(propName);
            this.registerDestroyListener(core.$watch(expr, this.viewParent, this.context, function (nv) { return _this.widget[propName] = nv; }, getWatchIdentifier(this.widgetId, propName), propName === 'datasource'));
        };
        /**
         * Remove watch on the bound property
         */
        BaseComponent.prototype.removePropertyBinding = function (propName) {
            core.$unwatch(getWatchIdentifier(this.widgetId, propName));
        };
        /**
         * invoke the event callback method
         * @param {string} eventName
         * @param extraLocals
         */
        BaseComponent.prototype.invokeEventCallback = function (eventName, extraLocals) {
            var callbackInfo = this.eventHandlers.get(eventName);
            if (callbackInfo) {
                var fn = callbackInfo.callback;
                var locals = callbackInfo.locals || {};
                if (fn) {
                    return fn(Object.assign(locals, extraLocals));
                }
            }
        };
        /**
         * Process the attribute
         * If the attribute is an event expression, generate a functional representation of the expression
         *      and keep in eventHandlers
         * If the attribute is a bound expression, register a watch on the expression
         */
        BaseComponent.prototype.processAttr = function (attrName, attrValue) {
            var _a = attrName.split('.'), propName = _a[0], type = _a[1], meta = _a[2], length = _a.length;
            if (type === 'bind') {
                // if the show property is bound, set the initial value to false
                if (propName === 'show') {
                    this.nativeElement.hidden = true;
                }
                this.processBindAttr(propName, attrValue);
            }
            else if (type === 'event') {
                this.processEventAttr(propName, attrValue, meta);
            }
            else if (length === 1) {
                // remove class and name attributes. Component will set them on the proper node
                if (attrName === 'class') {
                    core.removeClass(this.nativeElement, attrValue);
                }
                else if (attrName === 'tabindex' || attrName === 'name') {
                    core.removeAttr(this.nativeElement, attrName);
                }
                this.initState.set(propName, attrValue);
            }
        };
        /**
         * Process the attributes
         */
        BaseComponent.prototype.processAttrs = function () {
            var e_1, _a;
            var elDef = this.inj.elDef;
            try {
                for (var _b = __values(elDef.element.attrs), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 3), attrName = _d[1], attrValue = _d[2];
                    this.$attrs.set(attrName, attrValue);
                    this.processAttr(attrName, attrValue);
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        };
        /**
         * Update the initState with the default property values and the values provided in the markup
         * Process the attributes
         * Register the widget
         */
        BaseComponent.prototype.initWidget = function () {
            var _this = this;
            this.initState = new Map();
            // get the widget properties
            var widgetProps = getWidgetPropsByType(this.widgetSubType);
            widgetProps.forEach(function (v, k) {
                if (core.isDefined(v.value)) {
                    _this.initState.set(k, v.value);
                }
            });
            this.widgetProps = widgetProps;
            this.processAttrs();
            this.registerWidget(this.initState.get('name'));
        };
        /**
         * Update the default properties and the properties provided in the markup in component
         * Invoking this method will result in invocation of propertyChange handlers on the component for the first time
         */
        BaseComponent.prototype.setInitProps = function () {
            var _this = this;
            if (this.initState.get('name')) {
                this.widget.name = this.initState.get('name');
            }
            this.initState.forEach(function (v, k) {
                // name is already set, ignore name
                // if the key is part of to be ignored attributes list do not set it on the component instance
                if ((_this.widgetProps.get(k) || isStyle(k)) && k !== 'name') {
                    _this.widget[k] = v;
                }
            });
            this.initState.clear();
            this.initState = undefined;
            this.readyState.next();
            this.readyState.complete();
        };
        /**
         * Returns true, if a listener registered for the given event on this widget markup.
         * @param eventName
         * @returns {boolean}
         */
        BaseComponent.prototype.hasEventCallback = function (eventName) {
            return this.eventHandlers.has(eventName);
        };
        /**
         * Sets the focus on the widget
         */
        BaseComponent.prototype.focus = function () {
            /**
             * Check for the nodes having focus-target attribute inside the element
             * If found, focus the first node (eg, date widget)
             * else, focus the element (eg, text widget)
             */
            var $target = this.$element[0].querySelector('[focus-target]');
            if (!$target) {
                $target = this.$element[0];
            }
            $target.focus();
        };
        // Defining the execute method on BaseComponent. If dataset is binded to widgets ouptut then datasource.execute will be defined
        BaseComponent.prototype.execute = function (operation, options) {
        };
        /**
         * nativeElement will be available by this time
         * if the delayInit is false, properties meta will be available by this time
         * Invoke the setInitProps if the delayInit is false
         */
        BaseComponent.prototype.ngOnInit = function () {
            if (!this.delayedInit) {
                this.setInitProps();
            }
        };
        /**
         * Register the events
         */
        BaseComponent.prototype.ngAfterViewInit = function () {
            var e_2, _a;
            if (this.toBeSetupEventsQueue.length) {
                try {
                    for (var _b = __values(this.toBeSetupEventsQueue), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var fn = _c.value;
                        fn();
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
            }
            this.toBeSetupEventsQueue.length = 0;
        };
        BaseComponent.prototype.ngAfterContentInit = function () { };
        BaseComponent.prototype.ngOnDestroy = function () {
            this.isDestroyed = true;
            this.widget = Object.create(null);
            this.styleChange.complete();
            this.propertyChange.complete();
            this.destroy.complete();
        };
        return BaseComponent;
    }());

    var StylableComponent = /** @class */ (function (_super) {
        __extends(StylableComponent, _super);
        function StylableComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return StylableComponent;
    }(BaseComponent));

    var registerProps$1 = function () {
        register('wm-tabpane', new Map([
            ['badgevalue', PROP_STRING],
            ['badgetype', __assign({ value: 'default' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['content', PROP_STRING],
            ['disabled', PROP_BOOLEAN],
            ['heading', PROP_STRING],
            ['isdefaulttab', PROP_STRING],
            ['name', PROP_STRING],
            ['paneicon', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['smoothscroll', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', __assign({ value: 'Tab Title' }, PROP_STRING)]
        ]));
    };

    var RedrawableDirective = /** @class */ (function () {
        function RedrawableDirective(widget) {
            this.redraw = function () { return widget.redraw(); };
        }
        RedrawableDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[redrawable]'
                    },] }
        ];
        /** @nocollapse */
        RedrawableDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [WidgetRef,] }] }
            ];
        };
        return RedrawableDirective;
    }());

    var DEFAULT_CLS = 'tab-pane';
    var WIDGET_CONFIG = {
        widgetType: 'wm-tabpane',
        hostClass: DEFAULT_CLS
    };
    var TabPaneComponent = /** @class */ (function (_super) {
        __extends(TabPaneComponent, _super);
        function TabPaneComponent(inj, tabsRef, heading, title) {
            var _this = _super.call(this, inj, WIDGET_CONFIG) || this;
            _this.tabsRef = tabsRef;
            _this.heading = heading;
            _this.title = title;
            _this.$lazyLoad = core.noop;
            _this.isActive = false;
            _this.disabled = false;
            // title property here serves the purpose of heading.
            // TODO: make it common for all the widget.
            core.removeAttr(_this.nativeElement, 'title');
            return _this;
        }
        // parent tabs component will call this method for the order of callbacks to be proper
        // order of callbacks - deselect, select, change
        TabPaneComponent.prototype.invokeOnSelectCallback = function ($event) {
            this.invokeEventCallback('select', { $event: $event });
        };
        TabPaneComponent.prototype.select = function ($event) {
            // When called programatically $event won't be available
            if (this.isActive || this.disabled) {
                return;
            }
            this.isActive = true;
            this.$lazyLoad();
            this.redrawChildren();
            this.notifyParent($event);
            if ($event) {
                $event.stopPropagation();
                $event.preventDefault();
            }
        };
        TabPaneComponent.prototype.deselect = function () {
            if (this.isActive) {
                this.isActive = false;
                this.invokeEventCallback('deselect');
            }
        };
        TabPaneComponent.prototype.redrawChildren = function () {
            var _this = this;
            setTimeout(function () {
                if (_this.reDrawableComponents) {
                    _this.reDrawableComponents.forEach(function (c) { return c.redraw(); });
                }
            }, 100);
        };
        TabPaneComponent.prototype.notifyParent = function (evt) {
            this.tabsRef.notifyChange(this, evt);
        };
        // select next valid tab
        TabPaneComponent.prototype.handleSwipeLeft = function () {
            this.tabsRef.next();
        };
        // select prev valid tab
        TabPaneComponent.prototype.handleSwipeRight = function () {
            this.tabsRef.prev();
        };
        // select event is called manually
        TabPaneComponent.prototype.handleEvent = function (node, eventName, callback, locals) {
            if (eventName !== 'select') {
                _super.prototype.handleEvent.call(this, this.nativeElement, eventName, callback, locals);
            }
        };
        TabPaneComponent.prototype.onPropertyChange = function (key, nv, ov) {
            var _this = this;
            if (key === 'content') {
                if (this.isActive) {
                    setTimeout(function () { return _this.$lazyLoad(); }, 100);
                }
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        TabPaneComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.title = this.title || this.heading;
        };
        TabPaneComponent.prototype.ngAfterViewInit = function () {
            styler(this.nativeElement.querySelector('.tab-body'), this, exports.APPLY_STYLES_TYPE.CONTAINER);
            _super.prototype.ngAfterViewInit.call(this);
        };
        TabPaneComponent.initializeProps = registerProps$1();
        TabPaneComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmTabPane]',
                        template: "<div class=\"tab-body\" partial-container-target [wmSmoothscroll]=\"smoothscroll\">\n    <ng-content></ng-content>\n</div>",
                        providers: [
                            provideAsWidgetRef(TabPaneComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        TabPaneComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: TabsComponent },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['heading',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['title',] }] }
            ];
        };
        TabPaneComponent.propDecorators = {
            isActive: [{ type: core$1.HostBinding, args: ['class.active',] }],
            disabled: [{ type: core$1.HostBinding, args: ['class.disabled',] }],
            reDrawableComponents: [{ type: core$1.ContentChildren, args: [RedrawableDirective, { descendants: true },] }]
        };
        return TabPaneComponent;
    }(StylableComponent));

    var DEFAULT_CLS$1 = 'app-tabs clearfix';
    var WIDGET_CONFIG$1 = {
        widgetType: 'wm-tabs',
        hostClass: DEFAULT_CLS$1
    };
    var TabsComponent = /** @class */ (function (_super) {
        __extends(TabsComponent, _super);
        function TabsComponent(inj, _transition, _tabsPosition) {
            var _this = this;
            // handle to the promise resolver
            var resolveFn = core.noop;
            _this = _super.call(this, inj, WIDGET_CONFIG$1, new Promise(function (res) { return resolveFn = res; })) || this;
            _this.transition = _transition;
            _this.tabsposition = _tabsPosition;
            _this.promiseResolverFn = resolveFn;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        TabsComponent.prototype.animateIn = function (element) {
            var tabHeader = $(element);
            // when the animation is not present toggle the active class.
            tabHeader.siblings('.active').removeClass('active');
            tabHeader.addClass('active');
            var ul = this.nativeElement.querySelector('ul.nav.nav-tabs');
            // move the tabheader into the viewport
            var $prevHeaderEle = tabHeader.prev();
            if ($prevHeaderEle.length) {
                ul.scrollLeft = $prevHeaderEle[0].offsetLeft;
            }
            else {
                ul.scrollLeft = 0;
            }
        };
        /**
         * TabPane children components invoke this method to communicate with the parent
         * if the evt argument is defined on-change callback will be invoked.
         */
        TabsComponent.prototype.notifyChange = function (paneRef, evt) {
            if (!this.isSelectableTab(paneRef)) {
                return;
            }
            var headerElement;
            // invoke deselect event callback on the preset active tab
            if (this.activeTab) {
                this.activeTab.deselect();
            }
            // invoke select callback on the selected tab
            paneRef.invokeOnSelectCallback(evt);
            this.activeTab = paneRef.getWidget();
            // invoke change callback if the evt is present, select a tab programmatically will not have the event
            if (evt) {
                this.invokeEventCallback('change', {
                    $event: evt,
                    newPaneIndex: this.getPaneIndexByRef(paneRef),
                    oldPaneIndex: this.getActiveTabIndex()
                });
            }
            if (evt) {
                headerElement = $(evt.target).closest('li.tab-header');
            }
            else {
                headerElement = this.nativeElement.querySelector("li[data-paneid=" + paneRef.widgetId + "]");
            }
            this.animateIn(headerElement);
            // this.setTabsLeftPosition(this.getPaneIndexByRef(this.activeTab), this.panes.length);
            if (this.canSlide()) {
                if (!this.tabsAnimator) {
                    this.tabsAnimator = new TabsAnimator(this);
                    this.tabsAnimator.setGesturesEnabled(this.canSlide());
                }
                this.tabsAnimator.transitionTabIntoView();
            }
        };
        TabsComponent.prototype.goToTab = function (tabIndex) {
            if (this.isValidPaneIndex(tabIndex - 1)) {
                var tab = this.getPaneRefByIndex(tabIndex - 1);
                tab.select();
            }
        };
        TabsComponent.prototype.getPaneIndexByRef = function (paneRef) {
            return this.panes.toArray().indexOf(paneRef);
        };
        // Returns the active tab index from tabs.
        TabsComponent.prototype.getActiveTabIndex = function () {
            return _.findIndex(this.panes.toArray(), { isActive: true });
        };
        TabsComponent.prototype.isValidPaneIndex = function (index) {
            return (index >= 0 && index < this.panes.length);
        };
        TabsComponent.prototype.getPaneRefByIndex = function (index) {
            return this.panes.toArray()[index];
        };
        // returns false if the pane is hidden or disabled
        TabsComponent.prototype.isSelectableTab = function (paneRef) {
            return paneRef.show && !paneRef.disabled;
        };
        TabsComponent.prototype.canSlide = function () {
            return this.transition === 'slide' && !this.vertical;
        };
        TabsComponent.prototype.getSelectableTabAfterIndex = function (index) {
            for (var i = index + 1; i < this.panes.length; i++) {
                var pane = this.getPaneRefByIndex(i);
                if (this.isSelectableTab(pane)) {
                    return pane;
                }
            }
        };
        TabsComponent.prototype.getSelectableTabBeforeIndex = function (index) {
            for (var i = index - 1; i >= 0; i--) {
                var pane = this.getPaneRefByIndex(i);
                if (this.isSelectableTab(pane)) {
                    return pane;
                }
            }
        };
        // select next tab relative to the current active tab
        TabsComponent.prototype.next = function () {
            var pane = this.getSelectableTabAfterIndex(this.getActiveTabIndex());
            if (pane) {
                pane.select();
            }
        };
        // select prev tab relative to the current active tab
        TabsComponent.prototype.prev = function () {
            var pane = this.getSelectableTabBeforeIndex(this.getActiveTabIndex());
            if (pane) {
                pane.select();
            }
        };
        /**
         * this method will be invoked during the initialization of the component and on defaultpaneindex property change,
         * if the provided defaultpaneindex is not valid, find the first pane index which can be shown and select it
         */
        TabsComponent.prototype.selectDefaultPaneByIndex = function (index) {
            if (!this.isValidPaneIndex(index)) {
                return;
            }
            var paneRef = this.getPaneRefByIndex(index);
            if (!this.isSelectableTab(paneRef)) {
                paneRef = this.getSelectableTabAfterIndex(0);
            }
            if (paneRef) {
                paneRef.select();
            }
        };
        // update the postion of tab header
        TabsComponent.prototype.setTabsPosition = function () {
            var ul = this.nativeElement.children[0];
            this.vertical = (this.tabsposition === 'left' || this.tabsposition === 'right');
            core.removeClass(this.nativeElement, 'inverted');
            if (this.tabsposition === 'bottom' || this.tabsposition === 'right') {
                core.appendNode(ul, this.nativeElement);
                core.addClass(this.nativeElement, 'inverted');
            }
        };
        TabsComponent.prototype.onPropertyChange = function (key, nv, ov) {
            var _this = this;
            if (key === 'defaultpaneindex') {
                // If no active tab is set ie.. no isdefaulttab then honor the defaultpaneindex
                setTimeout(function () { return _this.selectDefaultPaneByIndex(nv || 0); }, 20);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        TabsComponent.prototype.registerTabsScroll = function () {
            var _this = this;
            setTimeout(function () {
                var $ul = _this.$element.find('> ul');
                var $liPosition;
                var $li = $ul.children();
                $liPosition = $li.last().position();
                if ($liPosition && ($liPosition.left > $ul.width())) {
                    $ul.on('mousewheel', function (e) {
                        var left = $ul[0].scrollLeft, _delta = -1 * e.originalEvent.wheelDelta;
                        e.stopPropagation();
                        e.preventDefault();
                        $ul.animate({ scrollLeft: left + _delta }, { 'duration': 10 });
                    });
                }
            });
        };
        TabsComponent.prototype.ngAfterContentInit = function () {
            this.promiseResolverFn();
            _super.prototype.ngAfterContentInit.call(this);
            this.setTabsPosition();
        };
        TabsComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            this.registerTabsScroll();
        };
        TabsComponent.initializeProps = registerProps();
        TabsComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmTabs]',
                        template: "<ul class=\"nav nav-tabs\" [ngClass]=\"{'nav-stacked': vertical, 'nav-justified': justified}\" role=\"tablist\">\n    <li class=\"tab-header\" *ngFor=\"let pane of panes;\" [attr.data-paneid]=\"pane.widgetId\" [ngClass]=\"{'active': pane.isActive, 'disabled': pane.disabled}\"\n        [hidden]=\"!pane.show\" (click)=\"pane.select($event)\" role=\"tab\">\n        <a href=\"javascript:void(0);\" role=\"button\" [attr.aria-label]=\"pane.title\" [attr.title]=\"pane.title\" [tabindex]=\"pane.tabindex\">\n            <div class=\"tab-heading\">\n                <i [ngClass]=\"['app-icon', pane.paneicon]\" *ngIf=\"pane.paneicon\"></i>\n                <span [textContent]=\"pane.title\"></span>\n                <span *ngIf=\"pane.badgevalue\" class=\"label label-{{pane.badgetype}}\" [textContent]=\"pane.badgevalue\"></span>\n            </div>\n        </a>\n    </li>\n</ul>\n<div class=\"tab-content\" [ngClass]=\"{'tab-stacked': vertical, 'tab-justified': justified}\">\n    <ng-content select=\"div[wmTabPane]\"></ng-content>\n</div>\n",
                        providers: [
                            provideAsWidgetRef(TabsComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        TabsComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['transition',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['tabsposition',] }] }
            ];
        };
        TabsComponent.propDecorators = {
            panes: [{ type: core$1.ContentChildren, args: [TabPaneComponent,] }]
        };
        return TabsComponent;
    }(StylableComponent));

    var registerProps$2 = function () {
        register('wm-alertdialog', new Map([
            ['alerttype', __assign({ value: 'error' }, PROP_STRING)],
            ['animation', PROP_STRING],
            ['class', PROP_STRING],
            ['closable', { value: true, PROP_BOOLEAN: PROP_BOOLEAN }],
            ['iconclass', { value: 'wi wi-warning', PROP_STRING: PROP_STRING }],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['message', __assign({ value: 'Am an alert box!' }, PROP_STRING)],
            ['modal', __assign({ value: false }, PROP_BOOLEAN)],
            ['name', PROP_STRING],
            ['oktext', __assign({ value: 'OK' }, PROP_STRING)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', __assign({ value: 'Alert' }, PROP_STRING)]
        ]));
    };

    var eventsRegistered = false;
    var findRootContainer = function ($el) {
        var root = $el.closest('.app-prefab');
        if (!root.length) {
            root = $el.closest('.app-partial');
        }
        if (!root.length) {
            root = $el.closest('.app-page');
        }
        return root.length && root.parent()[0].tagName;
    };
    var invokeOpenedCallback = function (ref) {
        if (ref) {
            setTimeout(function () {
                var root = findRootContainer(ref.$element);
                // if page styles have to be applied to dialog then dialog has to be child of page element.
                if (root) {
                    $('body:first > modal-container > div').wrap('<' + root + '/>');
                }
                ref.invokeEventCallback('opened', { $event: { type: 'opened' } });
            });
        }
    };
    var invokeClosedCallback = function (ref) {
        if (ref) {
            ref.invokeEventCallback('close');
            ref.dialogRef = undefined;
        }
    };
    var BaseDialog = /** @class */ (function (_super) {
        __extends(BaseDialog, _super);
        function BaseDialog(inj, widgetConfig, modalOptions) {
            var _this = _super.call(this, inj, widgetConfig) || this;
            _this.modalOptions = modalOptions;
            _this.dialogService = inj.get(core.AbstractDialogService);
            _this.bsModal = inj.get(ngxBootstrap.BsModalService);
            // Subscribe to onShown and onHidden events only once as we will not be
            // unsubscribing to the,m ever and we will handle the logic of calling
            // respective dialog callbacks.
            if (!eventsRegistered) {
                eventsRegistered = true;
                _this.bsModal.onShown.subscribe(function () {
                    // Always get the reference of last pushed dialog in the array for calling onOpen callback
                    invokeOpenedCallback(_this.dialogService.getLastOpenedDialog());
                });
                _this.bsModal.onHidden.subscribe(function (closeReason) {
                    var ref = closeReason === 'esc' || closeReason === 'backdrop-click' ? _this.dialogService.getLastOpenedDialog() : _this.dialogService.getDialogRefFromClosedDialogs();
                    // remove the dialog reference from opened dialogs and closed dialogs
                    _this.dialogService.removeFromOpenedDialogs(ref);
                    _this.dialogService.removeFromClosedDialogs(ref);
                    invokeClosedCallback(ref);
                });
            }
            return _this;
        }
        /**
         * Opens the dialog
         * Subscribe to the onShown event emitter of bsModal and trigger on-opened event callback
         */
        BaseDialog.prototype.open = function (initState) {
            // remove the popovers in the page to avoid the overlap with dialog
            // closePopover(this.$element); Commenting this line because it is causing regression(if we have dialog inside popover as partail content, then the dialog close is not working because on closing the popover the partial get destroyed.)
            var _this = this;
            // do not open the dialog again if it is already opened
            var duplicateDialogCheck = function (openedDialog) {
                return openedDialog === _this;
            };
            if (this.dialogService.getOpenedDialogs().some(duplicateDialogCheck)) {
                return;
            }
            this.dialogService.addToOpenedDialogs(this);
            // extend the context with the initState
            Object.assign(this.context, initState);
            this.dialogRef = this.bsModal.show(this.getTemplateRef(), this.modalOptions);
        };
        /**
         * closes the dialog
         * invokes the on-close event callback
         */
        BaseDialog.prototype.close = function () {
            // remove the popovers in the page to avoid the overlap with dialog
            // closePopover(this.$element); Commenting this line because it is causing regression(if we have dialog inside popover as partail content, then the dialog close is not working because on closing the popover the partial get destroyed.)
            if (this.dialogRef) {
                this.dialogService.addToClosedDialogs(this);
                this.dialogRef.hide();
            }
        };
        /**
         * Register the dialog with the dialog service for programmatic access
         */
        BaseDialog.prototype.register = function (scope) {
            // add scope along with name in the dialogRefsCollection Map while registering dialog
            // So that 2 dialogs having same name on different pages won't be overridden.
            this.dialogService.register(this.name, this, scope);
        };
        /**
         * De Register the dialog with the dialog service after dialog destruction
         */
        BaseDialog.prototype.deRegister = function (scope) {
            this.dialogService.deRegister(this.name, scope);
        };
        BaseDialog.prototype.onPropertyChange = function (key, nv, ov) {
            // ignore the class attribute.
            // Prevent the framework from setting the class on the host element.
            if (key === 'class' || key === 'name' || key === 'tabindex') {
                return;
            }
            else if (key === 'animation') {
                this.modalOptions.class = this.modalOptions.class.replace('animated ' + ov, '');
                if (nv) {
                    this.modalOptions.class = this.modalOptions.class + 'animated ' + nv;
                }
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        BaseDialog.prototype.ngOnDestroy = function () {
            this.close();
            this.deRegister(this.viewParent);
            _super.prototype.ngOnDestroy.call(this);
        };
        return BaseDialog;
    }(BaseComponent));

    var DIALOG_CLS = 'app-dialog modal-dialog app-alert-dialog';
    var WIDGET_INFO = { widgetType: 'wm-alertdialog' };
    var AlertDialogComponent = /** @class */ (function (_super) {
        __extends(AlertDialogComponent, _super);
        function AlertDialogComponent(inj, dialogClass, modal, closable) {
            var _this = this;
            if (modal === null || modal === undefined) {
                modal = false;
            }
            if (closable === null || closable === undefined) {
                closable = true;
            }
            // setting the backdrop to 'static' will not close the dialog on backdrop click
            var backdrop = core.toBoolean(modal) ? 'static' : true;
            _this = _super.call(this, inj, WIDGET_INFO, {
                class: DIALOG_CLS + " " + (dialogClass || ''),
                backdrop: backdrop,
                keyboard: !core.toBoolean(modal)
            }) || this;
            return _this;
        }
        AlertDialogComponent.prototype.getTemplateRef = function () {
            return this.dialogTemplate;
        };
        /**
         * Click event handler for the ok button
         * invokes on-ok event callback
         * @param {Event} $event
         */
        AlertDialogComponent.prototype.onOk = function ($event) {
            this.invokeEventCallback('ok', { $event: $event });
        };
        AlertDialogComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.register(this.viewParent);
        };
        AlertDialogComponent.initializeProps = registerProps$2();
        AlertDialogComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmAlertDialog]',
                        template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"></div>\n    <div wmDialogBody>\n        <p class=\"app-dialog-message text-{{alerttype}}\" [attr.aria-describedby]=\"message\" [textContent]=\"message\"></p>\n    </div>\n    <div wmDialogFooter>\n        <button wmButton class=\"btn-primary ok-action\" caption.bind=\"oktext\" aria-label=\"Submit button\" (click)=\"onOk($event)\"></button>\n    </div>\n</ng-template>\n",
                        providers: [
                            provideAsWidgetRef(AlertDialogComponent),
                            provideAsDialogRef(AlertDialogComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        AlertDialogComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['class',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['modal',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['closable',] }] }
            ];
        };
        AlertDialogComponent.propDecorators = {
            dialogTemplate: [{ type: core$1.ViewChild, args: ['dialogTemplate',] }]
        };
        return AlertDialogComponent;
    }(BaseDialog));

    var registerProps$3 = function () {
        register('wm-anchor', new Map([
            ['badgevalue', PROP_STRING],
            ['caption', __assign({ value: 'Link' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['encodeurl', PROP_BOOLEAN],
            ['hint', PROP_STRING],
            ['hyperlink', __assign({ value: '' }, PROP_STRING)],
            ['iconclass', PROP_STRING],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconposition', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['name', PROP_STRING],
            ['shortcutkey', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['target', __assign({ value: '_self' }, PROP_STRING)]
        ]));
    };

    var registerProps$4 = function () {
        register('wm-nav-item', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$2 = 'app-nav-item';
    var WIDGET_CONFIG$2 = { widgetType: 'wm-nav-item', hostClass: DEFAULT_CLS$2 };
    var NavItemDirective = /** @class */ (function (_super) {
        __extends(NavItemDirective, _super);
        function NavItemDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$2) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        NavItemDirective.prototype.makeActive = function () {
            var parentNode = this.nativeElement.parentNode;
            $(parentNode).find('> li.active').removeClass('active');
            core.addClass(this.nativeElement, 'active');
        };
        NavItemDirective.initializeProps = registerProps$4();
        NavItemDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmNavItem]',
                        providers: [
                            provideAsWidgetRef(NavItemDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        NavItemDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        NavItemDirective.propDecorators = {
            makeActive: [{ type: core$1.HostListener, args: ['click',] }, { type: core$1.HostListener, args: ['keydown.enter',] }]
        };
        return NavItemDirective;
    }(StylableComponent));

    var disableContextMenu = function ($event) {
        $event.preventDefault();
    };
    var NavigationControlDirective = /** @class */ (function () {
        function NavigationControlDirective(eleRef) {
            this.nativeElement = eleRef.nativeElement;
        }
        Object.defineProperty(NavigationControlDirective.prototype, "wmNavigationControl", {
            set: function (val) {
                this._link = val;
                if (val && !this.disableMenuContext) {
                    core.setAttr(this.nativeElement, 'href', val);
                    this.nativeElement.removeEventListener('contextmenu', disableContextMenu);
                }
                else {
                    core.setAttr(this.nativeElement, 'href', 'javascript:void(0)');
                    this.nativeElement.addEventListener('contextmenu', disableContextMenu);
                }
            },
            enumerable: true,
            configurable: true
        });
        NavigationControlDirective.decorators = [
            { type: core$1.Directive, args: [{ selector: '[wmNavigationControl]' },] }
        ];
        /** @nocollapse */
        NavigationControlDirective.ctorParameters = function () {
            return [
                { type: core$1.ElementRef }
            ];
        };
        NavigationControlDirective.propDecorators = {
            disableMenuContext: [{ type: core$1.Input }],
            wmNavigationControl: [{ type: core$1.Input }]
        };
        return NavigationControlDirective;
    }());

    var DEFAULT_CLS$3 = 'app-anchor';
    var WIDGET_CONFIG$3 = {
        widgetType: 'wm-anchor',
        hostClass: DEFAULT_CLS$3,
        displayType: DISPLAY_TYPE.INLINE_BLOCK
    };
    var regex = /Actions.goToPage_(\w+)\.invoke\(\)/g;
    var AnchorComponent = /** @class */ (function (_super) {
        __extends(AnchorComponent, _super);
        function AnchorComponent(inj, navItemRef, app) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$3) || this;
            _this.navItemRef = navItemRef;
            _this.app = app;
            styler(_this.nativeElement, _this);
            return _this;
        }
        AnchorComponent.prototype.processEventAttr = function (eventName, expr, meta) {
            var _this = this;
            _super.prototype.processEventAttr.call(this, eventName, expr, meta);
            if (!this.hasNavigationToCurrentPageExpr) {
                var app_1 = this.inj.get(core.App);
                var fns = expr.split(';').map(Function.prototype.call, String.prototype.trim);
                if (fns.some(function (fn) {
                    regex.lastIndex = 0;
                    var matches = regex.exec(fn);
                    _this.hasGoToPageExpr = matches && (matches.length > 0);
                    return _this.hasGoToPageExpr && matches[1] === app_1.activePageName;
                })) {
                    this.hasNavigationToCurrentPageExpr = true;
                }
            }
        };
        AnchorComponent.prototype.setNavItemActive = function () {
            if (this.navItemRef) {
                core.addClass(this.navItemRef.getNativeElement(), 'active');
            }
        };
        AnchorComponent.prototype.handleEvent = function (node, eventName, eventCallback, locals, meta) {
            var _this = this;
            _super.prototype.handleEvent.call(this, node, eventName, function (e) {
                if (_this.hasGoToPageExpr && locals.$event) {
                    locals.$event.preventDefault();
                }
                eventCallback();
            }, locals, meta);
        };
        AnchorComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'hyperlink') {
                if (!nv) {
                    core.setAttr(this.nativeElement, 'href', 'javascript:void(0)');
                    this.nativeElement.addEventListener('contextmenu', disableContextMenu);
                    return;
                }
                if (this.encodeurl) {
                    nv = core.encodeUrl(nv);
                }
                // if hyperlink starts with 'www.' append '//' in the beginning
                if (nv.startsWith('www.')) {
                    nv = "//" + nv;
                }
                core.setAttr(this.nativeElement, 'href', nv);
                this.nativeElement.removeEventListener('contextmenu', disableContextMenu);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        AnchorComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            if (this.hasNavigationToCurrentPageExpr) {
                core.addClass(this.nativeElement, 'active');
            }
            if (this.navItemRef) {
                setTimeout(function () {
                    if (_this.hyperlink && core.getRouteNameFromLink(_this.hyperlink) === "/" + _this.app.activePageName) {
                        _this.setNavItemActive();
                    }
                    else if (_this.hasNavigationToCurrentPageExpr) {
                        _this.setNavItemActive();
                    }
                });
            }
        };
        AnchorComponent.initializeProps = registerProps$3();
        AnchorComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'a[wmAnchor]',
                        template: "<img data-identifier=\"img\" alt=\"Image\" class=\"anchor-image-icon\" [src]=\"iconurl | image\" *ngIf=\"iconurl\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin}\"/>\n<i class=\"app-icon {{iconclass}}\" aria-hidden=\"true\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin}\" *ngIf=\"iconclass\"></i>\n<span class=\"sr-only\" *ngIf=\"iconclass\">{{caption | trustAs:'html'}} {{appLocale.LABEL_ICON}}</span>\n<span class=\"anchor-caption\" [innerHTML]=\"caption | trustAs:'html'\"></span>\n<ng-content select=\".caret\"></ng-content>\n<span *ngIf=\"badgevalue\" class=\"badge pull-right\" [textContent]=\"badgevalue\"></span>",
                        providers: [
                            provideAsWidgetRef(AnchorComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        AnchorComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: NavItemDirective, decorators: [{ type: core$1.Optional }] },
                { type: core.App }
            ];
        };
        AnchorComponent.propDecorators = {
            target: [{ type: core$1.HostBinding, args: ['target',] }],
            shortcutkey: [{ type: core$1.HostBinding, args: ['attr.accesskey',] }],
            iconposition: [{ type: core$1.HostBinding, args: ['attr.icon-position',] }]
        };
        return AnchorComponent;
    }(StylableComponent));

    var registerProps$5 = function () {
        register('wm-breadcrumb', new Map([
            ['class', PROP_STRING],
            ['dataset', PROP_ANY],
            ['itemlabel', PROP_STRING],
            ['itemid', PROP_STRING],
            ['itemlink', PROP_STRING],
            ['itemicon', PROP_STRING],
            ['itemchildren', PROP_STRING],
            ['itemclass', PROP_STRING],
            ['itemtarget', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var noop = function () { };
    var Live_Operations;
    (function (Live_Operations) {
        Live_Operations["INSERT"] = "insert";
        Live_Operations["UPDATE"] = "update";
        Live_Operations["DELETE"] = "delete";
        Live_Operations["READ"] = "read";
    })(Live_Operations || (Live_Operations = {}));
    var ALLFIELDS = 'All Fields';
    var LIVE_CONSTANTS = {
        'EMPTY_KEY': 'EMPTY_NULL_FILTER',
        'EMPTY_VALUE': 'No Value',
        'LABEL_KEY': 'key',
        'LABEL_VALUE': 'value',
        'NULL_EMPTY': ['null', 'empty'],
        'NULL': 'null',
        'EMPTY': 'empty'
    };
    // Returns true if widget is autocomplete or chips
    function isSearchWidgetType(widget) {
        return _.includes([core.FormWidgetType.AUTOCOMPLETE, core.FormWidgetType.TYPEAHEAD, core.FormWidgetType.CHIPS], widget);
    }
    function onSuccess(response, res, rej) {
        if (response.error) {
            rej(response);
        }
        else {
            res(response);
        }
    }
    function performDataOperation(dataSource, requestData, options) {
        return new Promise(function (res, rej) {
            if (dataSource.execute(core.DataSource.Operation.SUPPORTS_CRUD)) {
                var fn = void 0;
                var operationType = options.operationType;
                switch (operationType) {
                    case Live_Operations.UPDATE:
                        fn = core.DataSource.Operation.UPDATE_RECORD;
                        break;
                    case Live_Operations.INSERT:
                        fn = core.DataSource.Operation.INSERT_RECORD;
                        break;
                    case Live_Operations.DELETE:
                        fn = core.DataSource.Operation.DELETE_RECORD;
                        break;
                }
                dataSource.execute(fn, requestData).then(function (response) { return onSuccess(response, res, rej); }, rej);
            }
            else if (dataSource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                dataSource.execute(core.DataSource.Operation.SET_INPUT, requestData);
                dataSource.execute(core.DataSource.Operation.INVOKE, {
                    'skipNotification': true
                }).then(res, rej);
            }
            else {
                res(requestData);
            }
        });
    }
    function refreshDataSource(dataSource, options) {
        return new Promise(function (res, rej) {
            if (!dataSource) {
                rej();
                return;
            }
            dataSource.execute(core.DataSource.Operation.LIST_RECORDS, {
                'filterFields': options.filterFields || {},
                'orderBy': options.orderBy,
                'page': options.page || 1
            }).then(res, rej);
        });
    }
    /**
     * @ngdoc function
     * @name wm.widgets.live.fetchRelatedFieldData
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * This function fetches the data for the related field in live form/ grid
     *
     * @param {object} columnDef field definition
     * @param {string} relatedField related field name
     * @param {string} datafield Datafield to be set on widget
     * @param {string} widget Type of the widget
     * @param {object} elScope element scope
     * @param {object} parentScope live form// grid scope
     */
    function fetchRelatedFieldData(dataSource, formField, options) {
        var primaryKeys;
        var displayField;
        var relatedField = options.relatedField;
        var datafield = options.datafield;
        if (!dataSource) {
            return;
        }
        primaryKeys = dataSource.execute(core.DataSource.Operation.GET_RELATED_PRIMARY_KEYS, relatedField);
        formField.datafield = datafield;
        formField._primaryKey = _.isEmpty(primaryKeys) ? undefined : primaryKeys[0];
        formField.compareby = primaryKeys && primaryKeys.join(',');
        displayField = datafield === ALLFIELDS ? undefined : datafield;
        formField.displayfield = displayField = (formField.displayfield || displayField || formField._primaryKey);
        if (isSearchWidgetType(formField[options.widget])) {
            formField.dataoptions = { 'relatedField': relatedField, 'filterExpr': formField.filterexpressions ? formField.filterexpressions : {} };
            formField.datasource = dataSource;
            formField.searchkey = formField.searchkey || displayField;
            formField.displaylabel = formField.displayfield = (formField.displaylabel || displayField);
        }
        else {
            interpolateBindExpressions(formField.viewParent, formField.filterexpressions, function (filterexpressions) {
                formField.filterexpressions = filterexpressions;
                dataSource.execute(core.DataSource.Operation.GET_RELATED_TABLE_DATA, {
                    relatedField: relatedField,
                    pagesize: formField.limit,
                    orderBy: formField.orderby ? _.replace(formField.orderby, /:/g, ' ') : '',
                    filterFields: {},
                    filterExpr: formField.filterexpressions ? formField.filterexpressions : {}
                }).then(function (response) {
                    formField.dataset = response.data;
                    formField.displayfield = formField.displayfield || _.head(_.keys(_.get(response, '[0]')));
                }, noop);
            });
        }
    }
    /**
     * used to interpolate the bind expression for keys in the query builder
     * @param context where we find the variable obj
     * @param filterexpressions - obj containing all the rule objs
     * @param callbackFn - function to be called with the new replaced values if any in the filterexpressions object
     */
    var interpolateBindExpressions = function (context, filterexpressions, callbackFn) {
        var debouncedFn = core.debounce(function () {
            if (_.isFunction(callbackFn)) {
                callbackFn(filterexpressions);
            }
        }, 300);
        /**
         * calling the debounced function first for the case where if there is any filterexpression without the bindedvariables.
         * without this it will never be called. processFilterExpBindNode will be called only for the binded variable expressions.
         */
        debouncedFn();
        var filterExpressions = filterexpressions ? (_.isObject(filterexpressions) ? filterexpressions : JSON.parse(filterexpressions)) : {};
        var destroyFn = context.registerDestroyListener ? context.registerDestroyListener.bind(context) : _.noop;
        var filterSubscription = core.processFilterExpBindNode(context, filterExpressions).subscribe(function (response) {
            filterexpressions = JSON.stringify(response.filterExpressions);
            debouncedFn();
        });
        destroyFn(function () { return filterSubscription.unsubscribe(); });
    };
    /**
     * @ngdoc function
     * @name wm.widgets.live.LiveWidgetUtils#getDistinctFieldProperties
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Returns the properties required for dataset widgets
     *
     * @param {object} dataSource variable source for the widget
     * @param {object} formField definition of the column/ field
     *
     */
    var getDistinctFieldProperties = function (dataSource, formField) {
        var props = {};
        var fieldColumn;
        if (formField['is-related']) {
            props.tableName = formField['lookup-type'];
            fieldColumn = formField['lookup-field'];
            props.distinctField = fieldColumn;
            props.aliasColumn = fieldColumn.replace('.', '$'); // For related fields, In response . is replaced by $
            props.filterExpr = formField.filterexpressions ? (_.isObject(formField.filterexpressions) ? formField.filterexpressions : JSON.parse(formField.filterexpressions)) : {};
        }
        else {
            props.tableName = dataSource.execute(core.DataSource.Operation.GET_ENTITY_NAME);
            fieldColumn = formField.field || formField.key;
            props.distinctField = fieldColumn;
            props.aliasColumn = fieldColumn;
        }
        return props;
    };
    /**
     * @ngdoc function
     * @name wm.widgets.live.LiveWidgetUtils#getDistinctValues
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Returns the distinct values for a field
     *
     * @param {object} formField definition of the column/ field
     * @param {string} widget widget property on the field
     * @param {object} variable variable for the widget
     * @param {function} callBack Function to be executed after fetching results
     *
     */
    function getDistinctValues(dataSource, formField, widget) {
        var props;
        return new Promise(function (res, rej) {
            if (isDataSetWidget(formField[widget]) && (!formField.isDataSetBound || widget === 'filterwidget')) {
                props = getDistinctFieldProperties(dataSource, formField);
                dataSource.execute(core.DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS, {
                    fields: props.distinctField,
                    entityName: props.tableName,
                    pagesize: formField.limit,
                    filterExpr: formField.filterexpressions ? JSON.parse(formField.filterexpressions) : {}
                }).then(function (response) {
                    res({ 'field': formField, 'data': response.data, 'aliasColumn': props.aliasColumn });
                }, rej);
            }
        });
    }
    // Set the data field properties on dataset widgets
    function setDataFields(formField, options) {
        // For search widget, set search key and display label
        if (isSearchWidgetType(formField[options.widget])) {
            formField.datafield = options.aliasColumn || LIVE_CONSTANTS.LABEL_KEY;
            formField.searchkey = options.distinctField || LIVE_CONSTANTS.LABEL_KEY;
            formField.displaylabel = formField.displayfield = (options.aliasColumn || LIVE_CONSTANTS.LABEL_VALUE);
            return;
        }
        formField.datafield = LIVE_CONSTANTS.LABEL_KEY;
        formField.displayfield = LIVE_CONSTANTS.LABEL_VALUE;
    }
    /**
     * @ngdoc function
     * @name wm.widgets.live.LiveWidgetUtils#setFieldDataSet
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Function to set the dataSet on the fields
     *
     * @param {object} formField definition of the column/ field
     * @param {object} data data returned from the server
     * @param {string} aliasColumn column field name
     * @param {string} widget widget property on the field
     * @param {boolean} isEnableEmptyFilter is null or empty values allowed on filter
     *
     */
    function setFieldDataSet(formField, data, options) {
        var emptySupportWidgets = [core.FormWidgetType.SELECT, core.FormWidgetType.RADIOSET];
        var emptyOption = {};
        var dataSet = [];
        if (options.isEnableEmptyFilter && _.includes(emptySupportWidgets, formField[options.widget]) &&
            !formField['is-range'] && !formField.multiple) {
            // If empty option is selected, push an empty object in to dataSet
            emptyOption[LIVE_CONSTANTS.LABEL_KEY] = LIVE_CONSTANTS.EMPTY_KEY;
            emptyOption[LIVE_CONSTANTS.LABEL_VALUE] = options.EMPTY_VALUE || LIVE_CONSTANTS.EMPTY_VALUE;
            dataSet.push(emptyOption);
        }
        _.each(data, function (key) {
            var value = key[options.aliasColumn];
            var option = {};
            if (value !== null && value !== '') {
                option[LIVE_CONSTANTS.LABEL_KEY] = value;
                option[LIVE_CONSTANTS.LABEL_VALUE] = value;
                dataSet.push(option);
            }
        });
        setDataFields(formField, options);
        formField.dataset = dataSet;
    }
    /**
     * @ngdoc function
     * @name wm.widgets.live.LiveWidgetUtils#fetchDistinctValues
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Function to fetch the distinct values for a field
     *
     * @param {object} scope scope of the widget
     * @param {object} formFields definitions of the column/ field
     * @param {string} widget widget property on the field
     * @param {boolean} isEnableEmptyFilter is null or empty values allowed on filter
     *
     */
    function fetchDistinctValues(dataSource, formFields, options) {
        if (_.isEmpty(formFields)) {
            return;
        }
        formFields.forEach(function (formField) {
            getDistinctValuesForField(dataSource, formField, options);
        });
    }
    /**
     * @ngdoc function
     * @name wm.widgets.live.LiveWidgetUtils#getDistinctValuesForField
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Function to fetch the distinct values for a field
     *
     * @param {object} scope scope of the widget
     * @param {object} formFields definitions of the column/ field
     * @param {string} widget widget property on the field
     * @param {boolean} isEnableEmptyFilter is null or empty values allowed on filter
     *
     */
    function getDistinctValuesForField(dataSource, formField, options) {
        if (!dataSource || !formField || formField.isDataSetBound) {
            return;
        }
        if (isSearchWidgetType(formField[options.widget])) {
            var dataoptions = getDistinctFieldProperties(dataSource, formField);
            formField.dataoptions = dataoptions;
            setDataFields(formField, Object.assign(options || {}, dataoptions));
            formField.datasource = dataSource;
        }
        else {
            interpolateBindExpressions(formField.viewParent, formField.filterexpressions, function (filterexpressions) {
                formField.filterexpressions = filterexpressions;
                getDistinctValues(dataSource, formField, options.widget).then(function (res) {
                    setFieldDataSet(res.field, res.data, {
                        aliasColumn: res.aliasColumn,
                        widget: options.widget,
                        isEnableEmptyFilter: getEnableEmptyFilter(options.enableemptyfilter),
                        EMPTY_VALUE: options.EMPTY_VALUE
                    });
                });
            });
        }
    }
    function isDefinedAndNotEmpty(val) {
        return core.isDefined(val) && val !== '' && val !== null;
    }
    /**
     * @ngdoc function
     * @name wm.widgets.live.getRangeFieldValue
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Function to get the field value for range
     *
     * @param {string} minValue min value selected
     * @param {string} maxValue max value selected
     */
    function getRangeFieldValue(minValue, maxValue) {
        var fieldValue;
        if (isDefinedAndNotEmpty(minValue) && isDefinedAndNotEmpty(maxValue)) {
            fieldValue = [minValue, maxValue];
        }
        else if (isDefinedAndNotEmpty(minValue)) {
            fieldValue = minValue;
        }
        else if (isDefinedAndNotEmpty(maxValue)) {
            fieldValue = maxValue;
        }
        return fieldValue;
    }
    /**
     * @ngdoc function
     * @name wm.widgets.live.getRangeMatchMode
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Function to get the match mode for range
     *
     * @param {string} minValue min value selected
     * @param {string} maxValue max value selected
     */
    function getRangeMatchMode(minValue, maxValue) {
        var matchMode;
        // If two values exists, then it is between. Otherwise, greater or lesser
        if (isDefinedAndNotEmpty(minValue) && isDefinedAndNotEmpty(maxValue)) {
            matchMode = core.MatchMode.BETWEEN;
        }
        else if (isDefinedAndNotEmpty(minValue)) {
            matchMode = core.MatchMode.GREATER;
        }
        else if (isDefinedAndNotEmpty(maxValue)) {
            matchMode = core.MatchMode.LESSER;
        }
        return matchMode;
    }
    /**
     * @ngdoc function
     * @name wm.widgets.live.getEnableEmptyFilter
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * This function checks if enable filter options is set on live filter
     *
     * @param {object} enableemptyfilter empty filter options
     */
    function getEnableEmptyFilter(enableemptyfilter) {
        return enableemptyfilter && _.intersection(enableemptyfilter.split(','), LIVE_CONSTANTS.NULL_EMPTY).length > 0;
    }
    /**
     * @ngdoc function
     * @name wm.widgets.live.getEmptyMatchMode
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Function to get the match mode based on the filter selected
     *
     * @param {object} enableemptyfilter empty filter options
     */
    function getEmptyMatchMode(enableemptyfilter) {
        var matchMode;
        var emptyFilterOptions = _.split(enableemptyfilter, ',');
        if (_.intersection(emptyFilterOptions, LIVE_CONSTANTS.NULL_EMPTY).length === 2) {
            matchMode = core.MatchMode.NULLOREMPTY;
        }
        else if (_.includes(emptyFilterOptions, LIVE_CONSTANTS.NULL)) {
            matchMode = core.MatchMode.NULL;
        }
        else if (_.includes(emptyFilterOptions, LIVE_CONSTANTS.EMPTY)) {
            matchMode = core.MatchMode.EMPTY;
        }
        return matchMode;
    }
    /**
     * converts the data passed to array.
     *  -> Array: [1,2,3] - [1,2,3]
     *  -> String: a,b,c - ['a','b','c']
     *  -> object: {a:1} - [{a:1}]
     *  -> null - []
     *  -> undefined - []
     * @param data
     * @returns {Array<any>}
     */
    var createArrayFrom = function (data) {
        if (_.isUndefined(data) || _.isNull(data)) {
            return [];
        }
        if (_.isString(data)) {
            data = data.split(',').map(Function.prototype.call, String.prototype.trim);
        }
        if (!_.isArray(data)) {
            data = [data];
        }
        return data;
    };
    /**
     * @ngdoc function
     * @name wm.widgets.live.applyFilterOnField
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * Function to get the updated values when filter on field is changed
     *
     * @param {object} $scope scope of the filter field/form field
     * @param {object} filterDef filter/form definition of the field
     * @param {boolean} isFirst boolean value to check if this method is called on load
     */
    function applyFilterOnField(dataSource, filterDef, formFields, newVal, options) {
        if (options === void 0) {
            options = {};
        }
        var fieldName = filterDef.field || filterDef.key;
        var filterOnFields = _.filter(formFields, { 'filter-on': fieldName });
        newVal = filterDef['is-range'] ? getRangeFieldValue(filterDef.minValue, filterDef.maxValue) : (core.isDefined(newVal) ? newVal : filterDef.value);
        if (!dataSource || (options.isFirst && (_.isUndefined(newVal) || newVal === ''))) {
            return;
        }
        // Loop over the fields for which the current field is filter on field
        _.forEach(filterOnFields, function (filterField) {
            var filterKey = filterField.field || filterField.key;
            var lookUpField = filterDef['lookup-field'] || filterDef._primaryKey;
            var filterWidget = filterField['edit-widget-type'] || filterField.widgettype;
            var filterFields = {};
            var filterOn = filterField['filter-on'];
            var filterVal;
            var fieldColumn;
            var matchMode;
            if (!isDataSetWidget(filterWidget) || filterField.isDataSetBound || filterOn === filterKey) {
                return;
            }
            // For related fields, add lookupfield for query generation
            if (filterDef && filterDef['is-related']) {
                filterOn += '.' + lookUpField;
            }
            if (core.isDefined(newVal)) {
                if (filterDef['is-range']) {
                    matchMode = getRangeMatchMode(filterDef.minValue, filterDef.maxValue);
                }
                else if (getEnableEmptyFilter(options.enableemptyfilter) && newVal === LIVE_CONSTANTS.EMPTY_KEY) {
                    matchMode = getEmptyMatchMode(options.enableemptyfilter);
                }
                else {
                    matchMode = core.MatchMode.EQUALS;
                }
                filterVal = (_.isObject(newVal) && !_.isArray(newVal)) ? newVal[lookUpField] : newVal;
                filterFields[filterOn] = {
                    'value': filterVal,
                    'matchMode': matchMode
                };
            }
            else {
                filterFields = {};
            }
            fieldColumn = filterKey;
            if (isSearchWidgetType(filterWidget) && filterField.dataoptions) {
                filterField.dataoptions.filterFields = filterFields;
            }
            else {
                dataSource.execute(core.DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS, {
                    'fields': fieldColumn,
                    'filterFields': filterFields,
                    'pagesize': filterField.limit
                }).then(function (response) {
                    setFieldDataSet(filterField, response.data, {
                        aliasColumn: fieldColumn,
                        widget: options.widget || 'widgettype',
                        isEnableEmptyFilter: getEnableEmptyFilter(options.enableemptyfilter),
                        EMPTY_VALUE: options.EMPTY_VALUE
                    });
                }, noop);
            }
        });
    }
    // Transform data as required by data table
    function transformData(dataObject, variableName) {
        var newObj, tempArr, keys, oldKeys, numKeys, newObject, tempObj;
        // data sanity testing
        dataObject = dataObject || [];
        // if the dataObject is not an array make it an array
        if (!_.isArray(dataObject)) {
            // if the data returned is of type string, make it an object inside an array
            if (_.isString(dataObject)) {
                keys = variableName.substring(variableName.indexOf('.') + 1, variableName.length).split('.');
                oldKeys = [];
                numKeys = keys.length;
                newObject = {};
                tempObj = newObject;
                // loop over the keys to form appropriate data object required for grid
                keys.forEach(function (key, index) {
                    // loop over old keys to create new object at the iterative level
                    oldKeys.forEach(function (oldKey) {
                        tempObj = newObject[oldKey];
                    });
                    tempObj[key] = index === numKeys - 1 ? dataObject : {};
                    oldKeys.push(key);
                });
                // change the string data to the new dataObject formed
                dataObject = newObject;
            }
            dataObject = [dataObject];
        }
        else {
            /*if the dataObject is an array and each value is a string, then lite-transform the string to an object
             * lite-transform: just checking if the first value is string and then transforming the object, instead of traversing through the whole array
             * */
            if (_.isString(dataObject[0])) {
                tempArr = [];
                _.forEach(dataObject, function (str) {
                    newObj = {};
                    newObj[variableName.split('.').join('-')] = str;
                    tempArr.push(newObj);
                });
                dataObject = tempArr;
            }
        }
        return dataObject;
    }

    var momentLocale = moment.localeData();
    var momentCalendarOptions = core.getClonedObject(momentLocale._calendar);
    var momentCalendarDayOptions = momentLocale._calendarDay || {
        lastDay: '[Yesterday]',
        lastWeek: '[Last] dddd',
        nextDay: '[Tomorrow]',
        nextWeek: 'dddd',
        sameDay: '[Today]',
        sameElse: 'L'
    };
    var GROUP_BY_OPTIONS = {
        ALPHABET: 'alphabet',
        WORD: 'word',
        OTHERS: 'Others'
    };
    var TIME_ROLLUP_OPTIONS = {
        HOUR: 'hour',
        DAY: 'day',
        WEEK: 'week',
        MONTH: 'month',
        YEAR: 'year'
    };
    var ROLLUP_PATTERNS = {
        DAY: 'yyyy-MM-dd',
        WEEK: 'w \'Week\',  yyyy',
        MONTH: 'MMM, yyyy',
        YEAR: 'YYYY',
        HOUR: 'hh:mm a'
    };
    /**
     * function to get the ordered dataset based on the given orderby
     */
    var getOrderedDataset = function (dataSet, orderBy, innerItem) {
        if (!orderBy) {
            return _.cloneDeep(dataSet);
        }
        // The order by only works when the dataset contains list of objects.
        var items = orderBy.split(','), fields = [], directions = [];
        items.forEach(function (obj) {
            var item = obj.split(':');
            fields.push(innerItem ? innerItem + '.' + item[0] : item[0]);
            directions.push(item[1]);
        });
        return _.orderBy(dataSet, fields, directions);
    };
    /**
     * Returns an array of object, each object contain the DataSetItem whose key, value, label are extracted from object keys.
     */
    var transformDataWithKeys = function (dataSet) {
        var data = [];
        // if the dataset is instance of object (not an array) or the first item in the dataset array is an object,
        // then we extract the keys from the object and prepare the dataset items.
        if (_.isObject(dataSet[0]) || (_.isObject(dataSet) && !(dataSet instanceof Array))) {
            // getting keys of the object
            var objectKeys = Object.keys(dataSet[0] || dataSet);
            _.forEach(objectKeys, function (objKey, index) {
                data.push({
                    key: objKey,
                    label: objKey,
                    value: objKey,
                    index: index + 1
                });
            });
        }
        return data;
    };
    // Converts any type of data to array.
    var extractDataAsArray = function (data) {
        if (_.isUndefined(data) || _.isNull(data) || _.trim(data) === '') {
            return [];
        }
        if (_.isString(data)) {
            data = _.split(data, ',').map(function (str) { return str.trim(); });
        }
        if (!_.isArray(data)) {
            data = [data];
        }
        return data;
    };
    // This function return always an object containing dataset details.
    var convertDataToObject = function (dataResult) {
        if (_.isString(dataResult)) {
            dataResult = _.split(dataResult, ',').map(function (str) { return str.trim(); });
        }
        return dataResult;
    };
    /**
     * The first step in datasetItems creation is data transformation:
     *
     * The dataset can contain one of the following formats and each of them to be converted to the given format;
     *
     * 1) The comma separated string..eg: A,B,C => [{ key: 'A', value: 'A'}, { key: 'B', value: 'B'}, { key: 'C', value: 'C'}]
     * 2) The array of values eg: [1,2,3] => [{ key: 1, value: 1}, { key: 2, value: 2}, { key: 3, value: 3}]
     * 3) an object eg: {name: 'A', age: 20} => [ {key: 'name', value: 'A'}, {key: 'age', value: 20}]
     * 4) an array of objects...eg: [ {name: 'A', age: 20}, {name: 'B', age: 20}] ==> returns [{key: _DATAFIELD_, value: _DISPLAYFIELD, label: _DISPLAYVALUE}]
     */
    var transformData$1 = function (context, dataSet, myDataField, displayOptions, startIndex) {
        var data = [];
        if (!dataSet) {
            return;
        }
        dataSet = convertDataToObject(dataSet);
        // startIndex is the index of the next new item.
        if (_.isUndefined(startIndex)) {
            startIndex = 1;
        }
        if (_.isString(dataSet)) {
            dataSet = dataSet.split(',').map(function (str) { return str.trim(); });
            dataSet.forEach(function (option, index) {
                data.push({ key: option, value: option, label: (core.isDefined(option) && option !== null) ? option.toString() : '', index: startIndex + index });
            });
        }
        else if (_.isArray(dataSet) && !_.isObject(dataSet[0])) { // array of primitive values only
            dataSet.forEach(function (option, index) {
                data.push({ key: option, value: option, label: (core.isDefined(option) && option !== null) ? option.toString() : '', index: startIndex + index });
            });
        }
        else if (!(dataSet instanceof Array) && _.isObject(dataSet)) {
            _.forEach(dataSet, function (value, key) {
                data.push({ key: _.trim(key), value: key, label: (core.isDefined(value) && value !== null) ? value.toString() : '', index: startIndex, dataObject: dataSet });
            });
        }
        else {
            if (!myDataField) { // consider the datafield as 'ALLFIELDS' when datafield is not given.
                myDataField = ALLFIELDS;
            }
            dataSet.forEach(function (option, index) {
                var key = myDataField === ALLFIELDS ? startIndex + index : getObjValueByKey(option, myDataField);
                // Omit all the items whose datafield (key) is null or undefined.
                if (!_.isUndefined(key) && !_.isNull(key)) {
                    var label = getEvaluatedData(option, {
                        field: displayOptions.displayField,
                        expression: displayOptions.displayExpr,
                        bindExpression: displayOptions.bindDisplayExpr
                    }, context);
                    var dataSetItem = {
                        key: key,
                        label: (core.isDefined(label) && label !== null) ? label.toString() : '',
                        value: myDataField === ALLFIELDS ? option : key,
                        dataObject: option,
                        index: startIndex + index
                    };
                    if (displayOptions.displayImgSrc || displayOptions.bindDisplayImgSrc) {
                        dataSetItem.imgSrc = getEvaluatedData(option, {
                            expression: displayOptions.displayImgSrc,
                            bindExpression: displayOptions.bindDisplayImgSrc
                        }, context);
                    }
                    data.push(dataSetItem);
                }
            });
        }
        return data;
    };
    /**
     * Private method to get the unique objects by the data field
     */
    var getUniqObjsByDataField = function (data, dataField, displayField, allowEmptyFields) {
        var uniqData;
        var isAllFields = dataField === ALLFIELDS;
        uniqData = isAllFields ? _.uniqWith(data, _.isEqual) : _.uniqBy(data, 'key');
        if (!displayField || allowEmptyFields) {
            return uniqData;
        }
        // return objects having non empty datafield and display field values.
        return _.filter(uniqData, function (obj) {
            if (isAllFields) {
                return _.trim(obj.label);
            }
            return _.trim(obj.key) && _.trim(obj.label);
        });
    };
    /**
     * This method returns sorted data based to groupkey.
     * Returns a array of objects, each object containing key which is groupKey and data is the sorted data which is sorted by groupby field in the data.
     *
     * @param groupedLiData, grouped data object with key as the groupKey and its value as the array of objects grouped under the groupKey.
     * @param groupBy, string groupby property
     * @returns {any[]}
     */
    var getSortedGroupedData = function (groupedLiData, groupBy, orderby) {
        var _groupedData = [];
        _.forEach(_.keys(groupedLiData), function (groupkey, index) {
            var liData = getOrderedDataset(groupedLiData[groupkey], orderby, 'dataObject');
            _groupedData.push({
                key: groupkey,
                data: _.sortBy(liData, function (data) {
                    data._groupIndex = index + 1;
                    return _.get(data, groupBy) || _.get(data.dataObject, groupBy);
                })
            });
        });
        return _groupedData;
    };
    /**
     * This method gets the groupedData using groupby property and match and returns the sorted array of objects.
     *
     * @param compRef represents the component's reference i.e. "this" value.
     * @param data represents the dataset i.e array of objects.
     * @param groupby, string groupby property
     * @param match, string match property
     * @param orderby, string orderby property
     * @param dateformat, string dateFormat property
     * @param innerItem, represents the innerItem on which groupby has to be applied. Incase of datasetItems, 'dataObject' contains the full object. Here innerItem is dataObject.
     * @returns {any[]} groupedData, array of objects, each object having key and data.
     */
    var groupData = function (compRef, data, groupby, match, orderby, dateformat, datePipe, innerItem, AppDefaults) {
        var groupedLiData = {};
        if (_.includes(groupby, '(')) {
            var groupDataByUserDefinedFn_1 = core.$parseEvent(groupby);
            groupedLiData = _.groupBy(data, function (val) {
                return groupDataByUserDefinedFn_1(compRef.viewParent, { 'row': val.dataObject || val });
            });
        }
        else {
            groupedLiData = getGroupedData(data, groupby, match, orderby, dateformat, datePipe, innerItem, AppDefaults);
        }
        return getSortedGroupedData(groupedLiData, groupby, orderby);
    };
    /**
     * This method prepares the grouped data.
     *
     * @param fieldDefs array of objects i.e. dataset
     * @param groupby string groupby
     * @param match string match
     * @param orderby string orderby
     * @param dateFormat string date format
     * @param innerItem, item to look for in the passed data
     */
    var getGroupedData = function (fieldDefs, groupby, match, orderby, dateFormat, datePipe, innerItem, AppDefaults) {
        // For day, set the relevant moment calendar options
        if (match === TIME_ROLLUP_OPTIONS.DAY) {
            momentLocale._calendar = momentCalendarDayOptions;
        }
        // handling case-in-sensitive scenario
        // ordering the data based on groupby field. If there is innerItem then apply orderby using the innerItem's containing the groupby field.
        fieldDefs = _.orderBy(fieldDefs, function (fieldDef) {
            var groupKey = _.get(innerItem ? fieldDef[innerItem] : fieldDef, groupby);
            if (groupKey) {
                return _.toLower(groupKey);
            }
        });
        // extract the grouped data based on the field obtained from 'groupDataByField'.
        var groupedLiData = _.groupBy(fieldDefs, groupDataByField.bind(undefined, groupby, match, innerItem, dateFormat, datePipe, AppDefaults));
        momentLocale._calendar = momentCalendarOptions; // Reset to default moment calendar options
        return groupedLiData;
    };
    // Format the date with given date format
    var filterDate = function (value, format, defaultFormat, datePipe) {
        if (format === 'timestamp') { // For timestamp format, return the epoch value
            return value;
        }
        return core.getFormattedDate(datePipe, value, format || defaultFormat);
    };
    /**
     * This method returns the groupkey based on the rollup (match) passed
     *
     * @param concatStr, string containing groupby field value
     * @param rollUp string containing the match property.
     * @param dateformat string containing the date format to display the date.
     */
    var getTimeRolledUpString = function (concatStr, rollUp, dateformat, datePipe, AppDefaults) {
        var groupByKey, strMoment = moment(concatStr), dateFormat = dateformat;
        var currMoment = moment(), getSameElseFormat = function () {
            return '[' + filterDate(this.valueOf(), dateFormat, ROLLUP_PATTERNS.DAY, datePipe) + ']';
        };
        switch (rollUp) {
            case TIME_ROLLUP_OPTIONS.HOUR:
                dateFormat = dateFormat || AppDefaults.timeFormat;
                // If date is invalid, check if data is in form of hh:mm a
                if (!strMoment.isValid()) {
                    strMoment = moment(new Date().toDateString() + ' ' + concatStr);
                    if (strMoment.isValid()) {
                        // As only time is present, roll up at the hour level with given time format
                        momentLocale._calendar.sameDay = function () {
                            return '[' + filterDate(this.valueOf(), dateFormat, ROLLUP_PATTERNS.HOUR, datePipe) + ']';
                        };
                    }
                }
                // round off to nearest last hour
                strMoment = strMoment.startOf('hour');
                momentLocale._calendar.sameElse = getSameElseFormat;
                groupByKey = strMoment.calendar(currMoment);
                break;
            case TIME_ROLLUP_OPTIONS.WEEK:
                groupByKey = filterDate(strMoment.valueOf(), dateFormat, ROLLUP_PATTERNS.WEEK, datePipe);
                break;
            case TIME_ROLLUP_OPTIONS.MONTH:
                groupByKey = filterDate(strMoment.valueOf(), dateFormat, ROLLUP_PATTERNS.MONTH, datePipe);
                break;
            case TIME_ROLLUP_OPTIONS.YEAR:
                groupByKey = strMoment.format(ROLLUP_PATTERNS.YEAR);
                break;
            case TIME_ROLLUP_OPTIONS.DAY:
                dateFormat = dateFormat || AppDefaults.dateFormat;
                strMoment = strMoment.startOf('day'); // round off to current day
                momentLocale._calendar.sameElse = getSameElseFormat;
                groupByKey = strMoment.calendar(currMoment);
                break;
        }
        // If invalid date is returned, Categorize it as Others.
        if (groupByKey === 'Invalid date') {
            return GROUP_BY_OPTIONS.OTHERS;
        }
        return groupByKey;
    };
    // groups the fields based on the groupby value.
    var groupDataByField = function (groupby, match, innerItem, dateFormat, datePipe, AppDefaults, liData) {
        // get the groupby field value from the liData or innerItem in the liData.
        var concatStr = _.get(innerItem ? liData[innerItem] : liData, groupby);
        // by default set the undefined groupKey as 'others'
        if (_.isUndefined(concatStr) || _.isNull(concatStr) || concatStr.toString().trim() === '') {
            return GROUP_BY_OPTIONS.OTHERS;
        }
        // if match prop is alphabetic ,get the starting alphabet of the word as key.
        if (match === GROUP_BY_OPTIONS.ALPHABET) {
            concatStr = concatStr.substr(0, 1);
        }
        // if match contains the time options then get the concatStr using 'getTimeRolledUpString'
        if (_.includes(_.values(TIME_ROLLUP_OPTIONS), match)) {
            concatStr = getTimeRolledUpString(concatStr, match, dateFormat, datePipe, AppDefaults);
        }
        return concatStr;
    };
    /**
     * This method toggles all the list items inside the each list group.
     * @param el, component reference on which groupby is applied.
     */
    var toggleAllHeaders = function (el) {
        var groups = $(el.nativeElement).find('.item-group');
        groups.find('.group-list-item').toggle();
        // toggle the collapse icon on list header.
        var groupIcons = groups.find('li.list-group-header .app-icon');
        if (groupIcons) {
            _.forEach(groupIcons, function (icon) {
                icon = $(icon);
                if (icon.hasClass('wi-chevron-down')) {
                    icon.removeClass('wi-chevron-down').addClass('wi-chevron-up');
                }
                else {
                    icon.removeClass('wi-chevron-up').addClass('wi-chevron-down');
                }
            });
        }
    };
    /**
     * On list header click, toggle the list items in this group.
     * and also toggle the header icon.
     * @param $event
     */
    var handleHeaderClick = function ($event) {
        var selectedGroup = $($event.target).closest('.item-group'), selectedAppIcon = selectedGroup.find('li.list-group-header .app-icon');
        if (selectedAppIcon.hasClass('wi-chevron-down')) {
            selectedAppIcon.removeClass('wi-chevron-down').addClass('wi-chevron-up');
        }
        else {
            selectedAppIcon.removeClass('wi-chevron-up').addClass('wi-chevron-down');
        }
        selectedGroup.find('.group-list-item').toggle();
    };
    /**
     * configures reordering the items.
     * @param $el element to be sortable
     * @param options object containing the sortable options.
     * @param startCb callback on drag start on the element.
     * @param updateCb callback triggerred when sorting is stopped and the DOM position has changed.
     */
    var configureDnD = function ($el, options, startCb, updateCb) {
        var sortOptions = Object.assign({
            containment: $el,
            delay: 100,
            opacity: 0.8,
            helper: 'clone',
            zIndex: 1050,
            tolerance: 'pointer',
            start: startCb,
            update: updateCb
        }, options);
        $el.sortable(sortOptions);
    };

    var getValidLink = function (link) {
        var routRegex = /^(\/|#\/|#)(?!\W).*/;
        if (link) {
            if (routRegex.test(link)) {
                link = _.first(link.match(/[\w]+.*/g)) || '';
                return "#/" + link;
            }
            if (_.startsWith(link, 'www.')) {
                return "//" + link;
            }
            return link;
        }
    };
    var DatasetAwareNavComponent = /** @class */ (function (_super) {
        __extends(DatasetAwareNavComponent, _super);
        function DatasetAwareNavComponent(inj, WIDGET_CONFIG) {
            var _this = _super.call(this, inj, WIDGET_CONFIG) || this;
            _this.nodes = [];
            // debounce function for reset nodes functions.
            _this._resetNodes = _.debounce(_this.resetNodes, 50);
            _this.securityService = _this.inj.get(security.SecurityService);
            _this.binditemlabel = _this.nativeElement.getAttribute('itemlabel.bind');
            _this.binditemicon = _this.nativeElement.getAttribute('itemicon.bind');
            _this.binditemaction = _this.nativeElement.getAttribute('itemaction.bind');
            _this.binditembadge = _this.nativeElement.getAttribute('itembadge.bind');
            _this.binditemchildren = _this.nativeElement.getAttribute('itemchildren.bind');
            _this.binditemid = _this.nativeElement.getAttribute('itemid.bind');
            _this.binditemlink = _this.nativeElement.getAttribute('itemlink.bind');
            _this.binditemtarget = _this.nativeElement.getAttribute('itemtarget.bind');
            _this.binduserrole = _this.nativeElement.getAttribute('userrole.bind');
            return _this;
        }
        /**
         * constructs individual node for the widget model.
         * @param fields
         * @param node
         */
        DatasetAwareNavComponent.prototype.getNode = function (fields, node) {
            var context = this.viewParent.pageScope || this.viewParent;
            var children = getEvaluatedData(node, { expression: 'itemchildren', bindExpression: this.binditemchildren }, context) || _.get(node, fields.childrenField);
            var navNode = {
                action: getEvaluatedData(node, { expression: 'itemaction', bindExpression: this.binditemaction }, context) || _.get(node, fields.actionField),
                badge: getEvaluatedData(node, { expression: 'itembadge', bindExpression: this.binditembadge }, context) || _.get(node, fields.badgeField),
                children: Array.isArray(children) ? this.getNodes(children) : [],
                class: _.get(node, fields.classField),
                disabled: node.disabled,
                icon: getEvaluatedData(node, { expression: 'itemicon', bindExpression: this.binditemicon }, context) || _.get(node, fields.iconField),
                id: getEvaluatedData(node, { expression: 'itemid', bindExpression: this.binditemid }, context) || _.get(node, fields.idField),
                label: getEvaluatedData(node, { expression: 'itemlabel', bindExpression: this.binditemlabel }, context) || _.get(node, fields.labelField),
                link: getValidLink(getEvaluatedData(node, { expression: 'itemlink', bindExpression: this.binditemlink }, context) || _.get(node, fields.linkField)),
                target: getValidLink(getEvaluatedData(node, { expression: 'itemtarget', bindExpression: this.binditemtarget }, context) || _.get(node, fields.targetField)),
                role: getEvaluatedData(node, { expression: 'userrole', bindExpression: this.binduserrole }, context),
                // older projects have display field & data field property for menu.
                value: this.datafield ? (this.datafield === 'All Fields' ? node : core.findValueOf(node, this.datafield)) : node
            };
            return _.omitBy(navNode, _.isUndefined);
        };
        DatasetAwareNavComponent.prototype.resetItemFieldMap = function () {
            this._itemFieldMap = null;
        };
        DatasetAwareNavComponent.prototype.getItemFieldsMap = function () {
            if (!this._itemFieldMap) {
                this._itemFieldMap = {
                    idField: this.itemid || 'itemid',
                    iconField: this.itemicon || 'icon',
                    labelField: this.itemlabel || 'label',
                    linkField: this.itemlink || 'link',
                    targetField: this.itemtarget || 'target',
                    badgeField: this.itembadge || 'badge',
                    childrenField: this.itemchildren || 'children',
                    classField: this.itemclass || 'class',
                    actionField: this.itemaction || 'action'
                };
            }
            return this._itemFieldMap;
        };
        /**
         * returns array for the value passed as nv.
         * nv: 'a,b' => [{label:a, value:a}, {label:b, value:b}]
         * nv: [1,2] => [{label:1, value:1}, {label:2, value:2}]
         * nv: [{obj}, {obj}] => [{obj}, {obj}]
         * @param nv
         */
        DatasetAwareNavComponent.prototype.prepareNodeDataSet = function (nv) {
            nv = createArrayFrom(nv);
            return nv.map(function (val) {
                if (!core.isObject(val)) {
                    return {
                        label: val,
                        value: val
                    };
                }
                return val;
            });
        };
        /**
         * constructs dataset form the nav elements.
         */
        DatasetAwareNavComponent.prototype.getNodes = function (nv) {
            var _this = this;
            if (nv === void 0) {
                nv = this.dataset || {};
            }
            var nodes = getOrderedDataset(this.prepareNodeDataSet(nv), this.orderby) || [];
            if (nodes.length) {
                var userRole_1 = this.userrole;
                var nodeFields_1 = this.getItemFieldsMap();
                nodes = nodes.reduce(function (result, node) {
                    if (core.validateAccessRoles(node[userRole_1], _this.securityService.loggedInUser)) {
                        result.push(_this.getNode(nodeFields_1, node));
                    }
                    return result;
                }, []);
            }
            return nodes;
        };
        // enable the inherited class to extend this method.
        DatasetAwareNavComponent.prototype.resetNodes = function () {
            this.resetItemFieldMap();
            this.nodes = this.getNodes();
            core.$appDigest();
        };
        DatasetAwareNavComponent.prototype.onPropertyChange = function (key, nv, ov) {
            switch (key) {
                case 'dataset':
                case 'itemicon':
                case 'itemlabel':
                case 'itemlink':
                case 'itemtarget':
                case 'itemclass':
                case 'itemchildren':
                case 'orderby':
                    // calls resetnodes method after 50ms. any calls within 50ms will be ignored.
                    this._resetNodes();
                    break;
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        return DatasetAwareNavComponent;
    }(StylableComponent));

    var DEFAULT_CLS$4 = 'breadcrumb app-breadcrumb';
    var WIDGET_CONFIG$4 = { widgetType: 'wm-breadcrumb', hostClass: DEFAULT_CLS$4 };
    var BreadcrumbComponent = /** @class */ (function (_super) {
        __extends(BreadcrumbComponent, _super);
        function BreadcrumbComponent(inj, route, location, beforeNavigateCB) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$4) || this;
            _this.route = route;
            _this.location = location;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            _this.disableMenuContext = !!beforeNavigateCB;
            return _this;
        }
        /**
         * Gets the first path found based on the key provided inside info Object.
         * @param info - Info object which has properties key(Active Page Name) and isPathFound[boolean] is set true if path found.
         * @param children - a child Object form children Array.
         * @param path - final path.
         * @returns {*|Array}: returns array of objects which represents the final path.
         */
        BreadcrumbComponent.prototype.getPath = function (info, children, path) {
            var _this = this;
            if (path === void 0) {
                path = [];
            }
            children.forEach(function (child) {
                // return if path already found.
                if (info.isPathFound) {
                    return path;
                }
                // if key is matched set path found to true and return the path.
                if (child.id === info.key) {
                    info.isPathFound = true;
                    // only push the child object by omiting the children within it.
                    path.push(child);
                    return path;
                }
                // if the node has children make a recursive call.
                if (child.children.length) {
                    path.push(child);
                    _this.getPath(info, child.children, path);
                    // if path is not found in that node pop the node.
                    if (!info.isPathFound) {
                        path.pop();
                    }
                }
            });
            // return the path.
            return path;
        };
        BreadcrumbComponent.prototype.getCurrentRoute = function () {
            return this.location.path().substr(1).split('?')[0];
        };
        // over rides resetNode function, generating path for the breadcrumb.
        BreadcrumbComponent.prototype.resetNodes = function () {
            _super.prototype.resetNodes.call(this);
            // get path only if the widget have id property.
            if (this.itemid || this.binditemid) {
                this.nodes = this.getPath({ key: this.getCurrentRoute(), isPathFound: false }, this.nodes);
            }
        };
        BreadcrumbComponent.prototype.onItemClick = function ($event, $item) {
            $event.preventDefault();
            var locals = { $item: $item.value, $event: $event };
            var canNavigate = !(this.invokeEventCallback('beforenavigate', locals) === false);
            var linkTarget = $item.target;
            var itemLink = $item.link;
            if (itemLink && canNavigate) {
                if (itemLink.startsWith('#/') && (!linkTarget || linkTarget === '_self')) {
                    var queryParams = core.getUrlParams(itemLink);
                    itemLink = core.getRouteNameFromLink(itemLink);
                    this.route.navigate([itemLink], { queryParams: queryParams });
                }
                else {
                    core.openLink(itemLink, linkTarget);
                }
            }
        };
        BreadcrumbComponent.initializeProps = registerProps$5();
        BreadcrumbComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmBreadcrumb]',
                        template: "<li *ngFor=\"let item of nodes; let last = last; let index = index\" [ngClass]=\"{active: last}\" class=\"{{item.class}}\">\n    <i class=\"{{item.icon}}\"></i>\n    <a [title]=\"item.label\" href=\"javascript:void(0)\" [wmNavigationControl]=\"item.link\" [disableMenuContext]=\"disableMenuContext || !!item.action\" (click)=\"onItemClick($event, item)\" *ngIf=\"!last\" [textContent]=\"item.label\"></a>\n    <label *ngIf=\"last\" [textContent]=\"item.label\"></label>\n</li>\n",
                        providers: [
                            provideAsWidgetRef(BreadcrumbComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        BreadcrumbComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: router.Router },
                { type: common.Location },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['beforenavigate.event',] }] }
            ];
        };
        return BreadcrumbComponent;
    }(DatasetAwareNavComponent));

    var registerProps$6 = function () {
        register('wm-button', new Map([
            ['badgevalue', PROP_STRING],
            ['caption', PROP_STRING],
            ['class', __assign({ value: 'btn-default' }, PROP_STRING)],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['disabled', PROP_BOOLEAN],
            ['hint', PROP_STRING],
            ['iconclass', PROP_STRING],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconposition', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['name', PROP_STRING],
            ['shortcutkey', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['type', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$5 = 'btn app-button';
    var WIDGET_CONFIG$5 = {
        widgetType: 'wm-button',
        hostClass: DEFAULT_CLS$5,
        displayType: DISPLAY_TYPE.INLINE_BLOCK
    };
    var ButtonComponent = /** @class */ (function (_super) {
        __extends(ButtonComponent, _super);
        function ButtonComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$5) || this;
            styler(_this.nativeElement, _this);
            return _this;
        }
        ButtonComponent.initializeProps = registerProps$6();
        ButtonComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'button[wmButton]',
                        template: "<img data-identifier=\"img\" alt=\"button image\" class=\"button-image-icon\" [src]=\"iconurl | image\" *ngIf=\"iconurl\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin}\"/>\n<i class=\"app-icon {{iconclass}}\" aria-hidden=\"true\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin, fontSize:iconwidth}\" *ngIf=\"iconclass\"></i>\n<span class=\"sr-only\" *ngIf=\"iconclass\">{{caption | trustAs:'html'}} {{appLocale.LABEL_ICON}}</span>\n<span class=\"btn-caption\" [innerHTML]=\"caption | trustAs:'html'\"></span>\n<ng-content select=\".caret\"></ng-content>\n<span *ngIf=\"badgevalue\" class=\"badge pull-right\" [textContent]=\"badgevalue\"></span>",
                        providers: [
                            provideAsWidgetRef(ButtonComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        ButtonComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        ButtonComponent.propDecorators = {
            type: [{ type: core$1.HostBinding, args: ['type',] }],
            tabindex: [{ type: core$1.HostBinding, args: ['tabIndex',] }],
            disabled: [{ type: core$1.HostBinding, args: ['disabled',] }],
            shortcutkey: [{ type: core$1.HostBinding, args: ['attr.accesskey',] }],
            iconposition: [{ type: core$1.HostBinding, args: ['attr.icon-position',] }]
        };
        return ButtonComponent;
    }(StylableComponent));

    var registerProps$7 = function () {
        register('wm-buttongroup', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['vertical', PROP_BOOLEAN]
        ]));
    };

    var DEFAULT_CLS$6 = 'btn-group app-button-group';
    var WIDGET_CONFIG$6 = {
        widgetType: 'wm-buttongroup',
        hostClass: DEFAULT_CLS$6
    };
    var ButtonGroupDirective = /** @class */ (function (_super) {
        __extends(ButtonGroupDirective, _super);
        function ButtonGroupDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$6) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        ButtonGroupDirective.initializeProps = registerProps$7();
        ButtonGroupDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmButtonGroup]',
                        providers: [
                            provideAsWidgetRef(ButtonGroupDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        ButtonGroupDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        ButtonGroupDirective.propDecorators = {
            vertical: [{ type: core$1.HostBinding, args: ['class.btn-group-vertical',] }]
        };
        return ButtonGroupDirective;
    }(StylableComponent));

    var registerProps$8 = function () {
        var props = new Map([
            ['calendartype', __assign({ value: 'basic' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['controls', __assign({ value: 'navigation, today, year, month, week, day' }, PROP_STRING)],
            ['dataset', PROP_ANY],
            ['datavalue', PROP_STRING],
            ['eventallday', PROP_STRING],
            ['eventclass', PROP_STRING],
            ['eventend', PROP_STRING],
            ['eventstart', PROP_STRING],
            ['eventtitle', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['showindevice', __assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
            ['view', PROP_STRING],
            ['selectionmode', PROP_STRING]
        ]);
        if (core.isMobileApp()) {
            props.set('view', __assign({ value: 'day' }, PROP_STRING));
        }
        register('wm-calendar', props);
    };

    var DEFAULT_CLS$7 = 'app-calendar';
    var dateFormats = ['yyyy-MM-dd', 'yyyy-M-dd', 'M-dd-yyyy', 'MM-dd-yy', 'yyyy, dd MMMM', 'yyyy, MMM dd', 'MM/dd/yyyy', 'M/d/yyyy', 'EEE, dd MMM yyyy', 'EEE MMM dd yyyy', 'EEEE, MMMM dd, yyyy', 'timestamp'];
    var defaultHeaderOptions = {
        left: 'prev next today',
        center: 'title',
        right: 'month basicWeek basicDay'
    };
    var VIEW_TYPES = {
        BASIC: 'basic',
        AGENDA: 'agenda',
        LIST: 'list'
    };
    var BUTTON_TEXT = {
        YEAR: 'Year',
        MONTH: 'Month',
        WEEK: 'Week',
        DAY: 'Day',
        TODAY: 'Today'
    };
    var SELECTION_MODES = {
        NONE: 'none',
        SINGLE: 'single',
        MULTIPLE: 'multiple'
    };
    var NEXT_DAY_THRESHOLD = {
        START: '00:00',
        END: '24:00'
    };
    var getEventMomentValue = function (value, key) {
        var isDate = false;
        dateFormats.forEach(function (format) {
            // moment supports uppercase formats
            if (moment(value, format.toUpperCase(), true).isValid()) {
                isDate = true;
                return false;
            }
        });
        // if the value is date then for end date the value should be end of the day as the calendar is approximating it to the start.
        if (isDate && key === 'end') {
            return moment(value).endOf('day');
        }
        return moment(value);
    };
    var getUTCDateTime = function (dateObj) {
        dateObj = _.isObject(dateObj) ? dateObj : moment(dateObj);
        var year = dateObj.format('YYYY'), 
        // javascript starts the month count from '0' where as moment returns the human count
        month = dateObj.format('MM') - 1, day = dateObj.format('DD'), hours = dateObj.format('HH'), minutes = dateObj.format('mm'), seconds = dateObj.format('ss');
        return new Date(year, month, day, hours, minutes, seconds);
    };
    var WIDGET_CONFIG$7 = { widgetType: 'wm-calendar', hostClass: DEFAULT_CLS$7 };
    // mobile calendar class names
    var multipleEventClass = 'app-calendar-event';
    var doubleEventClass = multipleEventClass + ' two';
    var singleEventClass = multipleEventClass + ' one';
    var dateFormat = 'YYYY/MM/DD';
    var CalendarComponent = /** @class */ (function (_super) {
        __extends(CalendarComponent, _super);
        function CalendarComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$7) || this;
            _this.controls = 'navigation, today, year, month, week, day';
            _this.eventSources = [];
            _this.dataSetEvents = {
                events: []
            };
            _this.changesStack = [];
            _this.invokeOnViewRenderback = _.debounce(function () { return _this.invokeEventCallback('viewrender', { $view: _this.calendarOptions }); }, 300);
            // calendarOptions to the calendar
            _this.calendarOptions = {
                calendar: {
                    height: 600,
                    eventSources: _this.eventSources,
                    editable: true,
                    locale: core.getSessionStorageItem('selectedLocale') || 'en',
                    selectable: false,
                    header: defaultHeaderOptions,
                    nextDayThreshold: NEXT_DAY_THRESHOLD,
                    views: {
                        month: {
                            eventLimit: 0
                        }
                    },
                    unselectAuto: false,
                    eventDrop: _this.eventDrop.bind(_this),
                    eventResizeStart: _this.onEventChangeStart.bind(_this),
                    eventDragStart: _this.onEventChangeStart.bind(_this),
                    eventResize: _this.eventResize.bind(_this),
                    eventClick: _this.eventClick.bind(_this),
                    select: _this.select.bind(_this),
                    eventRender: _this.eventRender.bind(_this),
                    viewRender: _this.viewRender.bind(_this)
                }
            };
            _this.dayClass = [];
            _this.mobileCalendar = core.isMobile();
            _this.eventSources.push(_this.dataSetEvents);
            return _this;
        }
        // this function selects the default date given for the calendar
        CalendarComponent.prototype.selectDate = function () {
            var start, end;
            if (_.isObject(this.datavalue)) {
                start = this.datavalue.start;
                end = this.datavalue.end;
            }
            else {
                start = moment(this.datavalue);
                end = moment(this.datavalue).add(1, 'day').startOf('day');
            }
            this.$fullCalendar.fullCalendar('gotoDate', start); // after selecting the date go to the date.
            this.$fullCalendar.fullCalendar('select', start, end);
        };
        // changes the calendar view to the default date given for the calendar.
        CalendarComponent.prototype.gotoDate = function () {
            this.$fullCalendar.fullCalendar('gotoDate', moment(this.datavalue));
        };
        // this function takes the calendar view to the a year ahead
        CalendarComponent.prototype.gotoNextYear = function () {
            this.$fullCalendar.fullCalendar('nextYear');
        };
        // this function takes the calendar view to the a year before
        CalendarComponent.prototype.gotoPrevYear = function () {
            this.$fullCalendar.fullCalendar('prevYear');
        };
        /**
         * this function takes the calendar view to the specified month
         * @param monthVal, 1-12 value of month
         */
        CalendarComponent.prototype.gotoMonth = function (monthVal) {
            var presentDay = this.$fullCalendar.fullCalendar('getDate');
            var presentMonthVal = new Date(presentDay).getMonth();
            if (presentMonthVal < monthVal) {
                this.$fullCalendar.fullCalendar('gotoDate', presentDay.add(monthVal - presentMonthVal - 1, 'M'));
            }
            else {
                this.$fullCalendar.fullCalendar('gotoDate', presentDay.subtract(presentMonthVal - monthVal + 1, 'M'));
            }
        };
        // this function takes the calendar view to the a month ahead
        CalendarComponent.prototype.gotoNextMonth = function () {
            var presentDay = this.$fullCalendar.fullCalendar('getDate');
            this.$fullCalendar.fullCalendar('gotoDate', presentDay.add(1, 'M'));
        };
        // this function takes the calendar view to the a month before
        CalendarComponent.prototype.gotoPrevMonth = function () {
            var presentDay = this.$fullCalendar.fullCalendar('getDate');
            this.$fullCalendar.fullCalendar('gotoDate', presentDay.subtract(1, 'M'));
        };
        // this function re-renders the events assigned to the calendar.
        CalendarComponent.prototype.rerenderEvents = function () {
            this.$fullCalendar.fullCalendar('rerenderEvents');
        };
        CalendarComponent.prototype.setSelectedData = function (start, end) {
            var dataset = this.dataset;
            if (!dataset) {
                return;
            }
            var filteredDates = [];
            var eventStartKey = this.eventstart || 'start';
            var eventEndKey = this.eventend || 'end';
            var startDate = moment(new Date(start)).format('MM/DD/YYYY');
            var endDate = moment(new Date(end)).subtract(1, 'days').format('MM/DD/YYYY');
            dataset = dataset.data || dataset;
            dataset.forEach(function (value) {
                if (!value[eventStartKey]) {
                    return;
                }
                var eventStartDate = moment(new Date(value[eventStartKey])).format('MM/DD/YYYY');
                var eventEndDate = moment(new Date(value[eventEndKey] || value[eventStartKey])).format('MM/DD/YYYY');
                var eventExists = moment(eventStartDate).isSameOrAfter(startDate) && moment(eventEndDate).isSameOrBefore(endDate);
                if (eventExists) {
                    filteredDates.push(value);
                }
            });
            return filteredDates;
        };
        CalendarComponent.prototype.eventDrop = function ($newData, $delta, $revertFunc, $event, $ui, $view) {
            this.invokeEventCallback('eventdrop', { $event: $event, $newData: $newData, $oldData: this.oldData, $delta: $delta, $revertFunc: $revertFunc, $ui: $ui, $view: $view });
        };
        CalendarComponent.prototype.select = function (start, end, jsEvent, $view) {
            this.selecteddates = { start: getUTCDateTime(start), end: getUTCDateTime(end) };
            this.selecteddata = this.setSelectedData(start, end);
            this.invokeEventCallback('select', { $start: start.valueOf(), $end: end.valueOf(), $view: $view, $data: this.selecteddata });
        };
        CalendarComponent.prototype.eventResize = function ($newData, $delta, $revertFunc, $event, $ui, $view) {
            this.invokeEventCallback('eventresize', { $event: $event, $newData: $newData, $oldData: this.oldData, $delta: $delta, $revertFunc: $revertFunc, $ui: $ui, $view: $view });
        };
        CalendarComponent.prototype.onEventChangeStart = function (event) {
            this.oldData = core.getClonedObject(event);
        };
        CalendarComponent.prototype.eventClick = function ($data, $event, $view) {
            this.invokeEventCallback('eventclick', { $event: $event, $data: $data, $view: $view });
        };
        CalendarComponent.prototype.eventRender = function ($data, $event, $view) {
            if (this.calendartype === VIEW_TYPES.LIST) {
                this.$fullCalendar.find('.fc-list-table').addClass('table');
            }
            this.invokeEventCallback('eventrender', { $event: $event, $data: $data, $view: $view });
        };
        CalendarComponent.prototype.viewRender = function ($view) {
            this.currentview = { start: $view.start.format(), end: $view.end.subtract(1, 'days').format() };
            if (this.calendartype === VIEW_TYPES.LIST) {
                this.$fullCalendar.find('.fc-list-table').addClass('table');
            }
            this.invokeEventCallback('viewrender', { $view: $view });
        };
        // update the calendar header options once the controls changes
        CalendarComponent.prototype.updateCalendarHeaderOptions = function () {
            var ctrls = this.controls, viewType = this.calendartype, regEx = new RegExp('\\bday\\b', 'g');
            var left = '', right = '';
            if (ctrls && viewType) {
                if (_.includes(ctrls, 'navigation')) {
                    left += ' prev next';
                }
                if (_.includes(ctrls, 'today')) {
                    left += ' today';
                }
                if (_.includes(ctrls, 'year')) {
                    right += (viewType === VIEW_TYPES.LIST) ? 'listYear' : '';
                }
                if (_.includes(ctrls, 'month')) {
                    right += (viewType === VIEW_TYPES.LIST) ? ' listMonth' : ' month';
                }
                if (_.includes(ctrls, 'week')) {
                    right += (viewType === VIEW_TYPES.BASIC) ? ' basicWeek' : (viewType === VIEW_TYPES.LIST) ? ' listWeek' : ' agendaWeek';
                }
                if (regEx.test(ctrls)) {
                    right += (viewType === VIEW_TYPES.BASIC) ? ' basicDay' : (viewType === VIEW_TYPES.LIST) ? ' listDay' : ' agendaDay';
                }
                _.extend(this.calendarOptions.calendar.header, { 'left': left, 'right': right });
            }
        };
        // to calculate the height for the event limit and parsing the value when it is percentage based.
        CalendarComponent.prototype.calculateHeight = function (height) {
            var $parent = $(this.nativeElement).parent(), elHeight = height || '650px';
            var parentHeight = $parent.css('height'), computedHeight;
            if (_.includes(elHeight, '%')) {
                if (_.includes(parentHeight, '%')) {
                    parentHeight = $parent.height();
                }
                computedHeight = (parseInt(parentHeight, 10) * Number(elHeight.replace(/\%/g, ''))) / 100;
            }
            else {
                computedHeight = parseInt(elHeight, 10);
            }
            this.calendarOptions.calendar.views.month.eventLimit = parseInt('' + computedHeight / 200, 10) + 1;
            return computedHeight;
        };
        CalendarComponent.prototype.triggerMobileCalendarChange = function () {
            this.prepareCalendarEvents();
            // change the model so that the view is rendered again with the events , after the dataset is changed.
            this.proxyModel = this.proxyModel || moment().valueOf();
            this.selecteddates = {
                start: moment(this.proxyModel).valueOf(),
                end: moment(this.proxyModel).endOf('day').valueOf()
            };
            this.invokeEventCallback('eventrender', { $data: this.eventData });
        };
        // prepares events for the mobie calendar
        CalendarComponent.prototype.prepareCalendarEvents = function () {
            var _this = this;
            var eventDay, dataset;
            this.eventData = {};
            if (!this.dataset) {
                return;
            }
            dataset = this.dataset;
            dataset = _.isArray(dataset) ? dataset : (_.isObject(dataset) ? [dataset] : []);
            this.events = dataset || this.constructCalendarDataset(dataset);
            this.events.forEach(function (event) {
                var eventStart = event.start || event[_this.eventstart];
                if (eventStart) {
                    eventDay = moment(eventStart).startOf('day').format(dateFormat);
                    if (_this.eventData[eventDay]) {
                        _this.eventData[eventDay].push(event);
                    }
                    else {
                        _this.eventData[eventDay] = [event];
                    }
                    if (_this.mobileCalendar) {
                        // custom class on the date in the date picker.
                        _this.dayClass.push({
                            date: new Date(eventStart).setHours(0, 0, 0, 0),
                            mode: 'day',
                            clazz: _this.getDayClass({ eventDay: eventDay })
                        });
                    }
                }
            });
            // add the eventData on the calendar by calling refreshView
            if (this.mobileCalendar && this._datepickerInnerComponent) {
                this._datepickerInnerComponent.refreshView();
            }
        };
        // constructs the calendar dataset by mapping the eventstart, eventend, eventtitle etc.,
        CalendarComponent.prototype.constructCalendarDataset = function (eventSource) {
            var _this = this;
            var properties = {
                title: this.eventtitle || 'title',
                allDay: this.eventallday || 'allday',
                start: this.eventstart || 'start',
                end: this.eventend || 'end',
                className: this.eventclass || 'className'
            };
            eventSource.forEach(function (obj) {
                _.mapKeys(properties, function (value, key) {
                    var objVal;
                    if (key === 'title') {
                        objVal = getEvaluatedData(obj, { expression: value }, _this.viewParent);
                    }
                    else if (key === 'allDay') {
                        objVal = !!_.get(obj, value);
                    }
                    else {
                        objVal = _.get(obj, value);
                    }
                    if (!objVal) {
                        return;
                    }
                    if (key === 'start' || key === 'end') {
                        objVal = getEventMomentValue(objVal, key);
                    }
                    obj[key] = objVal;
                });
            });
            return eventSource;
        };
        CalendarComponent.prototype.setLocale = function () {
            var year = _.get(this.appLocale, 'LABEL_CALENDAR_YEAR') || BUTTON_TEXT.YEAR;
            var month = _.get(this.appLocale, 'LABEL_CALENDAR_MONTH') || BUTTON_TEXT.MONTH;
            var week = _.get(this.appLocale, 'LABEL_CALENDAR_WEEK') || BUTTON_TEXT.WEEK;
            var day = _.get(this.appLocale, 'LABEL_CALENDAR_DAY') || BUTTON_TEXT.DAY;
            var today = _.get(this.appLocale, 'LABEL_CALENDAR_TODAY') || BUTTON_TEXT.TODAY;
            this.calendarOptions.calendar.buttonText = { year: year, month: month, week: week, day: day, today: today,
                'listYear': year,
                'listMonth': month,
                'listWeek': week,
                'listDay': day
            };
        };
        CalendarComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            styler(this.nativeElement, this, exports.APPLY_STYLES_TYPE.CONTAINER, ['height']);
            if (this.mobileCalendar) {
                if (!this.view || this.view === 'week') {
                    this.view = 'day';
                }
                this.triggerMobileCalendarChange();
            }
            else {
                this.setLocale();
            }
        };
        CalendarComponent.prototype.onStyleChange = function (key, nv, ov) {
            _super.prototype.onStyleChange.call(this, key, nv, ov);
            if (key === 'height') {
                this.calendarOptions.calendar.height = this.calculateHeight(nv);
                this.updateCalendarOptions('option', 'height', this.calendarOptions.calendar.height);
            }
        };
        CalendarComponent.prototype.onPropertyChange = function (key, nv, ov) {
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
            switch (key) {
                case 'selectionmode':
                    if (nv !== SELECTION_MODES.NONE) {
                        this.calendarOptions.calendar.selectable = true;
                        this.updateCalendarOptions('option', 'selectable', true);
                        if (nv === SELECTION_MODES.SINGLE) {
                            this.calendarOptions.calendar.selectConstraint = {
                                start: '00:00',
                                end: '24:00'
                            };
                            this.updateCalendarOptions('option', 'selectConstraint', this.calendarOptions.calendar.selectConstraint);
                        }
                        else {
                            this.updateCalendarOptions('option', 'selectConstraint', {});
                        }
                    }
                    else {
                        this.calendarOptions.calendar.selectable = false;
                        this.updateCalendarOptions('option', 'selectable', false);
                    }
                    break;
                case 'view':
                    if (nv !== 'month' || this.calendartype === VIEW_TYPES.LIST) {
                        this.calendarOptions.calendar.defaultView = this.calendartype + _.capitalize(nv);
                    }
                    else {
                        this.calendarOptions.calendar.defaultView = nv;
                    }
                    this.updateCalendarOptions('changeView', this.calendarOptions.calendar.defaultView);
                    break;
                case 'calendartype':
                    this.calendartype = nv || 'basic';
                case 'controls':
                    this.updateCalendarHeaderOptions();
                    break;
                case 'dataset':
                    var dataSet = void 0;
                    this.dataset = nv;
                    dataSet = createArrayFrom(core.getClonedObject(nv));
                    dataSet = this.constructCalendarDataset(dataSet);
                    this.dataSetEvents.events = dataSet.filter(function (event) {
                        event.start = event.start || event.end;
                        if (event.start) {
                            return true;
                        }
                    });
                    if (this.mobileCalendar) {
                        this.triggerMobileCalendarChange();
                    }
                    else {
                        this.updateCalendarOptions('removeEvents');
                        this.updateCalendarOptions('addEventSource', this.dataSetEvents.events);
                        this.updateCalendarOptions('rerenderEvents');
                    }
                    break;
            }
        };
        // Returns the default date when the datavalue is provided
        CalendarComponent.prototype.getDefaultDate = function () {
            if (this.datavalue) {
                return new Date(this.datavalue);
            }
        };
        CalendarComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            if (this.mobileCalendar && this._datepicker) {
                var lastActiveDate_1 = this._datepicker.activeDate;
                // renderview when active date changes
                this._datepicker.activeDateChange.subscribe(function (dt) {
                    var prevYear = lastActiveDate_1.getYear();
                    var prevMonth = lastActiveDate_1.getMonth();
                    var selectedYear = dt.getYear();
                    var selectedMonth = dt.getMonth();
                    // invoke renderView only when month is changed.
                    if (prevMonth !== selectedMonth || prevYear !== selectedYear) {
                        lastActiveDate_1 = dt;
                        _this.renderMobileView(dt);
                    }
                });
                this._datepickerInnerComponent = this._datepicker._datePicker;
                this.renderMobileView(moment(this.datavalue));
                this.registerDestroyListener(core.$watch('_datepickerInnerComponent.datepickerMode', this, {}, function (nv, ov) {
                    if (ov && !_.isEmpty(ov)) {
                        _this.invokeOnViewRenderback();
                    }
                }));
                return;
            }
            this.$fullCalendar = $(this._calendar.nativeElement);
            this.$fullCalendar.fullCalendar(this.calendarOptions.calendar);
            // if the changes are already stacked before calendar renders then execute them when needed
            if (this.changesStack.length) {
                this.changesStack.forEach(function (changeObj) {
                    _this.$fullCalendar.fullCalendar(changeObj.operationType, changeObj.argumentKey, changeObj.argumentValue);
                });
                this.changesStack.length = 0;
            }
        };
        CalendarComponent.prototype.updateCalendarOptions = function (operationType, argumentKey, argumentValue) {
            if (!this.$fullCalendar) {
                this.changesStack.push({
                    operationType: operationType,
                    argumentKey: argumentKey,
                    argumentValue: argumentValue
                });
                return;
            }
            this.$fullCalendar.fullCalendar(operationType, argumentKey, argumentValue);
        };
        CalendarComponent.prototype.redraw = function () {
            this.updateCalendarOptions('render');
        };
        // on date change invoke the select event, and if date has event on it then invoke the event click.
        CalendarComponent.prototype.onValueChange = function (value) {
            this.proxyModel = value;
            var selectedDate = this.proxyModel && moment(this.proxyModel).startOf('day').format(dateFormat), selectedEventData = this.eventData[selectedDate], start = moment(this.proxyModel), end = moment(this.proxyModel).endOf('day');
            this.selecteddata = selectedEventData;
            this.selecteddates = {
                'start': moment(selectedDate).valueOf(),
                'end': moment(selectedDate).endOf('day').valueOf()
            };
            this.calendarOptions.calendar.select(start.valueOf(), end.valueOf(), {}, this, selectedEventData);
            if (selectedEventData) {
                this.calendarOptions.calendar.eventClick(selectedEventData, {}, this);
            }
        };
        // returns the custom class for the events depending on the length of the events for that day.
        CalendarComponent.prototype.getDayClass = function (data) {
            var eventDay = data.eventDay;
            if (!_.isEmpty(this.eventData) && this.eventData[eventDay]) {
                var eventsLength = this.eventData[eventDay].length;
                if (eventsLength === 1) {
                    return singleEventClass;
                }
                if (eventsLength === 2) {
                    return doubleEventClass;
                }
                return multipleEventClass;
            }
            return '';
        };
        // sets the current view and invokes the viewrender method.
        CalendarComponent.prototype.renderMobileView = function (viewObj) {
            var startDate, endDate;
            if (!viewObj) {
                return;
            }
            startDate = moment(viewObj).startOf('month').valueOf();
            endDate = moment(viewObj).endOf('month').valueOf();
            this.currentview = { start: startDate, end: endDate };
            this.invokeOnViewRenderback();
        };
        CalendarComponent.initializeProps = registerProps$8();
        CalendarComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmCalendar]',
                        template: "<div *ngIf=\"!mobileCalendar\" #calendar></div>\n\n<datepicker *ngIf=\"mobileCalendar\" #datepicker [(ngModel)]=\"proxyModel\"\n            [initDate]=\"getDefaultDate()\"\n            [minDate]=\"minDate\"\n            [datepickerMode]=\"view\"\n            [showWeeks]=\"false\"\n            [customClass]=\"dayClass\"\n            (selectionDone)=\"onValueChange($event)\">\n</datepicker>\n\n\n\n",
                        providers: [
                            provideAsWidgetRef(CalendarComponent)
                        ],
                        encapsulation: core$1.ViewEncapsulation.None,
                        styles: ["/*!\n * FullCalendar v3.10.0\n * Docs & License: https://fullcalendar.io/\n * (c) 2018 Adam Shaw\n */.fc{direction:ltr;text-align:left}.fc-rtl{text-align:right}body .fc{font-size:1em}.fc-highlight{background:#bce8f1;opacity:.3}.fc-bgevent{background:#8fdf82;opacity:.3}.fc-nonbusiness{background:#d7d7d7}.fc button{box-sizing:border-box;margin:0;height:2.1em;padding:0 .6em;font-size:1em;white-space:nowrap;cursor:pointer}.fc button::-moz-focus-inner{margin:0;padding:0}.fc-state-default{border:1px solid;background-color:#f5f5f5;background-image:linear-gradient(to bottom,#fff,#e6e6e6);background-repeat:repeat-x;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);color:#333;text-shadow:0 1px 1px rgba(255,255,255,.75);box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05)}.fc-state-default.fc-corner-left{border-top-left-radius:4px;border-bottom-left-radius:4px}.fc-state-default.fc-corner-right{border-top-right-radius:4px;border-bottom-right-radius:4px}.fc button .fc-icon{position:relative;top:-.05em;margin:0 .2em;vertical-align:middle}.fc-state-active,.fc-state-disabled,.fc-state-down,.fc-state-hover{color:#333;background-color:#e6e6e6}.fc-state-hover{color:#333;text-decoration:none;background-position:0 -15px;transition:background-position .1s linear}.fc-state-active,.fc-state-down{background-color:#ccc;background-image:none;box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05)}.fc-state-disabled{cursor:default;background-image:none;opacity:.65;box-shadow:none}.fc-button-group{display:inline-block}.fc .fc-button-group>*{float:left;margin:0 0 0 -1px}.fc .fc-button-group>:first-child{margin-left:0}.fc-popover{position:absolute;box-shadow:0 2px 6px rgba(0,0,0,.15)}.fc-popover .fc-header{padding:2px 4px}.fc-popover .fc-header .fc-title{margin:0 2px}.fc-popover .fc-header .fc-close{cursor:pointer}.fc-ltr .fc-popover .fc-header .fc-title,.fc-rtl .fc-popover .fc-header .fc-close{float:left}.fc-ltr .fc-popover .fc-header .fc-close,.fc-rtl .fc-popover .fc-header .fc-title{float:right}.fc-divider{border-style:solid;border-width:1px}hr.fc-divider{height:0;margin:0;padding:0 0 2px;border-width:1px 0}.fc-clear{clear:both}.fc-bg,.fc-bgevent-skeleton,.fc-helper-skeleton,.fc-highlight-skeleton{position:absolute;top:0;left:0;right:0}.fc-bg{bottom:0}.fc-bg table{height:100%}.fc table{width:100%;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{border-style:solid;border-width:1px;padding:0;vertical-align:top}.fc td.fc-today{border-style:double}a[data-goto]{cursor:pointer}a[data-goto]:hover{text-decoration:underline}.fc .fc-row{border-style:solid;border-width:0}.fc-row table{border-left:0 hidden transparent;border-right:0 hidden transparent;border-bottom:0 hidden transparent}.fc-row:first-child table{border-top:0 hidden transparent}.fc-row{position:relative}.fc-row .fc-bg{z-index:1}.fc-row .fc-bgevent-skeleton,.fc-row .fc-highlight-skeleton{bottom:0}.fc-row .fc-bgevent-skeleton table,.fc-row .fc-highlight-skeleton table{height:100%}.fc-row .fc-bgevent-skeleton td,.fc-row .fc-highlight-skeleton td{border-color:transparent}.fc-row .fc-bgevent-skeleton{z-index:2}.fc-row .fc-highlight-skeleton{z-index:3}.fc-row .fc-content-skeleton{position:relative;z-index:4;padding-bottom:2px}.fc-row .fc-helper-skeleton{z-index:5}.fc .fc-row .fc-content-skeleton table,.fc .fc-row .fc-content-skeleton td,.fc .fc-row .fc-helper-skeleton td{background:0 0;border-color:transparent}.fc-row .fc-content-skeleton td,.fc-row .fc-helper-skeleton td{border-bottom:0}.fc-row .fc-content-skeleton tbody td,.fc-row .fc-helper-skeleton tbody td{border-top:0}.fc-scroller{-webkit-overflow-scrolling:touch}.fc-scroller>.fc-day-grid,.fc-scroller>.fc-time-grid{position:relative;width:100%}.fc-event{position:relative;display:block;font-size:.85em;line-height:1.3;border-radius:3px;border:1px solid #3a87ad}.fc-event,.fc-event-dot{background-color:#3a87ad}.fc-event,.fc-event:hover{color:#fff;text-decoration:none}.fc-event.fc-draggable,.fc-event[href]{cursor:pointer}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc-event .fc-bg{z-index:1;background:#fff;opacity:.25}.fc-event .fc-content{position:relative;z-index:2}.fc-event .fc-resizer{position:absolute;z-index:4;display:none}.fc-event.fc-allow-mouse-resize .fc-resizer,.fc-event.fc-selected .fc-resizer{display:block}.fc-event.fc-selected .fc-resizer:before{content:\"\";position:absolute;z-index:9999;top:50%;left:50%;width:40px;height:40px;margin-left:-20px;margin-top:-20px}.fc-event.fc-selected{z-index:9999!important;box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event.fc-selected.fc-dragging{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-h-event.fc-selected:before{content:\"\";position:absolute;z-index:3;top:-10px;bottom:-10px;left:0;right:0}.fc-ltr .fc-h-event.fc-not-start,.fc-rtl .fc-h-event.fc-not-end{margin-left:0;border-left-width:0;padding-left:1px;border-top-left-radius:0;border-bottom-left-radius:0}.fc-ltr .fc-h-event.fc-not-end,.fc-rtl .fc-h-event.fc-not-start{margin-right:0;border-right-width:0;padding-right:1px;border-top-right-radius:0;border-bottom-right-radius:0}.fc-ltr .fc-h-event .fc-start-resizer,.fc-rtl .fc-h-event .fc-end-resizer{cursor:w-resize;left:-1px}.fc-ltr .fc-h-event .fc-end-resizer,.fc-rtl .fc-h-event .fc-start-resizer{cursor:e-resize;right:-1px}.fc-h-event.fc-allow-mouse-resize .fc-resizer{width:7px;top:-1px;bottom:-1px}.fc-h-event.fc-selected .fc-resizer{border-radius:4px;width:6px;height:6px;background:#fff;top:50%;margin-top:-4px;border:1px solid;border-color:inherit}.fc-ltr .fc-h-event.fc-selected .fc-start-resizer,.fc-rtl .fc-h-event.fc-selected .fc-end-resizer{margin-left:-4px}.fc-ltr .fc-h-event.fc-selected .fc-end-resizer,.fc-rtl .fc-h-event.fc-selected .fc-start-resizer{margin-right:-4px}.fc-day-grid-event{margin:1px 2px 0;padding:0 1px}tr:first-child>td>.fc-day-grid-event{margin-top:2px}.fc-day-grid-event.fc-selected:after{content:\"\";position:absolute;z-index:1;top:-1px;right:-1px;bottom:-1px;left:-1px;background:#000;opacity:.25}.fc-day-grid-event .fc-content{white-space:nowrap;overflow:hidden}.fc-day-grid-event .fc-time{font-weight:700}.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer,.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer{margin-left:-2px}.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer,.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer{margin-right:-2px}a.fc-more{margin:1px 3px;font-size:.85em;cursor:pointer;text-decoration:none}a.fc-more:hover{text-decoration:underline}.fc-limited{display:none}.fc-day-grid .fc-row{z-index:1}.fc-more-popover{z-index:2;width:220px}.fc-more-popover .fc-event-container{padding:10px}.fc-now-indicator{position:absolute;border:0 solid red}.fc-unselectable{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent}.fc-unthemed .fc-content,.fc-unthemed .fc-divider,.fc-unthemed .fc-list-heading td,.fc-unthemed .fc-list-view,.fc-unthemed .fc-popover,.fc-unthemed .fc-row,.fc-unthemed tbody,.fc-unthemed td,.fc-unthemed th,.fc-unthemed thead{border-color:#ddd}.fc-unthemed .fc-popover{background-color:#fff;border-width:1px;border-style:solid}.fc-unthemed .fc-divider,.fc-unthemed .fc-list-heading td,.fc-unthemed .fc-popover .fc-header{background:#eee}.fc-unthemed .fc-popover .fc-header .fc-close{color:#666;font-size:.9em;margin-top:2px}.fc-unthemed td.fc-today{background:#fcf8e3}.fc-unthemed .fc-disabled-day{background:#d7d7d7;opacity:.3}.fc-icon{display:inline-block;height:1em;line-height:1em;font-size:1em;text-align:center;overflow:hidden;font-family:\"Courier New\",Courier,monospace;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.fc-icon:after{position:relative}.fc-icon-left-single-arrow:after{content:\"\\2039\";font-weight:700;font-size:200%;top:-7%}.fc-icon-right-single-arrow:after{content:\"\\203A\";font-weight:700;font-size:200%;top:-7%}.fc-icon-left-double-arrow:after{content:\"\\AB\";font-size:160%;top:-7%}.fc-icon-right-double-arrow:after{content:\"\\BB\";font-size:160%;top:-7%}.fc-icon-left-triangle:after{content:\"\\25C4\";font-size:125%;top:3%}.fc-icon-right-triangle:after{content:\"\\25BA\";font-size:125%;top:3%}.fc-icon-down-triangle:after{content:\"\\25BC\";font-size:125%;top:2%}.fc-icon-x:after{content:\"\\D7\";font-size:200%;top:6%}.fc-unthemed .fc-list-item:hover td{background-color:#f5f5f5}.ui-widget .fc-disabled-day{background-image:none}.fc-popover>.ui-widget-header+.ui-widget-content{border-top:0}.ui-widget .fc-event{color:#fff;text-decoration:none;font-weight:400}.ui-widget td.fc-axis{font-weight:400}.fc-time-grid .fc-slats .ui-widget-content{background:0 0}.fc.fc-bootstrap3 a{text-decoration:none}.fc.fc-bootstrap3 a[data-goto]:hover{text-decoration:underline}.fc-bootstrap3 hr.fc-divider{border-color:inherit}.fc-bootstrap3 .fc-today.alert{border-radius:0}.fc-bootstrap3 .fc-popover .panel-body{padding:0}.fc-bootstrap3 .fc-time-grid .fc-slats table{background:0 0}.fc.fc-bootstrap4 a{text-decoration:none}.fc.fc-bootstrap4 a[data-goto]:hover{text-decoration:underline}.fc-bootstrap4 hr.fc-divider{border-color:inherit}.fc-bootstrap4 .fc-today.alert{border-radius:0}.fc-bootstrap4 a.fc-event:not([href]):not([tabindex]){color:#fff}.fc-bootstrap4 .fc-popover.card{position:absolute}.fc-bootstrap4 .fc-popover .card-body{padding:0}.fc-bootstrap4 .fc-time-grid .fc-slats table{background:0 0}.fc-toolbar{text-align:center}.fc-toolbar.fc-header-toolbar{margin-bottom:1em}.fc-toolbar.fc-footer-toolbar{margin-top:1em}.fc-toolbar .fc-left{float:left}.fc-toolbar .fc-right{float:right}.fc-toolbar .fc-center{display:inline-block}.fc .fc-toolbar>*>*{float:left;margin-left:.75em}.fc .fc-toolbar>*>:first-child{margin-left:0}.fc-toolbar h2{margin:0}.fc-toolbar button{position:relative}.fc-toolbar .fc-state-hover,.fc-toolbar .ui-state-hover{z-index:2}.fc-toolbar .fc-state-down{z-index:3}.fc-toolbar .fc-state-active,.fc-toolbar .ui-state-active{z-index:4}.fc-toolbar button:focus{z-index:5}.fc-view-container *,.fc-view-container :after,.fc-view-container :before{box-sizing:content-box}.fc-view,.fc-view>table{position:relative;z-index:1}.fc-basicDay-view .fc-content-skeleton,.fc-basicWeek-view .fc-content-skeleton{padding-bottom:1em}.fc-basic-view .fc-body .fc-row{min-height:4em}.fc-row.fc-rigid{overflow:hidden}.fc-row.fc-rigid .fc-content-skeleton{position:absolute;top:0;left:0;right:0}.fc-day-top.fc-other-month{opacity:.3}.fc-basic-view .fc-day-number,.fc-basic-view .fc-week-number{padding:2px}.fc-basic-view th.fc-day-number,.fc-basic-view th.fc-week-number{padding:0 2px}.fc-ltr .fc-basic-view .fc-day-top .fc-day-number{float:right}.fc-rtl .fc-basic-view .fc-day-top .fc-day-number{float:left}.fc-ltr .fc-basic-view .fc-day-top .fc-week-number{float:left;border-radius:0 0 3px}.fc-rtl .fc-basic-view .fc-day-top .fc-week-number{float:right;border-radius:0 0 0 3px}.fc-basic-view .fc-day-top .fc-week-number{min-width:1.5em;text-align:center;background-color:#f2f2f2;color:grey}.fc-basic-view td.fc-week-number{text-align:center}.fc-basic-view td.fc-week-number>*{display:inline-block;min-width:1.25em}.fc-agenda-view .fc-day-grid{position:relative;z-index:2}.fc-agenda-view .fc-day-grid .fc-row{min-height:3em}.fc-agenda-view .fc-day-grid .fc-row .fc-content-skeleton{padding-bottom:1em}.fc .fc-axis{vertical-align:middle;padding:0 4px;white-space:nowrap}.fc-ltr .fc-axis{text-align:right}.fc-rtl .fc-axis{text-align:left}.fc-time-grid,.fc-time-grid-container{position:relative;z-index:1}.fc-time-grid{min-height:100%}.fc-time-grid table{border:0 hidden transparent}.fc-time-grid>.fc-bg{z-index:1}.fc-time-grid .fc-slats,.fc-time-grid>hr{position:relative;z-index:2}.fc-time-grid .fc-content-col{position:relative}.fc-time-grid .fc-content-skeleton{position:absolute;z-index:3;top:0;left:0;right:0}.fc-time-grid .fc-business-container{position:relative;z-index:1}.fc-time-grid .fc-bgevent-container{position:relative;z-index:2}.fc-time-grid .fc-highlight-container{z-index:3;position:relative}.fc-time-grid .fc-event-container{position:relative;z-index:4}.fc-time-grid .fc-now-indicator-line{z-index:5}.fc-time-grid .fc-helper-container{position:relative;z-index:6}.fc-time-grid .fc-slats td{height:1.5em;border-bottom:0}.fc-time-grid .fc-slats .fc-minor td{border-top-style:dotted}.fc-time-grid .fc-highlight{position:absolute;left:0;right:0}.fc-ltr .fc-time-grid .fc-event-container{margin:0 2.5% 0 2px}.fc-rtl .fc-time-grid .fc-event-container{margin:0 2px 0 2.5%}.fc-time-grid .fc-bgevent,.fc-time-grid .fc-event{position:absolute;z-index:1}.fc-time-grid .fc-bgevent{left:0;right:0}.fc-v-event.fc-not-start{border-top-width:0;padding-top:1px;border-top-left-radius:0;border-top-right-radius:0}.fc-v-event.fc-not-end{border-bottom-width:0;padding-bottom:1px;border-bottom-left-radius:0;border-bottom-right-radius:0}.fc-time-grid-event{overflow:hidden}.fc-time-grid-event.fc-selected{overflow:visible}.fc-time-grid-event.fc-selected .fc-bg{display:none}.fc-time-grid-event .fc-content{overflow:hidden}.fc-time-grid-event .fc-time,.fc-time-grid-event .fc-title{padding:0 1px}.fc-time-grid-event .fc-time{font-size:.85em;white-space:nowrap}.fc-time-grid-event.fc-short .fc-content{white-space:nowrap}.fc-time-grid-event.fc-short .fc-time,.fc-time-grid-event.fc-short .fc-title{display:inline-block;vertical-align:top}.fc-time-grid-event.fc-short .fc-time span{display:none}.fc-time-grid-event.fc-short .fc-time:before{content:attr(data-start)}.fc-time-grid-event.fc-short .fc-time:after{content:\"\\A0-\\A0\"}.fc-time-grid-event.fc-short .fc-title{font-size:.85em;padding:0}.fc-time-grid-event.fc-allow-mouse-resize .fc-resizer{left:0;right:0;bottom:0;height:8px;overflow:hidden;line-height:8px;font-size:11px;font-family:monospace;text-align:center;cursor:s-resize}.fc-time-grid-event.fc-allow-mouse-resize .fc-resizer:after{content:\"=\"}.fc-time-grid-event.fc-selected .fc-resizer{border-radius:5px;width:8px;height:8px;background:#fff;left:50%;margin-left:-5px;bottom:-5px;border:1px solid;border-color:inherit}.fc-time-grid .fc-now-indicator-line{border-top-width:1px;left:0;right:0}.fc-time-grid .fc-now-indicator-arrow{margin-top:-5px}.fc-ltr .fc-time-grid .fc-now-indicator-arrow{left:0;border-width:5px 0 5px 6px;border-top-color:transparent;border-bottom-color:transparent}.fc-rtl .fc-time-grid .fc-now-indicator-arrow{right:0;border-width:5px 6px 5px 0;border-top-color:transparent;border-bottom-color:transparent}.fc-event-dot{display:inline-block;width:10px;height:10px;border-radius:5px}.fc-rtl .fc-list-view{direction:rtl}.fc-list-view{border-width:1px;border-style:solid}.fc .fc-list-table{table-layout:auto}.fc-list-table td{border-width:1px 0 0;padding:8px 14px}.fc-list-table tr:first-child td{border-top-width:0}.fc-list-heading{border-bottom-width:1px}.fc-list-heading td{font-weight:700}.fc-ltr .fc-list-heading-main{float:left}.fc-ltr .fc-list-heading-alt,.fc-rtl .fc-list-heading-main{float:right}.fc-rtl .fc-list-heading-alt{float:left}.fc-list-item.fc-has-url{cursor:pointer}.fc-list-item-marker,.fc-list-item-time{white-space:nowrap;width:1px}.fc-ltr .fc-list-item-marker{padding-right:0}.fc-rtl .fc-list-item-marker{padding-left:0}.fc-list-item-title a{text-decoration:none;color:inherit}.fc-list-item-title a[href]:hover{text-decoration:underline}.fc-list-empty-wrap2{position:absolute;top:0;left:0;right:0;bottom:0}.fc-list-empty-wrap1{width:100%;height:100%;display:table}.fc-list-empty{display:table-cell;vertical-align:middle;text-align:center}.fc-unthemed .fc-list-empty{background-color:#eee}"]
                    }] }
        ];
        /** @nocollapse */
        CalendarComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        CalendarComponent.propDecorators = {
            _calendar: [{ type: core$1.ViewChild, args: ['calendar',] }],
            _datepicker: [{ type: core$1.ViewChild, args: ['datepicker',] }]
        };
        return CalendarComponent;
    }(StylableComponent));

    var registerProps$9 = function () {
        register('wm-card', new Map([
            ['actions', PROP_STRING],
            ['class', PROP_STRING],
            ['iconclass', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['imageheight', __assign({ value: '200px' }, PROP_STRING)],
            ['itemaction', PROP_STRING],
            ['itemchildren', PROP_STRING],
            ['itemicon', PROP_STRING],
            ['itemlabel', PROP_STRING],
            ['itemlink', PROP_STRING],
            ['name', PROP_STRING],
            ['picturesource', PROP_STRING],
            ['picturetitle', __assign({ value: '' }, PROP_STRING)],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['subheading', PROP_STRING],
            ['title', PROP_STRING],
            ['userrole', PROP_STRING]
        ]));
    };

    var registerProps$a = function () {
        register('wm-menu', new Map([
            ['accessroles', __assign({ value: 'Everyone' }, PROP_STRING)],
            ['animateitems', PROP_STRING],
            ['autoclose', __assign({ value: 'always' }, PROP_STRING)],
            ['autoopen', __assign({ value: 'never' }, PROP_STRING)],
            ['caption', PROP_STRING],
            ['class', PROP_STRING],
            ['dataset', __assign({ value: 'Menu Item 1, Menu Item 2, Menu Item 3' }, PROP_ANY)],
            ['hint', __assign({ value: '' }, PROP_STRING)],
            ['iconclass', PROP_STRING],
            ['iconposition', __assign({ value: 'left' }, PROP_STRING)],
            ['itemaction', PROP_STRING],
            ['itemchildren', PROP_STRING],
            ['itemclass', PROP_STRING],
            ['itemicon', PROP_STRING],
            ['itemlabel', PROP_STRING],
            ['itemlink', PROP_STRING],
            ['itemtarget', PROP_STRING],
            ['linktarget', __assign({ value: '_self' }, PROP_STRING)],
            ['menuclass', PROP_STRING],
            ['menulayout', PROP_STRING],
            ['menuposition', PROP_STRING],
            ['name', PROP_STRING],
            ['orderby', PROP_STRING],
            ['shortcutkey', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['type', __assign({ value: 'menu' }, PROP_STRING)],
            ['userrole', PROP_STRING]
        ]));
    };

    var registerProps$b = function () {
        register('wm-nav', new Map([
            ['autoclose', __assign({ value: 'always' }, PROP_STRING)],
            ['autoopen', __assign({ value: 'never' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['dataset', PROP_ANY],
            ['iconposition', __assign({ value: 'left' }, PROP_STRING)],
            ['itemlabel', PROP_STRING],
            ['itemlink', PROP_STRING],
            ['itemicon', PROP_STRING],
            ['itemclass', PROP_STRING],
            ['itemchildren', PROP_STRING],
            ['itemaction', PROP_STRING],
            ['itembadge', PROP_STRING],
            ['itemtarget', PROP_STRING],
            ['layout', PROP_STRING],
            ['name', PROP_STRING],
            ['orderby', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['type', PROP_STRING],
            ['userrole', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$8 = 'nav app-nav';
    var WIDGET_CONFIG$8 = { widgetType: 'wm-nav', hostClass: DEFAULT_CLS$8 };
    var NavClassMap = {
        pills: 'nav-pills',
        tabs: 'nav-tabs',
        navbar: 'navbar-nav'
    };
    var NavComponent = /** @class */ (function (_super) {
        __extends(NavComponent, _super);
        function NavComponent(inj, cdRef, router$$1, userDefinedExecutionContext, app, selectEventCB) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$8) || this;
            _this.cdRef = cdRef;
            _this.router = router$$1;
            _this.userDefinedExecutionContext = userDefinedExecutionContext;
            _this.app = app;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            _this.disableMenuContext = !!selectEventCB;
            _this.pageScope = _this.viewParent;
            return _this;
        }
        Object.defineProperty(NavComponent.prototype, "activePageName", {
            get: function () {
                return this.app.activePageName;
            },
            enumerable: true,
            configurable: true
        });
        NavComponent.prototype.setNavType = function (type) {
            core.addClass(this.nativeElement, NavClassMap[type]);
        };
        NavComponent.prototype.setNavLayout = function (layout) {
            core.addClass(this.nativeElement, "nav-" + layout);
        };
        NavComponent.prototype.onNavSelect = function ($event, item, liRef) {
            $event.preventDefault();
            if (this.activeNavLINode) {
                core.removeClass(this.activeNavLINode, 'active');
            }
            this.activeNavLINode = liRef;
            core.addClass(liRef, 'active');
            this.selecteditem = item;
            this.invokeEventCallback('select', { $event: $event, $item: item.value });
            var itemLink = item.link;
            var itemAction = item.action;
            var linkTarget = item.target;
            if (itemAction) {
                if (!this.itemActionFn) {
                    this.itemActionFn = core.$parseEvent(itemAction);
                }
                this.itemActionFn(this.userDefinedExecutionContext, Object.create(item));
            }
            if (itemLink) {
                if (itemLink.startsWith('#/') && (!linkTarget || linkTarget === '_self')) {
                    var queryParams = core.getUrlParams(itemLink);
                    itemLink = core.getRouteNameFromLink(itemLink);
                    this.router.navigate([itemLink], { queryParams: queryParams });
                }
                else {
                    core.openLink(itemLink, linkTarget);
                }
            }
        };
        NavComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.setNavType(this.type);
            this.setNavLayout(this.layout);
        };
        /**
         * invoked from the menu widget when a menu item is selected.
         * @param $event
         * @param widget
         * @param $item
         */
        NavComponent.prototype.onMenuItemSelect = function ($event, widget, $item) {
            this.selecteditem = _.omit($item, ['children', 'value']);
            this.invokeEventCallback('select', { $event: $event, $item: this.selecteditem });
        };
        NavComponent.initializeProps = registerProps$b();
        NavComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmNav]',
                        template: "<ng-template #menuRef let-item=\"item\" let-index=\"index\">\n    <div wmMenu dropdown\n         type=\"anchor\"\n         autoclose.bind=\"autoclose\"\n         iconclass.bind=\"item.icon\"\n         autoopen.bind=\"autoopen\"\n         caption.bind=\"item.label\"\n         dataset.bind=\"item.children\"\n         iconposition.bind=\"iconposition\"\n         select.event=\"onMenuItemSelect($event, widget, $item)\"></div>\n</ng-template>\n\n<ng-template #anchorRef let-item=\"item\" let-index=\"index\" let-liRef=\"liRef\">\n    <a wmAnchor\n       [disableMenuContext]=\"disableMenuContext || !!item.action\"\n       [wmNavigationControl]=\"item.link\"\n       caption.bind=\"item.label\"\n       iconclass.bind=\"item.icon\"\n       badgevalue.bind=\"item.badge\"\n       iconposition.bind=\"iconposition\"\n       click.event=\"onNavSelect($event, item, liRef)\"></a>\n</ng-template>\n\n<li class=\"app-nav-item {{item.class}}\" *ngFor=\"let item of nodes; let index = index;\" #liRef [ngClass]=\"{active: item.link === '#/' + activePageName}\">\n    <ng-container [ngTemplateOutlet]=\"anchorRef\" [ngTemplateOutletContext]=\"{item: item, index:index, liRef: liRef}\" *ngIf=\"!item.children.length\"></ng-container>\n    <ng-container [ngTemplateOutlet]=\"menuRef\" [ngTemplateOutletContext]=\"{item: item, index:index}\"  *ngIf=\"item.children.length\"></ng-container>\n</li>\n\n<ng-content *ngIf=\"!nodes.length\" select=\"[wmNavItem]\"></ng-content>",
                        providers: [
                            provideAsWidgetRef(NavComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        NavComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.ChangeDetectorRef },
                { type: router.Router },
                { type: core.UserDefinedExecutionContext },
                { type: core.App },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['select.event',] }] }
            ];
        };
        return NavComponent;
    }(DatasetAwareNavComponent));

    var KEYBOARD_MOVEMENTS = {
        MOVE_UP: 'UP-ARROW',
        MOVE_LEFT: 'LEFT-ARROW',
        MOVE_RIGHT: 'RIGHT-ARROW',
        MOVE_DOWN: 'DOWN-ARROW',
        ON_ENTER: 'ENTER',
        ON_TAB: 'TAB',
        ON_ESCAPE: 'ESC'
    };
    var MENU_POSITION = {
        UP_LEFT: 'up,left',
        UP_RIGHT: 'up,right',
        DOWN_LEFT: 'down,left',
        DOWN_RIGHT: 'down,right',
        INLINE: 'inline'
    };
    var POSITION = {
        DOWN_RIGHT: 'down,right',
        DOWN_LEFT: 'down,left',
        UP_RIGHT: 'up,right',
        UP_LEFT: 'up,left',
        INLINE: 'inline'
    };
    var CARET_CLS = {
        UP: 'fa-caret-up',
        DOWN: 'fa-caret-down'
    };
    var PULL_CLS = {
        LEFT: 'pull-left',
        RIGHT: 'pull-right'
    };
    var AUTO_OPEN = {
        NEVER: 'never',
        ACTIVE_PAGE: 'activepage',
        ALWAYS: 'always'
    };
    var WIDGET_CONFIG$9 = { widgetType: 'wm-menu', hostClass: 'dropdown app-menu' };
    var MenuComponent = /** @class */ (function (_super) {
        __extends(MenuComponent, _super);
        function MenuComponent(inj, route, bsDropdown, parentNav, selectEventCB) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$9) || this;
            _this.route = route;
            _this.bsDropdown = bsDropdown;
            _this.parentNav = parentNav;
            _this.selectEventCB = selectEventCB;
            _this.menuCaret = 'fa-caret-down';
            _this._selectFirstItem = false;
            if (parentNav) {
                _this.disableMenuContext = !!parentNav.disableMenuContext;
            }
            else {
                _this.disableMenuContext = !!selectEventCB;
            }
            return _this;
        }
        MenuComponent.prototype.onShow = function () {
            var _this = this;
            if (this._selectFirstItem) {
                setTimeout(function () {
                    _this.$element.find('> ul[wmmenudropdown] li.app-menu-item:first > a').focus();
                });
            }
            core.$appDigest();
        };
        MenuComponent.prototype.onHide = function () {
            this.$element.find('>.dropdown-toggle').focus();
            this.$element.find('li').removeClass('open');
            this._selectFirstItem = false;
            core.$appDigest();
        };
        MenuComponent.prototype.onKeyDown = function ($event, eventAction) {
            var KEY_MOVEMENTS = _.clone(KEYBOARD_MOVEMENTS);
            if (this.menuposition === MENU_POSITION.UP_RIGHT) {
                KEY_MOVEMENTS.MOVE_UP = 'DOWN-ARROW';
                KEY_MOVEMENTS.MOVE_DOWN = 'UP-ARROW';
            }
            else if (this.menuposition === MENU_POSITION.UP_LEFT) {
                KEY_MOVEMENTS.MOVE_UP = 'DOWN-ARROW';
                KEY_MOVEMENTS.MOVE_DOWN = 'UP-ARROW';
                KEY_MOVEMENTS.MOVE_LEFT = 'RIGHT-ARROW';
                KEY_MOVEMENTS.MOVE_RIGHT = 'LEFT-ARROW';
            }
            else if (this.menuposition === MENU_POSITION.DOWN_LEFT) {
                KEY_MOVEMENTS.MOVE_LEFT = 'RIGHT-ARROW';
                KEY_MOVEMENTS.MOVE_RIGHT = 'LEFT-ARROW';
            }
            if (_.includes([KEY_MOVEMENTS.MOVE_DOWN, KEY_MOVEMENTS.MOVE_RIGHT], eventAction)) {
                if (!this.bsDropdown.isOpen) {
                    this._selectFirstItem = true;
                    this.bsDropdown.show();
                }
                else {
                    this.$element.find('> ul[wmmenudropdown] li.app-menu-item:first > a').focus();
                }
            }
            else if (eventAction === KEY_MOVEMENTS.ON_ENTER) {
                this.bsDropdown.toggle(true);
            }
            else if (_.includes([KEY_MOVEMENTS.MOVE_UP, KEY_MOVEMENTS.MOVE_LEFT], eventAction)) {
                this.bsDropdown.hide();
            }
            $event.preventDefault();
        };
        /**
         * returns true if the menu has link to the current page.
         * @param nodes
         */
        MenuComponent.prototype.hasLinkToCurrentPage = function (nodes) {
            var _this = this;
            return nodes.some(function (node) {
                if (isActiveNavItem(node.link, _this.route.url)) {
                    return true;
                }
                if (node.children) {
                    return _this.hasLinkToCurrentPage(node.children);
                }
            });
        };
        MenuComponent.prototype.resetNodes = function () {
            _super.prototype.resetNodes.call(this);
            // open the menu if any of its menu items has link to current page and if autoopen value is 'active page'
            if ((this.autoopen === AUTO_OPEN.ACTIVE_PAGE && this.hasLinkToCurrentPage(this.nodes)) || this.autoopen === AUTO_OPEN.ALWAYS) {
                this.bsDropdown.show();
            }
        };
        MenuComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.setMenuPosition();
        };
        MenuComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'tabindex') {
                return;
            }
            if (key === 'autoclose') {
                this.bsDropdown.autoClose = nv !== 'disabled';
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        MenuComponent.prototype.setMenuPosition = function () {
            switch (this.menuposition) {
                case POSITION.DOWN_RIGHT:
                    core.removeClass(this.nativeElement, 'dropup');
                    this.menualign = PULL_CLS.LEFT;
                    this.menuCaret = CARET_CLS.DOWN;
                    break;
                case POSITION.DOWN_LEFT:
                    core.removeClass(this.nativeElement, 'dropup');
                    this.menualign = PULL_CLS.RIGHT;
                    this.menuCaret = CARET_CLS.DOWN;
                    break;
                case POSITION.UP_LEFT:
                    core.addClass(this.nativeElement, 'dropup');
                    this.menualign = PULL_CLS.RIGHT;
                    this.menuCaret = CARET_CLS.UP;
                    break;
                case POSITION.UP_RIGHT:
                    core.addClass(this.nativeElement, 'dropup');
                    this.menualign = PULL_CLS.LEFT;
                    this.menuCaret = CARET_CLS.UP;
                    break;
                case POSITION.INLINE:
                    this.menualign = 'dropinline-menu';
                    break;
            }
        };
        MenuComponent.prototype.onMenuItemSelect = function (args) {
            var $event = args.$event;
            var $item = args.$item.value;
            this.invokeEventCallback('select', { $event: $event, $item: $item });
        };
        MenuComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.nativeElement.querySelector('.dropdown-toggle'), this);
        };
        MenuComponent.initializeProps = registerProps$a();
        MenuComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmMenu]',
                        template: "<ng-template #menuTemplate>\n    <button wmButton\n            dropdownToggle\n            aria-haspopup=\"true\"\n            aria-expanded=\"false\"\n\n            class=\"btn app-button dropdown-toggle {{menuclass}}\"\n            hint.bind=\"hint\"\n            shortcutkey.bind=\"shortcutkey\"\n            tabindex.bind=\"tabindex\"\n            caption.bind=\"caption\"\n            iconclass.bind=\"iconclass\"\n            iconposition.bind=\"iconposition\">\n        <span class=\"pull-right caret fa {{menuCaret}}\"></span>\n    </button>\n</ng-template>\n\n<ng-template #innerTemplate>\n    <i class=\"app-icon {{iconclass}}\"></i>\n    <span class=\"caption\" [textContent]=\"caption\"></span>\n    <span class=\"pull-right caret fa {{menuCaret}}\"></span>\n</ng-template>\n\n<ng-container *ngIf=\"type === 'anchor'; else menuTemplate\">\n    <a wmAnchor\n       dropdownToggle\n\n       href=\"javascript:void(0);\"\n       role=\"button\"\n       aria-haspopup=\"true\"\n       aria-expanded=\"false\"\n\n       hint.bind=\"hint\"\n       class=\"dropdown-toggle {{menuclass}}\"\n       shortcutkey.bind=\"shortcutkey\"\n       tabindex.bind=\"tabindex\"\n       caption.bind=\"caption\"\n       iconclass.bind=\"iconclass\"\n       iconposition.bind=\"iconposition\"\n    >\n        <span class=\"pull-right caret fa {{menuCaret}}\"></span>\n    </a>\n</ng-container>\n\n<ul wmMenuDropdown [items]=\"nodes\" [ngClass]=\"menulayout\" class=\"icon-position-{{iconposition}}\" *dropdownMenu aria-labelledby=\"dropdownmenu\"></ul>\n",
                        providers: [
                            provideAsWidgetRef(MenuComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        MenuComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: router.Router },
                { type: ngxBootstrap.BsDropdownDirective, decorators: [{ type: core$1.Self }, { type: core$1.Optional }] },
                { type: NavComponent, decorators: [{ type: core$1.Optional }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['select.event',] }] }
            ];
        };
        MenuComponent.propDecorators = {
            onShow: [{ type: core$1.HostListener, args: ['onShown',] }],
            onHide: [{ type: core$1.HostListener, args: ['onHidden',] }],
            onKeyDown: [{ type: core$1.HostListener, args: ['keydown.arrowup', ['$event', '"UP-ARROW"'],] }, { type: core$1.HostListener, args: ['keydown.arrowdown', ['$event', '"DOWN-ARROW"'],] }, { type: core$1.HostListener, args: ['keydown.arrowright', ['$event', '"RIGHT-ARROW"'],] }, { type: core$1.HostListener, args: ['keydown.arrowleft', ['$event', '"LEFT-ARROW"'],] }, { type: core$1.HostListener, args: ['keydown.enter', ['$event', '"ENTER"'],] }]
        };
        return MenuComponent;
    }(DatasetAwareNavComponent));

    var menuProps = ['itemlabel', 'itemicon', 'itemlink', 'itemaction', 'itemchildren', 'userrole'];
    var MenuAdapterComponent = /** @class */ (function (_super) {
        __extends(MenuAdapterComponent, _super);
        function MenuAdapterComponent(inj, WIDGET_CONFIG) {
            var _this = _super.call(this, inj, WIDGET_CONFIG) || this;
            _this.pageScope = _this.viewParent;
            _this.binditemlabel = _this.nativeElement.getAttribute('itemlabel.bind');
            _this.binditemicon = _this.nativeElement.getAttribute('itemicon.bind');
            _this.binditemaction = _this.nativeElement.getAttribute('itemaction.bind');
            _this.binditemlink = _this.nativeElement.getAttribute('itemlink.bind');
            _this.binduserrole = _this.nativeElement.getAttribute('userrole.bind');
            _this.binditemchildren = _this.nativeElement.getAttribute('itemchildren.bind');
            return _this;
        }
        MenuAdapterComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (_.includes(menuProps, key) && this.menuRef) {
                this.menuRef.itemlabel = nv;
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        MenuAdapterComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            var subscriber = this.menuRefQL.changes.subscribe(function (menuRefQL) {
                if (menuRefQL.first) {
                    _this.menuRef = menuRefQL.first;
                    menuProps.forEach(function (prop) {
                        var bindProp = "bind" + prop;
                        if (_this[bindProp]) {
                            _this.menuRef[bindProp] = _this[bindProp];
                        }
                        _this.menuRef[prop] = _this[prop];
                    });
                    subscriber.unsubscribe();
                }
            });
        };
        MenuAdapterComponent.propDecorators = {
            menuRefQL: [{ type: core$1.ViewChildren, args: [MenuComponent,] }]
        };
        return MenuAdapterComponent;
    }(StylableComponent));

    var DEFAULT_CLS$9 = 'app-card card app-panel';
    var WIDGET_CONFIG$a = {
        widgetType: 'wm-card',
        hostClass: DEFAULT_CLS$9
    };
    var CardComponent = /** @class */ (function (_super) {
        __extends(CardComponent, _super);
        function CardComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$a) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.SHELL);
            return _this;
        }
        CardComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.cardContainerElRef.nativeElement, this, exports.APPLY_STYLES_TYPE.INNER_SHELL);
        };
        CardComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'title' || key === 'subheading' || key === 'iconclass' || key === 'iconurl' || key === 'actions') {
                this.showHeader = !!(this.title || this.subheading || this.iconclass || this.iconurl || this.actions);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        CardComponent.initializeProps = registerProps$9();
        CardComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmCard]',
                        template: "<div class=\"app-card-header panel-heading\" *ngIf=\"showHeader\">\n    <div class=\"app-card-avatar\" *ngIf=\"iconclass || iconurl\">\n        <i class=\"app-icon\" [ngClass]=\"iconclass\" *ngIf=\"iconclass && !iconurl\"></i>\n        <img class=\"img-circle\" [src]=\"iconurl\" *ngIf=\"iconurl\" />\n    </div>\n    <div class=\"app-card-header-text\">\n        <h4 class=\"card-heading\" [textContent]=\"title\"></h4>\n        <h5 class=\"card-subheading text-muted\" [textContent]=\"subheading\"></h5>\n    </div>\n    <div class=\"panel-actions\" *ngIf=\"actions\">\n        <!-- TODO(punith) need to bind autoclose-->\n        <div wmMenu dropdown\n             [autoClose]=\"autoclose !== 'disabled'\"\n             class=\"panel-action\"\n             type=\"anchor\"\n             iconclass=\"wi wi-more-vert\"\n             menuposition=\"down,left\"\n             hint=\"Actions\"\n             caption=\"\"\n             dataset.bind=\"actions\">\n        </div>\n    </div>\n</div>\n<div class=\"app-card-image\" *ngIf=\"picturesource\"  [ngStyle]=\"{'max-height':imageheight}\">\n   <img wmPicture class=\"card-image\" picturesource.bind=\"picturesource\" hint.bind=\"picturetitle\" />\n</div>\n<div #cardContainerWrapper>\n    <ng-content select=\"[wmCardContent]\"></ng-content>\n</div>\n<div>\n    <ng-content select=\"[wmCardActions]\"></ng-content>\n</div>\n<div>\n    <ng-content select=\"[wmCardFooter]\"></ng-content>\n</div>",
                        providers: [
                            provideAsWidgetRef(CardComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        CardComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        CardComponent.propDecorators = {
            cardContainerElRef: [{ type: core$1.ViewChild, args: ['cardContainerWrapper',] }]
        };
        return CardComponent;
    }(MenuAdapterComponent));
    // Todo(swathi) - menu

    var registerProps$c = function () {
        register('wm-card-actions', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ]));
    };

    var DEFAULT_CLS$a = 'app-card-actions';
    var WIDGET_CONFIG$b = {
        widgetType: 'wm-card-actions',
        hostClass: DEFAULT_CLS$a
    };
    var CardActionsDirective = /** @class */ (function (_super) {
        __extends(CardActionsDirective, _super);
        function CardActionsDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$b) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        CardActionsDirective.initializeProps = registerProps$c();
        CardActionsDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmCardActions]'
                    },] }
        ];
        /** @nocollapse */
        CardActionsDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return CardActionsDirective;
    }(StylableComponent));

    var registerProps$d = function () {
        register('wm-card-content', new Map([
            ['class', PROP_STRING],
            ['content', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$b = 'app-card-content card-body card-block';
    var WIDGET_CONFIG$c = {
        widgetType: 'wm-card-content',
        hostClass: DEFAULT_CLS$b
    };
    var CardContentComponent = /** @class */ (function (_super) {
        __extends(CardContentComponent, _super);
        function CardContentComponent(inj) {
            return _super.call(this, inj, WIDGET_CONFIG$c) || this;
        }
        CardContentComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.cardContentContainerElRef.nativeElement, this, exports.APPLY_STYLES_TYPE.CONTAINER);
        };
        CardContentComponent.initializeProps = registerProps$d();
        CardContentComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmCardContent]',
                        template: "<div partial-container-target #cardContentContainer>\n    <ng-content></ng-content>\n</div>",
                        providers: [
                            provideAsWidgetRef(CardContentComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        CardContentComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        CardContentComponent.propDecorators = {
            cardContentContainerElRef: [{ type: core$1.ViewChild, args: ['cardContentContainer',] }]
        };
        return CardContentComponent;
    }(StylableComponent));

    var registerProps$e = function () {
        register('wm-card-footer', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ]));
    };

    var DEFAULT_CLS$c = 'app-card-footer text-muted card-footer';
    var WIDGET_CONFIG$d = {
        widgetType: 'wm-card-footer',
        hostClass: DEFAULT_CLS$c
    };
    var CardFooterDirective = /** @class */ (function (_super) {
        __extends(CardFooterDirective, _super);
        function CardFooterDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$d) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        CardFooterDirective.initializeProps = registerProps$e();
        CardFooterDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmCardFooter]'
                    },] }
        ];
        /** @nocollapse */
        CardFooterDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return CardFooterDirective;
    }(StylableComponent));

    var registerProps$f = function () {
        register('wm-chart', new Map([
            ['aggregation', __assign({ value: 'none' }, PROP_STRING)],
            ['aggregationcolumn', PROP_STRING],
            ['areaviewtype', __assign({ value: 'stack' }, PROP_STRING)],
            ['barspacing', __assign({ value: 'medium' }, PROP_STRING)],
            ['bubblesize', PROP_STRING],
            ['centerlabel', PROP_STRING],
            ['class', PROP_STRING],
            ['customcolors', PROP_STRING],
            ['dataset', PROP_ANY],
            ['datasource', PROP_STRING],
            ['donutratio', __assign({ value: 'medium' }, PROP_STRING)],
            ['formattype', { value: '', PROP_STRING: PROP_STRING }],
            ['groupby', PROP_STRING],
            ['height', { value: '210px', PROP_STRING: PROP_STRING }],
            ['highlightpoints', PROP_BOOLEAN],
            ['iconclass', PROP_STRING],
            ['interpolation', __assign({ value: 'linear' }, PROP_STRING)],
            ['labelthreshold', __assign({ value: 0.01 }, PROP_NUMBER)],
            ['labeltype', __assign({ value: 'percent' }, PROP_STRING)],
            ['legendtype', __assign({ value: 'furious' }, PROP_STRING)],
            ['linethickness', PROP_STRING],
            ['loadingdatamsg', __assign({ value: 'Loading...' }, PROP_STRING)],
            ['name', PROP_STRING],
            ['nodatamessage', __assign({ value: 'No Data Available.' }, PROP_STRING)],
            ['offset', PROP_STRING],
            ['offsetbottom', __assign({ value: 55 }, PROP_NUMBER)],
            ['offsetleft', __assign({ value: 75 }, PROP_NUMBER)],
            ['offsetright', __assign({ value: 25 }, PROP_NUMBER)],
            ['offsettop', __assign({ value: 25 }, PROP_NUMBER)],
            ['orderby', PROP_STRING],
            ['reducexticks', __assign({ value: true }, PROP_BOOLEAN)],
            ['shape', __assign({ value: 'circle' }, PROP_STRING)],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['showlabels', __assign({ value: 'outside' }, PROP_STRING)],
            ['showlabelsoutside', __assign({ value: true }, PROP_BOOLEAN)],
            ['showlegend', __assign({ value: 'top' }, PROP_STRING)],
            ['showvalues', __assign({ value: false }, PROP_BOOLEAN)],
            ['showxaxis', __assign({ value: true }, PROP_BOOLEAN)],
            ['showxdistance', __assign({ value: false }, PROP_BOOLEAN)],
            ['showyaxis', __assign({ value: true }, PROP_BOOLEAN)],
            ['showydistance', __assign({ value: false }, PROP_BOOLEAN)],
            ['staggerlabels', __assign({ value: false }, PROP_BOOLEAN)],
            ['subheading', PROP_STRING],
            ['theme', PROP_STRING],
            ['title', PROP_STRING],
            ['tooltips', __assign({ value: true }, PROP_BOOLEAN)],
            ['type', PROP_STRING],
            ['viewtype', __assign({ value: 'Grouped' }, PROP_STRING)],
            ['xaxisdatakey', PROP_STRING],
            ['xaxislabel', PROP_STRING],
            ['xaxislabeldistance', __assign({ value: 12 }, PROP_NUMBER)],
            ['xdateformat', PROP_STRING],
            ['xdomain', __assign({ value: 'Default' }, PROP_STRING)],
            ['xnumberformat', PROP_STRING],
            ['xunits', PROP_STRING],
            ['yaxisdatakey', PROP_STRING],
            ['yaxislabel', PROP_STRING],
            ['yaxislabeldistance', __assign({ value: 12 }, PROP_NUMBER)],
            ['ydomain', __assign({ value: 'Default' }, PROP_STRING)],
            ['ynumberformat', PROP_STRING],
            ['yunits', PROP_STRING]
        ]));
    };

    var chartTypes = ['Column', 'Line', 'Area', 'Cumulative Line', 'Bar', 'Pie', 'Donut', 'Bubble'], allShapes = ['circle', 'square', 'diamond', 'cross', 'triangle-up', 'triangle-down'];
    var dateList = ['01/01/2001', '01/01/2002', '01/01/2003'], themes = {
        'Terrestrial': {
            colors: ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'],
            tooltip: {
                'backgroundColor': '#de7d28',
                'textColor': '#FFFFFF'
            }
        },
        'Annabelle': {
            colors: ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'],
            tooltip: {
                'backgroundColor': '#2e306f',
                'textColor': '#FFFFFF'
            }
        },
        'Azure': {
            colors: ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'],
            tooltip: {
                'backgroundColor': '#3182bd',
                'textColor': '#FFFFFF'
            }
        },
        'Retro': {
            colors: ['#0ca7a1', '#ffa615', '#334957', '#acc5c2', '#988f90', '#8accc9', '#515151', '#f27861', '#36c9fd', '#794668', '#0f709d', '#0d2738', '#44be78', '#4a1839', '#6a393f', '#557d8b', '#6c331c', '#1c1c1c', '#861500', '#09562a'],
            tooltip: {
                'backgroundColor': '#80513a',
                'textColor': '#FFFFFF'
            }
        },
        'Mellow': {
            colors: ['#f0dcbf', '#88c877', '#aeb918', '#2e2c23', '#ddddd2', '#dfe956', '#4c963b', '#5d3801', '#e1eec3', '#cd8472', '#fcfab3', '#9a4635', '#9295ad', '#2e3f12', '#565677', '#557d8b', '#4f4d02', '#0c0c1b', '#833324', '#24120e'],
            tooltip: {
                'backgroundColor': '#7c9e73',
                'textColor': '#FFFFFF'
            }
        },
        'Orient': {
            colors: ['#a80000', '#cc6c3c', '#f0e400', '#000084', '#fccc6c', '#009c6c', '#cc309c', '#78cc00', '#fc84e4', '#48e4fc', '#4878d8', '#186c0c', '#606060', '#a8a8a8', '#000000', '#d7d7d7', '#75a06e', '#190d0b', '#888888', '#694b84'],
            tooltip: {
                'backgroundColor': '#c14242',
                'textColor': '#FFFFFF'
            }
        },
        'GrayScale': {
            colors: ['#141414', '#353535', '#5b5b5b', '#848484', '#a8a8a8', '#c3c3c3', '#e0e0e0', '#c8c8c8', '#a5a5a5', '#878787', '#656565', '#4e4e4e', '#303030', '#1c1c1c', '#4f4f4f', '#3b3b3b', '#757575', '#606060', '#868686', '#c1c1c1'],
            tooltip: {
                'backgroundColor': '#575757',
                'textColor': '#FFFFFF'
            }
        },
        'Flyer': {
            colors: ['#3f454c', '#5a646e', '#848778', '#cededf', '#74c4dd', '#0946ed', '#380bb1', '#000ff0', '#f54a23', '#1db262', '#bca3aa', '#ffa500', '#a86b32', '#63a18c', '#56795e', '#934343', '#b75f5f', '#752d2d', '#4e1111', '#920606'],
            tooltip: {
                'backgroundColor': '#47637c',
                'textColor': '#FFFFFF'
            }
        },
        'Luminosity': {
            colors: ['#FFFFFF', '#e4e4e4', '#00bcd4', '#f0dd2f', '#00aabf', '#018376', '#e91e63', '#39e5d4', '#ff6d6d', '#00ff76', '#ff9800', '#969696', '#ff4200', '#e00000', '#95cbe5', '#5331ff', '#fff4a7', '#e7a800', '#0061e4', '#d5e7ff'],
            tooltip: {
                'backgroundColor': '#47637c',
                'textColor': '#FFFFFF'
            }
        }
    }, basicProperties = ['xaxislabel', 'yaxislabel', 'xunits', 'yunits', 'xnumberformat', 'xdateformat', 'ynumberformat',
        'showvalues', 'showlabels', 'viewtype', 'areaviewtype', 'staggerlabels', 'reducexticks', 'offsettop', 'offsetbottom', 'offsetright', 'offsetleft',
        'barspacing', 'xaxislabeldistance', 'yaxislabeldistance', 'theme', 'labeltype', 'donutratio', 'showlabelsoutside', 'showxdistance', 'showydistance', 'shape', 'nodatamessage', 'captions', 'showxaxis', 'showyaxis',
        'centerlabel', 'customcolors', 'showlegend', 'legendtype', 'xdomain', 'ydomain', 'tooltips', 'linethickness', 'highlightpoints', 'interpolation', 'labelthreshold'], barSpacingMap = {
        'small': 0.3,
        'medium': 0.5,
        'large': 0.8
    }, donutRatioMap = {
        'small': 0.3,
        'medium': 0.6,
        'large': 0.7
    }, barSpacingMapInvert = _.invert(barSpacingMap), donutRatioMapInvert = _.invert(donutRatioMap), tickformats = {
        'Thousand': {
            'prefix': 'K',
            'divider': 1000
        },
        'Million': {
            'prefix': 'M',
            'divider': 1000000
        },
        'Billion': {
            'prefix': 'B',
            'divider': 1000000000
        }
    }, chartId = '#preview-chart', dataTypeJSON = ['Column', 'Line', 'Pie', 'Bar', 'Donut', 'Bubble'], // Charts that supports the data to be JSON;
    lineTypeCharts = ['Line', 'Area', 'Cumulative Line'], // Charts that does not supports the string type of data in the xaxis in the nvd3;
    dataTypeArray = ['Cumulative Line', 'Area'], // Charts that supports the data to be Array
    SAMPLE_DATA = {
        'group1': 'Europe',
        'group2': 'Asia',
        'group3': 'America',
        'group4': 'Australia'
    };
    // returns true if chart type is pie
    var isPieChart = function (type) { return type === 'Pie'; };
    // returns true if chart type is line
    var isLineChart = function (type) { return type === 'Line'; };
    // returns true if chart type is bar
    var isBarChart = function (type) { return type === 'Bar'; };
    // returns true if chart type is donut
    var isDonutChart = function (type) { return type === 'Donut'; };
    // returns true if chart type is bubble
    var isBubbleChart = function (type) { return type === 'Bubble'; };
    // returns true if chart type is column
    var isColumnChart = function (type) { return type === 'Column'; };
    // returns true if chart type is area
    var isAreaChart = function (type) { return type === 'Area'; };
    // returns true if chart type is area
    var isPieType = function (type) { return isPieChart(type) || isDonutChart(type); };
    // The format of chart data is array of json objects in case of the following types of chart
    var isChartDataJSON = function (type) { return _.includes(dataTypeJSON, type) || !_.includes(chartTypes, type); };
    // The format of chart data is array of objects in case of the following types of chart
    var isChartDataArray = function (type) { return _.includes(dataTypeArray, type); };
    // returns true is the chart type is 'line', 'area' or 'cumulative line' else false
    var isLineTypeChart = function (type) { return _.includes(lineTypeCharts, type); };
    // X/Y Domain properties are supported only for Column and Area charts
    var isAxisDomainSupported = function (type) { return isColumnChart(type) || isAreaChart(type); };
    // Returns bar spacing value
    var getBarSpacingValue = function (value, prop) {
        if (prop === 'value') {
            return barSpacingMap[value];
        }
        if (prop === 'key') {
            return barSpacingMapInvert[value];
        }
    };
    // Returns radius value
    var getRadiusValue = function (value, prop) {
        if (prop === 'value') {
            return donutRatioMap[value];
        }
        if (prop === 'key') {
            return donutRatioMapInvert[value];
        }
    };
    // Returns labels config
    var getLabelValues = function (showlabels, showlabelsoutside, prop) {
        var labelsConfig = {};
        switch (showlabels) {
            case 'hide':
                labelsConfig.showlabels = false;
                break;
            case 'inside':
                labelsConfig.showlabels = true;
                labelsConfig.showlabelsoutside = false;
                break;
            case 'outside':
                labelsConfig.showlabels = true;
                labelsConfig.showlabelsoutside = true;
                break;
        }
        return labelsConfig;
    };
    // Construct the sample data
    var constructSampleData = function (dataType, yaxisLength, shape) {
        var first_series = [], second_series = [], third_series = [], first_series_array = [], second_series_array = [], third_series_array = [], first_series_bubble = [], second_series_bubble = [], third_series_bubble = [], data = [];
        switch (dataType) {
            case 'jsonFormat':
                first_series = [
                    { 'x': '01/01/2001', 'y': 4000000 },
                    { 'x': '01/01/2002', 'y': 1000000 },
                    { 'x': '01/01/2003', 'y': 5000000 }
                ];
                second_series = [
                    { 'x': '01/01/2001', 'y': 3000000 },
                    { 'x': '01/01/2002', 'y': 4000000 },
                    { 'x': '01/01/2003', 'y': 7000000 }
                ];
                third_series = [
                    { 'x': '01/01/2001', 'y': 2000000 },
                    { 'x': '01/01/2002', 'y': 8000000 },
                    { 'x': '01/01/2003', 'y': 6000000 }
                ];
                data[0] = {
                    values: first_series,
                    key: SAMPLE_DATA.group1
                };
                if (yaxisLength >= 2) {
                    data[1] = {
                        values: second_series,
                        key: SAMPLE_DATA.group2
                    };
                }
                if (yaxisLength >= 3) {
                    data[2] = {
                        values: third_series,
                        key: SAMPLE_DATA.group3
                    };
                }
                break;
            case 'lineChartFormat':
                first_series = [
                    { 'x': 1, 'y': 4000000 },
                    { 'x': 2, 'y': 1000000 },
                    { 'x': 3, 'y': 5000000 }
                ];
                second_series = [
                    { 'x': 1, 'y': 3000000 },
                    { 'x': 2, 'y': 4000000 },
                    { 'x': 3, 'y': 7000000 }
                ];
                third_series = [
                    { 'x': 1, 'y': 2000000 },
                    { 'x': 2, 'y': 8000000 },
                    { 'x': 3, 'y': 6000000 }
                ];
                data[0] = {
                    values: first_series,
                    key: SAMPLE_DATA.group1
                };
                if (yaxisLength >= 2) {
                    data[1] = {
                        values: second_series,
                        key: SAMPLE_DATA.group2
                    };
                }
                if (yaxisLength >= 3) {
                    data[2] = {
                        values: third_series,
                        key: SAMPLE_DATA.group3
                    };
                }
                break;
            case 'arrayFormat':
                first_series_array = [
                    [1, 4000000],
                    [2, 1000000],
                    [3, 5000000]
                ];
                second_series_array = [
                    [1, 3000000],
                    [2, 4000000],
                    [3, 7000000]
                ];
                third_series_array = [
                    [1, 2000000],
                    [2, 8000000],
                    [3, 6000000]
                ];
                data[0] = {
                    values: first_series_array,
                    key: SAMPLE_DATA.group1
                };
                if (yaxisLength >= 2) {
                    data[1] = {
                        values: second_series_array,
                        key: SAMPLE_DATA.group2
                    };
                }
                if (yaxisLength >= 3) {
                    data[2] = {
                        values: third_series_array,
                        key: SAMPLE_DATA.group3
                    };
                }
                break;
            case 'bubbleFormat':
                shape = shape === 'random' ? allShapes[Math.floor(Math.random() * allShapes.length)] : shape;
                first_series_bubble = [
                    { 'x': 80.66, 'y': 33739900, 'size': 78, 'shape': shape },
                    { 'x': 79.84, 'y': 81902300, 'size': 90, 'shape': shape },
                    { 'x': 78.6, 'y': 5523100, 'size': 45, 'shape': shape }
                ];
                second_series_bubble = [
                    { 'x': 72.73, 'y': 79716200, 'size': 98, 'shape': shape },
                    { 'x': 80.05, 'y': 61801600, 'size': 20, 'shape': shape },
                    { 'x': 72.49, 'y': 73137200, 'size': 34, 'shape': shape }
                ];
                third_series_bubble = [
                    { 'x': 68.09, 'y': 33739900, 'size': 45, 'shape': shape },
                    { 'x': 81.55, 'y': 7485600, 'size': 78, 'shape': shape },
                    { 'x': 68.60, 'y': 141850000, 'size': 56, 'shape': shape }
                ];
                data[0] = {
                    values: first_series_bubble,
                    key: SAMPLE_DATA.group1
                };
                if (yaxisLength >= 2) {
                    data[1] = {
                        values: second_series_bubble,
                        key: SAMPLE_DATA.group2
                    };
                }
                if (yaxisLength >= 3) {
                    data[2] = {
                        values: third_series_bubble,
                        key: SAMPLE_DATA.group3
                    };
                }
                break;
            case 'pieChartFormat':
                data = [
                    { 'x': SAMPLE_DATA.group1, 'y': 1000000 },
                    { 'x': SAMPLE_DATA.group2, 'y': 2000000 },
                    { 'x': SAMPLE_DATA.group3, 'y': 3000000 },
                    { 'x': SAMPLE_DATA.group4, 'y': 4000000 }
                ];
                break;
        }
        return data;
    };
    var getDataType = function (widgetContext) {
        var type = widgetContext.type;
        if (isLineChart(type)) {
            return 'lineChartFormat';
        }
        if (isPieType(type)) {
            return 'pieChartFormat';
        }
        if (isBubbleChart(type)) {
            return 'bubbleFormat';
        }
        return isChartDataJSON(type) ? 'jsonFormat' : 'arrayFormat';
    };
    // Sample data to populate when no data is bound
    var getSampleData = function (widgetContext) { return constructSampleData(getDataType(widgetContext), _.split(widgetContext.yaxisdatakey, ',').length, widgetContext.shape); };
    // Check whether X/Y Domain was set to Min and is supported for the present chart
    var isAxisDomainValid = function (widgetContext, axis) {
        if (widgetContext[axis + 'domain'] === 'Min' && (isAxisDomainSupported(widgetContext.type))) {
            return true;
        }
        return false;
    };
    // Check whether min and max values are finite or not
    var areMinMaxValuesValid = function (values) {
        if (_.isFinite(values.min) && _.isFinite(values.max)) {
            return true;
        }
        return false;
    };
    var getYScaleMinValue = function (value) {
        var _min = Math.floor(value);
        /* If the number has a) decimal part returning floor value - 0.1
         b) no decimal part returning floor value - 1 */
        return Math.abs(value) - _min > 0 ? value - 0.1 : _min - 1;
    };
    // Chooses the data points of line/cumulative line/area chart and highlights them
    var highlightPoints = function (id, highlightpoints) {
        var chartSvg = id ? d3.select('#wmChart' + id + ' svg') : d3.select(chartId + ' svg');
        if (highlightpoints) {
            chartSvg.selectAll('.nv-point').style({ 'stroke-width': '6px', 'fill-opacity': '.95', 'stroke-opacity': '.95' });
        }
        else {
            chartSvg.selectAll('.nv-point').style({ 'stroke-width': '0px', 'fill-opacity': '0' });
        }
    };
    // Chooses the line of line/cumulative line and increases the thickness of it
    var setLineThickness = function (id, thickness) {
        var chartSvg = id ? d3.select('#wmChart' + id + ' svg') : d3.select(chartId + ' svg');
        thickness = thickness || 1.5;
        chartSvg.selectAll('.nv-line').style({ 'stroke-width': thickness });
    };
    // Constructing a common key value map for preview and canvas mode
    var initProperties = function (widgetContext, propertyValueMap) {
        if (!propertyValueMap || core.isEmptyObject(propertyValueMap)) {
            propertyValueMap = {};
        }
        _.forEach(basicProperties, function (prop) {
            if (_.isUndefined(propertyValueMap[prop])) {
                propertyValueMap[prop] = widgetContext[prop];
            }
        });
        return propertyValueMap;
    };
    var getNumberValue = function (value, callback) {
        return isNaN(parseInt(value, 10)) ? callback(value, 'value') : value;
    };
    // Formats the given value according to date format
    var getDateFormatedData = function (dateFormat, d) {
        dateFormat = dateFormat || '%x';
        return d3.time.format(dateFormat)(new Date(d));
    };
    // Formats the given value according to number format
    var getNumberFormatedData = function (numberFormat, d) {
        var formattedData, divider, prefix;
        formattedData = d3.format(numberFormat)(d);
        // formatting the data based on number format selected
        if (numberFormat) {
            // Getting the respective divider[1000,1000000,1000000000] based on the number format choosen
            divider = (tickformats[numberFormat] && tickformats[numberFormat].divider) || 0;
            prefix = tickformats[numberFormat] && tickformats[numberFormat].prefix;
            if (prefix && divider !== 0) {
                formattedData = d3.format('.2f')(d / divider) + prefix;
            }
        }
        else {
            // Auto formatting the data when no formating option is chosen
            formattedData = d >= 1000 ? d3.format('.1s')(d) : d;
        }
        return formattedData;
    };
    var modifyLegendPosition = function (widgetContext, position, id) {
        var showLegend = isShowLegend(widgetContext.showlegend), chart_Id = id ? '#wmChart' + id : chartId, legendWrap = d3.select(chart_Id + ' .nv-legendWrap'), legendPadding = 5;
        // Return when showlegend is false
        if (!showLegend || !legendWrap[0][0]) {
            return;
        }
        if (position === 'bottom') {
            var legendWrapHeight_1 = legendWrap[0][0].getBoundingClientRect().height, wrap = d3.select(chart_Id + ' .nv-wrap'), wrapTransform = (wrap && wrap.attr('transform')) ? wrap.attr('transform').replace(/, /g, ',') : '', coordinates = /translate\(\s*([^\s,)]+)[ ,]([^\s,)]+)/.exec(wrapTransform), getChartHeight = function () {
                var chartHeight = $(chart_Id + ' svg>.nvd3.nv-wrap')[0].getBoundingClientRect().height;
                if (chartHeight === 0) { // fix for IE
                    chartHeight = ($(chart_Id + ' svg')[0].getBoundingClientRect().height - (legendWrapHeight_1 + 15));
                }
                return chartHeight;
            };
            legendWrap.attr('transform', 'translate(0 , ' + (getChartHeight() - legendWrapHeight_1 - legendPadding) + ')');
            if (coordinates) {
                wrap.attr('transform', 'translate(' + coordinates[1] + ',' + legendPadding + ')');
            }
        }
    };
    // Returns value if legend need to shown or not
    var isShowLegend = function (value) {
        // Old projects will have either true or false
        if (value === 'false' || value === false) {
            return false;
        }
        if (value === 'true' || value === true) {
            return true;
        }
        // New projects will have either 'Hide Legend', 'Show Top', 'Show Bottom'
        return value === 'hide' ? false : true;
    };
    /**
     * Customise the tooltip for donut & pie charts and also for charts having only one value attached to yaxis
     * @param key
     * @param label
     */
    var customiseTooltip = function (chart, propertyValueMap, widgetContext, label) {
        chart.tooltip.contentGenerator(function (key) {
            var xValue = key.data.x, yValue;
            yValue = getNumberFormatedData(propertyValueMap.ynumberformat, key.data.y);
            if (isPieType(widgetContext.type)) {
                label = key.data.x;
                xValue = '';
            }
            return '<table>' +
                '<tbody>' +
                '<tr class="value"><b>' + xValue +
                '</b></tr>' +
                '<tr>' +
                '<td class="legend-color-guide"><div style="background-color:' + key.color + ';"></div></td>' +
                '<td class="key">' + label + '</td>' +
                '<td class="value">' + yValue + '</td>' +
                '</tr>' +
                '</tbody>' +
                '</table>';
        });
    };
    // intializes the chart obejct
    var initChart = function (widgetContext, xDomainValues, yDomainValues, propertyValueMap, isPreview) {
        propertyValueMap = initProperties(widgetContext, propertyValueMap);
        var chart, colors = [], xaxislabel, yaxislabel, labelConfig, radius, barSpacing, showLegend, xAxisValue, hasMultipleYValues;
        var xValue = {}, yValue = {};
        switch (widgetContext.type) {
            case 'Column':
                barSpacing = getNumberValue(propertyValueMap.barspacing, getBarSpacingValue) || barSpacingMap.medium;
                chart = nv.models.multiBarChart()
                    .x(function (d) { return d.x; })
                    .y(function (d) { return d.y; })
                    .reduceXTicks(propertyValueMap.reducexticks)
                    .rotateLabels(0)
                    .showControls(false)
                    .stacked(propertyValueMap.viewtype === 'Stacked' ? true : false)
                    .groupSpacing(barSpacing);
                break;
            case 'Cumulative Line':
                chart = nv.models.cumulativeLineChart()
                    .x(function (d) { return d[0]; })
                    .y(function (d) { return d[1]; })
                    .showControls(false)
                    .useInteractiveGuideline(propertyValueMap.tooltips)
                    .interpolate(propertyValueMap.interpolation);
                break;
            case 'Line':
                chart = nv.models.lineChart()
                    .useInteractiveGuideline(propertyValueMap.tooltips)
                    .interpolate(propertyValueMap.interpolation);
                break;
            case 'Area':
                chart = nv.models.stackedAreaChart()
                    .x(function (d) { return d[0]; })
                    .y(function (d) { return d[1]; })
                    .clipEdge(true)
                    .showControls(false)
                    .style(propertyValueMap.areaviewtype)
                    .useInteractiveGuideline(propertyValueMap.tooltips)
                    .interpolate(propertyValueMap.interpolation);
                break;
            case 'Bar':
                barSpacing = getNumberValue(propertyValueMap.barspacing, getBarSpacingValue) || barSpacingMap.medium;
                chart = nv.models.multiBarHorizontalChart()
                    .x(function (d) { return d.x; })
                    .y(function (d) { return d.y; })
                    .showControls(false)
                    .stacked(propertyValueMap.viewtype === 'Stacked' ? true : false)
                    .showValues(propertyValueMap.showvalues)
                    .groupSpacing(barSpacing);
                break;
            case 'Pie':
            case 'Donut':
                labelConfig = getLabelValues(propertyValueMap.showlabels, propertyValueMap.showlabelsoutside, 'value');
                radius = getNumberValue(propertyValueMap.donutratio, getRadiusValue) || donutRatioMap.medium;
                chart = nv.models.pieChart()
                    .x(function (d) { return d.x; })
                    .y(function (d) { return d.y; })
                    .showLabels(labelConfig.showlabels)
                    .labelType(propertyValueMap.labeltype)
                    .valueFormat(d3.format('%'))
                    .title(propertyValueMap.centerlabel)
                    .labelThreshold(propertyValueMap.labelthreshold || 0.01)
                    .labelsOutside(labelConfig.showlabelsoutside);
                if (isDonutChart(widgetContext.type)) {
                    chart.donut(true)
                        .donutRatio(radius);
                }
                if (propertyValueMap.labeltype === 'key-value') {
                    chart.labelType(function (d) { return d.data.x + ' ' + d.data.y; });
                }
                break;
            case 'Bubble':
                chart = nv.models.scatterChart()
                    .x(function (d) { return d.x; })
                    .y(function (d) { return d.y; })
                    .showDistX(propertyValueMap.showxdistance)
                    .showDistY(propertyValueMap.showydistance);
                break;
        }
        if (xDomainValues) {
            xValue.min = xDomainValues.min.x || xDomainValues.min[0];
            xValue.max = xDomainValues.max.x || xDomainValues.max[0];
            // If the values on the x axis are string then min max values gives Infinity
            if (areMinMaxValuesValid(xValue)) {
                // Reducing the min value to 0.1 so the min value is not missed out
                xValue.min = getYScaleMinValue(xValue.min);
                chart.xDomain([xValue.min, xValue.max]);
            }
        }
        if (yDomainValues) {
            // Reducing the min value to 1 so the min value is not missed out
            yValue.min = yDomainValues.min.y || yDomainValues.min[1];
            yValue.max = yDomainValues.max.y || yDomainValues.max[1];
            // If the values on the y axis are string or invalid then min max values gives Infinity
            if (areMinMaxValuesValid(yValue)) {
                // Reducing the min value to 1 so the min value is not missed out
                yValue.min = getYScaleMinValue(yValue.min);
                chart.yDomain([yValue.min, yValue.max]);
            }
        }
        // Setting the legend type choosen by user or default it will be furious
        chart.legend.vers((propertyValueMap.legendtype && propertyValueMap.legendtype.toLowerCase()) || 'furious');
        if (!_.includes(chartTypes, widgetContext.type)) {
            chart = nv.models.multiBarChart()
                .x(function (d) { return d.x; })
                .y(function (d) { return d.y; });
        }
        if (isPieType(widgetContext.type)) {
            // In case of pie/donut chart formatting the values of it
            if (propertyValueMap.labeltype === 'percent') {
                chart.valueFormat(d3.format('%'));
            }
            else {
                chart.valueFormat(function (d) { return getNumberFormatedData(propertyValueMap.ynumberformat, d); });
            }
            // Customizing the tooltips in case of the pie and donut when labelType is value
            customiseTooltip(chart, propertyValueMap, widgetContext);
        }
        else {
            chart.showXAxis(propertyValueMap.showxaxis)
                .showYAxis(propertyValueMap.showyaxis);
            // Setting the labels if they are specified explicitly or taking the axiskeys chosen
            xaxislabel = propertyValueMap.xaxislabel || core.prettifyLabels(widgetContext.xaxisdatakey) || 'x caption';
            yaxislabel = propertyValueMap.yaxislabel || core.prettifyLabels(widgetContext.yaxisdatakey) || 'y caption';
            // Checking if y axis has multiple values
            if (widgetContext.yaxisdatakey && widgetContext.yaxisdatakey.split(',').length > 1) {
                hasMultipleYValues = true;
            }
            // Customizing the tooltip to show yaxislabel, only if the y axis contains one value
            if (!hasMultipleYValues && !isBubbleChart(widgetContext.type)) {
                customiseTooltip(chart, propertyValueMap, widgetContext, yaxislabel);
            }
            // Adding the units to the captions if they are specified
            xaxislabel += propertyValueMap.xunits ? '(' + propertyValueMap.xunits + ')' : '';
            yaxislabel += propertyValueMap.yunits ? '(' + propertyValueMap.yunits + ')' : '';
            chart.xAxis
                .axisLabel(xaxislabel)
                .axisLabelDistance(propertyValueMap.xaxislabeldistance)
                .staggerLabels(propertyValueMap.staggerlabels);
            // If date format set format based date format
            if (propertyValueMap.xdateformat || (isPreview && !isBubbleChart(widgetContext.type))) {
                if (isLineTypeChart(widgetContext.type)) {
                    chart.xAxis.tickFormat(function (d) {
                        // get the actual value
                        xAxisValue = isPreview ? dateList[d - 1] : widgetContext.xDataKeyArr[d];
                        return getDateFormatedData(propertyValueMap.xdateformat, xAxisValue);
                    });
                }
                else {
                    chart.xAxis.tickFormat(function (d) { return getDateFormatedData(propertyValueMap.xdateformat, d); });
                }
            }
            else if (propertyValueMap.xnumberformat) {
                chart.xAxis.tickFormat(function (d) { return getNumberFormatedData(propertyValueMap.xnumberformat, d); });
            }
            else {
                if (isLineTypeChart(widgetContext.type)) {
                    // get the actual value
                    chart.xAxis.tickFormat(function (d) { return widgetContext.xDataKeyArr[d]; });
                }
            }
            chart.yAxis
                .axisLabel(yaxislabel)
                .axisLabelDistance(propertyValueMap.yaxislabeldistance)
                .staggerLabels(propertyValueMap.staggerlabels)
                .tickFormat(function (d) { return getNumberFormatedData(propertyValueMap.ynumberformat, d); });
            if (isBarChart(widgetContext.type)) {
                chart.valueFormat(function (d) { return getNumberFormatedData(propertyValueMap.ynumberformat, d); });
            }
        }
        // Support for custom colors if user gives direct string of colors in text box
        if (_.isString(propertyValueMap.customcolors) && propertyValueMap.customcolors) {
            colors = _.split(propertyValueMap.customcolors, ',');
        }
        if (_.isArray(propertyValueMap.customcolors)) {
            colors = propertyValueMap.customcolors;
        }
        showLegend = isShowLegend(propertyValueMap.showlegend);
        chart.showLegend(showLegend)
            .margin({ top: propertyValueMap.offsettop, right: propertyValueMap.offsetright, bottom: propertyValueMap.offsetbottom, left: propertyValueMap.offsetleft })
            .color(colors.length ? colors : themes[propertyValueMap.theme].colors);
        chart.tooltip.enabled(propertyValueMap.tooltips);
        widgetContext.message = propertyValueMap.nodatamessage || 'No data found';
        // setting the no data message
        chart.noData(widgetContext.message);
        if (isLineTypeChart(widgetContext.type) && widgetContext.highlightpoints) {
            chart.dispatch.on('stateChange', function () {
                setTimeout(function () { return postPlotChartProcess(widgetContext); }, 100);
            });
        }
        return chart;
    };
    var postPlotChartProcess = function (widgetContext, isPreview) {
        var id = isPreview ? null : widgetContext.$id;
        // If user sets to highlight the data points and increase the thickness of the line
        if (isLineTypeChart(widgetContext.type)) {
            setLineThickness(id, widgetContext.linethickness);
            highlightPoints(id, widgetContext.highlightpoints);
        }
        // Modifying the legend position only when legend is shown
        if (widgetContext.showlegend) {
            modifyLegendPosition(widgetContext, widgetContext.showlegend, id);
        }
    };
    var getDateList = function () { return dateList; };

    var WIDGET_CONFIG$e = { widgetType: 'wm-chart', hostClass: 'app-chart' };
    var NONE = 'none', advanceDataProps = ['aggregation', 'aggregationcolumn', 'groupby', 'orderby'], 
    // XPaths to get actual data of data points in charts
    chartDataPointXpath = {
        'Column': 'rect.nv-bar',
        'Bar': 'g.nv-bar',
        'Area': '.nv-stackedarea .nv-point',
        'Cumulative Line': '.nv-cumulativeLine .nv-scatterWrap path.nv-point',
        'Line': '.nv-lineChart .nv-scatterWrap path.nv-point',
        'Pie': '.nv-pieChart .nv-slice path',
        'Donut': '.nv-pieChart .nv-slice path',
        'Bubble': '.nv-scatterChart .nv-point-paths path'
    }, 
    styleProps = {
        'fontunit': 'font-size',
        'fontsize': 'font-size',
        'color': 'fill',
        'fontfamily': 'font-family',
        'fontweight': 'font-weight',
        'fontstyle': 'font-style',
        'textdecoration': 'text-decoration'
    }, 
    // Getting the relevant aggregation function based on the selected option
    aggregationFnMap = {
        'average': 'AVG',
        'count': 'COUNT',
        'maximum': 'MAX',
        'minimum': 'MIN',
        'sum': 'SUM'
    };
    var getBooleanValue = function (val) {
        if (val === true || val === 'true') {
            return true;
        }
        if (val === false || val === 'false') {
            return false;
        }
        return val;
    };
    // returns orderby columns and their orders in two separate arrays
    var getLodashOrderByFormat = function (orderby) {
        var columns;
        var orderByColumns = [], orders = [];
        _.forEach(_.split(orderby, ','), function (col) {
            columns = _.split(col, ':');
            orderByColumns.push(columns[0]);
            orders.push(columns[1]);
        });
        return {
            'columns': orderByColumns,
            'orders': orders
        };
    };
    // Replacing the '.' by the '$' because '.' is not supported in the alias names
    var getValidAliasName = function (aliasName) { return aliasName ? aliasName.replace(/\./g, '$') : null; };
    // Applying the font related styles for the chart
    var setTextStyle = function (properties, id) {
        var charttext = d3.select('#wmChart' + id + ' svg').selectAll('text');
        charttext.style(properties);
    };
    var angle = function (d) {
        var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
        return a > 90 ? a - 180 : a;
    };
    var ChartComponent = /** @class */ (function (_super) {
        __extends(ChartComponent, _super);
        function ChartComponent(inj, app) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$e) || this;
            _this.app = app;
            _this.iconclass = '';
            _this.nonPrimaryColumns = [];
            _this.xDataKeyArr = [];
            _this.chartData = [];
            _this._processedData = [];
            _this._plotChartProxy = _.debounce(_this.plotChartProxy.bind(_this), 100);
            _this.redraw = _this._plotChartProxy.bind(_this);
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER, ['fontsize', 'fontunit', 'color', 'fontfamily', 'fontweight', 'fontstyle', 'textdecoration']);
            // generate unique id for the component
            _this.$id = _this.widgetId || Math.random();
            // remove title attribute as the element on hover shows you the hint through-out the element
            core.removeAttr(_this.nativeElement, 'title');
            _this.chartReady = false;
            _this.binddataset = _this.nativeElement.getAttribute('dataset.bind');
            // Show loading status based on the variable life cycle
            _this.app.subscribe('toggle-variable-state', _this.handleLoading.bind(_this));
            return _this;
        }
        ChartComponent.prototype.isGroupByEnabled = function () {
            return !!(this.groupby && this.groupby !== NONE);
        };
        // Check if x and y axis that are chosen are valid to plot chart
        ChartComponent.prototype.isValidAxis = function () {
            // Check if x axis and y axis are chosen and are not equal
            return this.binddataset ? (this.xaxisdatakey && this.yaxisdatakey) : true;
        };
        // Check if aggregation is chosen
        ChartComponent.prototype.isAggregationEnabled = function () {
            return !!((this.isGroupByEnabled() && this.aggregation !== NONE && this.aggregationcolumn));
        };
        // Check if either groupby, aggregation or orderby is chosen
        ChartComponent.prototype.isDataFilteringEnabled = function () {
            /*Query need to be triggered if any of the following cases satisfy
            * 1. Group By and aggregation both chosen
            * 2. Only Order By is chosen
            * */
            return this.isAggregationEnabled() || (!this.isVisuallyGrouped && this.orderby);
        };
        /*Charts like Line,Area,Cumulative Line does not support any other datatype
            other than integer unlike the column and bar.It is a nvd3 issue. Inorder to
            support that this is a fix*/
        ChartComponent.prototype.getxAxisVal = function (dataObj, xKey, index) {
            var value = _.get(dataObj, xKey);
            // If x axis is other than number type then add indexes
            if (isLineTypeChart(this.type) && !core.isNumberType(this.xAxisDataType)) {
                // Verification to get the unique data keys
                this.xDataKeyArr.push(value);
                return index;
            }
            return value;
        };
        // Getting the min and max values among all the x values
        ChartComponent.prototype.getXMinMaxValues = function (datum) {
            if (!datum) {
                return;
            }
            var xValues = {};
            /*
             compute the min x value
             eg: When data has objects
                input: [{x:1, y:2}, {x:2, y:3}, {x:3, y:4}]
                min x: 1
             eg: When data has arrays
                input: [[10, 20], [20, 30], [30, 40]];
                min x: 10
            */
            xValues.min = _.minBy(datum.values, function (dataObject) { return dataObject.x || dataObject[0]; });
            /*
             compute the max x value
             eg: When data has objects
                input: [{x:1, y:2}, {x:2, y:3}, {x:3, y:4}]
                max x: 3
             eg: When data has arrays
                input: [[10, 20], [20, 30], [30, 40]];
                max x: 30
             */
            xValues.max = _.maxBy(datum.values, function (dataObject) { return dataObject.x || dataObject[0]; });
            return xValues;
        };
        // Getting the min and max values among all the y values
        ChartComponent.prototype.getYMinMaxValues = function (datum) {
            var yValues = {}, minValues = [], maxValues = [];
            if (!datum) {
                return;
            }
            /*
             Getting the min and max y values among all the series of data
             compute the min y value
             eg: When data has objects
                input: [[{x:1, y:2}, {x:2, y:3}, {x:3, y:4}], [{x:2, y:3}, {x:3, y:4}, {x:4, y:5}]]
                min y values : '2'(among first set) & '3'(among second set)
                max y values : '4'(among first set) & '5'(among second set)

             eg: When data has arrays
                input: [[[10, 20], [20, 30], [30, 40]], [[20, 30], [30, 40], [40, 50]]]
                min y values : '20'(among first set) & '30'(among second set)
                max y values : '40'(among first set) & '50'(among second set)
             */
            _.forEach(datum, function (data) {
                minValues.push(_.minBy(data.values, function (dataObject) { return dataObject.y || dataObject[1]; }));
                maxValues.push(_.maxBy(data.values, function (dataObject) { return dataObject.y || dataObject[1]; }));
            });
            // Gets the least and highest values among all the min and max values of respective series of data
            yValues.min = _.minBy(minValues, function (dataObject) { return dataObject.y || dataObject[1]; });
            yValues.max = _.maxBy(maxValues, function (dataObject) { return dataObject.y || dataObject[1]; });
            return yValues;
        };
        // If the x-axis values are undefined, we return empty array else we return the values
        ChartComponent.prototype.getValidData = function (values) {
            return (values.length === 1 && values[0] === undefined) ? [] : values;
        };
        // Returns the single data point based on the type of the data chart accepts
        ChartComponent.prototype.valueFinder = function (dataObj, xKey, yKey, index, shape) {
            var xVal = this.getxAxisVal(dataObj, xKey, index), value = _.get(dataObj, yKey), yVal = parseFloat(value) || value, size = parseFloat(dataObj[this.bubblesize]) || 2;
            var dataPoint = {};
            if (isChartDataJSON(this.type)) {
                dataPoint.x = xVal;
                dataPoint.y = yVal;
                // only Bubble chart has the third dimension
                if (isBubbleChart(this.type)) {
                    dataPoint.size = size;
                    dataPoint.shape = shape || 'circle';
                }
            }
            else if (isChartDataArray(this.type)) {
                dataPoint = [xVal, yVal];
            }
            // Adding actual unwrapped data to chart data to use at the time of selected data point of chart event
            dataPoint._dataObj = dataObj;
            return dataPoint;
        };
        // Setting appropriate error messages
        ChartComponent.prototype.setErrMsg = function (message) {
            if (this.showNoDataMsg) {
                this.showContentLoadError = true;
                this.invalidConfig = true;
                // TODO: Set the locale from the message
                this.errMsg = ''; // $rootScope.locale[message];
            }
        };
        ChartComponent.prototype.processChartData = function () {
            var _this = this;
            this.sampleData = getSampleData(this);
            // scope variables used to keep the actual key values for x-axis
            this.xDataKeyArr = [];
            // Plotting the chart with sample data when the chart dataset is not bound
            if (!this.binddataset) {
                this.xDataKeyArr = getDateList();
                return this.sampleData;
            }
            if (!this.chartData || !this.chartData.length) {
                return [];
            }
            var datum = [], yAxisKey, shapes = [], values = [];
            var xAxisKey = this.xaxisdatakey, yAxisKeys = this.yaxisdatakey ? this.yaxisdatakey.split(',') : [], dataSet = this.chartData;
            if (_.isArray(dataSet)) {
                if (isPieType(this.type)) {
                    yAxisKey = yAxisKeys[0];
                    datum = _.map(dataSet, function (dataObj, index) {
                        if (!core.isEmptyObject(dataSet[index])) {
                            return _this.valueFinder(dataSet[index], xAxisKey, yAxisKey);
                        }
                    });
                    datum = this.getValidData(datum);
                }
                else {
                    if (isBubbleChart(this.type)) {
                        shapes = this.shape === 'random' ? allShapes : this.shape;
                    }
                    yAxisKeys.forEach(function (yAxisKey, series) {
                        values = _.map(dataSet, function (dataObj, index) {
                            if (!core.isEmptyObject(dataSet[index])) {
                                return _this.valueFinder(dataSet[index], xAxisKey, yAxisKey, index, (_.isArray(shapes) && shapes[series]) || _this.shape);
                            }
                        });
                        values = _this.getValidData(values);
                        datum.push({
                            values: values,
                            key: core.prettifyLabels(yAxisKey)
                        });
                    });
                }
            }
            return datum;
        };
        ChartComponent.prototype.setChartData = function (data) {
            if (data) {
                this._processedData = data;
            }
        };
        ChartComponent.prototype.getChartData = function () {
            return this._processedData;
        };
        // constructing the grouped data based on the selection of orderby, x & y axis
        ChartComponent.prototype.getVisuallyGroupedData = function (queryResponse, groupingColumn) {
            var _this = this;
            var groupData = {}, groupValues = [], orderByDetails, maxLength;
            var chartData = [], _isAreaChart = isAreaChart(this.type), yAxisKey = _.first(_.split(this.yaxisdatakey, ','));
            this.xDataKeyArr = [];
            queryResponse = _.orderBy(queryResponse, _.split(this.groupby, ','));
            if (this.orderby) {
                orderByDetails = getLodashOrderByFormat(this.orderby);
                queryResponse = _.orderBy(queryResponse, orderByDetails.columns, orderByDetails.orders);
            }
            queryResponse = _.groupBy(queryResponse, groupingColumn);
            // In case of area chart all the series data should be of same length
            if (_isAreaChart) {
                maxLength = _.max(_.map(queryResponse, function (obj) { return obj.length; }));
            }
            _.forEach(queryResponse, function (values, groupKey) {
                groupValues = isAreaChart ? _.fill(new Array(maxLength), [0, 0]) : [];
                _.forEachRight(values, function (value, index) {
                    groupValues[index] = _this.valueFinder(value, _this.xaxisdatakey, yAxisKey, index);
                });
                groupData = {
                    key: groupKey,
                    values: groupValues
                };
                chartData.push(groupData);
            });
            return chartData;
        };
        /*Decides whether the data should be visually grouped or not
                Visually grouped when a different column is choosen in the group by other than x and y axis and aggregation is not chosen*/
        ChartComponent.prototype.getGroupingDetails = function () {
            var _this = this;
            if (this.isGroupByEnabled() && !this.isAggregationEnabled()) {
                var isVisuallyGrouped_1 = false, visualGroupingColumn_1, groupingExpression = void 0, columns_1 = [], groupingColumnIndex_1;
                var groupbyColumns_1 = this.groupby && this.groupby !== NONE ? this.groupby.split(',') : [], yAxisKeys_1 = this.yaxisdatakey ? this.yaxisdatakey.split(',') : [];
                if (groupbyColumns_1.length > 1) {
                    /*Getting the group by column which is not selected either in x or y axis*/
                    groupbyColumns_1.every(function (column, index) {
                        if (_this.xaxisdatakey !== column && $.inArray(column, yAxisKeys_1) === -1) {
                            isVisuallyGrouped_1 = true;
                            visualGroupingColumn_1 = column;
                            groupingColumnIndex_1 = index;
                            groupbyColumns_1.splice(groupingColumnIndex_1, 1);
                            return false;
                        }
                        return true;
                    });
                    // Constructing the groupby expression
                    if (visualGroupingColumn_1) {
                        columns_1.push(visualGroupingColumn_1);
                    }
                    if (groupbyColumns_1.length) {
                        columns_1 = _.concat(columns_1, groupbyColumns_1);
                    }
                }
                // If x and y axis are not included in aggregation need to be included in groupby
                if (this.xaxisdatakey !== this.aggregationcolumn) {
                    columns_1.push(this.xaxisdatakey);
                }
                _.forEach(yAxisKeys_1, function (key) {
                    if (key !== _this.aggregationcolumn) {
                        columns_1.push(key);
                    }
                });
                groupingExpression = columns_1.join(',');
                // set isVisuallyGrouped flag in scope for later use
                this.isVisuallyGrouped = isVisuallyGrouped_1;
                return {
                    expression: groupingExpression,
                    isVisuallyGrouped: isVisuallyGrouped_1,
                    visualGroupingColumn: visualGroupingColumn_1
                };
            }
            return {
                expression: '',
                isVisuallyGrouped: false,
                visualGroupingColumn: ''
            };
        };
        // Function to get the aggregated data after applying the aggregation & group by or order by operations.
        ChartComponent.prototype.getAggregatedData = function (callback) {
            var _this = this;
            var variable = this.datasource, yAxisKeys = this.yaxisdatakey ? this.yaxisdatakey.split(',') : [], data = {};
            var sortExpr, columns = [], colAlias, orderByColumns, groupByFields = [];
            if (!variable) {
                return;
            }
            if (this.isGroupByEnabled()) {
                groupByFields = _.split(this.groupby, ',');
            }
            if (this.orderby) {
                sortExpr = _.replace(this.orderby, /:/g, ' ');
                columns = _.uniq(_.concat(columns, groupByFields, [this.aggregationcolumn]));
                orderByColumns = getLodashOrderByFormat(this.orderby).columns;
                // If the orderby column is chosen either in groupby or orderby then replace . with $ for that column
                _.forEach(_.intersection(columns, orderByColumns), function (col) {
                    colAlias = getValidAliasName(col);
                    sortExpr = _.replace(sortExpr, col, colAlias);
                });
            }
            if (this.isAggregationEnabled()) {
                // Send the group by in the aggregations api only if aggregation is also chosen
                data.groupByFields = groupByFields;
                data.aggregations = [
                    {
                        'field': this.aggregationcolumn,
                        'type': aggregationFnMap[this.aggregation],
                        'alias': getValidAliasName(this.aggregationcolumn)
                    }
                ];
            }
            // Execute the query.
            variable.execute('getAggregatedData', {
                'aggregations': data,
                'sort': sortExpr
            }).then(function (response) {
                // Transform the result into a format supported by the chart.
                var chartData = [], aggregationAlias = getValidAliasName(_this.aggregationcolumn), xAxisAliasKey = getValidAliasName(_this.xaxisdatakey), yAxisAliasKeys = [];
                yAxisKeys.forEach(function (yAxisKey) { return yAxisAliasKeys.push(getValidAliasName(yAxisKey)); });
                _.forEach(response.body.content, function (responseContent) {
                    var obj = {};
                    // Set the response in the chartData based on 'aggregationColumn', 'xAxisDataKey' & 'yAxisDataKey'.
                    if (_this.isAggregationEnabled()) {
                        obj[_this.aggregationcolumn] = responseContent[aggregationAlias];
                        obj[_this.aggregationcolumn] = _.get(responseContent, aggregationAlias) || _.get(responseContent, _this.aggregationcolumn);
                    }
                    obj[_this.xaxisdatakey] = _.get(responseContent, xAxisAliasKey) || _.get(responseContent, _this.xaxisdatakey);
                    yAxisKeys.forEach(function (yAxisKey, index) {
                        obj[yAxisKey] = responseContent[yAxisAliasKeys[index]];
                        obj[yAxisKey] = _.get(responseContent, yAxisAliasKeys[index]) || _.get(responseContent, yAxisKey);
                    });
                    chartData.push(obj);
                });
                _this.chartData = chartData;
                core.triggerFn(callback);
            }, function () {
                _this.chartData = [];
                _this.setErrMsg('MESSAGE_ERROR_FETCH_DATA');
                core.triggerFn(callback);
            });
        };
        // This function sets maximum width for the labels that can be displayed.This will helpful when they are overlapping
        ChartComponent.prototype.setLabelsMaxWidth = function () {
            var xTicks, tickWidth, maxLength, xDist, yDist, totalHeight, maxNoLabels, nthElement, labelsAvailableWidth, barWrapper, yAxisWrapper, svgWrapper;
            var fontsize = parseInt(this.fontsize, 10) || 12, isBarchart = isBarChart(this.type);
            // getting the x ticks in the chart
            xTicks = $('#wmChart' + this.$id + ' svg').find('g.nv-x').find('g.tick').find('text');
            // getting the distance between the two visible ticks associated with visible text
            xTicks.each(function () {
                var xTick = $(this);
                var xTransform, tickDist;
                if (xTick.text() && xTick.css('opacity') === '1') {
                    xTransform = xTick.parent().attr('transform').split(',');
                    xDist = parseFloat(xTransform[0].substr(10));
                    yDist = parseFloat(xTransform[1] || '0');
                    if (!isBarchart && xDist > 0) {
                        tickDist = xDist;
                    }
                    else if (yDist > 0) {
                        tickDist = yDist;
                    }
                    if (tickWidth) {
                        tickWidth = tickDist - tickWidth;
                        return false;
                    }
                    tickWidth = tickDist;
                    return true;
                }
            });
            // In case of bar chart getting the available space for the labels to be displayed
            if (isBarchart) {
                barWrapper = $('#wmChart' + this.$id + ' svg>g.nv-wrap>g>g.nv-barsWrap')[0];
                yAxisWrapper = $('#wmChart' + this.$id + ' svg>g.nv-wrap>g>g.nv-y')[0];
                svgWrapper = $('#wmChart' + this.$id + ' svg')[0];
                // getting the total height of the chart
                totalHeight = barWrapper ? barWrapper.getBoundingClientRect().height : 0;
                // getting the labels available space
                labelsAvailableWidth = yAxisWrapper ? svgWrapper.getBoundingClientRect().width - yAxisWrapper.getBoundingClientRect().width : svgWrapper.getBoundingClientRect().width;
                // Setting the max length for the label
                maxLength = Math.round(labelsAvailableWidth / fontsize);
                // if available space for each label is less than the font-size
                // then limiting the labels to be displayed
                if (tickWidth < fontsize) {
                    // calculate the maximum no of labels to be fitted
                    maxNoLabels = totalHeight / fontsize;
                    // showing only the nth element
                    nthElement = Math.ceil(this.chartData.length / maxNoLabels);
                    // showing up only some labels
                    d3.select('#wmChart' + this.$id + ' svg').select('g.nv-x').selectAll('g.tick').select('text').each(function (text, i) {
                        // hiding every non nth element
                        if (i % nthElement !== 0) {
                            d3.select(this).attr('opacity', 0);
                        }
                    });
                }
            }
            else {
                // Setting the max length for the label
                maxLength = Math.round(tickWidth / fontsize);
            }
            // maxLength should always be a positive number
            maxLength = Math.abs(maxLength);
            // Validating if every label exceeds the max length and if so limiting the length and adding ellipsis
            xTicks.each(function () {
                if (this.textContent.length > maxLength) {
                    this.textContent = this.textContent.substr(0, maxLength) + '...';
                }
            });
        };
        // Returns the columns of that can be choosen in the x and y axis
        ChartComponent.prototype.getDefaultColumns = function () {
            var type, stringColumn, i, temp;
            var defaultColumns = [], columns = this.datasource.execute(core.DataSource.Operation.GET_PROPERTIES_MAP) || [];
            for (i = 0; i < columns.length && defaultColumns.length <= 2; i += 1) {
                type = columns[i].type;
                if (!columns[i].isRelated && (core.isNumberType(type))) {
                    defaultColumns.push(columns[i].fieldName);
                }
                else if (type === 'string' && !stringColumn) {
                    stringColumn = columns[i].fieldName;
                }
            }
            // Other than bubble chart x: string type y: number type
            // Bubble chart x: number type y: number type
            if (stringColumn && defaultColumns.length > 0 && !isBubbleChart(this.type)) {
                temp = defaultColumns[0];
                defaultColumns[0] = stringColumn;
                defaultColumns[1] = temp;
            }
            return defaultColumns;
        };
        // Call user defined javascript function when user links it to click event of the widget.
        ChartComponent.prototype.attachClickEvent = function () {
            var _this = this;
            var dataObj;
            d3.select('#wmChart' + this.$id + ' svg').selectAll(chartDataPointXpath[this.type]).style('pointer-events', 'all')
                .on('click', function (data, index) {
                switch (_this.type) {
                    case 'Column':
                    case 'Bar':
                        dataObj = data._dataObj;
                        break;
                    case 'Pie':
                    case 'Donut':
                        dataObj = data.data._dataObj;
                        break;
                    case 'Area':
                    case 'Cumulative Line':
                    case 'Line':
                        dataObj = data[0]._dataObj;
                        break;
                    case 'Bubble':
                        dataObj = data.data.point[4]._dataObj;
                        break;
                }
                _this.selecteditem = dataObj;
                _this.invokeEventCallback('select', { $event: d3.event, selectedChartItem: data, selectedItem: _this.selecteditem });
            });
        };
        /*  Returns Y Scale min value
               Ex: Input   : 8.97
                   Output  : 8.87

                   Input   : 8
                   Output  : 7
           */
        ChartComponent.prototype.postPlotProcess = function (chart) {
            var _this = this;
            var chartSvg, pieLabels, pieGroups, angleArray;
            var styleObj = {};
            var element = this.$element;
            postPlotChartProcess(this);
            if (!isPieType(this.type)) {
                this.setLabelsMaxWidth();
            }
            else if (!this.showlabelsoutside) {
                /** Nvd3 has a issue in rotating text. So we will use this as a temp fix.
                 * If the issue is resolved there, we can remove this.*/
                /* If it is a donut chart, then rotate the text and position them*/
                chartSvg = d3.select('#wmChart' + this.$id + ' svg');
                pieLabels = chartSvg.select('.nv-pieLabels').selectAll('.nv-label');
                pieGroups = chartSvg.select('.nv-pie').selectAll('.nv-slice');
                angleArray = [];
                if (pieGroups && pieGroups.length) {
                    pieGroups.each(function () {
                        d3.select(this).attr('transform', function (d) {
                            angleArray.push(angle(d));
                        });
                    });
                    pieLabels.each(function (d, i) {
                        var group = d3.select(this);
                        $(group[0][0]).find('text').attr('transform', 'rotate(' + angleArray[i] + ')');
                    });
                }
            }
            // prepare text style props object and set
            _.forEach(styleProps, function (value, key) {
                if (key === 'fontsize' || key === 'fontunit') {
                    styleObj[value] = _this.fontsize + _this.fontunit;
                }
                else {
                    styleObj[value] = _this[key];
                }
            });
            setTextStyle(styleObj, this.$id);
            /*
             * allow window-resize functionality, for only-run mode as
             * updating chart is being handled by watchers of height & width in studio-mode
             * */
            core.triggerFn(this._resizeFn && this._resizeFn.clear);
            this._resizeFn = nv.utils.windowResize(function () {
                if (element[0].getBoundingClientRect().height) {
                    chart.update();
                    postPlotChartProcess(_this);
                    if (!isPieType(_this.type)) {
                        _this.setLabelsMaxWidth();
                    }
                }
            });
        };
        // prepares and configures the chart properties
        ChartComponent.prototype.configureChart = function () {
            // Copy the data only in case of pie chart with default data
            // Reason : when multiple pie charts are bound to same data, first chart theme will be applied to all charts
            var xDomainValues;
            var yDomainValues;
            var chart;
            var beforeRenderVal;
            if (this._processedData.length > 0) {
                if (isAxisDomainValid(this, 'x')) {
                    xDomainValues = this.binddataset ? this.getXMinMaxValues(this._processedData[0]) : { 'min': { 'x': 1 }, 'max': { 'x': 5 } };
                }
                if (isAxisDomainValid(this, 'y')) {
                    yDomainValues = this.binddataset ? this.getYMinMaxValues(this._processedData) : { 'min': { 'y': 1 }, 'max': { 'y': 5 } };
                }
            }
            if (isPieType(this.type) && (!this.binddataset || !this.scopedataset)) {
                this._processedData = core.getClonedObject(this.scopedataset || this._processedData);
            }
            // get the chart object
            chart = initChart(this, xDomainValues, yDomainValues, null, !this.binddataset);
            if (_.isArray(this._processedData)) {
                beforeRenderVal = this.invokeEventCallback('beforerender', { 'chartInstance': chart });
                if (beforeRenderVal) {
                    chart = beforeRenderVal;
                }
                this.chart = chart;
                // changing the default no data message
                d3.select('#wmChart' + this.$id + ' svg')
                    .datum(this._processedData)
                    .call(this.chart);
                this.postPlotProcess(chart);
                return chart;
            }
        };
        // Plotting the chart with set of the properties set to it
        ChartComponent.prototype.plotChart = function () {
            var _this = this;
            var element = this.$element;
            // call user-transformed function
            this.chartData = (this.invokeEventCallback('transform')) || this.chartData;
            // Getting the order by data only in run mode. The order by applies for all the charts other than pie and donut charts
            if (this.isVisuallyGrouped && !isPieType(this.type)) {
                this._processedData = this.chartData;
            }
            else {
                this._processedData = this.processChartData();
            }
            // checking the parent container before plotting the chart
            if (!element[0].getBoundingClientRect().height) {
                return;
            }
            if (this.clearCanvas) {
                // empty svg to add-new chart
                element.find('svg').replaceWith('<svg></svg>');
                this.clearCanvas = false;
            }
            // In case of invalid axis show no data available message
            if (!this.isValidAxis()) {
                this._processedData = [];
            }
            nv.addGraph(function () { return _this.configureChart(); }, function () {
                /*Bubble chart has an time out delay of 300ms in their implementation due to which we
                * won't be getting required data points on attaching events
                * hence delaying it 600ms*/
                setTimeout(function () {
                    _this.attachClickEvent();
                }, 600);
            });
            this.isLoadInProgress = false;
        };
        Object.defineProperty(ChartComponent.prototype, "isLiveVariable", {
            // TODO: Need way to figure out if the datasource is a live source
            get: function () {
                // setting the flag for the live variable in the scope for the checks
                var variableObj = this.datasource;
                return variableObj && variableObj.category === 'wm.LiveVariable';
            },
            enumerable: true,
            configurable: true
        });
        ChartComponent.prototype.plotChartProxy = function () {
            var _this = this;
            this.showContentLoadError = false;
            this.invalidConfig = false;
            // Checking if x and y axis are chosen
            this.isLoadInProgress = true;
            var groupingDetails = this.getGroupingDetails();
            // If aggregation/group by/order by properties have been set, then get the aggregated data and plot the result in the chart.
            // TODO: datasource for live variable detection
            if (this.binddataset && this.isLiveVariable && (this.filterFields || this.isDataFilteringEnabled())) {
                this.getAggregatedData(function () { return _this.plotChart(); });
            }
            else { // Else, simply plot the chart.
                // In case of live variable resetting the aggregated data to the normal dataset when the aggregation has been removed
                if (this.dataset && this.isLiveVariable) {
                    this.chartData = this.dataset;
                    if (this.isGroupByEnabled() && groupingDetails.isVisuallyGrouped) {
                        this.chartData = this.getVisuallyGroupedData(this.chartData, groupingDetails.visualGroupingColumn);
                    }
                }
                this.plotChart();
            }
        };
        // sets the default x and y axis options
        ChartComponent.prototype.setDefaultAxisOptions = function () {
            var defaultColumns = this.getDefaultColumns();
            // If we get the valid default columns then assign them as the x and y axis
            // In case of service variable we may not get the valid columns because we cannot know the datatypes
            this.xaxisdatakey = defaultColumns[0] || null;
            this.yaxisdatakey = defaultColumns[1] || null;
        };
        ChartComponent.prototype.getCutomizedOptions = function (prop, fields) {
            var groupByColumns = _.split(this.groupby, ','), aggColumns = _.split(this.aggregationcolumn, ',');
            if (!this.binddataset) {
                return fields;
            }
            if (!this.axisoptions) {
                this.axisoptions = fields;
            }
            var newOptions;
            switch (prop) {
                case 'xaxisdatakey':
                    // If group by enabled, columns chosen in groupby will be populated in x axis options
                    if (this.isGroupByEnabled()) {
                        newOptions = groupByColumns;
                    }
                    break;
                case 'yaxisdatakey':
                    // If aggregation by enabled, columns chosen in aggregation will be populated in y axis options
                    if (this.isAggregationEnabled()) {
                        newOptions = aggColumns;
                    }
                    else if (this.isLiveVariable) {
                        // In case of live variable populating only numeric columns
                        newOptions = this.numericColumns;
                    }
                    break;
                case 'groupby':
                    // Filtering only non primary key columns
                    if (this.isLiveVariable && this.nonPrimaryColumns && this.nonPrimaryColumns.length) {
                        newOptions = this.nonPrimaryColumns;
                    }
                    break;
                case 'aggregationcolumn':
                    // Set the 'aggregationColumn' to show all keys in case of aggregation function is count or to numeric keys in all other cases.
                    if (this.isLiveVariable && this.isAggregationEnabled() && this.aggregation !== 'count') {
                        newOptions = this.numericColumns;
                    }
                    break;
                case 'orderby':
                    // Set the 'aggregationColumn' to show all keys in case of aggregation function is count or to numeric keys in all other cases.
                    if (this.isLiveVariable && this.isAggregationEnabled()) {
                        newOptions = _.uniq(_.concat(groupByColumns, aggColumns));
                    }
                    break;
                case 'bubblesize':
                    if (this.numericColumns && this.numericColumns.length) {
                        newOptions = this.numericColumns;
                    }
                    break;
            }
            return newOptions || fields || this.axisoptions;
        };
        // Function that iterates through all the columns and then fetching the numeric and non primary columns among them
        ChartComponent.prototype.setNumericandNonPrimaryColumns = function () {
            var _this = this;
            var columns, type;
            var propertiesMap = this.datasource.execute(core.DataSource.Operation.GET_PROPERTIES_MAP);
            this.numericColumns = [];
            this.nonPrimaryColumns = [];
            // Fetching all the columns
            if (this.dataset && !_.isEmpty(propertiesMap)) {
                columns = []; // TODO: fetchPropertiesMapColumns(propertiesMap);
            }
            if (columns) {
                // Iterating through all the columns and fetching the numeric and non primary key columns
                _.forEach(Object.keys(columns), function (key) {
                    type = columns[key].type;
                    if (core.isNumberType(type)) {
                        _this.numericColumns.push(key);
                    }
                    // Hiding only table's primary key
                    if (columns[key].isRelatedPk === 'true' || !columns[key].isPrimaryKey) {
                        _this.nonPrimaryColumns.push(key);
                    }
                });
                this.numericColumns = this.numericColumns.sort();
                this.nonPrimaryColumns = this.nonPrimaryColumns.sort();
            }
        };
        // plot the chart
        ChartComponent.prototype.handleDataSet = function (newVal) {
            this.errMsg = '';
            // Resetting the flag to false when the binding was removed
            if (!newVal && !this.binddataset) {
                this.isVisuallyGrouped = false;
                this.axisoptions = null;
            }
            // liveVariables contain data in 'data' property' of the variable
            this.chartData = this.isLiveVariable ? newVal || '' : (newVal && newVal.dataValue === '' && _.keys(newVal).length === 1) ? '' : newVal;
            // if the data returned is an object make it an array of object
            if (!_.isArray(this.chartData) && _.isObject(this.chartData)) {
                this.chartData = [this.chartData];
            }
            if (newVal && newVal.filterFields) {
                this.filterFields = newVal.filterFields;
            }
            // plotchart for only valid data and only after bound variable returns data
            if (this.chartData) {
                this._plotChartProxy();
            }
        };
        ChartComponent.prototype.onPropertyChange = function (key, newVal, oldVal) {
            _super.prototype.onPropertyChange.call(this, key, newVal, oldVal);
            switch (key) {
                case 'dataset':
                    this.handleDataSet(newVal);
                    break;
                case 'type':
                    // Based on the change in type deciding the default margins
                    if (isPieType(this.type)) {
                        this.offsettop = 20;
                        this.offsetright = 0;
                        this.offsetbottom = 0;
                        this.offsetleft = 0;
                    }
                    else if (oldVal === 'Pie' || oldVal === 'Donut') {
                        this.offsettop = 25;
                        this.offsetright = 25;
                        this.offsetbottom = 55;
                        this.offsetleft = 75;
                    }
                    if (oldVal !== newVal) {
                        this.clearCanvas = true;
                    }
                    // In studio mode, configure properties dependent on chart type
                    this._plotChartProxy();
                    break;
                default:
                    // In RunMode, the plotchart method will not be called for all property change
                    this._plotChartProxy();
                    break;
            }
            if (_.includes(advanceDataProps, key)) {
                this._plotChartProxy();
            }
        };
        ChartComponent.prototype.handleLoading = function (data) {
            var dataSource = this.datasource;
            if (dataSource && dataSource.execute(core.DataSource.Operation.IS_API_AWARE) && core.isDataSourceEqual(data.variable, dataSource)) {
                this.variableInflight = data.active;
                this.isLoadInProgress = data.active;
            }
        };
        ChartComponent.prototype.onStyleChange = function (key, newVal, oldVal) {
            var styleObj = {};
            _super.prototype.onStyleChange.call(this, key, newVal, oldVal);
            switch (key) {
                case 'fontsize':
                case 'fontunit':
                case 'color':
                case 'fontfamily':
                case 'fontweight':
                case 'fontstyle':
                case 'textdecoration':
                    styleObj[styleProps[key]] = (key === 'fontsize' || key === 'fontunit') ? this.fontsize + this.fontunit : newVal;
                    setTextStyle(styleObj, this.$id);
                    break;
            }
        };
        ChartComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            // For old projects
            if (!_.includes(['outside', 'inside', 'hide'], this.showlabels)) {
                this.showlabels = getBooleanValue(this.showlabels);
                this.showlabelsoutside = getBooleanValue(this.showlabelsoutside);
                this.showlabels = this.showlabels ? (this.showlabelsoutside ? 'outside' : 'inside') : 'hide';
            }
            if (!this.theme) {
                // Default theme for pie/donut is Azure and for other it is Terrestrial
                this.theme = isPieType(this.type) ? 'Azure' : 'Terrestrial';
            }
            this.nativeElement.setAttribute('id', 'wmChart' + this.$id);
            // When there is not value binding, then plot the chart with sample data
            if (!this.binddataset && !this.nativeElement.getAttribute('scopedataset')) {
                this._plotChartProxy();
            }
        };
        ChartComponent.initializeProps = registerProps$f();
        ChartComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmChart]',
                        template: "<div class=\"panel-heading\" *ngIf=\"title\">\n    <h3 class=\"panel-title\">\n        <div class=\"pull-left\"><i class=\"app-icon panel-icon {{iconclass}}\" [class.ng-hide]=\"!iconclass\"></i></div>\n        <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\"></div>\n        <div class=\"description\" *ngIf=\"subheading\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n    </h3>\n</div>\n<div class=\"app-chart-inner\" [ngClass]=\"{'loading':isLoadInProgress, 'panel-body': title}\">\n    <svg></svg>\n    <div class=\"wm-content-info readonly-wrapper\" *ngIf=\"showContentLoadError && showNoDataMsg\">\n        <p class=\"wm-message\" [title]=\"hintMsg\" [ngClass]=\"{'error': invalidConfig}\" [innerText]=\"errMsg\"></p>\n    </div>\n    <div wmSpinner show.bind=\"isLoadInProgress\" caption.bind=\"loadingdatamsg\"></div>\n</div>",
                        providers: [
                            provideAsWidgetRef(ChartComponent)
                        ],
                        encapsulation: core$1.ViewEncapsulation.None,
                        styles: [".nvd3 .nv-axis{pointer-events:none;opacity:1}.nvd3 .nv-axis path{fill:none;stroke:#000;stroke-opacity:.75;shape-rendering:crispEdges}.nvd3 .nv-axis path.domain{stroke-opacity:.75}.nvd3 .nv-axis.nv-x path.domain{stroke-opacity:0}.nvd3 .nv-axis line{fill:none;stroke:#e5e5e5;shape-rendering:crispEdges}.nvd3 .nv-axis .zero line,.nvd3 .nv-axis line.zero{stroke-opacity:.75}.nvd3 .nv-axis .nv-axisMaxMin text{font-weight:700}.nvd3 .x .nv-axis .nv-axisMaxMin text,.nvd3 .x2 .nv-axis .nv-axisMaxMin text,.nvd3 .x3 .nv-axis .nv-axisMaxMin text{text-anchor:middle}.nvd3 .nv-axis.nv-disabled{opacity:0}.nvd3 .nv-bars rect{fill-opacity:.75;transition:fill-opacity 250ms linear}.nvd3 .nv-bars rect.hover{fill-opacity:1}.nvd3 .nv-bars .hover rect{fill:#add8e6}.nvd3 .nv-bars text{fill:transparent}.nvd3 .nv-bars .hover text{fill:rgba(0,0,0,1)}.nvd3 .nv-discretebar .nv-groups rect,.nvd3 .nv-multibar .nv-groups rect,.nvd3 .nv-multibarHorizontal .nv-groups rect{stroke-opacity:0;transition:fill-opacity 250ms linear}.nvd3 .nv-candlestickBar .nv-ticks rect:hover,.nvd3 .nv-discretebar .nv-groups rect:hover,.nvd3 .nv-multibar .nv-groups rect:hover,.nvd3 .nv-multibarHorizontal .nv-groups rect:hover{fill-opacity:1}.nvd3 .nv-discretebar .nv-groups text,.nvd3 .nv-multibarHorizontal .nv-groups text{font-weight:700;fill:rgba(0,0,0,1);stroke:transparent}.nvd3 .nv-boxplot circle{fill-opacity:.5}.nvd3 .nv-boxplot circle:hover,.nvd3 .nv-boxplot rect:hover{fill-opacity:1}.nvd3 line.nv-boxplot-median{stroke:#000}.nv-boxplot-tick:hover{stroke-width:2.5px}.nvd3.nv-bullet{font:10px sans-serif}.nvd3.nv-bullet .nv-measure{fill-opacity:.8}.nvd3.nv-bullet .nv-measure:hover{fill-opacity:1}.nvd3.nv-bullet .nv-marker{stroke:#000;stroke-width:2px}.nvd3.nv-bullet .nv-markerTriangle{stroke:#000;fill:#fff;stroke-width:1.5px}.nvd3.nv-bullet .nv-markerLine{stroke:#000;stroke-width:1.5px}.nvd3.nv-bullet .nv-tick line{stroke:#666;stroke-width:.5px}.nvd3.nv-bullet .nv-range.nv-s0{fill:#eee}.nvd3.nv-bullet .nv-range.nv-s1{fill:#ddd}.nvd3.nv-bullet .nv-range.nv-s2{fill:#ccc}.nvd3.nv-bullet .nv-title{font-size:14px;font-weight:700}.nvd3.nv-bullet .nv-subtitle{fill:#999}.nvd3.nv-bullet .nv-range{fill:#bababa;fill-opacity:.4}.nvd3.nv-bullet .nv-range:hover{fill-opacity:.7}.nvd3.nv-candlestickBar .nv-ticks .nv-tick{stroke-width:1px}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.hover{stroke-width:2px}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.positive rect{stroke:#2ca02c;fill:#2ca02c}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.negative rect{stroke:#d62728;fill:#d62728}.with-transitions .nv-candlestickBar .nv-ticks .nv-tick{transition:stroke-width 250ms linear,stroke-opacity 250ms linear}.nvd3.nv-candlestickBar .nv-ticks line{stroke:#333}.nv-force-node{stroke:#fff;stroke-width:1.5px}.nv-force-link{stroke:#999;stroke-opacity:.6}.nv-force-node text{stroke-width:0}.nvd3 .nv-check-box .nv-box{fill-opacity:0;stroke-width:2}.nvd3 .nv-check-box .nv-check{fill-opacity:0;stroke-width:4}.nvd3 .nv-series.nv-disabled .nv-check-box .nv-check{fill-opacity:0;stroke-opacity:0}.nvd3 .nv-controlsWrap .nv-legend .nv-check-box .nv-check{opacity:0}.nvd3.nv-linePlusBar .nv-bar rect{fill-opacity:.75}.nvd3.nv-linePlusBar .nv-bar rect:hover{fill-opacity:1}.nvd3 .nv-groups path.nv-line{fill:none}.nvd3 .nv-groups path.nv-area{stroke:none}.nvd3.nv-line .nvd3.nv-scatter .nv-groups .nv-point{fill-opacity:0;stroke-opacity:0}.nvd3.nv-scatter.nv-single-point .nv-groups .nv-point{fill-opacity:.5!important;stroke-opacity:.5!important}.with-transitions .nvd3 .nv-groups .nv-point{transition:stroke-width 250ms linear,stroke-opacity 250ms linear}.nvd3 .nv-groups .nv-point.hover,.nvd3.nv-scatter .nv-groups .nv-point.hover{stroke-width:7px;fill-opacity:.95!important;stroke-opacity:.95!important}.nvd3 .nv-point-paths path{stroke:#aaa;stroke-opacity:0;fill:#eee;fill-opacity:0}.nvd3 .nv-indexLine{cursor:ew-resize}svg.nvd3-svg{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;width:100%;height:100%}.nvtooltip.with-3d-shadow,.with-3d-shadow .nvtooltip{box-shadow:0 5px 10px rgba(0,0,0,.2);border-radius:5px}.nvd3 text{font:12px Arial,sans-serif}.nvd3 .title{font:bold 14px Arial,sans-serif}.nvd3 .nv-background{fill:#fff;fill-opacity:0}.nvd3.nv-noData{font-size:18px;font-weight:700}.nv-brush .extent{fill-opacity:.125;shape-rendering:crispEdges}.nv-brush .resize path{fill:#eee;stroke:#666}.nvd3 .nv-legend .nv-series{cursor:pointer}.nvd3 .nv-legend .nv-disabled circle{fill-opacity:0}.nvd3 .nv-brush .extent{fill-opacity:0!important}.nvd3 .nv-brushBackground rect{stroke:#000;stroke-width:.4;fill:#fff;fill-opacity:.7}@media print{.nvd3 text{stroke-width:0;fill-opacity:1}}.nvd3.nv-ohlcBar .nv-ticks .nv-tick{stroke-width:1px}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.hover{stroke-width:2px}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.positive{stroke:#2ca02c}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.negative{stroke:#d62728}.nvd3 .background path{fill:none;stroke:#eee;stroke-opacity:.4;shape-rendering:crispEdges}.nvd3 .foreground path{fill:none;stroke-opacity:.7}.nvd3 .nv-parallelCoordinates-brush .extent{fill:#fff;fill-opacity:.6;stroke:gray;shape-rendering:crispEdges}.nvd3 .nv-parallelCoordinates .hover{fill-opacity:1;stroke-width:3px}.nvd3 .missingValuesline line{fill:none;stroke:#000;stroke-width:1;stroke-opacity:1;stroke-dasharray:5,5}.nvd3.nv-pie path{stroke-opacity:0;transition:fill-opacity 250ms linear,stroke-width 250ms linear,stroke-opacity 250ms linear;stroke:#fff;stroke-width:1px;stroke-opacity:1;fill-opacity:.7}.nvd3.nv-pie .nv-pie-title{font-size:24px;fill:rgba(19,196,249,.59)}.nvd3.nv-pie .nv-slice text{stroke:#000;stroke-width:0}.nvd3.nv-pie .hover path{fill-opacity:1}.nvd3.nv-pie .nv-label{pointer-events:none}.nvd3.nv-pie .nv-label rect{fill-opacity:0;stroke-opacity:0}.nvd3 .nv-groups .nv-point.hover{stroke-width:20px;stroke-opacity:.5}.nvd3 .nv-scatter .nv-point.hover{fill-opacity:1}.nv-distx,.nv-disty,.nv-noninteractive{pointer-events:none}.nvd3.nv-sparkline path{fill:none}.nvd3.nv-sparklineplus g.nv-hoverValue{pointer-events:none}.nvd3.nv-sparklineplus .nv-hoverValue line{stroke:#333;stroke-width:1.5px}.nvd3.nv-sparklineplus,.nvd3.nv-sparklineplus g{pointer-events:all}.nvd3 .nv-hoverArea{fill-opacity:0;stroke-opacity:0}.nvd3.nv-sparklineplus .nv-xValue,.nvd3.nv-sparklineplus .nv-yValue{stroke-width:0;font-size:.9em;font-weight:400}.nvd3.nv-sparklineplus .nv-yValue{stroke:#f66}.nvd3.nv-sparklineplus .nv-maxValue{stroke:#2ca02c;fill:#2ca02c}.nvd3.nv-sparklineplus .nv-minValue{stroke:#d62728;fill:#d62728}.nvd3.nv-sparklineplus .nv-currentValue{font-weight:700;font-size:1.1em}.nvd3.nv-stackedarea path.nv-area{fill-opacity:.7;stroke-opacity:0;transition:fill-opacity 250ms linear,stroke-opacity 250ms linear}.nvd3.nv-stackedarea path.nv-area.hover{fill-opacity:.9}.nvd3.nv-stackedarea .nv-groups .nv-point{stroke-opacity:0;fill-opacity:0}.nvtooltip{position:absolute;color:rgba(0,0,0,1);padding:1px;border:1px solid rgba(0,0,0,.5);z-index:10000;display:block;font-family:Arial,sans-serif;font-size:13px;text-align:left;pointer-events:none;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background:rgba(255,255,255,.8);border-radius:4px}.nvtooltip.with-transitions,.with-transitions .nvtooltip{transition:opacity 50ms linear .2s}.nvtooltip.x-nvtooltip,.nvtooltip.y-nvtooltip{padding:8px}.nvtooltip h3{margin:0;padding:4px 14px;line-height:18px;font-weight:400;background-color:rgba(247,247,247,.75);color:rgba(0,0,0,1);text-align:center;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.nvtooltip p{margin:0;padding:5px 14px;text-align:center}.nvtooltip span{display:inline-block;margin:2px 0}.nvtooltip table{margin:6px;border-spacing:0}.nvtooltip table td{padding:2px 9px 2px 0;vertical-align:middle}.nvtooltip table td.key{font-weight:400}.nvtooltip table td.key.total{font-weight:700}.nvtooltip table td.value{text-align:right;font-weight:700}.nvtooltip table td.percent{color:#a9a9a9}.nvtooltip table tr.highlight td{padding:1px 9px 1px 0;border-bottom-style:solid;border-bottom-width:1px;border-top-style:solid;border-top-width:1px}.nvtooltip table td.legend-color-guide div{vertical-align:middle;width:12px;height:12px;border:1px solid #999}.nvtooltip .footer{padding:3px;text-align:center}.nvtooltip-pending-removal{pointer-events:none;display:none}.nvd3 .nv-interactiveGuideLine{pointer-events:none}.nvd3 line.nv-guideline{stroke:#ccc}"]
                    }] }
        ];
        /** @nocollapse */
        ChartComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core.App }
            ];
        };
        ChartComponent.propDecorators = {
            title: [{ type: core$1.HostBinding, args: ['class.panel',] }]
        };
        return ChartComponent;
    }(StylableComponent));

    var checkboxProps = new Map([
        ['caption', PROP_STRING],
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['checkedvalue', __assign({ value: true }, PROP_STRING)],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['name', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['uncheckedvalue', __assign({ value: false }, PROP_STRING)]
    ]);
    var registerProps$g = function () {
        register('wm-checkbox', checkboxProps);
    };

    var BaseFormComponent = /** @class */ (function (_super) {
        __extends(BaseFormComponent, _super);
        function BaseFormComponent(inj, config, initPromise) {
            var _this = _super.call(this, inj, config, initPromise) || this;
            _this.inj = inj;
            _this.binddatavalue = _this.$element.attr('datavalue.bind');
            return _this;
        }
        /**
         * Responsible for updating the variable bound to the widget's datavalue property.
         * @param value
         */
        BaseFormComponent.prototype.updateBoundVariable = function (value) {
            var binddatavalue = this.binddatavalue;
            // return if the variable bound is not static.
            if (this.datavaluesource && this.datavaluesource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                return;
            }
            else if (this.datavaluesource && !this.datavaluesource.twoWayBinding) {
                return;
            }
            // return if widget is bound.
            if (!binddatavalue || binddatavalue.startsWith('Widgets.') || binddatavalue.startsWith('itemRef.currentItemWidgets')) {
                return;
            }
            binddatavalue = binddatavalue.replace(/\[\$i\]/g, '[0]');
            // In case of list widget context will be the listItem.
            if (_.has(this.context, binddatavalue.split('.')[0])) {
                _.set(this.context, binddatavalue, value);
            }
            else {
                _.set(this.viewParent, binddatavalue, value);
            }
        };
        BaseFormComponent.prototype.invokeOnChange = function (value, $event) {
            // invoke the event callback
            if ($event) {
                if (this.datavalue !== this.prevDatavalue) {
                    this.updateBoundVariable(value);
                    this.invokeEventCallback('change', {
                        $event: $event,
                        newVal: value,
                        oldVal: this.prevDatavalue
                    });
                }
            }
            // update the previous value
            this.prevDatavalue = value;
        };
        BaseFormComponent.prototype.updatePrevDatavalue = function (val) {
            this.prevDatavalue = val;
        };
        return BaseFormComponent;
    }(StylableComponent));

    var BaseFormCustomComponent = /** @class */ (function (_super) {
        __extends(BaseFormCustomComponent, _super);
        function BaseFormCustomComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onChange = function () { };
            _this._onTouched = function () { };
            return _this;
        }
        BaseFormCustomComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this._formControl = this.inj.get(forms.FormControlName, null);
        };
        BaseFormCustomComponent.prototype.registerOnChange = function (fn) {
            this._onChange = fn;
        };
        BaseFormCustomComponent.prototype.registerOnTouched = function (fn) {
            this._onTouched = fn;
        };
        BaseFormCustomComponent.prototype.writeValue = function (value) {
            if (this.isDestroyed) {
                return;
            }
            if (this._formControl) {
                this.datavalue = value;
                this.onPropertyChange('datavalue', value);
                this.updatePrevDatavalue(value);
            }
        };
        BaseFormCustomComponent.prototype.invokeOnChange = function (value, $event, valid) {
            // let the angular know about the change
            this._onChange(value);
            if (valid) {
                _super.prototype.invokeOnChange.call(this, value, $event);
            }
        };
        BaseFormCustomComponent.prototype.invokeOnTouched = function ($event) {
            this._onTouched();
            if ($event) {
                this.invokeEventCallback('blur', { $event: $event });
            }
        };
        BaseFormCustomComponent.prototype.invokeOnFocus = function ($event) {
            this.invokeEventCallback('focus', { $event: $event });
        };
        return BaseFormCustomComponent;
    }(BaseFormComponent));

    var DEFAULT_CLS$d = 'app-checkbox checkbox';
    var WIDGET_CONFIG$f = {
        widgetType: 'wm-checkbox',
        hostClass: DEFAULT_CLS$d
    };
    /*
     * try to convert the chekedvalue and unchecked values to boolean/number
     */
    var unStringify = function (val, defaultVal) {
        if (val === null) {
            return defaultVal;
        }
        if (val === true || val === 'true') {
            return true;
        }
        if (val === false || val === 'false') {
            return false;
        }
        var number = parseInt(val, 10);
        if (!isNaN(number)) {
            return number;
        }
        return val;
    };
    var CheckboxComponent = /** @class */ (function (_super) {
        __extends(CheckboxComponent, _super);
        function CheckboxComponent(inj, checkedVal, uncheckedVal, type) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$f) || this;
            _this._caption = '&nbsp';
            _this._checkedvalue = unStringify(checkedVal, true);
            _this._uncheckedvalue = unStringify(uncheckedVal, false);
            // if the type of the checkbox is toggle update the related classes on the host node
            core.toggleClass(_this.nativeElement, 'app-toggle', type === 'toggle');
            return _this;
        }
        Object.defineProperty(CheckboxComponent.prototype, "datavalue", {
            // if the checkbox is checked, return checkedvalue else return uncheckedvalue
            get: function () {
                return core.isDefined(this.proxyModel) ? (this.proxyModel ? this._checkedvalue : this._uncheckedvalue) : undefined;
            },
            // when the datavalue is set, update the checked state
            set: function (v) {
                this.proxyModel = (core.isDefined(v) && v !== '') ? v === this._checkedvalue : undefined;
                this.updatePrevDatavalue(this.datavalue);
            },
            enumerable: true,
            configurable: true
        });
        CheckboxComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'tabindex') {
                return;
            }
            if (key === 'caption') {
                if (!core.isDefined(nv) || nv === '') {
                    this._caption = '&nbsp;';
                }
                else {
                    this._caption = nv;
                }
            }
            else if (key === 'checkedvalue') {
                this._checkedvalue = unStringify(nv, true);
            }
            else if (key === 'uncheckedvalue') {
                this._uncheckedvalue = unStringify(nv, false);
            }
            else if (key === 'datavalue') {
                this.datavalue = unStringify(nv);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        // change and blur events are handled from template
        CheckboxComponent.prototype.handleEvent = function (node, eventName, callback, locals) {
            if (eventName !== 'change' && eventName !== 'blur') {
                // applying tap (Hammer event) on the label as the event handler is not getting triggered on the input.
                var $el = eventName === 'tap' ? this.nativeElement.querySelector('label') : this.checkboxEl.nativeElement;
                _super.prototype.handleEvent.call(this, $el, eventName, callback, locals);
            }
        };
        CheckboxComponent.prototype.handleChange = function (newVal) {
            this.invokeOnChange(this.datavalue, { type: 'change' }, this.ngModel.valid);
        };
        CheckboxComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.nativeElement.querySelector('label'), this);
        };
        CheckboxComponent.initializeProps = registerProps$g();
        CheckboxComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmCheckbox]',
                        template: "<label [ngClass]=\"{'unchecked': !proxyModel, 'disabled': (disabled || readonly), 'required': (required && _caption)}\" role=\"button\">\n    <input type=\"checkbox\" aria-describedby=\"checkbox\"\n           #checkbox\n           [attr.name]=\"name\"\n           focus-target\n           [(ngModel)]=\"proxyModel\"\n           [readonly]=\"readonly\"\n           [required]=\"required\"\n           [disabled]=\"disabled || readonly\"\n           [attr.accesskey]=\"shortcutkey\"\n           [tabindex]=\"tabindex\"\n           (blur)=\"invokeOnTouched($event)\"\n           (ngModelChange)=\"handleChange($event)\">\n    <span class=\"caption\" [innerHtml]=\"_caption\"></span>\n    <img alt=\"Checkbox Image\" src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" class=\"switch\"/>\n</label>\n<input type=\"hidden\" class=\"ng-hide model-holder\" [disabled]=\"disabled\" [value]=\"proxyModel\">\n",
                        providers: [
                            provideAsNgValueAccessor(CheckboxComponent),
                            provideAsWidgetRef(CheckboxComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        CheckboxComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['checkedvalue',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['uncheckedvalue',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['type',] }] }
            ];
        };
        CheckboxComponent.propDecorators = {
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }],
            checkboxEl: [{ type: core$1.ViewChild, args: ['checkbox', { read: core$1.ElementRef },] }]
        };
        return CheckboxComponent;
    }(BaseFormCustomComponent));

    var getEpochValue = function (data) {
        var epoch;
        // For data in form of string number ('123'), convert to number (123). And don't parse date objects.
        if (!_.isDate(data) && !isNaN(data)) {
            data = parseInt(data, 10);
        }
        // get the timestamp value. If data is time string, append date string to the time value
        epoch = moment(data).valueOf() || moment(new Date().toDateString() + ' ' + data).valueOf();
        return epoch;
    };
    var ToDatePipe = /** @class */ (function () {
        function ToDatePipe(datePipe) {
            this.datePipe = datePipe;
        }
        ToDatePipe.prototype.transform = function (data, format) {
            var timestamp;
            // 'null' is to be treated as a special case, If user wants to enter null value, empty string will be passed to the backend
            if (data === 'null' || data === '') {
                return '';
            }
            if (!core.isDefined(data)) {
                return '';
            }
            timestamp = getEpochValue(data);
            if (timestamp) {
                if (format === 'timestamp') {
                    return timestamp;
                }
                return this.datePipe.transform(timestamp, format);
            }
            return '';
        };
        ToDatePipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'toDate'
                    },] }
        ];
        /** @nocollapse */
        ToDatePipe.ctorParameters = function () {
            return [
                { type: common.DatePipe }
            ];
        };
        return ToDatePipe;
    }());
    var ToNumberPipe = /** @class */ (function () {
        function ToNumberPipe(decimalPipe) {
            this.decimalPipe = decimalPipe;
        }
        ToNumberPipe.prototype.transform = function (data, fracSize) {
            if (fracSize && !String(fracSize).match(/^(\d+)?\.((\d+)(-(\d+))?)?$/)) {
                fracSize = '1.' + fracSize + '-' + fracSize;
            }
            if (!_.isNaN(+data)) {
                return this.decimalPipe.transform(data, fracSize);
            }
        };
        ToNumberPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'toNumber'
                    },] }
        ];
        /** @nocollapse */
        ToNumberPipe.ctorParameters = function () {
            return [
                { type: common.DecimalPipe }
            ];
        };
        return ToNumberPipe;
    }());
    var ToCurrencyPipe = /** @class */ (function () {
        function ToCurrencyPipe(decimalPipe) {
            this.decimalPipe = decimalPipe;
        }
        ToCurrencyPipe.prototype.transform = function (data, currencySymbol, fracSize) {
            var _currencySymbol = (core.CURRENCY_INFO[currencySymbol] || {}).symbol || currencySymbol || '', _val = new ToNumberPipe(this.decimalPipe).transform(data, fracSize);
            return _val ? _currencySymbol + _val : '';
        };
        ToCurrencyPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'toCurrency'
                    },] }
        ];
        /** @nocollapse */
        ToCurrencyPipe.ctorParameters = function () {
            return [
                { type: common.DecimalPipe }
            ];
        };
        return ToCurrencyPipe;
    }());
    var PrefixPipe = /** @class */ (function () {
        function PrefixPipe() {
        }
        PrefixPipe.prototype.transform = function (data, padding) {
            return (_.isUndefined(data) || data === null || data === '') ? data : ((padding || '') + data);
        };
        PrefixPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'prefix'
                    },] }
        ];
        return PrefixPipe;
    }());
    var SuffixPipe = /** @class */ (function () {
        function SuffixPipe() {
        }
        SuffixPipe.prototype.transform = function (data, padding) {
            return (_.isUndefined(data) || data === null || data === '') ? data : (data + (padding || ''));
        };
        SuffixPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'suffix'
                    },] }
        ];
        return SuffixPipe;
    }());
    var TimeFromNowPipe = /** @class */ (function () {
        function TimeFromNowPipe() {
        }
        TimeFromNowPipe.prototype.transform = function (data) {
            var timestamp;
            if (!core.isDefined(data)) {
                return undefined;
            }
            timestamp = getEpochValue(data);
            return timestamp ? moment(timestamp).fromNow() : undefined;
        };
        TimeFromNowPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'timeFromNow'
                    },] }
        ];
        return TimeFromNowPipe;
    }());
    var NumberToStringPipe = /** @class */ (function (_super) {
        __extends(NumberToStringPipe, _super);
        function NumberToStringPipe() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NumberToStringPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'numberToString'
                    },] }
        ];
        return NumberToStringPipe;
    }(ToNumberPipe));
    var StringToNumberPipe = /** @class */ (function () {
        function StringToNumberPipe() {
        }
        StringToNumberPipe.prototype.transform = function (data) {
            return Number(data) || undefined;
        };
        StringToNumberPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'stringToNumber'
                    },] }
        ];
        return StringToNumberPipe;
    }());
    var FilterPipe = /** @class */ (function () {
        function FilterPipe() {
        }
        FilterPipe.prototype.transform = function (data, field, value) {
            if (!data) {
                return [];
            }
            // If object is passed as first paramter
            if (_.isObject(field)) {
                return _.filter(data, field);
            }
            // If key value pair is provided
            return _.filter(data, function (item) {
                return _.includes(item[field], value);
            });
        };
        FilterPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'filter'
                    },] }
        ];
        return FilterPipe;
    }());
    var FileSizePipe = /** @class */ (function () {
        function FileSizePipe() {
        }
        FileSizePipe.prototype.transform = function (bytes, precision) {
            var units = [
                'bytes',
                'KB',
                'MB',
                'GB',
                'TB',
                'PB'
            ];
            /*Todo[shubham]
            if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) {
                return isMobile() ? '' : '?';
            }*/
            var unit = 0;
            while (bytes >= 1024) {
                bytes /= 1024;
                unit++;
            }
            return bytes.toFixed(+precision) + ' ' + units[unit];
        };
        FileSizePipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'filesize'
                    },] }
        ];
        return FileSizePipe;
    }());
    var FileIconClassPipe = /** @class */ (function () {
        function FileIconClassPipe() {
        }
        FileIconClassPipe.prototype.transform = function (fileExtension) {
            var fileClassMapping = {
                'zip': 'fa-file-zip-o',
                'pdf': 'fa-file-pdf-o',
                'rar': 'fa-file-archive-o',
                'txt': 'fa-file-text-o',
                'ppt': 'fa-file-powerpoint-o',
                'pot': 'fa-file-powerpoint-o',
                'pps': 'fa-file-powerpoint-o',
                'pptx': 'fa-file-powerpoint-o',
                'potx': 'fa-file-powerpoint-o',
                'ppsx': 'fa-file-powerpoint-o',
                'mpg': 'fa-file-movie-o',
                'mp4': 'fa-file-movie-o',
                'mov': 'fa-file-movie-o',
                'avi': 'fa-file-movie-o',
                'mp3': 'fa-file-audio-o',
                'docx': 'fa-file-word-o',
                'js': 'fa-file-code-o',
                'md': 'fa-file-code-o',
                'html': 'fa-file-code-o',
                'css': 'fa-file-code-o',
                'xlsx': 'fa-file-excel-o',
                'png': 'fa-file-image-o',
                'jpg': 'fa-file-image-o',
                'jpeg': 'fa-file-image-o',
                'file': 'fa-file-o',
                'default': 'fa-file-o'
            };
            return 'fa ' + (fileClassMapping[fileExtension] || 'fa-file-o');
        };
        FileIconClassPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'fileIconClass'
                    },] }
        ];
        return FileIconClassPipe;
    }());
    var StateClassPipe = /** @class */ (function () {
        function StateClassPipe() {
        }
        StateClassPipe.prototype.transform = function (state) {
            var stateClassMap = {
                'success': 'wi wi-done text-success',
                'error': 'wi wi-cancel text-danger'
            };
            return stateClassMap[state.toLowerCase()];
        };
        StateClassPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'stateClass'
                    },] }
        ];
        return StateClassPipe;
    }());
    var FileExtensionFromMimePipe = /** @class */ (function () {
        function FileExtensionFromMimePipe() {
        }
        FileExtensionFromMimePipe.prototype.transform = function (mimeType) {
            var typeMapping = {
                'audio/aac': '.aac',
                'application/x-abiword': '.abw',
                'application/vnd.android.package-archive': '.apk',
                'video/x-msvideo': '.avi',
                'application/vnd.amazon.ebook': '.azw',
                'application/octet-stream': '.bin',
                'image/bmp': '.bmp',
                'application/x-bzip': '.bz',
                'application/x-bzip2': '.bz2',
                'application/x-csh': '.csh',
                'text/css': '.css',
                'text/csv': '.csv',
                'application/msword': '.doc',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx',
                'application/vnd.ms-fontobject': '.eot',
                'application/epub+zip': '.epub',
                'application/ecmascript': '.es',
                'image/gif': '.gif',
                'text/html': '.html',
                'image/x-icon': '.ico',
                'text/calendar': '.ics',
                'application/java-archive': '.jar',
                'image/jpeg': ['.jpeg', '.jpg'],
                'application/javascript': '.js',
                'application/json': '.json',
                'audio/midi': '.mid',
                'audio/x-midi': '.midi',
                'video/mpeg': '.mpeg',
                'application/vnd.apple.installer+xml': 'mpkg',
                'application/vnd.oasis.opendocument.presentation': '.odp',
                'application/vnd.oasis.opendocument.spreadsheet': '.ods',
                'application/vnd.oasis.opendocument.text': '.odt',
                'audio/ogg': '.oga',
                'video/ogg': '.ogv',
                'application/ogg': '.ogx',
                'font/otf': '.otf',
                'image/png': '.png',
                'application/pdf': '.pdf',
                'application/vnd.ms-powerpoint': '.ppt',
                'application/vnd.openxmlformats-officedocument.presentationml.presentation': '.pptx',
                'application/x-rar-compressed': '.rar',
                'application/rtf': '.rtf',
                'application/x-sh': '.sh',
                'image/svg+xml': '.svg',
                'application/x-shockwave-flash': '.swf',
                'application/x-tar': '.tar',
                'image/tiff': '.tiff',
                'application/typescript': '.ts',
                'font/ttf': '.ttf',
                'text/plain': '.txt',
                'application/vnd.visio': '.vsd',
                'audio/wav': '.wav',
                'audio/webm': '.weba',
                'video/webm': '.webm',
                'image/webp': '.webp',
                'font/woff': '.woff',
                'font/woff2': '.woff2',
                'application/xhtml+xml': '.xhtml',
                'application/vnd.ms-excel': '.xls',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': '.xlsx',
                'application/xml': '.xml',
                'application/vnd.mozilla.xul+xml': '.xul',
                'application/zip': '.zip',
                'video/3gpp': '.3gp',
                'audio/3gpp': '.3gp',
                'video/3gpp2': '.3g2',
                'audio/3gpp2': '.3g2',
                'application/x-7z-compressed': '.7z'
            };
            return typeMapping[mimeType];
        };
        FileExtensionFromMimePipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'fileExtensionFromMime'
                    },] }
        ];
        return FileExtensionFromMimePipe;
    }());

    var checkboxsetProps = new Map([
        ['class', PROP_STRING],
        ['collapsible', PROP_BOOLEAN],
        ['compareby', PROP_STRING],
        ['datafield', PROP_STRING],
        ['dataset', __assign({ value: 'Option 1, Option 2, Option 3' }, PROP_ANY)],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['dateformat', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['displayexpression', PROP_STRING],
        ['displayfield', PROP_STRING],
        ['displayValue', PROP_STRING],
        ['groupby', PROP_STRING],
        ['itemclass', __assign({ value: '' }, PROP_STRING)],
        ['layout', __assign({ value: 'stacked' }, PROP_STRING)],
        ['listclass', __assign({ value: '' }, PROP_STRING)],
        ['match', PROP_STRING],
        ['name', PROP_STRING],
        ['orderby', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showcount', PROP_BOOLEAN],
        ['showindevice', __assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['usekeys', PROP_BOOLEAN]
    ]);
    var registerProps$h = function () {
        register('wm-checkboxset', checkboxsetProps);
    };

    var DatasetAwareFormComponent = /** @class */ (function (_super) {
        __extends(DatasetAwareFormComponent, _super);
        function DatasetAwareFormComponent(inj, WIDGET_CONFIG) {
            var _this = _super.call(this, inj, WIDGET_CONFIG) || this;
            _this.datasetItems = [];
            _this.acceptsArray = false; // set to true if proxyModel on widget accepts array type.
            _this.dataset$ = new rxjs.Subject();
            _this.datavalue$ = new rxjs.Subject();
            _this.allowempty = true;
            _this._debounceDatavalueUpdation = _.debounce(function (values) {
                // if no item is found in datasetItems, wait untill the dataset updates by preserving the datavalue in toBeProcessedDatavalue.
                if (!core.isDefined(_this._modelByKey) || (_.isArray(_this._modelByKey) && !_this._modelByKey.length)) {
                    _this.toBeProcessedDatavalue = values;
                    _this._modelByValue = undefined;
                }
                else if (core.isDefined(_this.toBeProcessedDatavalue)) {
                    // obtain the first array value when multiple is set to false.
                    // set the modelByValue only when undefined.
                    if (!core.isDefined(_this._modelByValue)) {
                        _this._modelByValue = (!_this.multiple && _.isArray(_this.toBeProcessedDatavalue)) ? _this.toBeProcessedDatavalue[0] : _this.toBeProcessedDatavalue;
                    }
                    _this.toBeProcessedDatavalue = undefined;
                }
                _this.initDisplayValues();
            }, 150);
            _this.binddisplayexpression = _this.nativeElement.getAttribute('displayexpression.bind');
            _this.binddisplayimagesrc = _this.nativeElement.getAttribute('displayimagesrc.bind');
            _this.binddisplaylabel = _this.nativeElement.getAttribute('displaylabel.bind');
            _this._debouncedInitDatasetItems = core.debounce(function () {
                _this.initDatasetItems();
                core.$appDigest();
            }, 150);
            return _this;
        }
        Object.defineProperty(DatasetAwareFormComponent.prototype, "modelByKey", {
            get: function () {
                return this._modelByKey;
            },
            // triggers on ngModel change. This function extracts the datavalue value.
            set: function (val) {
                this.selectByKey(val);
                // invoke on datavalue change.
                this.invokeOnChange(this._modelByValue);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatasetAwareFormComponent.prototype, "datavalue", {
            get: function () {
                return this._modelByValue;
            },
            // triggers on setting the datavalue. This function extracts the model value.
            set: function (val) {
                if (this.multiple) {
                    val = extractDataAsArray(val);
                }
                this._modelByValue = val;
                this.selectByValue(val);
                // changes on the datavalue can be subscribed using listenToDatavalue
                this.datavalue$.next(val);
                // invoke on datavalue change.
                this.invokeOnChange(val, undefined, true);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This function sets the _datavalue value from the model and sets the selected flag when item is found.
         * Here model is the value obtained from ngModel.
         * @param keys represent the model.
         */
        DatasetAwareFormComponent.prototype.selectByKey = function (keys) {
            var _this = this;
            this.resetDatasetItems();
            if (!this.datasetItems.length) {
                return;
            }
            if (this.multiple && !_.isArray(keys)) {
                keys = [keys];
            }
            // Set the _modelByKey to the modified keys.
            this._modelByKey = keys;
            if (this.multiple) {
                this._modelByValue = [];
                keys.forEach(function (key) {
                    var itemByKey = _.find(_this.datasetItems, function (item) {
                        // not triple equal, as the instance type can be different.
                        // only value comparison should be done.
                        return _.toString(item.key) === _.toString(key);
                    });
                    if (itemByKey) {
                        itemByKey.selected = true;
                        _this._modelByValue = __spread(_this._modelByValue, [itemByKey.value]);
                    }
                });
            }
            else {
                this._modelByValue = '';
                var itemByKey = _.find(this.datasetItems, function (item) {
                    // not triple equal, as the instance type can be different.
                    // only value comparison should be done.
                    return _.toString(item.key) === _.toString(keys);
                });
                if (itemByKey) {
                    itemByKey.selected = true;
                    this._modelByValue = itemByKey.value;
                }
            }
            this.initDisplayValues();
        };
        /**
         * This function sets the _model value from the datavalue (selectedvalues) and sets the selected flag when item is found.
         * datavalue is the default value or a value representing the displayField (for suppose: object in case of ALLFIELDS).
         * If acceptsArray is true, the model always accepts an array.
         * For example, select always accepts model as array whether multiple select is true or false.
         * @param values represent the datavalue.
         */
        DatasetAwareFormComponent.prototype.selectByValue = function (values) {
            var _this = this;
            this.resetDatasetItems();
            // if datavalue is not defined or empty then set the model as undefined.
            if (!core.isDefined(values) || values === '' || _.isNull(values) || (values instanceof Array && !values.length)) {
                this._modelByKey = undefined;
                // do not return when allowempty is set to true.
                if (!this.allowempty || !core.isDefined(values)) {
                    return;
                }
            }
            if (this.acceptsArray && !_.isArray(values)) {
                values = this.allowempty ? [values] : extractDataAsArray(values);
            }
            // preserve the datavalue if datasetItems are empty.
            if (!this.datasetItems.length && core.isDefined(values)) {
                this.toBeProcessedDatavalue = values;
                return;
            }
            var filterField = this.datafield === ALLFIELDS ? 'dataObject' : 'key';
            if (_.isArray(values)) {
                this._modelByKey = [];
                values.forEach(function (val) {
                    var itemByValue = _.find(_this.datasetItems, function (item) {
                        if (filterField === 'dataObject') {
                            if (_this.compareby && _this.compareby.length) {
                                return core.isEqualWithFields(item[filterField], val, _this.compareby);
                            }
                        }
                        return (_.isObject(item.value) ? _.isEqual(item.value, val) : (_.toString(item.value)).toLowerCase() === (_.toString(val)).toLowerCase());
                    });
                    if (itemByValue) {
                        itemByValue.selected = true;
                        _this._modelByKey.push(itemByValue.key);
                    }
                });
            }
            else {
                this._modelByKey = undefined;
                var itemByValue = _.find(this.datasetItems, function (item) {
                    if (filterField === 'dataObject') {
                        if (_this.compareby && _this.compareby.length) {
                            return core.isEqualWithFields(item[filterField], values, _this.compareby);
                        }
                    }
                    return (_.isObject(item.value) ? _.isEqual(item.value, values) : (_.toString(item.value)).toLowerCase() === (_.toString(values)).toLowerCase());
                });
                if (itemByValue) {
                    itemByValue.selected = true;
                    this._modelByKey = itemByValue.key;
                }
            }
            // delaying the datavalue update as the widgets in liveform are having datavalue as undefined and not the default provided value
            // because datavalue is updated later when new dataset is available.
            this._debounceDatavalueUpdation(values);
        };
        // Updates the displayValue property.
        DatasetAwareFormComponent.prototype.initDisplayValues = function () {
            var displayValues = [];
            this.datasetItems.forEach(function (item) {
                if (item.selected) {
                    displayValues.push(item.label);
                }
            });
            this.displayValue = this.multiple ? displayValues : displayValues[0];
        };
        // This function parses the dataset and extracts the displayOptions from parsed dataset.
        DatasetAwareFormComponent.prototype.initDatasetItems = function () {
            if (!this.dataset || _.isEmpty(this.dataset)) {
                this.datasetItems = [];
                return;
            }
            // convert any dataset to the object format.
            var orderedDataset = getOrderedDataset(convertDataToObject(this.dataset), this.orderby);
            if (this.usekeys) {
                this.datasetItems = transformDataWithKeys(orderedDataset);
            }
            else {
                var displayOptions = transformData$1(this.viewParent, orderedDataset, this.datafield, {
                    displayField: this.displayfield || this.displaylabel,
                    displayExpr: this.displayexpression,
                    bindDisplayExpr: this.binddisplayexpression || this.binddisplaylabel,
                    bindDisplayImgSrc: this.binddisplayimagesrc,
                    displayImgSrc: this.displayimagesrc
                });
                // get the unique objects out of the extracted data. Notify change in datasetItems using [...datasetItems] notation
                this.datasetItems = __spread(getUniqObjsByDataField(displayOptions, this.datafield, this.displayfield || this.displaylabel, core.toBoolean(this.allowempty)));
            }
            this.postDatasetItemsInit();
        };
        // Once the datasetItems are ready, set the proxyModel by using datavalue.
        DatasetAwareFormComponent.prototype.postDatasetItemsInit = function () {
            if (this.datasetItems.length && !this._defaultQueryInvoked) {
                // use the latest of toBeProcessedDatavalue, datavalue
                var _datavalue = !core.isDefined(this.toBeProcessedDatavalue) ? this.datavalue : this.toBeProcessedDatavalue;
                this.selectByValue(_datavalue);
            }
            // notify the dataset listeners
            this.dataset$.next(this.datasetItems);
        };
        // Reset the selected flag on datasetItems to false.
        DatasetAwareFormComponent.prototype.resetDatasetItems = function () {
            this.datasetItems.forEach(function (item) { return item.selected = false; });
        };
        DatasetAwareFormComponent.prototype.onPropertyChange = function (key, nv, ov) {
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
            switch (key) {
                case 'dataset':
                case 'datafield':
                case 'displayfield':
                case 'displaylabel':
                case 'displayexpression':
                case 'orderby':
                case 'usekeys':
                    this._debouncedInitDatasetItems();
                    break;
            }
        };
        return DatasetAwareFormComponent;
    }(BaseFormCustomComponent));

    var DEFAULT_CLS$e = 'app-checkboxset list-group';
    var WIDGET_CONFIG$g = { widgetType: 'wm-checkboxset', hostClass: DEFAULT_CLS$e };
    var CheckboxsetComponent = /** @class */ (function (_super) {
        __extends(CheckboxsetComponent, _super);
        function CheckboxsetComponent(inj, groupby, appDefaults, datePipe) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$g) || this;
            _this.groupby = groupby;
            _this.appDefaults = appDefaults;
            _this.datePipe = datePipe;
            _this.layout = '';
            styler(_this.nativeElement, _this);
            _this.multiple = true;
            _this.handleHeaderClick = core.noop;
            return _this;
        }
        CheckboxsetComponent.prototype.onCheckboxLabelClick = function ($event, key) {
            if (!$($event.target).is('input')) {
                return;
            }
            // construct the _model from the checked elements.
            var inputElements = this.nativeElement.querySelectorAll('input:checked');
            var keys = [];
            _.forEach(inputElements, function ($el) {
                keys.push($el.value);
            });
            this.modelByKey = keys;
            this.invokeOnTouched();
            // invoke on datavalue change.
            this.invokeOnChange(this.datavalue, $event || {}, true);
        };
        // change and blur events are added from the template
        CheckboxsetComponent.prototype.handleEvent = function (node, eventName, callback, locals) {
            if (eventName === 'click') {
                this.eventManager.addEventListener(node, eventName, function (e) {
                    if (!$(e.target).is('input')) {
                        return;
                    }
                    locals.$event = e;
                    return callback();
                });
            }
            else if (!_.includes(['change'], eventName)) {
                _super.prototype.handleEvent.call(this, node, eventName, callback, locals);
            }
        };
        CheckboxsetComponent.prototype.getGroupedData = function () {
            return this.datasetItems.length ? groupData(this, convertDataToObject(this.datasetItems), this.groupby, this.match, this.orderby, this.dateformat, this.datePipe, 'dataObject', this.appDefaults) : [];
        };
        CheckboxsetComponent.prototype.datasetSubscription = function () {
            var _this = this;
            var datasetSubscription = this.dataset$.subscribe(function () {
                _this.groupedData = _this.getGroupedData();
            });
            this.registerDestroyListener(function () { return datasetSubscription.unsubscribe(); });
        };
        CheckboxsetComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'tabindex') {
                return;
            }
            if (key === 'layout') {
                core.switchClass(this.nativeElement, nv, ov);
            }
            else if (key === 'groupby' || key === 'match') {
                this.datasetSubscription();
                // If groupby is set, get the groupedData from the datasetItems.
                this.groupedData = this.getGroupedData();
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        CheckboxsetComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            if (this.groupby) {
                this.datasetSubscription();
                // If groupby is set, get the groupedData from the datasetItems.
                this.groupedData = this.getGroupedData();
            }
            // adding the handler for header click and toggle headers.
            if (this.groupby && this.collapsible) {
                this.handleHeaderClick = handleHeaderClick;
                this.toggleAllHeaders = toggleAllHeaders.bind(undefined, this);
            }
        };
        CheckboxsetComponent.initializeProps = registerProps$h();
        CheckboxsetComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmCheckboxset]',
                        exportAs: 'wmCheckboxset',
                        template: "<ng-template [ngIf]=\"!groupby\" [ngIfElse]=\"groupedListTemplate\">\n    <li [ngClass]=\"['checkbox', 'app-checkbox', itemclass]\"\n        [class.active]=\"item.selected\"\n        *ngFor=\"let item of datasetItems; let i = index\"\n        (click)=\"onCheckboxLabelClick($event, item.key)\">\n        <label class=\"app-checkboxset-label\" [ngClass]=\"{'disabled':disabled || readonly}\" [title]=\"item.label\">\n            <input [name]=\"'checkboxset_' + widgetId\" type=\"checkbox\" aria-label=\"checkbox group\"\n                   [tabindex]=\"tabindex\"\n                   [disabled]=\"disabled || readonly\" [attr.data-attr-index]=\"i\"\n                   [value]=\"item.key\" [tabindex]=\"tabindex\" [checked]=\"item.selected\"/>\n            <span class=\"caption\" [textContent]=\"item.label\"></span>\n        </label>\n    </li>\n</ng-template>\n<input [disabled]=\"disabled || readonly\" hidden class=\"model-holder\">\n<div *ngIf=\"readonly || disabled\" class=\"readonly-wrapper\"></div>\n\n<!-- This template will be displayed when groupby is specified. -->\n<ng-template #groupedListTemplate>\n    <li *ngFor=\"let groupObj of groupedData\" class=\"app-list-item-group\">\n        <ul class=\"item-group\">\n            <li class=\"list-group-header\" (click)=\"handleHeaderClick($event)\" [title]=\"groupObj.key\" [ngClass]=\"{'collapsible-content': collapsible}\">\n                <h4 class=\"group-title\">{{groupObj.key}}\n                    <div class=\"header-action\">\n                        <i class=\"app-icon wi action wi-chevron-up\" *ngIf=\"collapsible\" title=\"{{appLocale.LABEL_COLLAPSE}}/{{appLocale.LABEL_EXPAND}}\"></i>\n                        <span *ngIf=\"showcount\" class=\"label label-default\" [textContent]=\"groupObj.data.length\"></span>\n                    </div>\n                </h4>\n            </li>\n            <li *ngFor=\"let item of groupObj.data; let i = index;\"\n                [ngClass]=\"['checkbox', 'app-checkbox', 'group-list-item', itemclass]\"\n                [class.active]=\"item.selected\"\n                (click)=\"onCheckboxLabelClick($event, item)\">\n                <label class=\"app-checkboxset-label\" [ngClass]=\"{'disabled':disabled || readonly}\" [title]=\"item.label\">\n                    <input [name]=\"'checkboxset_' + widgetId\" type=\"checkbox\" aria-label=\"checkbox group\"\n                           [tabindex]=\"tabindex\"\n                           [disabled]=\"disabled || readonly\" [attr.data-attr-index]=\"i\"\n                           [value]=\"item.key\" [tabindex]=\"tabindex\" [checked]=\"item.selected\"/>\n                    <span class=\"caption\" [textContent]=\"item.label\"></span>\n                </label>\n            </li>\n        </ul>\n    </li>\n</ng-template>",
                        providers: [
                            provideAsNgValueAccessor(CheckboxsetComponent),
                            provideAsWidgetRef(CheckboxsetComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        CheckboxsetComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['groupby',] }] },
                { type: core.AppDefaults },
                { type: ToDatePipe }
            ];
        };
        return CheckboxsetComponent;
    }(DatasetAwareFormComponent));

    var chipsProps = new Map([
        ['allowonlyselect', PROP_BOOLEAN],
        ['autofocus', PROP_BOOLEAN],
        ['chipclass', PROP_STRING],
        ['class', PROP_STRING],
        ['compareby', PROP_STRING],
        ['datafield', PROP_STRING],
        ['dataoptions', PROP_ANY],
        ['dataset', __assign({ value: 'Option 1, Option 2, Option 3' }, PROP_ANY)],
        ['datasource', PROP_ANY],
        ['datavalue', PROP_ANY],
        ['datavaluesource', PROP_ANY],
        ['disabled', PROP_BOOLEAN],
        ['displayexpression', PROP_STRING],
        ['displayfield', PROP_STRING],
        ['displayimagesrc', PROP_STRING],
        ['enablereorder', PROP_BOOLEAN],
        ['inputposition', __assign({ value: 'last' }, PROP_STRING)],
        ['inputwidth', __assign({ value: 'default' }, PROP_STRING)],
        ['limit', PROP_NUMBER],
        ['loadingdatamsg', __assign({ value: 'Loading items...' }, PROP_STRING)],
        ['matchmode', PROP_STRING],
        ['maxsize', PROP_NUMBER],
        ['minchars', __assign({ value: 1 }, PROP_NUMBER)],
        ['name', PROP_STRING],
        ['navsearchbar', __assign({ value: false }, PROP_BOOLEAN)],
        ['orderby', PROP_STRING],
        ['placeholder', __assign({ value: 'Type here..' }, PROP_STRING)],
        ['query', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['searchkey', PROP_STRING],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showsearchicon', PROP_BOOLEAN],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['type', __assign({ value: 'search' }, PROP_STRING)],
        ['debouncetime', __assign({ value: 250 }, PROP_NUMBER)],
    ]);
    var registerProps$i = function () {
        register('wm-chips', chipsProps);
    };

    var searchProps = new Map([
        ['casesensitive', __assign({ value: false }, PROP_BOOLEAN)],
        ['class', PROP_STRING],
        ['datacompletemsg', __assign({ value: 'No more data to load' }, PROP_STRING)],
        ['datafield', __assign({ value: 'All Fields' }, PROP_STRING)],
        ['dataoptions', PROP_ANY],
        ['dataset', PROP_ANY],
        ['datasource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['disabled', PROP_BOOLEAN],
        ['displayimagesrc', PROP_STRING],
        ['displaylabel', PROP_STRING],
        ['dropup', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['imagewidth', __assign({ value: '16px' }, PROP_STRING)],
        ['limit', PROP_NUMBER],
        ['loadingdatamsg', __assign({ value: 'Loading items...' }, PROP_STRING)],
        ['matchmode', PROP_STRING],
        ['minchars', PROP_NUMBER],
        ['name', PROP_STRING],
        ['navsearchbar', __assign({ value: false }, PROP_BOOLEAN)],
        ['orderby', PROP_STRING],
        ['placeholder', __assign({ value: 'Search' }, PROP_STRING)],
        ['position', PROP_STRING],
        ['query', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['searchkey', PROP_STRING],
        ['searchon', __assign({ value: 'typing' }, PROP_STRING)],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showsearchicon', PROP_BOOLEAN],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['type', __assign({ value: 'search' }, PROP_STRING)],
        ['debouncetime', __assign({ value: 250 }, PROP_NUMBER)],
        ['width', PROP_STRING]
    ]);
    var registerProps$j = function () {
        register('wm-search', searchProps);
    };

    var LocalDataProvider = /** @class */ (function () {
        function LocalDataProvider() {
        }
        // LocalData filtering is done based on the searchkey.
        LocalDataProvider.prototype.filter = function (config) {
            var entries = config.dataset;
            var casesensitive = config.casesensitive;
            var queryText = config.query, filteredData;
            return new Promise(function (resolve, reject) {
                /**
                 * If searchKey is defined, then check for match string against each item in the dataset with item's field name as the searchKey
                 * return the filtered data containing the matching string.
                 */
                if (config.searchKey) {
                    var keys_1 = _.split(config.searchKey, ',');
                    filteredData = _.filter(config.dataset, function (item) {
                        return keys_1.some(function (key) {
                            var a = _.get(item, key), b = queryText;
                            if (!casesensitive) {
                                a = _.toLower(_.toString(a));
                                b = _.toLower(_.toString(b));
                            }
                            return _.includes(a, b);
                        });
                    });
                }
                else {
                    // local search on data with array of objects.
                    // Iterate over each item and return the filtered data containing the matching string.
                    if (_.isArray(entries) && _.isObject(entries[0])) {
                        filteredData = _.filter(entries, function (entry) {
                            return (_.includes(_.toLower(_.values(entry).join(' ')), _.toLower(queryText)));
                        });
                    }
                    else {
                        filteredData = _.filter(entries, function (entry) {
                            if (!casesensitive) {
                                entry = _.toLower(entry);
                                queryText = _.toLower(queryText);
                            }
                            return _.includes(entry, queryText);
                        });
                    }
                }
                resolve({
                    data: filteredData,
                    hasMoreData: false,
                    isLastPage: true
                });
            });
        };
        return LocalDataProvider;
    }());

    var RemoteDataProvider = /** @class */ (function () {
        function RemoteDataProvider() {
        }
        RemoteDataProvider.prototype.filter = function (config) {
            var _this = this;
            return this.filterData(config).then(function (response) { return _this.onFilterSuccess(config, response); }, function () { return _this.onFilterFailure(); });
        };
        RemoteDataProvider.prototype.filterData = function (config) {
            if (config.dataoptions) {
                var dataoptions_1 = config.dataoptions;
                var requestParams_1 = config.datasource.execute(core.DataSource.Operation.GET_REQUEST_PARAMS, config);
                // If options are specified, make specifics calls to fetch the results
                // Fetch the related field data
                if (dataoptions_1.relatedField) {
                    return new Promise(function (resolve, reject) {
                        interpolateBindExpressions(config.viewParent, dataoptions_1.filterExpr, function (filterexpressions) {
                            requestParams_1.filterExpr = dataoptions_1.filterExpr = filterexpressions;
                            dataoptions_1.filterExpr = filterexpressions;
                            config.datasource.execute(core.DataSource.Operation.GET_RELATED_TABLE_DATA, _.assign({ relatedField: dataoptions_1.relatedField }, requestParams_1)).then(resolve, reject);
                        });
                    });
                }
                // Fetch the distinct data
                if (dataoptions_1.distinctField) {
                    return config.datasource.execute(core.DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS, {
                        pagesize: config.limit || config.pagesize,
                        page: config.page,
                        fields: dataoptions_1.distinctField,
                        entityName: dataoptions_1.tableName,
                        filterFields: _.assign(dataoptions_1.filterFields, requestParams_1.filterFields),
                        filterExpr: core.getClonedObject(dataoptions_1.filterExpr || {})
                    });
                }
            }
            // search records using the searchkey
            return config.datasource.execute(core.DataSource.Operation.SEARCH_RECORDS, config);
        };
        // Check if the page retrieved currently is the last page. If last page, don't send any more request
        RemoteDataProvider.prototype.isLast = function (page, dataSize, maxResults, currentResults) {
            // if last page info is not returned by backend and current results is less than max results, this is the last page
            if (dataSize === core.AppConstants.INT_MAX_VALUE) {
                return currentResults !== 0 && currentResults < maxResults;
            }
            var pageCount = ((dataSize > maxResults) ? (Math.ceil(dataSize / maxResults)) : (dataSize < 0 ? 0 : 1));
            return page === pageCount;
        };
        // this function transform the response data in case it is not an array
        RemoteDataProvider.prototype.getTransformedData = function (variable, data) {
            var operationResult = variable.operation + 'Result'; // when output is only string it is available as oprationNameResult
            var tempResponse = data[operationResult];
            // in case data received is value as string then add that string value to object and convert object into array
            if (tempResponse) {
                var tempObj = {};
                _.set(tempObj, operationResult, tempResponse);
                data = [tempObj]; // convert data into an array having tempObj
            }
            else {
                // in case data received is already an object then convert it into an array
                data = [data];
            }
            return data;
        };
        RemoteDataProvider.prototype.onFilterFailure = function () {
            return [];
        };
        RemoteDataProvider.prototype.isLastPageForDistinctApi = function (data, page, totalElements, _isLastPage) {
            return page > 1 && !_isLastPage && _.isEmpty(data) && totalElements === core.AppConstants.INT_MAX_VALUE;
        };
        // this function processes the response depending on pageOptions, isPageable and prepares the formattedDataset.
        RemoteDataProvider.prototype.onFilterSuccess = function (config, response) {
            var _this = this;
            var data = response.data;
            var formattedData;
            var _isLastPage;
            var page;
            var isPaginatedData;
            var expressionArray = _.split(config.binddataset, '.');
            var dataExpression = _.slice(expressionArray, _.indexOf(expressionArray, 'dataSet') + 1).join('.');
            var $I = '[$i]';
            return new Promise(function (resolve, reject) {
                var pageOptions = response.pagination;
                if (config.datasource.execute(core.DataSource.Operation.IS_PAGEABLE)) {
                    page = pageOptions.number + 1;
                    _isLastPage = _this.isLast(page, (config.limit > 0 && config.limit) || pageOptions.totalElements, pageOptions.size, pageOptions.numberOfElements);
                    isPaginatedData = true;
                    if (_this.isLastPageForDistinctApi(data, page, pageOptions.totalElements, _isLastPage)) {
                        _isLastPage = true;
                        resolve({
                            data: [],
                            isLastPage: _isLastPage,
                            hasMoreData: page > 1,
                            isPaginatedData: isPaginatedData,
                            page: page
                        });
                        return;
                    }
                }
                // if data expression exists, extract the data from the expression path
                if (dataExpression) {
                    var index = dataExpression.lastIndexOf($I);
                    var restExpr_1 = dataExpression.substr(index + 5);
                    if (_.isArray(data)) {
                        formattedData = data.map(function (datum) { return core.findValueOf(datum, restExpr_1); });
                    }
                    else if (_.isObject(data)) {
                        formattedData = _.get(data, dataExpression);
                    }
                    data = formattedData || data;
                }
                if (!_.isArray(data)) {
                    data = _this.getTransformedData(config.datasource, data);
                }
                // in case of no data received, resolve the promise with empty array
                if (!data.length) {
                    resolve({ data: [], isLastPage: _isLastPage, hasMoreData: page > 1, isPaginatedData: isPaginatedData, page: page });
                }
                else {
                    resolve({ data: data, isLastPage: _isLastPage, hasMoreData: page > 1, isPaginatedData: isPaginatedData, page: page });
                }
            });
        };
        return RemoteDataProvider;
    }());

    var DataProvider = /** @class */ (function () {
        function DataProvider() {
        }
        DataProvider.prototype.filter = function (config) {
            var _this = this;
            var promise;
            /**
             * Make call to remoteDataProvider when searchkey is available and data is not from local / model variable.
             * Otherwise use localDataProvider
             * If datasource is a serviceVariable with no input params, then perform local search.
             * when there is no dataset on the datasource when first time make a remote call to set the dataset for service variable.
             */
            var hasNoVariableDataset = config.datasource && config.datasource.execute(core.DataSource.Operation.IS_UPDATE_REQUIRED, config.hasData);
            if (!config.isLocalFilter && (config.dataoptions || ((config.datasource && config.datasource.execute(core.DataSource.Operation.IS_API_AWARE))
                && config.searchKey
                && hasNoVariableDataset))) {
                promise = DataProvider.remoteDataProvider.filter(config);
            }
            else {
                promise = DataProvider.localDataProvider.filter(config);
            }
            return promise.then(function (response) {
                _this.updateDataset = config.datasource && !config.datasource.execute(core.DataSource.Operation.SUPPORTS_CRUD) && hasNoVariableDataset;
                _this.hasMoreData = response.hasMoreData;
                _this.isLastPage = response.isLastPage;
                _this.page = response.page;
                _this.isPaginatedData = response.isPaginatedData;
                return response;
            });
        };
        DataProvider.remoteDataProvider = new RemoteDataProvider();
        DataProvider.localDataProvider = new LocalDataProvider();
        return DataProvider;
    }());

    var WIDGET_CONFIG$h = { widgetType: 'wm-search', hostClass: 'input-group' };
    var SearchComponent = /** @class */ (function (_super) {
        __extends(SearchComponent, _super);
        function SearchComponent(inj, binddatavalue, binddataset) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$h) || this;
            _this.binddatavalue = binddatavalue;
            _this.binddataset = binddataset;
            _this.query = '';
            _this.page = 1;
            // this flag will not allow the empty datafield values.
            _this.allowempty = false;
            core.addClass(_this.nativeElement, 'app-search', true);
            /**
             * Listens for the change in the ngModel on every search and retrieves the data as observable.
             * This observable data is passed to the typeahead.
             * @type {Observable<any>}
             */
            _this.typeaheadDataSource = rxjs.Observable
                .create(function (observer) {
                // Runs on every search
                if (_this.listenQuery) {
                    if (_this.isMobileAutoComplete() && !_this.$element.hasClass('full-screen')) {
                        _this.renderMobileAutoComplete();
                        return;
                    }
                    _this._defaultQueryInvoked = false;
                    _this._loadingItems = true;
                    observer.next(_this.query);
                }
                // on keydown, while scrolling the dropdown items, when last item is reached next call is triggered
                // unless the call is resolved, we are able to scroll next to first item and soon
                // This shows flickering from first item to next new items appended.
                // By setting container to undefined, key events changes will be stopped while loading items
                if (_this.lastSelectedIndex) {
                    _this.typeahead._container = undefined;
                }
            }).pipe(operators.mergeMap(function (token) { return _this.getDataSourceAsObservable(token); }));
            _this.dataProvider = new DataProvider();
            /**
             * When default datavalue is not found within the dataset, a filter call is made to get the record using fetchDefaultModel.
             * after getting the response, set the queryModel and query.
             */
            var datavalueSubscription = _this.datavalue$.subscribe(function (val) {
                var query = (_.isArray(val) ? val[0] : val);
                if (query === null || query === '') {
                    _this._modelByValue = '';
                    // reset the query.
                    _this.query = _this.queryModel = '';
                    // on clear or reset filter, empty the lastResults to fetch new records.
                    _this._lastResult = undefined;
                    return;
                }
                if (!_this._unsubscribeDv) {
                    _this._defaultQueryInvoked = false;
                    // if prev datavalue is not equal to current datavalue then clear the modelByKey and queryModel
                    if (!_.isObject(val) && _this.prevDatavalue !== val) {
                        _this._modelByKey = undefined;
                        _this.query = _this.queryModel = '';
                    }
                    // if the datafield is ALLFILEDS do not fetch the records
                    // update the query model with the values we have
                    _this.updateByDatavalue(val);
                }
            });
            _this.registerDestroyListener(function () { return datavalueSubscription.unsubscribe(); });
            var datasetSubscription = _this.dataset$.subscribe(function () {
                // set the next item index.
                _this.startIndex = _this.datasetItems.length;
                _this.updateByDataset(_this.datavalue || _this.toBeProcessedDatavalue);
            });
            _this.registerDestroyListener(function () { return datasetSubscription.unsubscribe(); });
            return _this;
        }
        Object.defineProperty(SearchComponent.prototype, "datasource", {
            // getter setter is added to pass the datasource to searchcomponent.
            get: function () {
                return this._datasource;
            },
            set: function (nv) {
                this._datasource = nv;
                var data = this.datavalue || this.toBeProcessedDatavalue;
                this.updateByDatavalue(data);
            },
            enumerable: true,
            configurable: true
        });
        // on clear, trigger search with page size 1
        SearchComponent.prototype.clearSearch = function ($event, loadOnClear) {
            this.query = '';
            this.onInputChange($event);
            this.dataProvider.isLastPage = false;
            this.listenQuery = false;
            if (loadOnClear) {
                this.listenQuery = true;
                this._unsubscribeDv = false;
                this.loadMoreData();
            }
            this.invokeEventCallback('clearsearch');
        };
        // Close the full screen mode in mobile view of auto complete
        SearchComponent.prototype.closeSearch = function () {
            this._loadingItems = false;
            this.page = 1;
            // after closing the search, insert the element at its previous position (elIndex)
            this.insertAtIndex(this.elIndex);
            this.elIndex = undefined;
            this.parentEl = undefined;
            this.$element.removeClass('full-screen');
            if (this._domUpdated) {
                this._domUpdated = false;
            }
            this.listenQuery = false;
            this._unsubscribeDv = true;
            this.typeahead.hide();
        };
        SearchComponent.prototype.renderMobileAutoComplete = function () {
            // Get the parent element of the search element which can be next or prev element, if both are empty then get the parent of element.
            if (!core.isDefined(this.elIndex)) {
                this.parentEl = this.$element.parent();
                this.elIndex = this.parentEl.children().index(this.$element);
            }
            if (!this.$element.hasClass('full-screen')) {
                // this flag is set to notify that the typeahead-container dom has changed its position
                this._domUpdated = true;
                this.$element.appendTo('div[data-role="pageContainer"]');
                // Add full screen class on focus of the input element.
                this.$element.addClass('full-screen');
                // Add position to set the height to auto
                if (this.position === 'inline') {
                    this.$element.addClass(this.position);
                }
            }
            // focus is lost when element is changed to full-screen, keydown to select next items will not work
            // Hence explicitly focusing the input
            if (this.$element.hasClass('full-screen')) {
                this.$element.find('.app-search-input').focus();
            }
        };
        SearchComponent.prototype.getDataSourceAsObservable = function (query) {
            // show dropdown only when there is change in query. This should not apply when dataoptions with filterFields are updated.
            // when lastResult is not available i.e. still the first call is pending and second query is invoked then do not return.
            if (this._lastQuery === query && !_.get(this.dataoptions, 'filterFields') && core.isDefined(this._lastResult)) {
                this._loadingItems = false;
                return rxjs.of(this._lastResult);
            }
            this._lastQuery = this.query;
            return rxjs.from(this.getDataSource(query));
        };
        SearchComponent.prototype.handleEvent = function (node, eventName, eventCallback, locals) {
            if (!_.includes(['blur', 'focus', 'select', 'submit', 'change'], eventName)) {
                _super.prototype.handleEvent.call(this, node, eventName, eventCallback, locals);
            }
        };
        // highlight the characters in the dropdown matching the query.
        SearchComponent.prototype.highlight = function (match, query) {
            if (this.typeaheadContainer) {
                // highlight of chars will work only when label are strings.
                match.value = match.item.label.toString();
                return this.typeaheadContainer.highlight(match, query);
            }
        };
        // inserts the element at the index position
        SearchComponent.prototype.insertAtIndex = function (i) {
            if (i === 0) {
                this.parentEl.prepend(this.$element);
            }
            else {
                var $elAtIndex = this.parentEl.children().eq(i);
                if ($elAtIndex.length) {
                    this.$element.insertBefore(this.parentEl.children().eq(i));
                }
                else {
                    this.$element.insertAfter(this.parentEl.children().eq(i - 1));
                }
            }
        };
        // Check if the widget is of type autocomplete in mobile view/ app
        SearchComponent.prototype.isMobileAutoComplete = function () {
            return this.type === 'autocomplete' && core.isMobile();
        };
        SearchComponent.prototype.loadMoreData = function (incrementPage) {
            if (this.dataProvider.isLastPage) {
                return;
            }
            // Increase the page number and trigger force query update
            this.page = incrementPage ? this.page + 1 : this.page;
            this.isScrolled = true;
            this._loadingItems = true;
            // when invoking new set of results, reset the lastQuery.
            if (incrementPage) {
                this._lastQuery = undefined;
            }
            // trigger the typeahead change manually to fetch the next set of results.
            this.typeahead.onInput({
                target: {
                    value: _.trim(this.query) || '0' // dummy data to notify the observables
                }
            });
        };
        // on focusout, subscribe to the datavalue changes again
        SearchComponent.prototype.onFocusOut = function () {
            var _this = this;
            this._unsubscribeDv = false;
            this._loadingItems = false;
            // reset the page value on focusout.
            this.page = 1;
            // if domUpdated is true then do not hide the dropdown in the fullscreen
            if (!this._domUpdated && this._isOpen) {
                this.listenQuery = false;
                // hide the typeahead only after the item is selected from dropdown.
                setTimeout(function () {
                    if (_this.typeahead._typeahead.isShown) {
                        _this.typeahead.hide();
                    }
                }, 200);
            }
            this._isOpen = false;
            // on outside click, typeahead is hidden. To avoid this, when fullscreen is set, overridding isFocused flag on the typeahead container
            if (this._domUpdated && this.typeahead && this.typeahead._container) {
                this.typeahead._container.isFocused = true;
            }
        };
        SearchComponent.prototype.onInputChange = function ($event) {
            // reset all the previous page details in order to fetch new set of result.
            this.result = [];
            this.page = 1;
            this.listenQuery = this.isUpdateOnKeyPress();
            this._modelByValue = undefined;
            // when input is cleared, reset the datavalue
            if (this.query === '') {
                this.queryModel = '';
                this._modelByValue = '';
                this.invokeOnChange(this._modelByValue, {}, true);
                // trigger onSubmit only when the search input is cleared off and do not trigger when tab is pressed.
                if ($event && $event.which !== 9) {
                    this.invokeEventCallback('submit', { $event: $event });
                }
            }
            else {
                // invoking change event on every input value change.
                this.invokeEventCallback('change', {
                    $event: $event,
                    newVal: this._modelByValue || this.query,
                    oldVal: this.prevDatavalue
                });
            }
            this.showClosebtn = (this.query !== '');
        };
        // Triggered for enter event
        SearchComponent.prototype.handleEnterEvent = function ($event) {
            // submit event triggered when there is no search results
            if (!this.typeahead._container) {
                this.onSelect($event);
            }
        };
        // Triggerred when typeahead option is selected.
        SearchComponent.prototype.onSelect = function ($event) {
            // searchOn is set as onBtnClick, then invoke the search api call manually.
            if (!this.isUpdateOnKeyPress()) {
                this.listenQuery = true;
                // trigger the typeahead change manually to fetch the next set of results.
                this.typeahead.onInput({
                    target: {
                        value: this.query // dummy data to notify the observables
                    }
                });
                return;
            }
            // when matches are available.
            if (this.typeaheadContainer && this.liElements.length) {
                this.typeaheadContainer.selectActiveMatch();
            }
            else {
                this.queryModel = this.query;
                this.invokeEventCallback('submit', { $event: $event });
            }
        };
        SearchComponent.prototype.onBeforeservicecall = function (inputData) {
            this.invokeEventCallback('beforeservicecall', { inputData: inputData });
        };
        SearchComponent.prototype.onDropdownOpen = function () {
            var _this = this;
            // setting the ulElements, liElement on typeaheadContainer.
            // as we are using customOption template, liElements are not available on typeaheadContainer so append them explicitly.
            var fn = _.debounce(function () {
                _this._isOpen = true;
                _this.typeaheadContainer = _this.typeahead._container || _this.typeahead._typeahead.instance;
                _this.typeaheadContainer.liElements = _this.liElements;
                _this.typeaheadContainer.ulElement = _this.ulElement;
                core.adjustContainerPosition($('typeahead-container'), _this.nativeElement, _this.typeahead._typeahead, $('typeahead-container .dropdown-menu'));
            });
            fn();
            // open full-screen search view
            if (this.isMobileAutoComplete()) {
                var dropdownEl = this.dropdownEl.closest('typeahead-container');
                dropdownEl.insertAfter(this.$element.find('input:first'));
                var screenHeight = this.$element.closest('.app-content').height();
                dropdownEl.css({ position: 'relative', top: 0, height: screenHeight + 'px' });
                this.showClosebtn = this.query && this.query !== '';
                if (!this.dataProvider.isLastPage) {
                    this.triggerSearch();
                }
            }
        };
        SearchComponent.prototype.selectNext = function () {
            var matches = this.typeaheadContainer.matches;
            if (!matches) {
                return;
            }
            var index = matches.indexOf(this.typeaheadContainer.active);
            // on keydown, if scroll is at the bottom and next page records are available, fetch next page items.
            if (!this._loadingItems && !this.dataProvider.isLastPage && index + 1 > matches.length - 1) {
                // index is saved in order to select the lastSelected item in the dropdown after fetching next page items.
                this.lastSelectedIndex = index;
                this.loadMoreData(true);
            }
        };
        SearchComponent.prototype.setLastActiveMatchAsSelected = function () {
            if (this.lastSelectedIndex) {
                this.typeaheadContainer._active = this.typeaheadContainer.matches[this.lastSelectedIndex];
                this.typeaheadContainer.nextActiveMatch();
                this.lastSelectedIndex = undefined;
            }
        };
        SearchComponent.prototype.triggerSearch = function () {
            if (this.dataProvider.isLastPage || !this.$element.hasClass('full-screen')) {
                return;
            }
            var typeAheadDropDown = this.dropdownEl;
            var $lastItem = typeAheadDropDown.find('li').last();
            // Check if last item is not below the full screen
            if ($lastItem.length && typeAheadDropDown.length && (typeAheadDropDown.height() + typeAheadDropDown.position().top > $lastItem.height() + $lastItem.position().top)) {
                this.loadMoreData(true);
            }
        };
        SearchComponent.prototype.isUpdateOnKeyPress = function () {
            return this.searchon === 'typing';
        };
        SearchComponent.prototype.debounceDefaultQuery = function (data) {
            var _this = this;
            this._defaultQueryInvoked = true;
            this.getDataSource(data, true).then(function (response) {
                if (response.length) {
                    _this.queryModel = response;
                    _this._lastQuery = _this.query = _this.queryModel[0].label || '';
                    _this._modelByValue = _this.queryModel[0].value;
                    _this._modelByKey = _this.queryModel[0].key;
                }
                else {
                    _this._modelByValue = undefined;
                    _this.queryModel = undefined;
                    _this.query = '';
                }
            });
        };
        SearchComponent.prototype.updateByDatavalue = function (data) {
            this.updateByDataset(data);
            this.updateByDataSource(data);
        };
        SearchComponent.prototype.updateByDataSource = function (data) {
            // value is present but the corresponding key is not found then fetch next set
            // modelByKey will be set only when datavalue is available inside the localData otherwise make a N/w call.
            if (core.isDefined(data) && !_.isObject(data) && this.datasource && !core.isDefined(this._modelByKey) && this.datafield !== ALLFIELDS) {
                // Avoid making default query if queryModel already exists.
                if (core.isDefined(this.queryModel) && !_.isEmpty(this.queryModel)) {
                    this.updateDatavalueFromQueryModel();
                    return;
                }
                // Make default query call only when datasource supports CRUD (live variable).
                if (!this._defaultQueryInvoked && this.datasource.execute(core.DataSource.Operation.SUPPORTS_CRUD)) {
                    this.debounceDefaultQuery(data);
                }
            }
        };
        // updates the model value using queryModel
        SearchComponent.prototype.updateDatavalueFromQueryModel = function () {
            this._modelByValue = _.isArray(this.queryModel) ? this.queryModel[0].value : this.queryModel;
            this._modelByKey = _.isArray(this.queryModel) ? this.queryModel[0].key : this.queryModel;
            this.toBeProcessedDatavalue = undefined;
        };
        SearchComponent.prototype.updateByDataset = function (data) {
            // default query is already invoked then do not make other default query call.
            // For local search i.e. searchkey is undefined, do not return, verify the datavalue against the datasetItems .
            if (this._defaultQueryInvoked && this.searchkey) {
                return;
            }
            var selectedItem = _.find(this.datasetItems, function (item) {
                return (_.isObject(item.value) ? _.isEqual(item.value, data) : (_.toString(item.value)).toLowerCase() === (_.toString(data)).toLowerCase());
            });
            // set the default only when it is available in dataset.
            if (selectedItem) {
                this.queryModel = [selectedItem];
            }
            else if (this.datafield === ALLFIELDS && _.isObject(data)) {
                this.queryModel = this.getTransformedData(extractDataAsArray(data));
            }
            else {
                this.queryModel = undefined;
                this.query = '';
                return;
            }
            this.updateDatavalueFromQueryModel();
            // Show the label value on input.
            this._lastQuery = this.query = this.queryModel.length ? this.queryModel[0].label : '';
        };
        // This method returns a promise that provides the filtered data from the datasource.
        SearchComponent.prototype.getDataSource = function (query, searchOnDataField, nextItemIndex) {
            var _this = this;
            // For default query, searchOnDataField is set to true, then do not make a n/w call when datafield is ALLFIELDS
            if (searchOnDataField && this.datafield === ALLFIELDS) {
                this._loadingItems = false;
                return Promise.resolve([]);
            }
            // For default datavalue, search key as to be on datafield to get the default data from the filter call.
            var dataConfig = {
                dataset: this.dataset ? convertDataToObject(this.dataset) : undefined,
                binddataset: this.binddataset,
                datasource: this.datasource,
                datafield: this.datafield,
                hasData: this.dataset && this.dataset.length,
                query: query,
                isLocalFilter: !this.searchkey,
                searchKey: searchOnDataField ? this.datafield : this.searchkey,
                // default search call match mode should be startignorecase
                matchMode: searchOnDataField ? 'startignorecase' : this.matchmode,
                casesensitive: this.casesensitive,
                isformfield: this.isformfield,
                orderby: this.orderby,
                limit: this.limit,
                pagesize: this.pagesize,
                page: this.page,
                onBeforeservicecall: this.onBeforeservicecall.bind(this)
            };
            if (this.dataoptions) {
                dataConfig.dataoptions = this.dataoptions;
                dataConfig.viewParent = this.viewParent;
            }
            this._loadingItems = true;
            return this.dataProvider.filter(dataConfig)
                .then(function (response) {
                // response from dataProvider returns always data object.
                response = response.data || response;
                // for service variable, updating the dataset only if it is not defined or empty
                if ((!core.isDefined(_this.dataset) || !_this.dataset.length) && _this.dataProvider.updateDataset) {
                    _this.dataset = response;
                }
                if (_this.dataProvider.hasMoreData) {
                    _this.formattedDataset = _this.formattedDataset.concat(response);
                }
                else {
                    _this.formattedDataset = response;
                }
                // explicitly setting the optionslimit as the matches more than 20 will be ignored if optionslimit is not specified.
                if (_this.formattedDataset.length > 20 && !core.isDefined(_this.limit)) {
                    _this.typeahead.typeaheadOptionsLimit = _this.formattedDataset.length;
                }
                // In mobile, trigger the search by default until the results have height upto page height. Other results can be fetched by scrolling
                if (_this._isOpen && _this.isMobileAutoComplete() && !_this.dataProvider.isLastPage) {
                    _this.triggerSearch();
                }
                var transformedData = _this.getTransformedData(_this.formattedDataset, nextItemIndex);
                // result contains the datafield values.
                _this.result = _.map(transformedData, 'value');
                return transformedData;
            }, function (error) {
                _this._loadingItems = false;
                return [];
            }).then(function (result) {
                if (_this.isScrolled) {
                    (_.debounce(function () {
                        _this.setLastActiveMatchAsSelected();
                    }, 30))();
                    _this.isScrolled = false;
                }
                // When no result is found, set the datavalue to undefined.
                if (!result.length) {
                    _this._modelByValue = undefined;
                    _this.queryModel = query;
                }
                // on focusout i.e. on other widget focus, if n/w is pending loading icon is shown, when data is available then dropdown is shown again.
                // on unsubscribing do not show the results.
                if (_this._unsubscribeDv) {
                    result = [];
                }
                _this._loadingItems = false;
                _this._lastResult = result;
                return result;
            });
        };
        SearchComponent.prototype.getTransformedData = function (data, itemIndex, iscustom) {
            if (core.isDefined(itemIndex)) {
                itemIndex++;
            }
            var transformedData = transformData$1(this.viewParent, data, this.datafield, {
                displayField: this.displaylabel || this.displayfield,
                displayExpr: iscustom ? '' : this.displayexpression,
                bindDisplayExpr: iscustom ? '' : this.binddisplaylabel,
                bindDisplayImgSrc: this.binddisplayimagesrc,
                displayImgSrc: this.displayimagesrc
            }, itemIndex);
            return getUniqObjsByDataField(transformedData, this.datafield, this.displayfield || this.displaylabel, core.toBoolean(this.allowempty));
        };
        // OptionsListTemplate listens to the scroll event and triggers this function.
        SearchComponent.prototype.onScroll = function ($scrollEl, evt) {
            var totalHeight = $scrollEl.scrollHeight, clientHeight = $scrollEl.clientHeight;
            // If scroll is at the bottom and no request is in progress and next page records are available, fetch next page items.
            if (!this._loadingItems && !this.dataProvider.isLastPage && ($scrollEl.scrollTop + clientHeight >= totalHeight)) {
                this.loadMoreData(true);
            }
        };
        SearchComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            if (!core.isDefined(this.minchars)) {
                // for autocomplete set the minchars to 0
                if (this.type === 'autocomplete') {
                    this.minchars = 0;
                }
                else {
                    this.minchars = 1;
                }
            }
            this.listenQuery = this.isUpdateOnKeyPress();
            // by default for autocomplete do not show the search icon
            // by default show the searchicon for type = search
            this.showsearchicon = core.isDefined(this.showsearchicon) ? this.showsearchicon : (this.type === 'search');
        };
        SearchComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.nativeElement, this);
        };
        // triggered on select on option from the list. Set the queryModel, query and modelByKey from the matched item.
        SearchComponent.prototype.typeaheadOnSelect = function (match, $event) {
            var item = match.item;
            this.queryModel = item;
            item.selected = true;
            this.query = item.label;
            $event = $event || this.$typeaheadEvent;
            // As item.key can vary from key in the datasetItems
            this._modelByKey = item.key;
            this._modelByValue = item.value;
            this.invokeOnTouched();
            this.invokeOnChange(this.datavalue, $event || {});
            if (this.$element.hasClass('full-screen')) {
                this.closeSearch();
            }
            this.invokeEventCallback('select', { $event: $event, selectedValue: this.datavalue });
            this.invokeEventCallback('submit', { $event: $event });
            this.updatePrevDatavalue(this.datavalue);
        };
        SearchComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'tabindex') {
                return;
            }
            // when dataoptions are provided and there is no displaylabel given then displaylabel is set as the relatedfield
            if (key === 'displaylabel' && this.dataoptions && this.binddisplaylabel === null) {
                this.query = _.get(this._modelByValue, nv) || this._modelByValue;
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        SearchComponent.initializeProps = registerProps$j();
        SearchComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmSearch]',
                        template: "<ng-template #customItemTemplate let-model=\"item\" let-index=\"index\" let-query=\"query\" let-match=\"match\">\n    <a>\n        <img *ngIf=\"model.imgSrc\" [src]=\"model.imgSrc\" alt=\"Search\" [style.width]=\"imagewidth\">\n        <span [title]=\"model.label\" [innerHtml]=\"highlight(match, query) || model.label\"></span>\n    </a>\n</ng-template>\n\n<ng-template #customListTemplate let-matches=\"matches\" let-itemTemplate=\"itemTemplate\" let-query=\"query\">\n    <ul #ulElement class=\"app-search dropdown-menu\" scrollable>\n        <li #liElements *ngFor=\"let match of matches\" [ngClass]=\"{active: typeaheadContainer && typeaheadContainer.isActive(match)}\"\n            (mouseenter)=\"typeaheadContainer.selectActive(match);\"\n            (click)=\"typeaheadContainer.selectMatch(match, $event); $typeaheadEvent = $event;\">\n            <!-- itemTemplate comes from the <input> -->\n            <ng-container *ngIf=\"!match.isHeader()\" [ngTemplateOutlet]=\"itemTemplate\"\n                          [ngTemplateOutletContext]=\"{item: match.item, index: i, match: match, query: query}\">\n            </ng-container>\n        </li>\n        <div class=\"status\" [hidden]=\"_loadingItems || !(datacompletemsg && dataProvider.isLastPage)\">\n            <span [textContent]=\"datacompletemsg\"></span>\n        </div>\n        <div class=\"status\" [hidden]=\"!_loadingItems\">\n            <i class=\"fa fa-circle-o-notch fa-spin\"></i>\n            <span [textContent]=\"loadingdatamsg\"></span>\n        </div>\n    </ul>\n</ng-template>\n\n<!--This template is for search inside mobile navbar.-->\n<ng-container *ngIf=\"navsearchbar; else searchTemplate\">\n    <input [title]=\"query || ''\" type=\"text\" class=\"app-textbox form-control list-of-objs app-search-input\" [placeholder]=\"placeholder || ''\"\n           focus-target\n           container=\"body\"\n           [disabled]=\"disabled\"\n           autocomplete=\"off\"\n           [(ngModel)]=\"query\"\n           [readonly]=\"readonly\"\n           [disabled]=\"disabled\"\n           [typeahead]=\"typeaheadDataSource\"\n           [typeaheadWaitMs]=\"debouncetime\"\n           [typeaheadItemTemplate]=\"customItemTemplate\"\n           [optionsListTemplate]=\"customListTemplate\"\n           (input)=\"onInputChange($event)\"\n           (keydown)=\"listenQuery = true\"\n           (keydown.enter)=\"$typeaheadEvent = $event;\"\n           (keydown.arrowdown)=\"selectNext($event)\"\n           (blur)=\"invokeOnTouched($event)\"\n           (focus)=\"_unsubscribeDv = false; listenQuery = true; invokeOnFocus($event);\"\n           (focusout)=\"onFocusOut()\"\n           [typeaheadMinLength]=\"minchars\"\n           [typeaheadOptionsLimit]=\"limit\"\n           (typeaheadLoading)=\"_loadingItems\"\n           (typeaheadOnSelect)=\"typeaheadOnSelect($event)\"\n           typeaheadOptionField=\"label\"\n           [typeaheadAsync]=\"true\"\n           [typeaheadScrollable]=\"true\"\n           [typeaheadOptionsInScrollableView]=\"optionslimitinscrollableview\"\n           [dropup]=\"dropup\"\n           [tabindex]=\"tabindex\"\n           [attr.name]=\"name\"/>\n    <i class=\"btn-close wi wi-cancel\" [hidden]=\"!showClosebtn\" (click)=\"clearSearch($event);\"></i>\n</ng-container>\n<!--This template is for both web and fullscreen mode in mobile.-->\n<ng-template #searchTemplate>\n    <span class=\"wi wi-arrow-left form-control-feedback back-btn\" aria-hidden=\"true\" (click)=\"closeSearch()\"></span>\n    <span class=\"sr-only\">Back button</span>\n    <input [title]=\"query || ''\" type=\"text\" class=\"app-textbox form-control list-of-objs app-search-input\" [placeholder]=\"placeholder || ''\"\n           focus-target\n           container=\"body\"\n           [disabled]=\"disabled\"\n           autocomplete=\"off\"\n           [(ngModel)]=\"query\"\n           [readonly]=\"readonly\"\n           [typeahead]=\"typeaheadDataSource\"\n           [typeaheadWaitMs]=\"debouncetime\"\n           [typeaheadItemTemplate]=\"customItemTemplate\"\n           [optionsListTemplate]=\"customListTemplate\"\n           (input)=\"onInputChange($event)\"\n           (keydown)=\"listenQuery = true\"\n           (keydown.enter)=\"$typeaheadEvent = $event;handleEnterEvent($event)\"\n           (keydown.arrowdown)=\"selectNext($event)\"\n           (blur)=\"invokeOnTouched($event)\"\n           (focus)=\"_unsubscribeDv = false; listenQuery = true; invokeOnFocus($event)\"\n           (focusout)=\"onFocusOut()\"\n           [typeaheadMinLength]=\"minchars\"\n           [typeaheadOptionsLimit]=\"limit\"\n           (typeaheadLoading)=\"_loadingItems\"\n           (typeaheadOnSelect)=\"typeaheadOnSelect($event)\"\n           typeaheadOptionField=\"label\"\n           [typeaheadAsync]=\"true\"\n           [typeaheadScrollable]=\"true\"\n           [typeaheadOptionsInScrollableView]=\"optionslimitinscrollableview\"\n           [tabindex]=\"tabindex\"\n           [dropup]=\"dropup\"\n           [attr.name]=\"name\">\n    <input class=\"model-holder\" ng-model=\"proxyModel\" ng-required=\"required\" tabindex=\"-1\">\n    <span *ngIf=\"_loadingItems\" aria-hidden=\"true\" class=\"fa fa-circle-o-notch fa-spin form-control-feedback\"></span>\n    <span class=\"wi wi-close form-control-feedback clear-btn\" [hidden]=\"!showClosebtn\" (click)=\"clearSearch($event, true)\"></span>\n    <span class=\"sr-only\">Clear button</span>\n    <span *ngIf=\"showsearchicon\" class=\"input-group-addon\" aria-label=\"search icon\" [ngClass]=\"{'disabled': disabled}\">\n        <form>\n            <button title=\"Search\" [disabled]=\"disabled\" class=\"app-search-button wi wi-search\" type=\"submit\"\n                    (click)=\"onSelect($event)\"></button>\n        </form>\n    </span>\n</ng-template>\n",
                        providers: [
                            provideAsNgValueAccessor(SearchComponent),
                            provideAsWidgetRef(SearchComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        SearchComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['datavalue.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['dataset.bind',] }] }
            ];
        };
        SearchComponent.propDecorators = {
            typeahead: [{ type: core$1.ViewChild, args: [ngxBootstrap.TypeaheadDirective,] }],
            ulElement: [{ type: core$1.ViewChild, args: ['ulElement',] }],
            liElements: [{ type: core$1.ViewChildren, args: ['liElements',] }]
        };
        return SearchComponent;
    }(DatasetAwareFormComponent));

    var WIDGET_CONFIG$i = {
        widgetType: 'wm-chips',
        hostClass: 'app-chips nav nav-pills list-inline'
    };
    var ChipsComponent = /** @class */ (function (_super) {
        __extends(ChipsComponent, _super);
        function ChipsComponent(inj, bindDisplayField, bindDisplayExpr, bindDisplayImgSrc, bindDataField, bindDataSet, bindChipclass) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$i) || this;
            _this.bindDisplayField = bindDisplayField;
            _this.bindDisplayExpr = bindDisplayExpr;
            _this.bindDisplayImgSrc = bindDisplayImgSrc;
            _this.bindDataField = bindDataField;
            _this.bindDataSet = bindDataSet;
            _this.bindChipclass = bindChipclass;
            _this.chipsList = [];
            _this.maxSizeReached = 'Max size reached';
            _this._unsubscribeDv = false;
            styler(_this.nativeElement, _this);
            // set the showsearchicon as false by default.
            if (!core.isDefined(_this.showsearchicon)) {
                _this.showsearchicon = false;
            }
            _this.multiple = true;
            _this.nextItemIndex = 0; // default chip index
            _this._debounceUpdateQueryModel = core.debounce(function (val) {
                _this.updateQueryModel(val).then(function () {
                    if (_this.bindChipclass) {
                        _.forEach(_this.chipsList, function (item, index) {
                            _this.registerChipItemClass(item, index);
                        });
                    }
                });
            }, 150);
            var datasetSubscription = _this.dataset$.subscribe(function () {
                _this.searchComponent.dataset = _this.dataset;
                _this.nextItemIndex = _this.datasetItems.length;
                _this._debounceUpdateQueryModel(_this.datavalue || _this.toBeProcessedDatavalue);
            });
            _this.registerDestroyListener(function () { return datasetSubscription.unsubscribe(); });
            var datavalueSubscription = _this.datavalue$.subscribe(function (val) {
                // update queryModel only when parentRef is available.
                if (!_this._unsubscribeDv) {
                    _this.chipsList = [];
                    // if the datafield is ALLFILEDS do not fetch the records
                    // update the query model with the values we have
                    _this._debounceUpdateQueryModel(val);
                }
            });
            _this.registerDestroyListener(function () { return datavalueSubscription.unsubscribe(); });
            return _this;
        }
        Object.defineProperty(ChipsComponent.prototype, "datasource", {
            // getter setter is added to pass the datasource to searchcomponent.
            get: function () {
                return this._datasource;
            },
            set: function (nv) {
                this._datasource = nv;
                this.searchComponent.datasource = nv;
                this._debounceUpdateQueryModel(this.datavalue || this.toBeProcessedDatavalue);
            },
            enumerable: true,
            configurable: true
        });
        ChipsComponent.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.searchComponent.multiple = true;
            this.searchComponent.binddisplayimagesrc = this.bindDisplayImgSrc;
            this.searchComponent.displayimagesrc = this.displayimagesrc;
            this.searchComponent.binddisplaylabel = this.bindDisplayExpr;
            this.searchComponent.displaylabel = this.displayfield;
            this.searchComponent.datafield = this.bindDataField || this.datafield;
            this.searchComponent.binddataset = this.bindDataSet;
            this.searchComponent.dataset = this.dataset;
            this.searchComponent.searchkey = this.searchkey;
            this.searchComponent.limit = this.limit;
            this.searchComponent.debouncetime = this.debouncetime;
            this.searchComponent.matchmode = this.matchmode;
            this.getTransformedData = function (val, isCustom) {
                return _this.searchComponent.getTransformedData([val], _this.nextItemIndex++, isCustom);
            };
        };
        ChipsComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            if (this.enablereorder) {
                this.configureDnD();
            }
        };
        /**
         * This method returns the evaluated class expression.
         * @param $index index of the chip
         * @param item chip object containing the key, value, label
         * @returns {any} evaluated class expression value
         */
        ChipsComponent.prototype.registerChipItemClass = function (item, $index) {
            var _this = this;
            if (this.bindChipclass) {
                var watchName = this.widgetId + "_chipItemClass_" + $index;
                core.$unwatch(watchName);
                this.registerDestroyListener(core.$watch(this.bindChipclass, this.viewParent, { item: item, $index: $index }, function (nv, ov) {
                    _this.applyItemClass(getConditionalClasses(nv, ov), $index);
                }, watchName));
            }
        };
        ChipsComponent.prototype.applyItemClass = function (val, index) {
            var chipItem = this.nativeElement.querySelectorAll('.chip-item').item(index);
            $(chipItem).removeClass(val.toRemove).addClass(val.toAdd);
        };
        ChipsComponent.prototype.removeDuplicates = function () {
            this.chipsList = getUniqObjsByDataField(this.chipsList, this.datafield, this.displayfield || this.displaylabel);
        };
        // This method updates the queryModel.
        // default call to get the default data can be done only when defaultQuery is true.
        ChipsComponent.prototype.updateQueryModel = function (data) {
            var _this = this;
            var promises = [];
            if (!data) {
                this.chipsList = [];
                return Promise.resolve();
            }
            // clone the data as the updations on data will change the datavalue.
            var dataValue = _.clone(data);
            var prevChipsList = this.chipsList;
            this.chipsList = [];
            // update the model when model has items more than maxsize
            if (this.maxsize && dataValue.length > this.maxsize) {
                this._modelByValue = dataValue = _.slice(dataValue, 0, this.maxsize);
                data = dataValue;
            }
            var searchQuery = [];
            /**
             * For each value in datavalue,
             * 1. check whether value is in datasetItems, if item is found, addd to the chipsList.
             * 2. else make a default query to the filter and get the record.
             * 3. In step 2, if datavalue is not ALLFIELDS, then make a query. Extract the chipsList from the query response.
             * 4. If there is no response for the value and allowonlyselect is true, remove the value from the datavalue. So that datavalue just contains the valid values.
             * 5. In step 2, if datavalue is ALLFIELDS and value is object, then just prepare the datasetItem from the value.
             * 6. If value is not object and allowonlyselect is false, then create a customModel and replace this value with customModel and prepare datasetItem from this value
             */
            dataValue.forEach(function (val, i) {
                var itemFound = _.find(_this.datasetItems, function (item) {
                    return _.isObject(item.value) ? _.isEqual(item.value, val) : _.toString(item.value) === _.toString(val);
                });
                if (itemFound) {
                    _this.chipsList.push(itemFound);
                }
                else if (_this.datafield !== ALLFIELDS) {
                    searchQuery.push(val);
                }
                else if (_this.datafield === ALLFIELDS) {
                    var dataObj = void 0, isCustom = false;
                    if (!_.isObject(val)) {
                        dataObj = _this.createCustomDataModel(val);
                        isCustom = true;
                        if (dataObj) {
                            data.splice(i, 1, dataObj);
                        }
                    }
                    else {
                        // if custom chips is already generated, val will be object as {'dataField_val': 'entered_val'}
                        // Hence check this val in previous chipList and assign the iscustom flag
                        var prevChipObj = prevChipsList.find(function (obj) {
                            return _.isEqual(obj.value, val);
                        });
                        if (prevChipObj) {
                            isCustom = prevChipObj.iscustom;
                        }
                    }
                    dataObj = dataObj || val;
                    var transformedData = _this.getTransformedData(dataObj, isCustom);
                    var chipObj = transformedData[0];
                    if (isCustom) {
                        chipObj.iscustom = isCustom;
                    }
                    _this.chipsList.push(chipObj);
                }
            });
            // make default query with all the values and if response for the value is not in datavalue then add a custom chip object.
            if (searchQuery.length) {
                promises.push(this.getDefaultModel(searchQuery, this.nextItemIndex)
                    .then(function (response) {
                    _this.chipsList = _this.chipsList.concat(response || []);
                    dataValue.forEach(function (val, i) {
                        var isExists = _.find(_this.chipsList, function (obj) {
                            return obj.value.toString() === val.toString();
                        });
                        if (!isExists) {
                            if (_this.allowonlyselect) {
                                var index = data.indexOf(val);
                                if (index > -1) {
                                    data.splice(index, 1);
                                }
                                return;
                            }
                            var transformedData = _this.getTransformedData(val, true);
                            var chipObj = transformedData[0];
                            chipObj.iscustom = true;
                            _this.chipsList.push(chipObj);
                        }
                    });
                }));
            }
            // default chip data is adding focus on to the search input. Hence this flag helps not to focus.
            this.resetSearchModel(true);
            return Promise.all(promises).then(function () {
                _this._modelByValue = data;
                _this.removeDuplicates();
                _this.updateMaxSize();
                core.$appDigest();
            });
        };
        ChipsComponent.prototype.resetSearchModel = function (defaultQuery) {
            this._unsubscribeDv = true;
            // clear search will empty the query model and gets the data when minchars is 0 (i.e. autocomplete) on focus
            // defaultQuery flag is set when widget is not active. This will only load the autocomplete dropup with minchars as 0 when widget is focused/active
            this.searchComponent.clearSearch(undefined, !this.minchars && !defaultQuery);
            this._unsubscribeDv = false;
        };
        // Triggerred when typeahead option is selected by enter keypress.
        ChipsComponent.prototype.onSelect = function ($event) {
            if (!this.searchComponent.liElements.length) {
                this.addItem($event);
            }
        };
        // Add the newItem to the list
        ChipsComponent.prototype.addItem = function ($event, widget) {
            var searchComponent = widget;
            var allowAdd;
            var chipObj;
            if (searchComponent && core.isDefined(searchComponent.datavalue) && searchComponent.queryModel !== '') {
                if (!searchComponent.query || !_.trim(searchComponent.query)) {
                    return;
                }
                chipObj = searchComponent.queryModel;
            }
            else {
                if (this.allowonlyselect) {
                    return;
                }
                var dataObj = void 0;
                if (this.datafield === ALLFIELDS) {
                    if (!_.isObject(this.searchComponent.query) && _.trim(this.searchComponent.query)) {
                        dataObj = this.createCustomDataModel(this.searchComponent.query);
                        // return if the custom chip is empty
                        if (!dataObj) {
                            this.resetSearchModel();
                            return;
                        }
                    }
                }
                var data = dataObj || _.trim(this.searchComponent.query);
                if (data) {
                    var transformedData = this.getTransformedData(data, true);
                    chipObj = transformedData[0];
                    chipObj.iscustom = true;
                }
            }
            if (!core.isDefined(chipObj) || chipObj === '') {
                return;
            }
            allowAdd = this.invokeEventCallback('beforeadd', { $event: $event, newItem: chipObj });
            if (core.isDefined(allowAdd) && !core.toBoolean(allowAdd)) {
                return;
            }
            if (this.isDuplicate(chipObj)) {
                this.resetSearchModel();
                return;
            }
            this.registerChipItemClass(chipObj, this.chipsList.length);
            this.chipsList.push(chipObj);
            if (!this.datavalue) {
                this._modelByValue = [chipObj.value];
            }
            else {
                this._modelByValue = __spread(this._modelByValue, [chipObj.value]);
            }
            this._unsubscribeDv = true;
            this.invokeOnTouched();
            this.invokeOnChange(this._modelByValue, $event || {}, true);
            this.invokeEventCallback('add', { $event: $event, $item: chipObj });
            this.updateMaxSize();
            // reset input box when item is added.
            this.resetSearchModel();
            // stop the event to not to call the submit event on enter press.
            if ($event && ($event.key === 'Enter' || $event.keyCode === 13)) {
                this.stopEvent($event);
            }
        };
        // Prepare datavalue object from a string(junk) value when datafield is allFields.
        ChipsComponent.prototype.createCustomDataModel = function (val) {
            var key = this.displayfield || (this.datafield !== ALLFIELDS ? this.datafield : undefined);
            if (key) {
                var customObj = {};
                customObj[key] = val;
                return customObj;
            }
        };
        // Check if newItem already exists
        ChipsComponent.prototype.isDuplicate = function (item) {
            if (this.datafield === ALLFIELDS) {
                return _.findIndex(this.chipsList, { value: item.value }) > -1;
            }
            return _.findIndex(this.chipsList, { key: item.key }) > -1;
        };
        // Check if max size is reached
        ChipsComponent.prototype.updateMaxSize = function () {
            this.saturate = this.maxsize > 0 && this.chipsList.length === this.maxsize;
        };
        // Makes call to searchComponent to filter the dataSource based on the query.
        ChipsComponent.prototype.getDefaultModel = function (query, index) {
            this.nextItemIndex++;
            return this.searchComponent.getDataSource(query, true, index)
                .then(function (response) {
                return _.filter(query, function (queryVal) {
                    _.find(response, { value: queryVal });
                });
            });
        };
        ChipsComponent.prototype.handleChipClick = function ($event, chip) {
            if (this.readonly) {
                return;
            }
            $event.currentTarget.focus();
            this.invokeEventCallback('chipclick', { $event: $event, $item: chip });
        };
        ChipsComponent.prototype.handleChipFocus = function ($event, chip) {
            if (this.readonly) {
                return;
            }
            chip.active = true;
            this.invokeEventCallback('chipselect', { $event: $event, $item: chip });
        };
        // To avoid form submit on pressing enter key
        ChipsComponent.prototype.stopEvent = function ($event) {
            $event.stopPropagation();
            $event.preventDefault();
        };
        ChipsComponent.prototype.onTextDelete = function ($event) {
            if (core.isAppleProduct) {
                this.onInputClear($event);
            }
        };
        ChipsComponent.prototype.onInputClear = function ($event) {
            if (!this.chipsList || !this.chipsList.length || this.searchComponent.query) {
                return;
            }
            this.$element.find('li.chip-item > a.app-chip:last').focus();
            this.stopEvent($event);
        };
        ChipsComponent.prototype.onBackspace = function ($event, $item, $index) {
            if (this.readonly) {
                return;
            }
            this.removeItem($event, $item, $index, true);
        };
        ChipsComponent.prototype.onDelete = function ($event, $item, $index) {
            if (this.readonly) {
                return;
            }
            this.removeItem($event, $item, $index);
        };
        ChipsComponent.prototype.onArrowLeft = function ($item, $index) {
            if (this.readonly) {
                return;
            }
            // On left arrow click when search input query is empty.
            if (!this.searchComponent.query && !core.isDefined($index) && !core.isDefined($item)) {
                this.$element.find('li.chip-item > a.app-chip:last').focus();
                return;
            }
            if ($index > 0) {
                this.$element.find('li.chip-item > a.app-chip').get($index - 1).focus();
            }
            else {
                this.focusSearchBox();
            }
        };
        ChipsComponent.prototype.onArrowRight = function ($item, $index) {
            if (this.readonly) {
                return;
            }
            // On right arrow click when search input query is empty.
            if (!this.searchComponent.query && !core.isDefined($index) && !core.isDefined($item)) {
                this.$element.find('li.chip-item > a.app-chip:first').focus();
                return;
            }
            if ($index < (this.chipsList.length - 1)) {
                this.$element.find('li.chip-item > a.app-chip').get($index + 1).focus();
            }
            else {
                this.focusSearchBox();
            }
        };
        // focus search box.
        ChipsComponent.prototype.focusSearchBox = function () {
            this.$element.find('.app-chip-input > input.app-textbox').focus();
        };
        // Remove the item from list
        ChipsComponent.prototype.removeItem = function ($event, item, index, canFocus) {
            var _this = this;
            $event.stopPropagation();
            var indexes = _.isArray(index) ? index : [index];
            var focusIndex = _.max(indexes);
            var items = _.reduce(indexes, function (result, i) {
                result.push(_this.chipsList[i]);
                return result;
            }, []);
            // prevent deletion if the before-remove event callback returns false
            var allowRemove = this.invokeEventCallback('beforeremove', { $event: $event, $item: items.length === 1 ? items[0] : items });
            if (core.isDefined(allowRemove) && !core.toBoolean(allowRemove)) {
                return;
            }
            var prevDatavalue = _.clone(this.datavalue);
            // focus next chip after deletion.
            // if there are no chips in the list focus search box
            setTimeout(function () {
                var chipsLength = _this.chipsList.length;
                var $chipsList = _this.$element.find('li.chip-item > a.app-chip');
                if (!chipsLength || !canFocus) {
                    _this.focusSearchBox();
                }
                else if ((chipsLength - 1) < focusIndex) {
                    // if focus index is greater than chips length select last chip
                    $chipsList.get(chipsLength - 1).focus();
                }
                else {
                    // manually set the succeeding chip as active if there is a chip next to the current chip.
                    _this.chipsList[focusIndex].active = true;
                    $chipsList.get(focusIndex).focus();
                }
            });
            var pulledItems = _.pullAt(this.chipsList, indexes);
            pulledItems.forEach(function (datasetItem) {
                _this._modelByValue = _.filter(_this._modelByValue, function (val) {
                    return !(_.isObject(val) ? _.isEqual(val, datasetItem.value) : _.toString(val) === _.toString(datasetItem.value));
                });
            });
            this._unsubscribeDv = false;
            this.invokeOnChange(this._modelByValue, $event, true);
            this.invokeEventCallback('change', { $event: $event, newVal: this.datavalue, oldVal: prevDatavalue });
            this.updateMaxSize();
            this.invokeEventCallback('remove', { $event: $event, $item: items.length === 1 ? items[0] : items });
        };
        /**
         * Swaps items in an array if provided with indexes.
         * @param data :- array to be swapped
         * @param newIndex :- new index for the element to be placed
         * @param currentIndex :- the current index of the element.
         */
        ChipsComponent.prototype.swapElementsInArray = function (data, newIndex, currentIndex) {
            var draggedItem = _.pullAt(data, currentIndex)[0];
            data.splice(newIndex, 0, draggedItem);
        };
        /**
         * Cancels the reorder by reseting the elements to the original position.
         */
        ChipsComponent.prototype.resetReorder = function () {
            this.$element.removeData('oldIndex');
        };
        ChipsComponent.prototype.onBeforeservicecall = function (inputData) {
            this.invokeEventCallback('beforeservicecall', { inputData: inputData });
        };
        ChipsComponent.prototype.handleEvent = function (node, eventName, eventCallback, locals) {
            if (eventName === 'remove' || eventName === 'beforeremove' || eventName === 'chipselect'
                || eventName === 'chipclick' || eventName === 'add' || eventName === 'reorder' || eventName === 'change') {
                return;
            }
            _super.prototype.handleEvent.call(this, node, eventName, eventCallback, locals);
        };
        // Configures the reordable feature in chips widgets.
        ChipsComponent.prototype.configureDnD = function () {
            var options = {
                items: '> li:not(.app-chip-search)',
                placeholder: 'chip-placeholder'
            };
            configureDnD(this.$element, options, this.onReorderStart.bind(this), this.update.bind(this));
        };
        // Triggered on drag start while reordering.
        ChipsComponent.prototype.onReorderStart = function (evt, ui) {
            var helper = ui.helper;
            // increasing the width of the dragged item by 1
            helper.width(helper.width() + 1);
            this.$element.data('oldIndex', ui.item.index() - (this.inputposition === 'first' ? 1 : 0));
        };
        // updates the chipsList and datavalue on reorder.
        ChipsComponent.prototype.update = function ($event, ui) {
            var changedItem, newIndex, oldIndex;
            // Get the index of the item at position before drag and after the reorder.
            newIndex = ui.item.index() - (this.inputposition === 'first' ? 1 : 0);
            oldIndex = this.$element.data('oldIndex');
            newIndex = this.chipsList.length === newIndex ? newIndex - 1 : newIndex;
            changedItem = {
                oldIndex: oldIndex,
                newIndex: newIndex,
                item: this.chipsList[oldIndex]
            };
            if (newIndex === oldIndex) {
                this.resetReorder();
                return;
            }
            changedItem.item = this.chipsList[oldIndex];
            var allowReorder = this.invokeEventCallback('beforereorder', { $event: $event, $data: this.chipsList, $changedItem: changedItem });
            if (core.isDefined(allowReorder) && core.toBoolean(allowReorder) === false) {
                this.resetReorder();
                return;
            }
            // modify the chipsList and datavalue after the reorder.
            this.swapElementsInArray(this.chipsList, newIndex, oldIndex);
            this.swapElementsInArray(this._modelByValue, newIndex, oldIndex);
            changedItem.item = this.chipsList[newIndex];
            this.chipsList = __spread(this.chipsList);
            this.resetReorder();
            this.invokeEventCallback('reorder', { $event: $event, $data: this.chipsList, $changedItem: changedItem });
        };
        ChipsComponent.prototype.onPropertyChange = function (key, nv, ov) {
            var _this = this;
            if (key === 'tabindex') {
                return;
            }
            if (key === 'dataoptions') {
                this.searchComponent.dataoptions = nv;
            }
            if (key === 'datafield') {
                this.searchComponent.datafield = this.datafield;
            }
            if (key === 'displayfield') {
                this.searchComponent.displaylabel = this.displayfield;
            }
            if (key === 'displayexpression') {
                this.searchComponent.binddisplaylabel = this.binddisplayexpression ? this.binddisplayexpression : this.displayexpression;
            }
            if (key === 'displayimagesrc') {
                this.searchComponent.binddisplayimagesrc = this.binddisplayimagesrc ? this.binddisplayimagesrc : this.displayimagesrc;
            }
            if (key === 'limit') {
                this.searchComponent.limit = this.limit;
            }
            if (key === 'enablereorder') {
                if (this.$element.hasClass('ui-sortable')) {
                    this.$element.sortable('option', 'disabled', !nv);
                }
                else if (nv) {
                    this.configureDnD();
                }
            }
            if (key === 'readonly') {
                if (nv) {
                    this.$element.addClass('readonly');
                }
                else {
                    this.$element.removeClass('readonly');
                }
            }
            if (key === 'inputposition') {
                var $inputEl = this.$element.find('li.app-chip-search');
                if (nv === 'first') {
                    this.$element.prepend($inputEl);
                }
                else {
                    this.$element.append($inputEl);
                }
            }
            if (key === 'autofocus' && nv) {
                // setting the autofocus on the input once after dom is updated
                setTimeout(function () {
                    var $chipsList = _this.$element.find('.app-chip-input > input.app-textbox');
                    if ($chipsList && $chipsList.length) {
                        _this.focusSearchBox();
                    }
                });
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        ChipsComponent.initializeProps = registerProps$i();
        ChipsComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmChips]',
                        template: "<li class=\"chip-item\" role=\"option\" *ngFor=\"let item of chipsList; let $index = index;\"\n    [ngClass]=\"{'active': item.active, 'disabled': disabled}\">\n    <a class=\"app-chip\" href=\"javascript:void(0);\" tabindex=\"-1\"\n       (click)=\"handleChipClick($event, item)\"\n       (keydown.delete)=\"onDelete($event, item, $index)\"\n       (keydown.backspace)=\"onBackspace($event, item, $index)\"\n       (keydown.arrowleft)=\"onArrowLeft(item, $index)\"\n       (keydown.arrowright)=\"onArrowRight(item, $index)\"\n       (focus)=\"handleChipFocus($event, item)\"\n       (blur)=\"readonly ? 0 : item.active = false\"\n       [ngClass]=\"{'chip-duplicate bg-danger': item.isDuplicate, 'chip-picture': item.imgSrc}\">\n        <img data-identifier=\"img\" alt=\"Chip Image\" class=\"button-image-icon\" [src]=\"item.imgSrc\" *ngIf=\"item.imgSrc\"/>\n        <span class=\"app-chip-title\" [textContent]=\"item.label\" [title]=\"item.label\"></span>\n        <button type=\"button\" tabindex=\"-1\" arial-label=\"Clear Button\" class=\"btn btn-transparent\" (click)=\"removeItem($event, item, $index);\" *ngIf=\"!readonly\">\n            <i class=\"app-icon wi wi-close\"></i>\n        </button>\n    </a>\n</li>\n<li class=\"app-chip-search\" [ngClass]=\"{'full-width': inputwidth === 'full'}\">\n    <div #search wmSearch class=\"app-chip-input\"\n         name=\"app-chip-search\"\n         submit.event=\"addItem($event, widget)\"\n         beforeservicecall.event=\"onBeforeservicecall(inputData)\"\n         disabled.bind=\"disabled || readonly || saturate\"\n         datafield.bind=\"datafield\"\n         allowonlyselect.bind=\"allowonlyselect\"\n         searchkey.bind=\"searchkey\"\n         orderby.bind=\"orderby\"\n         placeholder.bind=\"saturate ? maxSizeReached : placeholder\"\n         showsearchicon.bind=\"showsearchicon\"\n         tabindex.bind=\"tabindex\"\n         minchars.bind=\"minchars\"\n         debouncetime.bind=\"debouncetime\"\n         matchmode.bind=\"matchmode\"\n         (keydown.enter)=\"onSelect($event)\"\n         (keydown.delete)=\"onTextDelete($event)\"\n         (keydown.backspace)=\"onInputClear($event)\"\n         (keydown.arrowleft)=\"onArrowLeft()\"\n         (keydown.arrowright)=\"onArrowRight()\">\n    </div>\n</li>\n",
                        providers: [
                            provideAsNgValueAccessor(ChipsComponent),
                            provideAsWidgetRef(ChipsComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        ChipsComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['displayfield.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['displayexpression.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['displayimagesrc.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['datafield.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['dataset.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['chipclass.bind',] }] }
            ];
        };
        ChipsComponent.propDecorators = {
            searchComponent: [{ type: core$1.ViewChild, args: [SearchComponent,] }]
        };
        return ChipsComponent;
    }(DatasetAwareFormComponent));

    var registerProps$k = function () {
        register('wm-form-group', new Map([
            ['captionposition', PROP_STRING],
            ['name', PROP_STRING],
            ['required', PROP_BOOLEAN],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$f = 'form-group app-composite-widget clearfix';
    var WIDGET_CONFIG$j = {
        widgetType: 'wm-form-group',
        hostClass: DEFAULT_CLS$f
    };
    var CAPTION_POSITION = {
        left: 'caption-left',
        right: 'caption-right',
        top: 'caption-top'
    };
    var CompositeDirective = /** @class */ (function (_super) {
        __extends(CompositeDirective, _super);
        function CompositeDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$j) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        /**
         * this is onPropertyChange handler for the form-group component
         * @param key
         * @param nv
         * @param ov
         */
        CompositeDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'captionposition') {
                core.switchClass(this.nativeElement, CAPTION_POSITION[nv], CAPTION_POSITION[ov]);
            }
            else if (key === 'required') {
                this.required = nv;
                this.assignRequiredToSubComponents();
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        /**
         * this method assigns the required on the component/directive based on the required attribute of the form-group
         */
        CompositeDirective.prototype.assignRequiredToSubComponents = function () {
            var _this = this;
            if (this.required && this.componentRefs) {
                setTimeout(function () {
                    _this.componentRefs.forEach(function (componentRef) { return componentRef.widget.required = true; });
                }, 50);
            }
        };
        CompositeDirective.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            core.addForIdAttributes(this.nativeElement);
            this.assignRequiredToSubComponents();
        };
        CompositeDirective.initializeProps = registerProps$k();
        CompositeDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'div[wmComposite]',
                        providers: [
                            provideAsWidgetRef(CompositeDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        CompositeDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        CompositeDirective.propDecorators = {
            componentRefs: [{ type: core$1.ContentChildren, args: [WidgetRef, { descendants: true },] }]
        };
        return CompositeDirective;
    }(StylableComponent));

    var registerProps$l = function () {
        register('wm-confirmdialog', new Map([
            ['animation', PROP_STRING],
            ['canceltext', __assign({ value: 'CANCEL' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['closable', { value: true, PROP_BOOLEAN: PROP_BOOLEAN }],
            ['iconclass', { value: 'wi wi-done', PROP_STRING: PROP_STRING }],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['message', __assign({ value: 'I am confirm box!' }, PROP_STRING)],
            ['modal', __assign({ value: false }, PROP_BOOLEAN)],
            ['name', PROP_STRING],
            ['oktext', __assign({ value: 'OK' }, PROP_STRING)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', __assign({ value: 'Confirm' }, PROP_STRING)]
        ]));
    };

    var DIALOG_CLS$1 = 'app-dialog modal-dialog app-confirm-dialog';
    var WIDGET_INFO$1 = { widgetType: 'wm-confirmdialog' };
    var ConfirmDialogComponent = /** @class */ (function (_super) {
        __extends(ConfirmDialogComponent, _super);
        function ConfirmDialogComponent(inj, dialogClass, modal, closable) {
            var _this = this;
            if (modal === null || modal === undefined) {
                modal = false;
            }
            if (closable === null || closable === undefined) {
                closable = true;
            }
            // setting the backdrop to 'static' will not close the dialog on backdrop click
            var backdrop = 'static';
            _this = _super.call(this, inj, WIDGET_INFO$1, {
                class: DIALOG_CLS$1 + " " + (dialogClass || ''),
                backdrop: backdrop,
                keyboard: !core.toBoolean(modal)
            }) || this;
            return _this;
        }
        ConfirmDialogComponent.prototype.getTemplateRef = function () {
            return this.dialogTemplate;
        };
        /**
         * Click event handler for the ok button
         * invokes on-ok event callback
         * @param {Event} $event
         */
        ConfirmDialogComponent.prototype.onOk = function ($event) {
            this.invokeEventCallback('ok', { $event: $event });
        };
        /**
         * Click event handler for the cancel button
         * invokes on-cancel event callback
         * @param {Event} $event
         */
        ConfirmDialogComponent.prototype.onCancel = function ($event) {
            this.invokeEventCallback('cancel', { $event: $event });
        };
        ConfirmDialogComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.register(this.viewParent);
        };
        ConfirmDialogComponent.initializeProps = registerProps$l();
        ConfirmDialogComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmConfirmDialog]',
                        template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"></div>\n    <div wmDialogBody>\n        <p class=\"app-dialog-message {{messageclass}}\" [attr.aria-describedby]=\"message\">{{message}}</p>\n    </div>\n    <div wmDialogFooter>\n        <button wmButton class=\"btn-default btn-secondary cancel-action\" caption.bind=\"canceltext\" aria-label=\"Cancel button\" (click)=\"onCancel($event)\"></button>\n        <button wmButton class=\"btn-primary ok-action\" caption.bind=\"oktext\" aria-label=\"Submit button\" (click)=\"onOk($event)\"></button>\n    </div>\n</ng-template>\n",
                        providers: [
                            provideAsWidgetRef(ConfirmDialogComponent),
                            provideAsDialogRef(ConfirmDialogComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        ConfirmDialogComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['class',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['modal',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['closable',] }] }
            ];
        };
        ConfirmDialogComponent.propDecorators = {
            dialogTemplate: [{ type: core$1.ViewChild, args: ['dialogTemplate',] }]
        };
        return ConfirmDialogComponent;
    }(BaseDialog));

    var registerProps$m = function () {
        register('wm-container', new Map([
            ['class', PROP_STRING],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['content', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$g = 'app-container';
    var WIDGET_CONFIG$k = {
        widgetType: 'wm-container',
        hostClass: DEFAULT_CLS$g
    };
    var ContainerDirective = /** @class */ (function (_super) {
        __extends(ContainerDirective, _super);
        function ContainerDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$k) || this;
            core.addClass(_this.nativeElement, DEFAULT_CLS$g);
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        ContainerDirective.initializeProps = registerProps$m();
        ContainerDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmContainer]',
                        providers: [
                            provideAsWidgetRef(ContainerDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        ContainerDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return ContainerDirective;
    }(StylableComponent));

    var registerProps$n = function () {
        register('wm-content', new Map([
            ['name', PROP_STRING],
            ['class', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$h = 'app-content clearfix';
    var WIDGET_CONFIG$l = { widgetType: 'wm-content', hostClass: DEFAULT_CLS$h };
    var ContentComponent = /** @class */ (function (_super) {
        __extends(ContentComponent, _super);
        function ContentComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$l) || this;
            styler(_this.nativeElement, _this);
            return _this;
        }
        ContentComponent.initializeProps = registerProps$n();
        ContentComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmContent]',
                        template: "<div class=\"row app-content-row clearfix\">\n    <ng-content></ng-content>\n</div>",
                        providers: [
                            provideAsWidgetRef(ContentComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        ContentComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return ContentComponent;
    }(StylableComponent));

    var currencyProps = new Map([
        ['class', PROP_STRING],
        ['currency', __assign({ value: 'USD' }, PROP_STRING)],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['maxvalue', PROP_NUMBER],
        ['minvalue', PROP_NUMBER],
        ['name', PROP_STRING],
        ['placeholder', __assign({ value: 'Enter value' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['step', __assign({ value: 1 }, PROP_NUMBER)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)]
    ]);
    var registerProps$o = function () {
        register('wm-currency', currencyProps);
    };

    var BaseInput = /** @class */ (function (_super) {
        __extends(BaseInput, _super);
        function BaseInput(inj, config) {
            var _this = _super.call(this, inj, config) || this;
            // possible values for ngModelOptions are 'blur' and 'change'
            // default is 'blur'
            _this.ngModelOptions = {
                updateOn: ''
            };
            var updateOn = _this.nativeElement.getAttribute('updateon') || 'blur';
            updateOn = updateOn === 'default' ? 'change' : updateOn;
            _this.ngModelOptions.updateOn = updateOn;
            return _this;
        }
        BaseInput.prototype.onPropertyChange = function (key, nv, ov) {
            // set the class on the input element
            if (key === 'tabindex') {
                return;
            }
            if (key === 'class') {
                if (this.inputEl.nativeElement) {
                    core.switchClass(this.inputEl.nativeElement, nv, ov);
                }
            }
            else if (key === 'datavalue') {
                // update the oldDataValue when the datavalue is modified programmatically
                this.updatePrevDatavalue(nv);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        // invoke the change callback
        BaseInput.prototype.handleChange = function (newValue) {
            this.invokeOnChange(this.datavalue, { type: 'change' }, this.ngModel.valid);
        };
        // Change event is registered from the template, Prevent the framework from registering one more event
        BaseInput.prototype.handleEvent = function (node, eventName, eventCallback, locals) {
            if (eventName !== 'change' && eventName !== 'blur') {
                _super.prototype.handleEvent.call(this, this.inputEl.nativeElement, eventName, eventCallback, locals);
            }
        };
        // invoke the blur callback
        BaseInput.prototype.handleBlur = function ($event) {
            this.invokeOnTouched($event);
        };
        // Update the model on enter key press
        BaseInput.prototype.flushViewChanges = function (val) {
            this.ngModel.update.next(val);
            core.$appDigest();
        };
        BaseInput.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            // add the class on the input element
            if (this.class) {
                core.addClass(this.inputEl.nativeElement, this.class);
            }
            styler(this.inputEl.nativeElement, this);
        };
        return BaseInput;
    }(BaseFormCustomComponent));

    var NumberLocale = /** @class */ (function (_super) {
        __extends(NumberLocale, _super);
        function NumberLocale(inj, config, i18nService, decimalPipe) {
            var _this = _super.call(this, inj, config) || this;
            _this.decimalPipe = decimalPipe;
            _this.isDefaultQuery = true;
            _this.selectedLocale = i18nService.getSelectedLocale();
            _this.DECIMAL = common.getLocaleNumberSymbol(_this.localefilter || _this.selectedLocale, common.NumberSymbol.Decimal);
            _this.GROUP = common.getLocaleNumberSymbol(_this.localefilter || _this.selectedLocale, common.NumberSymbol.Group);
            _this.numberfilter = '1.0-16';
            _this.resetValidations();
            return _this;
        }
        Object.defineProperty(NumberLocale.prototype, "datavalue", {
            // returns the actual model value of the widget.
            get: function () {
                return this.proxyModel;
            },
            // Setter for the datavalue.
            set: function (value) {
                // set text value to null if data value is empty.
                if (_.includes([null, undefined, ''], value)) {
                    var input = this.inputEl.nativeElement;
                    this.displayValue = input.value = this.proxyModel = null;
                    this.resetValidations();
                    this._onChange();
                    return;
                }
                // if the widget has default value and if we change the locale, the value should be in selected locale format.
                if (this.isDefaultQuery) {
                    value = this.transformNumber(value);
                }
                // get a valid number form the text.
                var model = this.parseNumber(value.toString());
                // if the number is valid or if number is not in range update the model value.
                if (this.isValid(model)) {
                    this.proxyModel = model;
                    // update the display value in the text box.
                    this.updateDisplayText();
                    this.handleChange(model);
                }
                else {
                    this.displayValue = value.toString();
                    this.proxyModel = null;
                    this.handleChange(null);
                }
            },
            enumerable: true,
            configurable: true
        });
        // resets all the flags related to the widget's validation.
        NumberLocale.prototype.resetValidations = function () {
            this.isInvalidNumber = false;
            this.numberNotInRange = false;
        };
        /**
         * Adds validations for the number before updating the widget model. like validating min and max value for the widget.
         * @param {number} val number to be validated
         * @returns {number}
         */
        NumberLocale.prototype.isValid = function (val) {
            // id number is infinite then consider it as invalid value
            if (_.isNaN(val) || !_.isFinite(val)) {
                this.isInvalidNumber = true;
                return false;
            }
            if (val !== this.getValueInRange(val)) {
                this.numberNotInRange = true;
                return true;
            }
            this.resetValidations();
            return true;
        };
        /**
         * returns a valid number by validating the minimum and maximum values.
         * @param {number} value
         * @returns {number}
         */
        NumberLocale.prototype.getValueInRange = function (value) {
            if (!_.isNaN(this.minvalue) && value < this.minvalue) {
                return this.minvalue;
            }
            if (!_.isNaN(this.maxvalue) && value > this.maxvalue) {
                return this.maxvalue;
            }
            return value;
        };
        /**
         * convert number to localized number using angular decimal pipe. eg 10,00,000 or 1,000,000
         * @param number
         * @returns {string}
         */
        NumberLocale.prototype.transformNumber = function (number) {
            return this.decimalPipe.transform(number, this.numberfilter, this.localefilter || this.selectedLocale);
        };
        /**
         * resets the cursor position in the text box.
         * @param {number} value cursor position index form left to right.
         */
        NumberLocale.prototype.resetCursorPosition = function (value) {
            var input = this.inputEl.nativeElement;
            // position of the cursor should be given form right to left.
            var position = input.value.length - value;
            position = position < 0 ? 0 : position;
            // set the cursor position in the text box.
            input.setSelectionRange(position, position);
        };
        /**
         * Method parses the Localized number(string) to a valid number.
         * if the string dose not result to a valid number then returns NaN.
         * @param {string} val Localized number.
         * @returns {number}
         */
        NumberLocale.prototype.parseNumber = function (val) {
            // splits string into two parts. decimal and number.
            var parts = val.split(this.DECIMAL);
            if (!parts.length) {
                return null;
            }
            if (parts.length > 2) {
                return NaN;
            }
            // If number have decimal point and not have a decimal value then return.
            if (parts[1] === '') {
                return NaN;
            }
            // replaces all group separators form the number.
            var number = Number(parts[0].split(this.GROUP).join(''));
            var decimal = Number("0." + (parts[1] || 0));
            if (Number.isNaN(number) || Number.isNaN(decimal)) {
                return NaN;
            }
            // if the number is negative then calculate the number as number - decimal
            // Ex: number = -123 and decimal = 0.45 then number - decimal = -123-045 = -123.45
            return number >= 0 ? number + decimal : number - decimal;
        };
        // updates the widgets text value.
        NumberLocale.prototype.updateDisplayText = function () {
            var input = this.inputEl.nativeElement;
            var position = input.selectionStart;
            var preValue = input.value;
            this.displayValue = input.value = this.transformNumber(this.proxyModel);
            // in safari browser, setSelectionRange will focus the input by default, which may invoke the focus event on widget.
            // Hence preventing the setSelectionRange when default value is set i.e. widget is not focused.
            if (this.updateon === 'default' && !this.isDefaultQuery) {
                this.resetCursorPosition(preValue.length - position);
            }
        };
        /**
         * returns the number of decimal places a number have.
         * @param value: number
         * @returns {number}
         */
        NumberLocale.prototype.countDecimals = function (value) {
            if ((value % 1) !== 0) {
                return value.toString().split('.')[1].length;
            }
            return 0;
        };
        /**
         * handles the arrow press event. Increases or decreases the number. triggered fom the template
         * @param $event keyboard event.
         * @param key identifier to increase or decrease the number.
         */
        NumberLocale.prototype.onArrowPress = function ($event, key) {
            $event.preventDefault();
            if (this.readonly || this.step === 0) {
                return;
            }
            var proxyModel = this.proxyModel;
            var value;
            // if the number is not in range and when arrow buttons are pressed need to get appropriate number value.
            if (this.numberNotInRange) {
                var inputValue = this.parseNumber(this.inputEl.nativeElement.value);
                // take the textbox value as current model if the value is valid.
                if (!_.isNaN(inputValue)) {
                    value = this.getValueInRange(inputValue);
                    proxyModel = inputValue;
                    this.resetValidations();
                }
            }
            else {
                if (_.isUndefined(proxyModel) || _.isNull(proxyModel)) {
                    proxyModel = value = this.getValueInRange((this.minvalue || 0));
                    this.resetValidations();
                }
                else {
                    value = this.getValueInRange(proxyModel + (key === 'UP' ? this.step : -this.step));
                }
            }
            if ((key === 'UP' && proxyModel <= value) || (key === 'DOWN' && proxyModel >= value)) {
                var decimalRoundValue = Math.max(this.countDecimals(proxyModel), this.countDecimals(this.step));
                // update the modelProxy.
                this.proxyModel = _.round(value, decimalRoundValue);
                this.updateDisplayText();
                this.handleChange(this.proxyModel);
            }
        };
        /**
         * method is called from the from widget. to check whether the value entered is valid or not.
         * @returns {object}
         */
        NumberLocale.prototype.validate = function (c) {
            if (this.isInvalidNumber) {
                return {
                    invalidNumber: {
                        valid: false
                    },
                };
            }
            if (this.numberNotInRange) {
                return {
                    numberNotInRange: {
                        valid: false
                    },
                };
            }
            return null;
        };
        NumberLocale.prototype.validateInputEntry = function ($event) {
            this.isDefaultQuery = false;
            // allow actions if control key is pressed or if backspace is pressed. (for Mozilla).
            if ($event.ctrlKey || _.includes(['Backspace', 'ArrowRight', 'ArrowLeft', 'Tab', 'Enter'], $event.key)) {
                return;
            }
            var validity = new RegExp("^[\\d\\s-,.e+" + this.GROUP + this.DECIMAL + "]$", 'i');
            var inputValue = $event.target.value;
            // validates if user entered an invalid character.
            if (!validity.test($event.key)) {
                return false;
            }
            // a decimal value can be entered only once in the input.
            if (_.includes(inputValue, this.DECIMAL) && $event.key === this.DECIMAL) {
                return false;
            }
            // 'e' can be entered only once in the input.
            if (_.intersection(_.toArray(inputValue), ['e', 'E']).length && _.includes('eE', $event.key)) {
                return false;
            }
            if ((_.includes(inputValue, '+') || _.includes(inputValue, '-')) && ($event.key === '+' || $event.key === '-')) {
                return false;
            }
        };
        NumberLocale.prototype.onEnter = function ($event) {
            this.datavalue = $event.target.value;
        };
        return NumberLocale;
    }(BaseInput));

    var DEFAULT_CLS$i = 'input-group app-currency';
    var WIDGET_CONFIG$m = {
        widgetType: 'wm-currency',
        hostClass: DEFAULT_CLS$i
    };
    var CurrencyComponent = /** @class */ (function (_super) {
        __extends(CurrencyComponent, _super);
        function CurrencyComponent(inj, i18nService, decimalPipe) {
            return _super.call(this, inj, WIDGET_CONFIG$m, i18nService, decimalPipe) || this;
        }
        CurrencyComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'currency') {
                this.currencySymbol = core.CURRENCY_INFO[this.currency || 'USD'].symbol;
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        CurrencyComponent.initializeProps = registerProps$o();
        CurrencyComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmCurrency]',
                        template: "<span class=\"input-group-addon\" [textContent]=\"currencySymbol\"></span>\n<input class=\"form-control app-textbox app-currency-input\"\n       #input\n       role=\"input\"\n       type=\"text\"\n       focus-target\n       [autofocus]=\"autofocus\"\n       [readonly]=\"readonly\"\n       [disabled]=\"disabled\"\n       [required]=\"required\"\n       [pattern]=\"regexp\"\n       [attr.name]=\"name\"\n       [attr.aria-label]=\"name\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [ngModel]=\"displayValue\"\n       [ngModelOptions]=\"ngModelOptions\"\n\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"datavalue=$event\"\n       (keypress)=\"validateInputEntry($event)\"\n       (keydown.enter)=\"onEnter($event)\"\n       (keydown.ArrowUp)=\"onArrowPress($event, 'UP')\"\n       (keydown.ArrowDown)=\"onArrowPress($event, 'DOWN')\">",
                        providers: [
                            provideAsNgValueAccessor(CurrencyComponent),
                            provideAsNgValidators(CurrencyComponent),
                            provideAsWidgetRef(CurrencyComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        CurrencyComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core.AbstractI18nService },
                { type: common.DecimalPipe }
            ];
        };
        CurrencyComponent.propDecorators = {
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }],
            inputEl: [{ type: core$1.ViewChild, args: ['input', { read: core$1.ElementRef },] }]
        };
        return CurrencyComponent;
    }(NumberLocale));

    var dateProps = new Map([
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['datepattern', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['excludedays', PROP_STRING],
        ['excludedates', PROP_STRING],
        ['hint', PROP_STRING],
        ['maxdate', PROP_STRING],
        ['mindate', PROP_STRING],
        ['name', PROP_STRING],
        ['outputformat', __assign({ value: 'yyyy-MM-dd' }, PROP_STRING)],
        ['placeholder', __assign({ value: 'Select Date' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showdropdownon', __assign({ value: 'default' }, PROP_STRING)],
        ['showbuttonbar', __assign({ value: true }, PROP_BOOLEAN)],
        ['showindevice', __assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
        ['showweeks', __assign({ value: false }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)]
    ]);
    var registerProps$p = function () {
        if (core.isMobileApp()) {
            dateProps.set('datepattern', __assign({ value: 'yyyy-MM-dd' }, PROP_STRING));
        }
        register('wm-date', dateProps);
    };

    var CURRENT_DATE = 'CURRENT_DATE';
    var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var DATEPICKER_DROPDOWN_OPTIONS = {
        BUTTON: 'button',
        DEFAULT: 'default'
    };
    var BaseDateTimeComponent = /** @class */ (function (_super) {
        __extends(BaseDateTimeComponent, _super);
        function BaseDateTimeComponent(inj, WIDGET_CONFIG) {
            var _this = _super.call(this, inj, WIDGET_CONFIG) || this;
            _this.useDatapicker = true;
            /**
             * This is an internal property used to map the containerClass, showWeekNumbers etc., to the bsDatepicker
             */
            _this._dateOptions = new ngxBootstrap.BsDatepickerConfig();
            _this.datePipe = _this.inj.get(ToDatePipe);
            return _this;
        }
        /**
         * returns true if the input value is default (i.e open date picker on input click)
         * @param1 dropdownvalue, user selected value (by default datepicker opens on input click)
         * **/
        BaseDateTimeComponent.prototype.isDropDownDisplayEnabledOnInput = function (dropdownvalue) {
            return dropdownvalue === DATEPICKER_DROPDOWN_OPTIONS.DEFAULT;
        };
        /**
         * This method is used to show validation message depending on the isNativePicker flag.
         */
        BaseDateTimeComponent.prototype.showValidation = function ($event, displayValue, isNativePicker, msg) {
            if (isNativePicker) {
                alert(msg);
                return $($event.target).val(displayValue);
            }
        };
        BaseDateTimeComponent.prototype.resetDisplayInput = function () {
            $(this.nativeElement).find('.display-input').val('');
        };
        BaseDateTimeComponent.prototype.validate = function () {
            if (this.invalidDateTimeFormat) {
                return {
                    invalidDateTimeFormat: {
                        valid: false
                    }
                };
            }
            if (!_.isUndefined(this.dateNotInRange) && this.dateNotInRange) {
                return {
                    dateNotInRange: {
                        valid: false
                    },
                };
            }
            if (!_.isUndefined(this.timeNotInRange) && this.timeNotInRange) {
                return {
                    timeNotInRange: {
                        valid: false
                    },
                };
            }
            return null;
        };
        /**
         * This method is used to validate date pattern and time pattern
         * If user selects one pattern in design time and if he tries to enter the date in another pattern then the device is throwing an error
         */
        BaseDateTimeComponent.prototype.formatValidation = function (newVal, inputVal, isNativePicker) {
            var pattern = this.datepattern || this.timepattern;
            var formattedDate = core.getFormattedDate(this.datePipe, newVal, pattern);
            inputVal = inputVal.trim();
            if (inputVal) {
                if (pattern === 'timestamp') {
                    if (!_.isNaN(inputVal) && _.parseInt(inputVal) !== formattedDate) {
                        this.invalidDateTimeFormat = true;
                        this.invokeOnChange(this.datavalue, undefined, false);
                        return false;
                    }
                }
                else {
                    if (isNativePicker) {
                        // format the date value only when inputVal is obtained from $event.target.value, as the format doesnt match.
                        inputVal = core.getFormattedDate(this.datePipe, inputVal, pattern);
                    }
                    if (inputVal !== formattedDate) {
                        this.invalidDateTimeFormat = true;
                        this.invokeOnChange(this.datavalue, undefined, false);
                        return false;
                    }
                }
            }
            return true;
        };
        /**
         * This method is used to validate min date, max date, exclude dates and exclude days
         * In mobile if invalid dates are entered, device is showing an alert.
         * In web if invalid dates are entered, device is showing validation message.
         */
        BaseDateTimeComponent.prototype.minDateMaxDateValidationOnInput = function (newVal, $event, displayValue, isNativePicker) {
            var _this = this;
            if (newVal) {
                newVal = moment(newVal).startOf('day').toDate();
                var minDate = moment(core.getDateObj(this.mindate)).startOf('day').toDate();
                var maxDate = moment(core.getDateObj(this.maxdate)).startOf('day').toDate();
                if (this.mindate && newVal < minDate) {
                    var msg = this.appLocale.LABEL_MINDATE_VALIDATION_MESSAGE + " " + this.mindate + ".";
                    this.dateNotInRange = true;
                    this.invokeOnChange(this.datavalue, undefined, false);
                    return this.showValidation($event, displayValue, isNativePicker, msg);
                }
                if (this.maxdate && newVal > maxDate) {
                    var msg = this.appLocale.LABEL_MAXDATE_VALIDATION_MESSAGE + " " + this.maxdate + ".";
                    this.dateNotInRange = true;
                    this.invokeOnChange(this.datavalue, undefined, false);
                    return this.showValidation($event, displayValue, isNativePicker, msg);
                }
                if (this.excludedates) {
                    var excludeDatesArray = void 0;
                    if (core.isString(this.excludedates)) {
                        excludeDatesArray = _.split(this.excludedates, ',');
                    }
                    else {
                        excludeDatesArray = this.excludedates;
                    }
                    excludeDatesArray = excludeDatesArray.map(function (d) { return core.getFormattedDate(_this.datePipe, d, _this.datepattern); });
                    if (excludeDatesArray.indexOf(core.getFormattedDate(this.datePipe, newVal, this.datepattern)) > -1) {
                        this.dateNotInRange = true;
                        this.invokeOnChange(this.datavalue, undefined, false);
                        return;
                    }
                }
                if (this.excludedays) {
                    var excludeDaysArray = _.split(this.excludedays, ',');
                    if (excludeDaysArray.indexOf(newVal.getDay().toString()) > -1) {
                        this.dateNotInRange = true;
                        this.invokeOnChange(this.datavalue, undefined, false);
                        return;
                    }
                }
            }
            if (!isNativePicker) {
                this.dateNotInRange = false;
                this.invokeOnChange(this.datavalue, undefined, false);
            }
        };
        /**
         * This method is used to highlight the current date
         */
        BaseDateTimeComponent.prototype.hightlightToday = function () {
            var toDay = new Date().getDate().toString();
            _.filter($("span:contains(" + toDay + ")").not('.is-other-month'), function (obj) {
                if ($(obj).text() === toDay) {
                    $(obj).addClass('current-date text-info');
                }
            });
        };
        /**
         * This method is used to find the new date is from another year or not
         * @param newDate - newly selected date value
         */
        BaseDateTimeComponent.prototype.isOtheryear = function (newDate) {
            return (newDate.getMonth() === 0 && this.activeDate.getMonth() === 11) || (newDate.getMonth() === 11 && this.activeDate.getMonth() === 0);
        };
        /**
         * This method is used to set focus for active day
         * @param newDate - newly selected date value
         * @param isMouseEvent - boolean value represents the event is mouse event/ keyboard event
         */
        BaseDateTimeComponent.prototype.setActiveDateFocus = function (newDate, isMouseEvent) {
            var _this = this;
            var activeMonth = this.activeDate.getMonth();
            // check for keyboard event
            if (!isMouseEvent) {
                if (newDate.getMonth() < activeMonth) {
                    this.isOtheryear(newDate) ? this.goToOtherMonthOryear('next', 'days') : this.goToOtherMonthOryear('previous', 'days');
                }
                else if (newDate.getMonth() > activeMonth) {
                    this.isOtheryear(newDate) ? this.goToOtherMonthOryear('previous', 'days') : this.goToOtherMonthOryear('next', 'days');
                }
            }
            setTimeout(function () {
                if (newDate.getMonth() === new Date().getMonth() && newDate.getFullYear() === new Date().getFullYear()) {
                    _this.hightlightToday();
                }
                var newDay = newDate.getDate().toString();
                _.filter($("span:contains(" + newDay + ")").not('.is-other-month'), function (obj) {
                    if ($(obj).text() === newDay) {
                        $(obj).focus();
                        _this.activeDate = newDate;
                    }
                });
            });
        };
        /**
         * This method is used to load other month days or other month or other year
         * @param btnClass - class(previous/next) of the button which we have to click
         * @param timePeriod - String value decides to load other month days or other month or other year
         */
        BaseDateTimeComponent.prototype.goToOtherMonthOryear = function (btnClass, timePeriod) {
            var $node = $(".bs-datepicker-head ." + btnClass);
            if ($node.attr('disabled')) {
                return;
            }
            $node.trigger('click');
            if (timePeriod === 'days') {
                this.loadDays();
            }
            else if (timePeriod === 'month') {
                this.loadMonths();
            }
            else if (timePeriod === 'year') {
                this.loadYears();
            }
        };
        /**
        * This method sets the mouse events to Datepicker popup. These events are required when we navigate date picker through mouse.
         */
        BaseDateTimeComponent.prototype.addDatepickerMouseEvents = function () {
            var _this = this;
            var datePikcerHead = $(".bs-datepicker-head");
            datePikcerHead.find(".previous").click(function (event) {
                // check for original mouse click
                if (event.originalEvent) {
                    _this.setFocusForDate(-1);
                }
            });
            datePikcerHead.find(".next").click(function (event) {
                // check for original mouse click
                if (event.originalEvent) {
                    _this.setFocusForDate(1);
                }
            });
            datePikcerHead.find(".current").click(function (event) {
                // check for original mouse click
                if (event.originalEvent) {
                    _this.setFocusForCurrentMonthOryear();
                }
            });
            $('.bs-datepicker-body').click(function (event) {
                event.stopPropagation();
                // check for original mouse click
                if (event.originalEvent) {
                    _this.setFocusForMonthOrDay();
                }
            });
        };
        /**
         * This method sets focus for months/days depending on the loaded datepicker table
         */
        BaseDateTimeComponent.prototype.setFocusForMonthOrDay = function () {
            var activeMonthOrYear = $(".bs-datepicker-head .current").first().text();
            var datePickerBody = $('.bs-datepicker-body');
            if (datePickerBody.find('table.months').length > 0) {
                if (_.parseInt(activeMonthOrYear) !== this.activeDate.getFullYear()) {
                    this.loadMonths();
                }
                var newDate = new Date(_.parseInt(activeMonthOrYear), this.activeDate.getMonth(), this.activeDate.getDate());
                this.setActiveMonthFocus(newDate, true);
            }
            else if (datePickerBody.find('table.days').length > 0) {
                var newMonth = months.indexOf(activeMonthOrYear);
                if (newMonth !== this.activeDate.getMonth()) {
                    this.loadDays();
                }
                var newDate = new Date(this.activeDate.getFullYear(), newMonth, 1);
                this.setActiveDateFocus(newDate, true);
            }
        };
        /**
         * This method sets focus for months/years depending on the loaded datepicker table
         */
        BaseDateTimeComponent.prototype.setFocusForCurrentMonthOryear = function () {
            var datePickerBody = $('.bs-datepicker-body');
            if (datePickerBody.find('table.months').length > 0) {
                this.loadMonths();
                this.setActiveMonthFocus(this.activeDate, true);
            }
            else if (datePickerBody.find('table.years').length > 0) {
                this.loadYears();
                this.setActiveYearFocus(this.activeDate, true);
            }
        };
        /**
         * This method sets focus for months/years/days depending on the loaded datepicker table
         */
        BaseDateTimeComponent.prototype.setFocusForDate = function (count) {
            var datePickerBody = $('.bs-datepicker-body');
            if (datePickerBody.find('table.months').length > 0) {
                this.loadMonths();
                var newDate = new Date(this.activeDate.getFullYear() + count, 0, this.activeDate.getDate());
                this.setActiveMonthFocus(newDate, true);
            }
            else if (datePickerBody.find('table.years').length > 0) {
                this.loadYears();
                var startYear = datePickerBody.find('table.years span').first().text();
                var newDate = new Date(_.parseInt(startYear), this.activeDate.getMonth(), this.activeDate.getDate());
                this.setActiveYearFocus(newDate, true);
            }
            else if (datePickerBody.find('table.days').length > 0) {
                this.loadDays();
                var newDate = new Date(this.activeDate.getFullYear(), this.activeDate.getMonth() + count, 1);
                this.setActiveDateFocus(newDate, true);
            }
        };
        /**
         * This method is used to add keyboard events while opening the date picker
         * @param scope - scope of the date/datetime widget
         * @param isDateTime - boolean value represents the loaded widget is date or datetime
         */
        BaseDateTimeComponent.prototype.addDatepickerKeyboardEvents = function (scope, isDateTime) {
            var _this = this;
            this.keyEventPluginInstance = scope.keyEventPlugin.constructor;
            this.elementScope = scope;
            var dateContainer = document.querySelector("." + scope.dateContainerCls);
            core.setAttr(dateContainer, 'tabindex', '0');
            dateContainer.onkeydown = function (event) {
                var action = _this.keyEventPluginInstance.getEventFullKey(event);
                // Check for Shift+Tab key or Tab key or escape
                if (action === 'shift.tab' || action === 'escape' || (action === 'tab' && !isDateTime)) {
                    _this.elementScope.hideDatepickerDropdown();
                    var displayInputElem_1 = _this.elementScope.nativeElement.querySelector('.display-input');
                    setTimeout(function () { return displayInputElem_1.focus(); });
                }
                if (action === 'tab' && isDateTime) {
                    _this.bsDatePickerDirective.hide();
                    _this.elementScope.toggleTimePicker(true);
                }
            };
            this.loadDays();
            this.setActiveDateFocus(this.activeDate);
        };
        /**
         * This method is used to add tabindex, keybord and mouse events for days
         */
        BaseDateTimeComponent.prototype.loadDays = function () {
            var _this = this;
            setTimeout(function () {
                $('.bs-datepicker-body').attr('tabindex', '0');
                $('[bsdatepickerdaydecorator]').not('.is-other-month').attr('tabindex', '0');
                _this.addKeyBoardEventsForDays();
                _this.addDatepickerMouseEvents();
            });
        };
        /**
         * This method sets keyboard events for days
         */
        BaseDateTimeComponent.prototype.addKeyBoardEventsForDays = function () {
            var _this = this;
            var datePickerBody = $('.bs-datepicker-body');
            if (datePickerBody.length > 0) {
                datePickerBody[0].addEventListener('mouseenter', function (event) {
                    event.stopPropagation();
                }, true);
            }
            datePickerBody.keydown(function (event) {
                var action = _this.keyEventPluginInstance.getEventFullKey(event);
                var newdate;
                if (action === 'arrowdown') {
                    event.preventDefault();
                    newdate = moment(_this.activeDate).add(+7, 'days').toDate();
                    _this.setActiveDateFocus(newdate);
                }
                else if (action === 'arrowup') {
                    event.preventDefault();
                    newdate = moment(_this.activeDate).add(-7, 'days').toDate();
                    _this.setActiveDateFocus(newdate);
                }
                else if (action === 'arrowleft') {
                    newdate = moment(_this.activeDate).add(-1, 'days').toDate();
                    _this.setActiveDateFocus(newdate);
                }
                else if (action === 'arrowright') {
                    newdate = moment(_this.activeDate).add(+1, 'days').toDate();
                    _this.setActiveDateFocus(newdate);
                }
                else if (action === 'control.arrowup') {
                    // clicking on table header month name to load list of months
                    $('.bs-datepicker-head .current').first().click();
                    _this.loadMonths();
                    _this.setActiveMonthFocus(_this.activeDate);
                }
                else if (action === 'enter') {
                    if ($(document.activeElement).hasClass('disabled')) {
                        return;
                    }
                    $(document.activeElement).click();
                    _this.elementScope.hideDatepickerDropdown();
                    var displayInputElem_2 = _this.elementScope.nativeElement.querySelector('.display-input');
                    setTimeout(function () { return displayInputElem_2.focus(); });
                }
            });
        };
        /**
         * This method is used to add tabindex, keybord and mouse events for months
         */
        BaseDateTimeComponent.prototype.loadMonths = function () {
            var _this = this;
            setTimeout(function () {
                var datePickerBody = $('.bs-datepicker-body');
                datePickerBody.attr('tabindex', '0');
                datePickerBody.find('table.months span').attr('tabindex', '0');
                _this.addKeyBoardEventsForMonths();
                _this.addDatepickerMouseEvents();
            });
        };
        /**
         * This method sets keyboard events for months
         */
        BaseDateTimeComponent.prototype.addKeyBoardEventsForMonths = function () {
            var _this = this;
            $('.bs-datepicker-body').keydown(function (event) {
                var action = _this.keyEventPluginInstance.getEventFullKey(event);
                var newdate;
                if (action === 'arrowdown') {
                    event.preventDefault();
                    newdate = moment(_this.activeDate).add(+3, 'month').toDate();
                    _this.setActiveMonthFocus(newdate);
                }
                else if (action === 'arrowup') {
                    event.preventDefault();
                    newdate = moment(_this.activeDate).add(-3, 'month').toDate();
                    _this.setActiveMonthFocus(newdate);
                }
                else if (action === 'arrowleft') {
                    newdate = moment(_this.activeDate).add(-1, 'month').toDate();
                    _this.setActiveMonthFocus(newdate);
                }
                else if (action === 'arrowright') {
                    newdate = moment(_this.activeDate).add(+1, 'month').toDate();
                    _this.setActiveMonthFocus(newdate);
                }
                else if (action === 'control.arrowup') {
                    // clicking on table header year to load list of years
                    $('.bs-datepicker-head .current').first().click();
                    _this.loadYears();
                    _this.setActiveYearFocus(_this.activeDate);
                }
                else if (action === 'control.arrowdown' || action === 'enter') {
                    if ($(document.activeElement).parent().hasClass('disabled')) {
                        return;
                    }
                    $(document.activeElement).click();
                    _this.loadDays();
                    var newDate = new Date(_this.activeDate.getFullYear(), _this.activeDate.getMonth(), 1);
                    _this.setActiveDateFocus(newDate);
                }
            });
        };
        /**
         * This method is used to add tabindex, keybord and mouse events for years
         */
        BaseDateTimeComponent.prototype.loadYears = function () {
            var _this = this;
            setTimeout(function () {
                var datePickerBody = $('.bs-datepicker-body');
                datePickerBody.attr('tabindex', '0');
                datePickerBody.find('table.years span').attr('tabindex', '0');
                _this.addKeyBoardEventsForYears();
                _this.addDatepickerMouseEvents();
            });
        };
        /**
         * This method is used to set focus for active month
         */
        BaseDateTimeComponent.prototype.setActiveMonthFocus = function (newDate, isMoouseEvent) {
            var _this = this;
            var newMonth = months[newDate.getMonth()];
            // check for keyboard event
            if (!isMoouseEvent) {
                if (newDate.getFullYear() < this.activeDate.getFullYear()) {
                    this.goToOtherMonthOryear('previous', 'month');
                }
                else if (newDate.getFullYear() > this.activeDate.getFullYear()) {
                    this.goToOtherMonthOryear('next', 'month');
                }
            }
            setTimeout(function () {
                $(".bs-datepicker-body table.months span:contains(" + newMonth + ")").focus();
                _this.activeDate = newDate;
            });
        };
        /**
         * This method sets keyboard events for years
         */
        BaseDateTimeComponent.prototype.addKeyBoardEventsForYears = function () {
            var _this = this;
            $('.bs-datepicker-body').keydown(function (event) {
                var action = _this.keyEventPluginInstance.getEventFullKey(event);
                var newdate;
                if (action === 'arrowdown') {
                    event.preventDefault();
                    newdate = moment(_this.activeDate).add(+4, 'year').toDate();
                    _this.setActiveYearFocus(newdate);
                }
                else if (action === 'arrowup') {
                    event.preventDefault();
                    newdate = moment(_this.activeDate).add(-4, 'year').toDate();
                    _this.setActiveYearFocus(newdate);
                }
                else if (action === 'arrowleft') {
                    newdate = moment(_this.activeDate).add(-1, 'year').toDate();
                    _this.setActiveYearFocus(newdate);
                }
                else if (action === 'arrowright') {
                    newdate = moment(_this.activeDate).add(+1, 'year').toDate();
                    _this.setActiveYearFocus(newdate);
                }
                else if (action === 'control.arrowdown' || action === 'enter') {
                    if ($(document.activeElement).parent().hasClass('disabled')) {
                        return;
                    }
                    $(document.activeElement).click();
                    _this.loadMonths();
                    _this.setActiveMonthFocus(_this.activeDate);
                }
            });
        };
        /**
         * This method is used to set focus for active year
         */
        BaseDateTimeComponent.prototype.setActiveYearFocus = function (newDate, isMouseEvent) {
            var _this = this;
            var newYear = newDate.getFullYear();
            var datePickerYears = $('.bs-datepicker-body table.years span');
            var startYear = datePickerYears.first().text();
            var endYear = datePickerYears.last().text();
            // check for keyboard event
            if (!isMouseEvent) {
                if (newDate.getFullYear() < _.parseInt(startYear)) {
                    this.goToOtherMonthOryear('previous', 'year');
                }
                else if (newDate.getFullYear() > _.parseInt(endYear)) {
                    this.goToOtherMonthOryear('next', 'year');
                }
            }
            setTimeout(function () {
                $(".bs-datepicker-body table.years span:contains(" + newYear + ")").focus();
                _this.activeDate = newDate;
            });
        };
        /**
         * This method sets focus for timepicker first input field(hours field) while opening time picker
         * @param scope - scope of the time picker widget
         */
        BaseDateTimeComponent.prototype.focusTimePickerPopover = function (scope) {
            this.keyEventPluginInstance = scope.keyEventPlugin.constructor;
            this.elementScope = scope;
            // setTimeout is used so that by then time input has the updated value. focus is setting back to the input field
            this.elementScope.ngZone.runOutsideAngular(function () {
                setTimeout(function () {
                    $('timepicker .form-group:first > input.form-control').focus();
                });
            });
        };
        /**
         * This function sets the keyboard events to Timepicker popup
         */
        BaseDateTimeComponent.prototype.bindTimePickerKeyboardEvents = function () {
            var _this = this;
            setTimeout(function () {
                var $timepickerPopup = $('body').find('> bs-dropdown-container timepicker');
                $timepickerPopup.attr('tabindex', 0);
                _this.addEventsOnTimePicker($timepickerPopup);
            });
        };
        /**
         * This function checks whether the given date is valid or not
         * @returns boolean value, true if date is valid else returns false
         */
        BaseDateTimeComponent.prototype.isValidDate = function (date) {
            return date && date instanceof Date && !isNaN(date.getTime());
        };
        /**
         * This function checks whether the given time is valid or not
         */
        BaseDateTimeComponent.prototype.timeFormatValidation = function () {
            var enteredDate = $(this.nativeElement).find('input').val();
            var newVal = core.getNativeDateObject(enteredDate);
            if (!this.formatValidation(newVal, enteredDate)) {
                return;
            }
            this.invalidDateTimeFormat = false;
            this.invokeOnChange(this.datavalue, undefined, false);
        };
        /**
         * This function sets the events to given element
         * @param $el - element on which the event is added
         */
        BaseDateTimeComponent.prototype.addEventsOnTimePicker = function ($el) {
            var _this = this;
            $el.on('keydown', function (evt) {
                var $target = $(evt.target);
                var $parent = $target.parent();
                var elementScope = _this.elementScope;
                var action = _this.keyEventPluginInstance.getEventFullKey(evt);
                var stopPropogation, preventDefault;
                if (action === 'escape') {
                    elementScope.hideTimepickerDropdown();
                }
                if ($target.hasClass('bs-timepicker-field')) {
                    if ($parent.is(':first-child')) {
                        if (action === 'shift.tab' || action === 'enter' || action === 'escape') {
                            elementScope.setIsTimeOpen(false);
                            _this.focus();
                            stopPropogation = true;
                            preventDefault = true;
                        }
                    }
                    else if ($parent.is(':last-child') || ($parent.next().next().find('button.disabled').length)) {
                        if (action === 'tab' || action === 'escape' || action === 'enter') {
                            elementScope.setIsTimeOpen(false);
                            _this.focus();
                            stopPropogation = true;
                            preventDefault = true;
                        }
                    }
                    else {
                        if (action === 'enter' || action === 'escape') {
                            elementScope.setIsTimeOpen(false);
                            _this.focus();
                            stopPropogation = true;
                            preventDefault = true;
                        }
                    }
                    if (stopPropogation) {
                        evt.stopPropagation();
                    }
                    if (preventDefault) {
                        evt.preventDefault();
                    }
                    if (elementScope.mintime && elementScope.maxtime && !_this.isValidDate(elementScope.bsTimeValue)) {
                        if (action === 'arrowdown') {
                            elementScope.bsTimeValue = elementScope.maxTime;
                        }
                        else if (action === 'arrowup') {
                            elementScope.bsTimeValue = elementScope.minTime;
                        }
                    }
                    if (action === 'tab') {
                        _this.invalidDateTimeFormat = false;
                        _this.invokeOnChange(_this.datavalue, undefined, false);
                        var pattern = _this.datepattern || _this.timepattern;
                        if (core.getFormattedDate(elementScope.datePipe, elementScope.bsTimeValue, pattern) === elementScope.displayValue) {
                            $(_this.nativeElement).find('.display-input').val(elementScope.displayValue);
                        }
                    }
                    if (action === 'arrowdown' || action === 'arrowup') {
                        _this.timeFormatValidation();
                    }
                }
                else if ($target.hasClass('btn-default')) {
                    if (action === 'tab' || action === 'escape') {
                        elementScope.setIsTimeOpen(false);
                        _this.focus();
                    }
                }
            });
            $el.find('a').on('click', function (evt) {
                var elementScope = _this.elementScope;
                var $target = $(evt.target);
                if (elementScope.mintime && elementScope.maxtime && !_this.isValidDate(elementScope.bsTimeValue)) {
                    if ($target.find('span').hasClass('bs-chevron-down')) {
                        elementScope.bsTimeValue = elementScope.maxTime;
                    }
                    else if ($target.find('span').hasClass('bs-chevron-up')) {
                        elementScope.bsTimeValue = elementScope.minTime;
                    }
                }
                _this.timeFormatValidation();
            });
        };
        BaseDateTimeComponent.prototype.updateFormat = function (pattern) {
            if (pattern === 'datepattern') {
                this._dateOptions.dateInputFormat = this.datepattern;
                this.showseconds = _.includes(this.datepattern, 's');
                this.ismeridian = _.includes(this.datepattern, 'h');
            }
            else if (pattern === 'timepattern') {
                this.showseconds = _.includes(this.timepattern, 's');
                this.ismeridian = _.includes(this.timepattern, 'h');
            }
        };
        BaseDateTimeComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'tabindex') {
                return;
            }
            if (this.useDatapicker && key === 'datepattern') {
                this.updateFormat(key);
            }
            else if (key === 'showweeks') {
                this._dateOptions.showWeekNumbers = nv;
            }
            else if (key === 'mindate') {
                this._dateOptions.minDate = (nv === CURRENT_DATE) ? this.mindate = new Date() : core.getDateObj(nv);
                this.minDateMaxDateValidationOnInput(this.datavalue);
            }
            else if (key === 'maxdate') {
                this._dateOptions.maxDate = (nv === CURRENT_DATE) ? this.maxdate = new Date() : core.getDateObj(nv);
                this.minDateMaxDateValidationOnInput(this.datavalue);
            }
            else if (key === 'excludedates' || key === 'excludedays') {
                this.minDateMaxDateValidationOnInput(this.datavalue);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        BaseDateTimeComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            if (this.bsDatePickerDirective) {
                this.dateOnShowSubscription = this.bsDatePickerDirective
                    .onShown
                    .subscribe(function (cal) {
                    cal.daysCalendar.subscribe(function (data) {
                        var excludedDates;
                        if (_this.excludedates) {
                            if (core.isString(_this.excludedates)) {
                                excludedDates = _.split(_this.excludedates, ',');
                            }
                            else {
                                excludedDates = _this.excludedates;
                            }
                            excludedDates = excludedDates.map(function (d) { return moment(d); });
                        }
                        data[0].weeks.forEach(function (week) {
                            week.days.forEach(function (day) {
                                if (!day.isDisabled && _this.excludedays) {
                                    day.isDisabled = _.includes(_this.excludedays, day.dayIndex);
                                }
                                if (!day.isDisabled && excludedDates) {
                                    var md_1 = moment(day.date);
                                    day.isDisabled = excludedDates.some(function (ed) { return md_1.isSame(ed, 'day'); });
                                }
                            });
                        });
                    });
                });
            }
        };
        BaseDateTimeComponent.prototype.ngOnDestroy = function () {
            if (this.dateOnShowSubscription) {
                this.dateOnShowSubscription.unsubscribe();
            }
            _super.prototype.ngOnDestroy.call(this);
        };
        BaseDateTimeComponent.propDecorators = {
            bsDropdown: [{ type: core$1.ViewChild, args: [ngxBootstrap.BsDropdownDirective,] }]
        };
        return BaseDateTimeComponent;
    }(BaseFormCustomComponent));

    var CURRENT_DATE$1 = 'CURRENT_DATE';
    var DEFAULT_CLS$j = 'app-date input-group';
    var WIDGET_CONFIG$n = {
        widgetType: 'wm-date',
        hostClass: DEFAULT_CLS$j
    };
    var DateComponent = /** @class */ (function (_super) {
        __extends(DateComponent, _super);
        // TODO use BsLocaleService to set the current user's locale to see the localized labels
        function DateComponent(inj, cdRef, appDefaults, evtMngrPlugins) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$n) || this;
            _this.cdRef = cdRef;
            _this.appDefaults = appDefaults;
            _this.isCurrentDate = false;
            _this.isEnterPressedOnDateInput = false;
            styler(_this.nativeElement, _this);
            // KeyEventsPlugin
            _this.keyEventPlugin = evtMngrPlugins[1];
            _this.dateContainerCls = "app-date-" + _this.widgetId;
            _this._dateOptions.containerClass = "app-date " + _this.dateContainerCls;
            _this._dateOptions.showWeekNumbers = false;
            _this.datepattern = _this.appDefaults.dateFormat || core.getDisplayDateTimeFormat(core.FormWidgetType.DATE);
            _this.updateFormat('datepattern');
            return _this;
        }
        Object.defineProperty(DateComponent.prototype, "timestamp", {
            get: function () {
                return this.bsDataValue ? this.bsDataValue.valueOf() : undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateComponent.prototype, "displayValue", {
            get: function () {
                return core.getFormattedDate(this.datePipe, this.bsDataValue, this._dateOptions.dateInputFormat) || '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateComponent.prototype, "datavalue", {
            get: function () {
                return core.getFormattedDate(this.datePipe, this.bsDataValue, this.outputformat) || '';
            },
            // Todo[Shubham]: needs to be redefined
            // sets the dataValue and computes the display model values
            set: function (newVal) {
                if (newVal === CURRENT_DATE$1) {
                    this.isCurrentDate = true;
                    this.setTimeInterval();
                    this.bsDataValue = new Date();
                }
                else {
                    this.bsDataValue = newVal ? core.getDateObj(newVal) : undefined;
                    this.clearTimeInterval();
                }
                // update the previous datavalue.
                this.invokeOnChange(this.datavalue, undefined, true);
                this.cdRef.detectChanges();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is an internal method triggered when the date input changes
         */
        DateComponent.prototype.onDisplayDateChange = function ($event, isNativePicker) {
            if (this.isEnterPressedOnDateInput) {
                this.isEnterPressedOnDateInput = false;
                return;
            }
            var newVal = core.getDateObj($event.target.value);
            // date pattern validation
            // if invalid pattern is entered, device is showing an error.
            if (!this.formatValidation(newVal, $event.target.value, isNativePicker)) {
                return;
            }
            // min date and max date validation in mobile view.
            // if invalid dates are entered, device is showing an alert.
            if (isNativePicker && this.minDateMaxDateValidationOnInput(newVal, $event, this.displayValue, isNativePicker)) {
                return;
            }
            this.setDataValue(newVal);
        };
        // sets the dataValue and computes the display model values
        DateComponent.prototype.setDataValue = function (newVal) {
            this.invalidDateTimeFormat = false;
            // min date and max date validation in web.
            // if invalid dates are entered, device is showing validation message.
            this.minDateMaxDateValidationOnInput(newVal);
            if (core.getFormattedDate(this.datePipe, newVal, this._dateOptions.dateInputFormat) === this.displayValue) {
                $(this.nativeElement).find('.app-dateinput').val(this.displayValue);
            }
            if (newVal) {
                this.bsDataValue = newVal;
            }
            else {
                this.bsDataValue = undefined;
            }
            this.invokeOnChange(this.datavalue, {}, true);
        };
        DateComponent.prototype.onDatePickerOpen = function () {
            this.isOpen = true;
            this.bsDataValue ? this.activeDate = this.bsDataValue : this.activeDate = new Date();
            if (!this.bsDataValue) {
                this.hightlightToday();
            }
            this.addDatepickerKeyboardEvents(this, false);
            core.adjustContainerPosition($('bs-datepicker-container'), this.nativeElement, this.bsDatePickerDirective._datepicker);
        };
        DateComponent.prototype.onInputBlur = function ($event) {
            if (!$($event.relatedTarget).hasClass('current-date')) {
                this.invokeOnTouched();
                this.invokeEventCallback('blur', { $event: $event });
            }
        };
        DateComponent.prototype.hideDatepickerDropdown = function () {
            this.invokeOnTouched();
            this.isOpen = false;
            this.isEnterPressedOnDateInput = false;
            if (this.deregisterEventListener) {
                this.deregisterEventListener();
            }
        };
        // change and blur events are added from the template
        DateComponent.prototype.handleEvent = function (node, eventName, callback, locals) {
            if (!_.includes(['blur', 'focus', 'change', 'click'], eventName)) {
                _super.prototype.handleEvent.call(this, node, eventName, callback, locals);
            }
        };
        /**
         * This is an internal method used to toggle the dropdown of the date widget
         */
        DateComponent.prototype.toggleDpDropdown = function ($event) {
            if ($event.type === 'click') {
                this.invokeEventCallback('click', { $event: $event });
            }
            if ($event.target && $($event.target).is('input') && !(this.isDropDownDisplayEnabledOnInput(this.showdropdownon))) {
                $event.stopPropagation();
                return;
            }
            this.bsDatePickerDirective.toggle();
            this.addBodyClickListener(this.bsDatePickerDirective.isOpen);
        };
        DateComponent.prototype.addBodyClickListener = function (skipListener) {
            var _this = this;
            if (!skipListener) {
                return;
            }
            var bodyElement = document.querySelector('body');
            setTimeout(function () {
                var bsDateContainerElement = bodyElement.querySelector("." + _this.dateContainerCls);
                _this.deregisterEventListener = core.addEventListenerOnElement(bodyElement, bsDateContainerElement, _this.nativeElement, 'click', _this.isDropDownDisplayEnabledOnInput(_this.showdropdownon), function () {
                    _this.isOpen = false;
                }, 0 /* ONCE */, true);
            }, 350);
        };
        /**
         * This is an internal method triggered when pressing key on the date input
         */
        DateComponent.prototype.onDisplayKeydown = function (event) {
            if (this.isDropDownDisplayEnabledOnInput(this.showdropdownon)) {
                event.stopPropagation();
                var newVal = core.getDateObj(event.target.value);
                var action = this.keyEventPlugin.constructor.getEventFullKey(event);
                if (action === 'enter' || action === 'arrowdown') {
                    event.preventDefault();
                    var formattedDate = core.getFormattedDate(this.datePipe, newVal, this._dateOptions.dateInputFormat);
                    var inputVal = event.target.value.trim();
                    if (inputVal && this.datepattern === 'timestamp') {
                        if (!_.isNaN(inputVal) && _.parseInt(inputVal) !== formattedDate) {
                            this.invalidDateTimeFormat = true;
                            this.invokeOnChange(this.datavalue, event, false);
                        }
                    }
                    else if (inputVal && inputVal !== formattedDate) {
                        this.invalidDateTimeFormat = true;
                        this.invokeOnChange(this.datavalue, event, false);
                    }
                    else {
                        this.invalidDateTimeFormat = false;
                        this.isEnterPressedOnDateInput = true;
                        this.bsDatePickerDirective.bsValue = newVal;
                    }
                    this.toggleDpDropdown(event);
                }
                else {
                    this.hideDatepickerDropdown();
                }
            }
            else {
                this.hideDatepickerDropdown();
            }
        };
        /**
         * This is an internal method used to maintain a time interval to update the time model when the data value is set to CURRENT_TIME
         */
        DateComponent.prototype.setTimeInterval = function () {
            var _this = this;
            if (this.timeinterval) {
                return;
            }
            this.timeinterval = setInterval(function () {
                _this.bsDataValue = new Date();
            }, 1000 * 60);
        };
        /**
         * This is an internal method used to clear the time interval created
         */
        DateComponent.prototype.clearTimeInterval = function () {
            if (this.timeinterval) {
                clearInterval(this.timeinterval);
                this.timeinterval = null;
            }
        };
        /**
         * This is an internal method triggered when the date selection changes
         */
        DateComponent.prototype.onDateChange = function (newVal) {
            var displayInputElem = this.nativeElement.querySelector('.display-input');
            if (this.isOpen) {
                setTimeout(function () { return displayInputElem.focus(); });
            }
            this.setDataValue(newVal);
        };
        DateComponent.initializeProps = registerProps$p();
        DateComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmDate]',
                        template: "<ng-container *ngIf=\"useDatapicker; then dataPickerTemplate else nativeDateTemplate\"></ng-container>\n<ng-template #dataPickerTemplate>\n    <input class=\"form-control app-textbox app-dateinput display-input\" aria-label=\"Select date\"\n           focus-target\n           type=\"text\"\n           [name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [value]=\"displayValue\"\n           (click)=\"toggleDpDropdown($event)\"\n           (focus)=\"invokeOnFocus($event)\"\n           (blur)=\"onInputBlur($event)\"\n           [disabled]=\"disabled || readonly\"\n           [autofocus]=\"autofocus\"\n           [required]=\"required\"\n           [attr.placeholder]=\"placeholder\"\n           [attr.accesskey]=\"shortcutkey\"\n           (change)=\"onDisplayDateChange($event)\"\n           (keydown)=\"onDisplayKeydown($event)\">\n    <div style=\"width: 0;display: inline-block;\" aria-label=\"datepicker dropdownmenu\" aria-controls=\"date\">\n        <input class=\"model-holder\"\n               container=\"body\"\n               [bsConfig]=\"_dateOptions\"\n               [isOpen]=\"isOpen\"\n               #datepicker=\"bsDatepicker\"\n               bsDatepicker\n               [isDisabled]=\"disabled || readonly\"\n               [bsValue]=\"bsDataValue\"\n               (onShown)=\"onDatePickerOpen()\"\n               (onHidden)=\"hideDatepickerDropdown()\"\n               (bsValueChange)=\"onDateChange($event)\">\n    </div>\n    <span class=\"input-group-btn\">\n            <button type=\"button\" class=\"btn btn-default btn-time\" [tabindex]=\"tabindex\" [disabled]=\"disabled || readonly\"\n                    aria-label=\"Select date\" aria-haspopup=\"true\" aria-expanded=\"false\"\n                    (click)=\"toggleDpDropdown($event)\">\n                <i aria-hidden=\"true\" class=\"app-icon wi wi-calendar\"></i>\n            </button>\n    </span>\n</ng-template>\n<ng-template #nativeDateTemplate>\n    <input type=\"date\" class=\"form-control app-textbox app-dateinput\"\n           role=\"input\"\n           step=\"any\"\n           [value]=\"displayValue\"\n           [required]=\"required\"\n           [disabled]=\"disabled || readonly\"\n           (change)=\"onDisplayDateChange($event, true)\"\n           (focus)=\"invokeOnFocus($event)\"\n           (blur)=\"invokeOnTouched($event)\">\n</ng-template>\n",
                        providers: [
                            provideAsNgValueAccessor(DateComponent),
                            provideAsNgValidators(DateComponent),
                            provideAsWidgetRef(DateComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        DateComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.ChangeDetectorRef },
                { type: core.AppDefaults },
                { type: undefined, decorators: [{ type: core$1.Inject, args: [platformBrowser.EVENT_MANAGER_PLUGINS,] }] }
            ];
        };
        DateComponent.propDecorators = {
            bsDatePickerDirective: [{ type: core$1.ViewChild, args: [ngxBootstrap.BsDatepickerDirective,] }]
        };
        return DateComponent;
    }(BaseDateTimeComponent));

    var dateTimeProps = new Map([
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['datepattern', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['excludedays', PROP_STRING],
        ['excludedates', PROP_STRING],
        ['hint', PROP_STRING],
        ['hourstep', __assign({ value: 1 }, PROP_NUMBER)],
        ['maxdate', PROP_STRING],
        ['mindate', PROP_STRING],
        ['minutestep', __assign({ value: 15 }, PROP_NUMBER)],
        ['name', PROP_STRING],
        ['outputformat', __assign({ value: 'timestamp' }, PROP_STRING)],
        ['placeholder', __assign({ value: 'Select date time' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['secondsstep', __assign({ value: 1 }, PROP_NUMBER)],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showdropdownon', __assign({ value: 'default' }, PROP_STRING)],
        ['showbuttonbar', PROP_BOOLEAN],
        ['showindevice', __assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
        ['showweeks', PROP_BOOLEAN],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['timestamp', PROP_STRING]
    ]);
    var registerProps$q = function () {
        if (core.isMobileApp()) {
            dateTimeProps.set('datepattern', __assign({ value: 'yyyy-MM-ddTHH:mm:ss' }, PROP_STRING));
        }
        register('wm-datetime', dateTimeProps);
    };

    var DEFAULT_CLS$k = 'app-datetime input-group';
    var WIDGET_CONFIG$o = { widgetType: 'wm-datetime', hostClass: DEFAULT_CLS$k };
    var CURRENT_DATE$2 = 'CURRENT_DATE';
    var DatetimeComponent = /** @class */ (function (_super) {
        __extends(DatetimeComponent, _super);
        function DatetimeComponent(inj, ngZone, cdRef, appDefaults, evtMngrPlugins) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$o) || this;
            _this.ngZone = ngZone;
            _this.cdRef = cdRef;
            _this.appDefaults = appDefaults;
            _this.isEnterPressedOnDateInput = false;
            /**
             * This property checks if the timePicker is Open
             */
            _this.isTimeOpen = false;
            /**
             * This property checks if the datePicker is Open
             */
            _this.isDateOpen = false;
            /**
             * This property is set to TRUE if the time component value is set to CURRENT_TIME; In this case the timer keeps changing the time value until the widget is available.
             */
            _this.isCurrentDate = false;
            _this._debouncedOnChange = _.debounce(_this.invokeOnChange, 10);
            _this.registerDestroyListener(function () { return _this.clearTimeInterval(); });
            styler(_this.nativeElement, _this);
            // KeyEventsPlugin
            _this.keyEventPlugin = evtMngrPlugins[1];
            _this.dateContainerCls = "app-date-" + _this.widgetId;
            _this._dateOptions.containerClass = "app-date " + _this.dateContainerCls;
            _this._dateOptions.showWeekNumbers = false;
            _this.datepattern = _this.appDefaults.dateTimeFormat || core.getDisplayDateTimeFormat(core.FormWidgetType.DATETIME);
            _this.updateFormat('datepattern');
            return _this;
        }
        Object.defineProperty(DatetimeComponent.prototype, "timestamp", {
            get: function () {
                return this.proxyModel ? this.proxyModel.valueOf() : undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatetimeComponent.prototype, "displayValue", {
            /**
             * The displayValue is the display value of the bsDateTimeValue after applying the datePattern on it.
             * @returns {any|string}
             */
            get: function () {
                return core.getFormattedDate(this.datePipe, this.proxyModel, this._dateOptions.dateInputFormat) || '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatetimeComponent.prototype, "datavalue", {
            get: function () {
                if (this.isCurrentDate && !this.proxyModel) {
                    return CURRENT_DATE$2;
                }
                return core.getFormattedDate(this.datePipe, this.proxyModel, this.outputformat);
            },
            /**Todo[Shubham]: needs to be redefined
             * This property sets the default value for the date selection
             */
            set: function (newVal) {
                if (newVal === CURRENT_DATE$2) {
                    this.isCurrentDate = true;
                    this.setTimeInterval();
                }
                else {
                    this.proxyModel = newVal ? core.getDateObj(newVal) : undefined;
                    this.clearTimeInterval();
                    this.isCurrentDate = false;
                }
                this.bsTimeValue = this.bsDateValue = this.proxyModel;
                this.cdRef.detectChanges();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is an internal method used to maintain a time interval to update the time model when the data value is set to CURRENT_TIME
         */
        DatetimeComponent.prototype.setTimeInterval = function () {
            var _this = this;
            if (this.timeinterval) {
                return;
            }
            this.timeinterval = setInterval(function () {
                var currentTime = new Date();
                _this.onModelUpdate(currentTime);
            }, 1000);
        };
        /**
         * This is an internal method used to clear the time interval created
         */
        DatetimeComponent.prototype.clearTimeInterval = function () {
            if (this.timeinterval) {
                clearInterval(this.timeinterval);
                this.timeinterval = null;
            }
        };
        /**
         * This is an internal method to toggle the time picker
         */
        DatetimeComponent.prototype.toggleTimePicker = function (newVal, $event) {
            this.isTimeOpen = newVal;
            if ($event && $event.type === 'click') {
                this.invokeEventCallback('click', { $event: $event });
            }
            this.addTimepickerClickListener(this.isTimeOpen);
        };
        DatetimeComponent.prototype.addTimepickerClickListener = function (skipListener) {
            var _this = this;
            if (!skipListener) {
                return;
            }
            var bodyElement = document.querySelector('body');
            setTimeout(function () {
                var dropdownElement = $(bodyElement).find('>bs-dropdown-container .dropdown-menu').get(0);
                _this.deregisterTimepickeEventListener = core.addEventListenerOnElement(bodyElement, dropdownElement, _this.nativeElement, 'click', _this.isDropDownDisplayEnabledOnInput(_this.showdropdownon), function () {
                    _this.toggleTimePicker(false);
                }, 0 /* ONCE */, true);
            }, 350);
        };
        /**
         * This function sets the value isOpen/isTimeOpen (i.e when datepicker popup is closed) based on widget type(i.e  DateTime, Time)
         * @param val - isOpen/isTimeOpen is set based on the timepicker popup is open/closed
         */
        DatetimeComponent.prototype.setIsTimeOpen = function (val) {
            this.isTimeOpen = val;
        };
        DatetimeComponent.prototype.hideTimepickerDropdown = function () {
            this.invokeOnTouched();
            this.toggleTimePicker(false);
            if (this.deregisterTimepickeEventListener) {
                this.deregisterTimepickeEventListener();
            }
        };
        /**
         * This is an internal method to add a click listener once the time dropdown is open
         */
        DatetimeComponent.prototype.onTimepickerOpen = function () {
            // adding class for time widget dropdown menu
            var tpElements = document.querySelectorAll('timepicker');
            _.forEach(tpElements, function (element) {
                core.addClass(element.parentElement, 'app-datetime', true);
            });
            this.bsDatePickerDirective.hide();
            this.focusTimePickerPopover(this);
            this.bindTimePickerKeyboardEvents();
            core.adjustContainerPosition($('bs-dropdown-container'), this.nativeElement, this.bsDropdown._dropdown, $('bs-dropdown-container .dropdown-menu'));
        };
        DatetimeComponent.prototype.onDatePickerOpen = function () {
            this.isDateOpen = !this.isDateOpen;
            this.toggleTimePicker(false);
            this.bsDateValue ? this.activeDate = this.bsDateValue : this.activeDate = new Date();
            if (!this.bsDateValue) {
                this.hightlightToday();
            }
            this.addDatepickerKeyboardEvents(this, true);
            core.adjustContainerPosition($('bs-datepicker-container'), this.nativeElement, this.bsDatePickerDirective._datepicker);
        };
        /**
         * This is an internal method to update the model
         */
        DatetimeComponent.prototype.onModelUpdate = function (newVal, type) {
            if (type === 'date') {
                this.invalidDateTimeFormat = false;
                if (core.getFormattedDate(this.datePipe, newVal, this._dateOptions.dateInputFormat) === this.displayValue) {
                    $(this.nativeElement).find('.display-input').val(this.displayValue);
                }
            }
            // min date and max date validation in web.
            // if invalid dates are entered, device is showing validation message.
            this.minDateMaxDateValidationOnInput(newVal);
            if (!newVal) {
                // Set timevalue as 00:00:00 if we remove any one from hours/minutes/seconds field in timepicker after selecting date
                if (this.bsDateValue && this.bsTimePicker && (this.bsTimePicker.hours === '' || this.bsTimePicker.minutes === '' || this.bsTimePicker.seconds === '')) {
                    this.bsDateValue = this.bsTimeValue = this.proxyModel = moment(this.bsDateValue).startOf('day').toDate();
                }
                else {
                    this.bsDateValue = this.bsTimeValue = this.proxyModel = undefined;
                }
                this._debouncedOnChange(this.datavalue, {}, true);
                return;
            }
            if (type === 'date') {
                if (this.isDateOpen) {
                    this.toggleTimePicker(true);
                }
            }
            this.proxyModel = newVal;
            if (this.proxyModel) {
                this.bsDateValue = this.bsTimeValue = this.proxyModel;
            }
            this._debouncedOnChange(this.datavalue, {}, true);
            this.cdRef.detectChanges();
        };
        /**
         * This is an internal method used to Prevent time picker close while changing time value
         */
        DatetimeComponent.prototype.preventTpClose = function ($event) {
            $event.stopImmediatePropagation();
        };
        /**
         * This is an internal method used to toggle the dropdown of the date widget
         */
        DatetimeComponent.prototype.toggleDpDropdown = function ($event) {
            if ($event.type === 'click') {
                this.invokeEventCallback('click', { $event: $event });
            }
            if ($event.target && $($event.target).is('input') && !(this.isDropDownDisplayEnabledOnInput(this.showdropdownon))) {
                $event.stopPropagation();
                return;
            }
            this.bsDatePickerDirective.toggle();
            this.addBodyClickListener(this.bsDatePickerDirective.isOpen);
        };
        DatetimeComponent.prototype.addBodyClickListener = function (skipListener) {
            var _this = this;
            if (!skipListener) {
                return;
            }
            var bodyElement = document.querySelector('body');
            setTimeout(function () {
                var bsDateContainerElement = bodyElement.querySelector("." + _this.dateContainerCls);
                _this.deregisterDatepickerEventListener = core.addEventListenerOnElement(bodyElement, bsDateContainerElement, _this.nativeElement, 'click', _this.isDropDownDisplayEnabledOnInput(_this.showdropdownon), function () {
                    _this.bsDatePickerDirective.hide();
                }, 0 /* ONCE */, true);
            }, 350);
        };
        DatetimeComponent.prototype.hideDatepickerDropdown = function () {
            this.isDateOpen = false;
            this.invokeOnTouched();
            this.bsDatePickerDirective.hide();
            this.isEnterPressedOnDateInput = false;
            if (this.deregisterDatepickerEventListener) {
                this.deregisterDatepickerEventListener();
            }
        };
        DatetimeComponent.prototype.onDateChange = function ($event, isNativePicker) {
            if (this.isEnterPressedOnDateInput) {
                this.isEnterPressedOnDateInput = false;
                return;
            }
            var newVal = $event.target.value.trim();
            newVal = newVal ? core.getNativeDateObject(newVal) : undefined;
            // datetime pattern validation
            // if invalid pattern is entered, device is showing an error.
            if (!this.formatValidation(newVal, $event.target.value, isNativePicker)) {
                return;
            }
            // min date and max date validation in mobile view.
            // if invalid dates are entered, device is showing an alert.
            if (isNativePicker && this.minDateMaxDateValidationOnInput(newVal, $event, this.displayValue, isNativePicker)) {
                return;
            }
            this.invalidDateTimeFormat = false;
            this.onModelUpdate(newVal);
        };
        /**
         * This is an internal method triggered when pressing key on the datetime input
         */
        DatetimeComponent.prototype.onDisplayKeydown = function (event) {
            if (this.isDropDownDisplayEnabledOnInput(this.showdropdownon)) {
                event.stopPropagation();
                var newVal = event.target.value.trim();
                newVal = newVal ? core.getNativeDateObject(newVal) : undefined;
                var action = this.keyEventPlugin.constructor.getEventFullKey(event);
                if (action === 'enter' || action === 'arrowdown') {
                    event.preventDefault();
                    var formattedDate = core.getFormattedDate(this.datePipe, newVal, this._dateOptions.dateInputFormat);
                    var inputVal = event.target.value.trim();
                    if (inputVal && this.datepattern === 'timestamp') {
                        if (!_.isNaN(inputVal) && _.parseInt(inputVal) !== formattedDate) {
                            this.invalidDateTimeFormat = true;
                            this.invokeOnChange(this.datavalue, event, false);
                        }
                    }
                    else if (inputVal && inputVal !== formattedDate) {
                        this.invalidDateTimeFormat = true;
                        this.invokeOnChange(this.datavalue, event, false);
                    }
                    else {
                        this.invalidDateTimeFormat = false;
                        this.isEnterPressedOnDateInput = true;
                        this.bsDatePickerDirective.bsValue = newVal;
                    }
                    this.toggleDpDropdown(event);
                }
                else {
                    this.hideDatepickerDropdown();
                    this.hideTimepickerDropdown();
                }
            }
            else {
                this.hideDatepickerDropdown();
                this.hideTimepickerDropdown();
            }
        };
        DatetimeComponent.prototype.isValid = function (event) {
            if (!event) {
                var enteredDate = $(this.nativeElement).find('input').val();
                var newVal = core.getNativeDateObject(enteredDate);
                if (!this.formatValidation(newVal, enteredDate)) {
                    return;
                }
            }
        };
        // change and blur events are added from the template
        DatetimeComponent.prototype.handleEvent = function (node, eventName, callback, locals) {
            if (!_.includes(['blur', 'focus', 'change', 'click'], eventName)) {
                _super.prototype.handleEvent.call(this, node, eventName, callback, locals);
            }
        };
        DatetimeComponent.prototype.onInputBlur = function ($event) {
            if (!$($event.relatedTarget).hasClass('current-date')) {
                this.invokeOnTouched();
                this.invokeEventCallback('blur', { $event: $event });
            }
        };
        DatetimeComponent.initializeProps = registerProps$q();
        DatetimeComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmDateTime]',
                        template: "<ng-container *ngIf=\"useDatapicker; then dataPickerTemplate else nativeDateTemplate\"></ng-container>\n\n<ng-template #dataPickerTemplate>\n    <div dropdown [isOpen]=\"isTimeOpen\" autoClose=\"false\" [container]=\"'body'\" (onShown)=\"onTimepickerOpen()\"\n         style=\"display: inherit;\">\n        <input class=\"form-control app-textbox display-input\" aria-label=\"Set the date and time\"\n               focus-target\n               [name]=\"name\"\n               [tabindex]=\"tabindex\"\n               type=\"text\"\n               [value]=\"displayValue\"\n               (click)=\"toggleDpDropdown($event)\"\n               (focus)=\"invokeOnFocus($event)\"\n               (blur)=\"onInputBlur($event)\"\n               (change)=\"onDateChange($event)\"\n               [autofocus]=\"autofocus\"\n               [disabled]=\"disabled || readonly || isCurrentDate\"\n               [required]=\"required\"\n               [attr.placeholder]=\"placeholder\"\n               [attr.accesskey]=\"shortcutkey\"\n               (keydown)=\"onDisplayKeydown($event)\">\n        <div style=\"width: 0;display: inline-block;\" aria-label=\"datepicker dropdownmenu\" aria-controls=\"date\">\n            <input class=\"model-holder\"\n                   focus-target\n                   [container]=\"'body'\"\n                   [bsConfig]=\"_dateOptions\"\n                   [isOpen]=\"isDateOpen\"\n                   (onShown)=\"onDatePickerOpen()\"\n                   (onHidden)=\"hideDatepickerDropdown()\"\n                   #datepicker=bsDatepicker\n                   bsDatepicker\n                   [isDisabled]=\"disabled || readonly || isCurrentDate\"\n                   [bsValue]=\"bsDateValue\"\n                   (bsValueChange)=\"onModelUpdate($event, 'date')\">\n        </div>\n        <span class=\"input-group-btn\">\n            <button type=\"button\" class=\"btn btn-default btn-date\"\n                    [tabindex]=\"tabindex\" [disabled]=\"disabled || readonly || isCurrentDate\" aria-label=\"Select date\" aria-haspopup=\"true\"\n                    aria-expanded=\"false\" (click)=\"toggleDpDropdown($event)\">\n                <i aria-hidden=\"true\" class=\"app-icon wi wi-calendar\"></i>\n            </button>\n            <button type=\"button\" class=\"btn btn-default btn-time\"\n                    [tabindex]=\"tabindex\" [disabled]=\"disabled || readonly || isCurrentDate\" aria-label=\"Select time\" aria-haspopup=\"true\"\n                    aria-expanded=\"false\" (click)=\"toggleTimePicker(!isTimeOpen, $event)\">\n                <i aria-hidden=\"true\" class=\"app-icon wi wi-access-time\"></i>\n            </button>\n        </span>\n        <div *dropdownMenu class=\"dropdown-menu\" aria-label=\"timepicker dropdown\" aria-controls=\"time\"\n             (click)=\"preventTpClose($event)\">\n            <timepicker class=\"model-holder\"\n                        [showMeridian]=\"ismeridian\"\n                        [readonlyInput]=\"disabled || readonly || isCurrentDate\"\n                        [(ngModel)]=\"bsTimeValue\"\n                        [min]=\"minTime\"\n                        [max]=\"maxTime\"\n                        [hourStep]=\"hourstep\"\n                        [minuteStep]=\"minutestep\"\n                        [secondsStep]=\"secondsstep\"\n                        [mousewheel]=\"true\"\n                        [arrowkeys]=\"true\"\n                        (isValid)=\"isValid($event)\"\n                        [showSeconds]=\"showseconds\" (ngModelChange)=\"onModelUpdate($event, 'time')\"></timepicker>\n        </div>\n    </div>\n</ng-template>\n<ng-template #nativeDateTemplate>\n    <input type=\"datetime-local\" class=\"form-control app-textbox\"\n           role=\"input\"\n           step=\"any\"\n           [value]=\"displayValue\"\n           [required]=\"required\"\n           [disabled]=\"disabled || readonly || isCurrentDate\"\n           (change)=\"onDateChange($event, true)\">\n</ng-template>\n",
                        providers: [
                            provideAsNgValueAccessor(DatetimeComponent),
                            provideAsNgValidators(DatetimeComponent),
                            provideAsWidgetRef(DatetimeComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        DatetimeComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.NgZone },
                { type: core$1.ChangeDetectorRef },
                { type: core.AppDefaults },
                { type: undefined, decorators: [{ type: core$1.Inject, args: [platformBrowser.EVENT_MANAGER_PLUGINS,] }] }
            ];
        };
        DatetimeComponent.propDecorators = {
            bsDatePickerDirective: [{ type: core$1.ViewChild, args: [ngxBootstrap.BsDatepickerDirective,] }],
            bsTimePicker: [{ type: core$1.ViewChild, args: [ngxBootstrap.TimepickerComponent,] }]
        };
        return DatetimeComponent;
    }(BaseDateTimeComponent));

    var propsMap = new Map([
        ['autocomplete', __assign({ value: false }, PROP_BOOLEAN)],
        ['captionalign', __assign({ value: 'left' }, PROP_STRING)],
        ['captionposition', __assign({ value: 'left' }, PROP_STRING)],
        ['captionsize', PROP_STRING],
        ['captionwidth', __assign({ value: 'xs-12 sm-3 md-3 lg-3' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['collapsible', PROP_BOOLEAN],
        ['dataset', PROP_ANY],
        ['datasource', PROP_STRING],
        ['expanded', __assign({ value: true }, PROP_BOOLEAN)],
        ['formdatasource', PROP_STRING],
        ['name', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showindevice', __assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
        ['subheading', PROP_STRING],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['title', PROP_STRING]
    ]);
    var registerFormProps = function () {
        if (core.isMobileApp()) {
            propsMap.set('captionwidth', __assign({ value: 'xs-4 sm-4 md-4 lg-4' }, PROP_STRING));
        }
        var formMap = new Map(propsMap);
        formMap.set('action', PROP_STRING);
        formMap.set('defaultmode', __assign({ value: 'Edit' }, PROP_STRING));
        formMap.set('metadata', PROP_STRING);
        formMap.set('method', PROP_STRING);
        formMap.set('postmessage', __assign({ value: 'Data posted successfully' }, PROP_STRING));
        formMap.set('target', PROP_STRING);
        formMap.set('enctype', PROP_STRING);
        formMap.set('errormessage', __assign({ value: 'An error occured. Please try again!' }, PROP_STRING));
        formMap.set('messagelayout', __assign({ value: 'Inline' }, PROP_STRING));
        formMap.set('formdata', PROP_STRING);
        formMap.set('novalidate', PROP_BOOLEAN);
        formMap.set('validationtype', __assign({ value: 'default' }, PROP_STRING));
        formMap.set('iconclass', PROP_STRING);
        register('wm-form', formMap);
    };
    var registerLiveFormProps = function () {
        if (core.isMobileApp()) {
            propsMap.set('captionwidth', __assign({ value: 'xs-4 sm-4 md-4 lg-4' }, PROP_STRING));
        }
        var liveFormMap = new Map(propsMap);
        liveFormMap.set('defaultmode', __assign({ value: 'View' }, PROP_STRING));
        liveFormMap.set('formlayout', __assign({ value: 'inline' }, PROP_STRING));
        liveFormMap.set('insertmessage', __assign({ value: 'Record added successfully' }, PROP_STRING));
        liveFormMap.set('updatemessage', __assign({ value: 'Record updated successfully' }, PROP_STRING));
        liveFormMap.set('deletemessage', __assign({ value: 'Record deleted successfully' }, PROP_STRING));
        liveFormMap.set('errormessage', __assign({ value: 'An error occured. Please try again!' }, PROP_STRING));
        liveFormMap.set('messagelayout', __assign({ value: 'Toaster' }, PROP_STRING));
        liveFormMap.set('formdata', PROP_STRING);
        liveFormMap.set('novalidate', PROP_BOOLEAN);
        liveFormMap.set('validationtype', __assign({ value: 'default' }, PROP_STRING));
        liveFormMap.set('iconclass', PROP_STRING);
        register('wm-liveform', liveFormMap);
    };
    var registerLiveFilterProps = function () {
        if (core.isMobileApp()) {
            propsMap.set('captionwidth', __assign({ value: 'xs-4 sm-4 md-4 lg-4' }, PROP_STRING));
        }
        var liveFilterMap = new Map(propsMap);
        liveFilterMap.set('autoupdate', PROP_BOOLEAN);
        liveFilterMap.set('enableemptyfilter', __assign({ value: ' ' }, PROP_STRING));
        liveFilterMap.set('pagesize', __assign({ value: 20 }, PROP_NUMBER));
        liveFilterMap.set('iconclass', __assign({ value: 'wi wi-filter-list' }, PROP_STRING));
        register('wm-livefilter', liveFilterMap);
    };

    var VIEW_MODE_OPTIONS = {
        DEFAULT: 'default',
        LABEL: 'label'
    };
    var EDIT_MODE = {
        QUICK_EDIT: 'quickedit',
        INLINE: 'inline',
        FORM: 'form',
        DIALOG: 'dialog'
    };
    // Method to set the header config of the data table
    var setHeaderConfig = function (headerConfig, config, field) {
        _.forEach(headerConfig, function (cols) {
            if (cols.isGroup) {
                if (cols.field === field) {
                    cols.columns.push(config);
                }
                else {
                    setHeaderConfig(cols.columns, config, field);
                }
            }
        });
    };
    var setHeaderConfigForTable = function (headerConfig, config, fieldName) {
        if (fieldName) {
            setHeaderConfig(headerConfig, config, fieldName);
        }
        else {
            headerConfig.push(config);
        }
    };
    var getRowOperationsColumn = function () {
        return {
            'field': 'rowOperations',
            'type': 'custom',
            'displayName': 'Actions',
            'width': '120px',
            'readonly': true,
            'sortable': false,
            'searchable': false,
            'resizable': false,
            'selectable': false,
            'show': true,
            'operations': [],
            'opConfig': {},
            'pcDisplay': true,
            'mobileDisplay': true,
            'include': true,
            'isRowOperation': true
        };
    };
    /**
     * Returns caption and widget bootstrap classes for the field
     */
    var getFieldLayoutConfig = function (captionWidth, captionPosition, os) {
        var captionCls = '', widgetCls = '';
        captionPosition = captionPosition || 'top';
        if (captionPosition === 'top') {
            if ((os && os === 'android') || !core.isMobileApp() || core.isAndroid()) { // Is android or not a mobile application
                captionCls = widgetCls = 'col-xs-12';
            }
            else if (core.isMobileApp()) { // Is a mobile application and not android
                captionCls = 'col-xs-4';
                widgetCls = 'col-xs-8';
            }
        }
        else if (captionWidth) {
            // handling itemsperrow containing string of classes
            _.forEach(_.split(captionWidth, ' '), function (cls) {
                var keys = _.split(cls, '-'), tier = keys[0];
                var _captionWidth, widgetWidth;
                _captionWidth = parseInt(keys[1], 10);
                widgetWidth = 12 - _captionWidth;
                widgetWidth = widgetWidth <= 0 ? 12 : widgetWidth;
                captionCls += ' ' + 'col-' + tier + '-' + _captionWidth;
                widgetCls += ' ' + 'col-' + tier + '-' + widgetWidth;
            });
        }
        return {
            'captionCls': captionCls,
            'widgetCls': widgetCls
        };
    };
    var getDefaultViewModeWidget = function (widget) {
        if (_.includes(['checkbox', 'toggle', 'rating'], widget)) {
            return VIEW_MODE_OPTIONS.DEFAULT;
        }
        return VIEW_MODE_OPTIONS.LABEL;
    };
    var parseBooleanValue = function (value) {
        if (value === 'true') {
            return true;
        }
        if (value === 'false') {
            return false;
        }
        if (/^\d+$/.test(value)) { // Check if the value is a string of number type like '123'
            return +value;
        }
        return value;
    };
    var parseValueByType = function (value, type, widget) {
        if (widget) {
            if (widget === core.FormWidgetType.NUMBER || widget === core.FormWidgetType.SLIDER || widget === core.FormWidgetType.CURRENCY) {
                return isNaN(Number(value)) ? null : Number(value);
            }
            if (widget === core.FormWidgetType.CHECKBOX || widget === core.FormWidgetType.TOGGLE) {
                return parseBooleanValue(value);
            }
            return value;
        }
        if (core.isNumberType(type)) {
            return isNaN(Number(value)) ? null : Number(value);
        }
        if (type === core.DataType.BOOLEAN) {
            return parseBooleanValue(value);
        }
        return value;
    };
    var fieldTypeWidgetTypeMap = {
        'integer': ['number', 'text', 'select', 'checkboxset', 'radioset', 'rating', 'slider', 'currency', 'autocomplete', 'chips'],
        'big_integer': ['number', 'text', 'select', 'checkboxset', 'radioset', 'rating', 'slider', 'currency', 'autocomplete', 'chips'],
        'short': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
        'float': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
        'big_decimal': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
        'number': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
        'double': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
        'long': ['number', 'text', 'select', 'checkboxset', 'radioset', 'rating', 'slider', 'currency', 'autocomplete', 'chips'],
        'byte': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
        'string': ['text', 'number', 'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp', 'switch', 'currency', 'autocomplete', 'chips', 'colorpicker'],
        'character': ['text', 'number', 'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset', 'switch', 'currency', 'autocomplete', 'chips'],
        'text': ['text', 'number', 'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp', 'switch', 'currency', 'autocomplete', 'chips', 'colorpicker'],
        'date': ['date', 'text', 'number', 'select', 'checkboxset', 'radioset', 'autocomplete', 'chips'],
        'time': ['time', 'text', 'number', 'select', 'checkboxset', 'radioset', 'autocomplete', 'chips'],
        'timestamp': ['timestamp', 'text', 'number', 'select', 'checkboxset', 'radioset', 'autocomplete', 'chips'],
        'datetime': ['datetime', 'text', 'select', 'checkboxset', 'radioset', 'autocomplete', 'chips'],
        'boolean': ['checkbox', 'radioset', 'toggle', 'select'],
        'list': ['select', 'radioset', 'checkboxset', 'switch', 'autocomplete', 'chips'],
        'clob': ['text', 'textarea', 'richtext'],
        'blob': ['upload'],
        'file': ['upload'],
        'custom': ['text', 'number', 'textarea', 'password', 'checkbox', 'toggle', 'slider', 'richtext', 'currency', 'switch',
            'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp', 'rating', 'datetime', 'autocomplete', 'chips', 'colorpicker']
    };
    // Get filter widget applicable to the given type
    var getDataTableFilterWidget = function (type) {
        var widget = fieldTypeWidgetTypeMap[type] && fieldTypeWidgetTypeMap[type][0];
        if (type === core.DataType.BOOLEAN) {
            widget = core.FormWidgetType.SELECT;
        }
        if (_.includes([core.FormWidgetType.TEXT, core.FormWidgetType.NUMBER, core.FormWidgetType.SELECT, core.FormWidgetType.AUTOCOMPLETE,
            core.FormWidgetType.DATE, core.FormWidgetType.TIME, core.FormWidgetType.DATETIME], widget)) {
            return widget;
        }
        return core.FormWidgetType.TEXT;
    };
    /**
     * @ngdoc function
     * @name wm.widgets.live.getEditModeWidget
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * This function returns the default widget for grid
     *
     * @param {object} colDef field definition
     */
    var getEditModeWidget = function (colDef) {
        if (colDef['related-entity-name'] && colDef['primary-key']) {
            return core.FormWidgetType.SELECT;
        }
        return (fieldTypeWidgetTypeMap[colDef.type] && fieldTypeWidgetTypeMap[colDef.type][0]) || core.FormWidgetType.TEXT;
    };
    /**
     * @ngdoc function
     * @name wm.widgets.live.LiveWidgetUtils#getDefaultValue
     * @methodOf wm.widgets.live.LiveWidgetUtils
     * @function
     *
     * @description
     * return the formatted default value
     *
     * @param {string} value value to be formatted
     * @param {string} type column type of the value
     */
    var getDefaultValue = function (value, type, widget) {
        if (widget) {
            if (widget === core.FormWidgetType.NUMBER || widget === core.FormWidgetType.SLIDER || widget === core.FormWidgetType.CURRENCY) {
                return isNaN(Number(value)) ? null : Number(value);
            }
            if (widget === core.FormWidgetType.CHECKBOX || widget === core.FormWidgetType.TOGGLE) {
                return parseBooleanValue(value);
            }
            return value;
        }
        if (core.isNumberType(type)) {
            return isNaN(Number(value)) ? null : Number(value);
        }
        if (type === core.DataType.BOOLEAN) {
            return parseBooleanValue(value);
        }
        return value;
    };

    var registerProps$r = function () {
        register('wm-message', new Map([
            ['caption', __assign({ value: 'Message' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['hideclose', __assign({ value: false }, PROP_BOOLEAN)],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['type', __assign({ value: 'success' }, PROP_STRING)],
        ]));
    };

    var DEFAULT_CLS$l = 'alert app-message';
    var WIDGET_CONFIG$p = { widgetType: 'wm-message', hostClass: DEFAULT_CLS$l };
    var MessageComponent = /** @class */ (function (_super) {
        __extends(MessageComponent, _super);
        function MessageComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$p) || this;
            _this.messageClass = '';
            _this.messageIconClass = '';
            _this.type = '';
            styler(_this.nativeElement, _this);
            return _this;
        }
        MessageComponent.prototype.showMessage = function (caption, type) {
            if (caption) {
                this.caption = caption;
            }
            if (type) {
                this.setWidgetProperty('type', type);
            }
            this.setWidgetProperty('show', true);
        };
        MessageComponent.prototype.hideMessage = function () {
            this.setWidgetProperty('show', false);
        };
        MessageComponent.prototype.dismiss = function ($event) {
            this.hideMessage();
            this.invokeEventCallback('close', { $event: $event });
        };
        MessageComponent.prototype.onMessageTypeChange = function (nv) {
            var msgCls, msgIconCls;
            switch (nv) {
                case 'success':
                    msgCls = 'alert-success';
                    msgIconCls = 'wi wi-done';
                    break;
                case 'error':
                    msgCls = 'alert-danger';
                    msgIconCls = 'wi wi-cancel';
                    break;
                case 'warn': /*To support old projects with type as "warn"*/
                case 'warning':
                    msgCls = 'alert-warning';
                    msgIconCls = 'wi wi-bell';
                    break;
                case 'info':
                    msgCls = 'alert-info';
                    msgIconCls = 'wi wi-info';
                    break;
                case 'loading':
                    msgCls = 'alert-info alert-loading';
                    msgIconCls = 'fa fa-spinner fa-spin';
                    break;
            }
            core.switchClass(this.nativeElement, msgCls, this.messageClass);
            this.messageClass = msgCls;
            this.messageIconClass = msgIconCls;
        };
        MessageComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'type') {
                this.onMessageTypeChange(nv);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        MessageComponent.initializeProps = registerProps$r();
        MessageComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmMessage]',
                        template: "<i [title]=\"type + 'Alert'\" class=\"icon {{type}} {{messageIconClass}}\"></i>\n<span [innerHtml]=\"caption | trustAs: 'html'\"></span>\n<button title=\"Close\" type=\"button\" class=\"btn-transparent close\" [hidden]=\"hideclose\" (click)=\"dismiss($event)\" aria-label=\"Close\">\n    <span aria-hidden=\"true\">&times;</span>\n</button>",
                        providers: [
                            provideAsWidgetRef(MessageComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        MessageComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return MessageComponent;
    }(StylableComponent));

    var registerProps$s = function () {
        register('wm-list', new Map([
            ['boundarylinks', __assign({ value: false }, PROP_BOOLEAN)],
            ['class', PROP_STRING],
            ['collapsible', PROP_BOOLEAN],
            ['dateformat', PROP_STRING],
            ['dataset', PROP_ANY],
            ['datasource', PROP_ANY],
            ['directionlinks', __assign({ value: true }, PROP_BOOLEAN)],
            ['disableitem', PROP_BOOLEAN],
            ['enablereorder', PROP_BOOLEAN],
            ['forceellipses', __assign({ value: true }, PROP_BOOLEAN)],
            ['groupby', PROP_STRING],
            ['iconclass', PROP_STRING],
            ['itemclass', __assign({ value: '' }, PROP_STRING)],
            ['itemsperrow', PROP_STRING],
            ['listclass', __assign({ value: 'list-group' }, PROP_STRING)],
            ['multiselect', PROP_BOOLEAN],
            ['loadingdatamsg', __assign({ value: 'Loading...' }, PROP_STRING)],
            ['loadingicon', __assign({ value: 'fa fa-circle-o-notch' }, PROP_STRING)],
            ['match', PROP_STRING],
            ['maxsize', __assign({ value: 5 }, PROP_NUMBER)],
            ['name', PROP_STRING],
            ['navigation', PROP_STRING],
            ['navigationalign', __assign({ value: 'left' }, PROP_STRING)],
            ['nodatamessage', __assign({ value: 'No data found' }, PROP_STRING)],
            ['ondemandmessage', __assign({ value: 'Load More' }, PROP_STRING)],
            ['orderby', PROP_STRING],
            ['paginationclass', PROP_STRING],
            ['pagesize', PROP_NUMBER],
            ['pulltorefresh', __assign({ value: core.isMobileApp() }, PROP_BOOLEAN)],
            ['selectfirstitem', PROP_BOOLEAN],
            ['selectionlimit', PROP_NUMBER],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['showcount', PROP_BOOLEAN],
            ['showrecordcount', PROP_BOOLEAN],
            ['subheading', PROP_STRING],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', PROP_STRING]
        ]));
    };

    var registerProps$t = function () {
        register('wm-pagination', new Map([
            ['boundarylinks', __assign({ value: false }, PROP_BOOLEAN)],
            ['class', PROP_STRING],
            ['dataset', PROP_ANY],
            ['directionlinks', __assign({ value: true }, PROP_BOOLEAN)],
            ['forceellipses', __assign({ value: true }, PROP_BOOLEAN)],
            ['maxResults', PROP_NUMBER],
            ['maxsize', __assign({ value: 5 }, PROP_NUMBER)],
            ['name', PROP_STRING],
            ['navigation', __assign({ value: 'Basic' }, PROP_STRING)],
            ['navigationalign', __assign({ value: 'left' }, PROP_STRING)],
            ['navigationsize', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['showrecordcount', PROP_BOOLEAN],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)]
        ]));
    };

    var DEFAULT_CLS$m = 'app-datanavigator clearfix';
    var WIDGET_CONFIG$q = { widgetType: 'wm-pagination', hostClass: DEFAULT_CLS$m };
    var sizeClasses = {
        'Pager': {
            'small': 'pager-sm',
            'large': 'pager-lg'
        },
        'Basic': {
            'small': 'pagination-sm',
            'large': 'pagination-lg'
        },
        'Classic': {
            'small': 'pagination-sm',
            'large': 'pagination-lg'
        }
    };
    var PaginationComponent = /** @class */ (function (_super) {
        __extends(PaginationComponent, _super);
        function PaginationComponent(inj, parent) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$q) || this;
            _this.parent = parent;
            _this.resultEmitter = new core$1.EventEmitter();
            _this.maxResultsEmitter = new core$1.EventEmitter();
            _this.dn = {
                currentPage: 1
            };
            _this.pageCount = 0;
            _this.isDisableNext = true;
            _this.isDisablePrevious = true;
            _this.isDisableFirst = true;
            _this.isDisableLast = true;
            _this._debouncedApplyDataset = core.debounce(function () { return _this.widget.dataset = _this.dataset; }, DEBOUNCE_TIMES.PAGINATION_DEBOUNCE_TIME);
            _this._debouncedPageChanged = core.debounce(function (event) {
                var currentPage = event && event.page;
                // Do not call goToPage if page has not changed
                if (currentPage !== _this.dn.currentPage) {
                    var inst = _this.parent || _this;
                    _this.dn.currentPage = currentPage;
                    inst.invokeEventCallback('paginationchange', { $event: undefined, $index: _this.dn.currentPage });
                    _this.goToPage();
                }
            }, DEBOUNCE_TIMES.PAGINATION_DEBOUNCE_TIME);
            styler(_this.nativeElement, _this);
            return _this;
        }
        PaginationComponent.prototype.setResult = function (result) {
            // TODO: Emit event only if result is changed
            this.result = result;
            this.resultEmitter.emit(this.result);
        };
        // Update navigationClass based on navigation and navigationSize props
        PaginationComponent.prototype.updateNavSize = function () {
            var sizeCls = sizeClasses[this.navcontrols];
            if (sizeCls && this.navigationsize) {
                this.navigationClass = sizeCls[this.navigationsize];
            }
            else {
                this.navigationClass = '';
            }
        };
        // Function to reset the paging values to default.
        PaginationComponent.prototype.resetPageNavigation = function () {
            this.pageCount = 0;
            this.dn.currentPage = 1;
            this.dataSize = 0;
        };
        /*Function to calculate the paging values.*/
        PaginationComponent.prototype.calculatePagingValues = function () {
            this.pageCount = (this.dataSize > this.maxResults) ? (Math.ceil(this.dataSize / this.maxResults)) : (this.dataSize < 0 ? 0 : 1);
            this.dn.currentPage = this.dn.currentPage || 1;
        };
        /*Function to set default values to the paging parameters*/
        PaginationComponent.prototype.setDefaultPagingValues = function (dataSize, maxResults, currentPage) {
            /*If neither 'dataSize' nor 'maxResults' is set, then set default values to the paging parameters.*/
            if (!dataSize && !maxResults) {
                this.pageCount = 1;
                this.dn.currentPage = 1;
                this.maxResults = dataSize;
                this.dataSize = dataSize;
            }
            else { /*Else, set the specified values and recalculate paging parameters.*/
                this.maxResults = maxResults || this.maxResults;
                this.dataSize = core.isDefined(dataSize) ? dataSize : this.dataSize;
                this.dn.currentPage = currentPage || this.dn.currentPage;
                this.calculatePagingValues();
            }
            this.maxResultsEmitter.emit(this.maxResults);
        };
        /*Function to check the dataSize and manipulate the navigator accordingly.*/
        PaginationComponent.prototype.checkDataSize = function (dataSize, numberOfElements, size) {
            /*If the dataSize is -1 or Integer.MAX_VALUE( which is 2147483647), then the total number of records is not known.
             * Hence,
             * 1. Hide the 'Total Record Count'.
             * 2. Disable the 'GoToLastPage' link as the page number of the last page is not known.*/
            if (dataSize === -1 || dataSize === core.AppConstants.INT_MAX_VALUE) {
                this.prevshowrecordcount = this.showrecordcount;
                this.isDisableLast = true;
                this.isDisableCount = true;
                this.showrecordcount = false;
                // If number of records in current page is less than the max records size, this is the last page. So disable next button.
                if (numberOfElements < size) {
                    this.isDisableNext = true;
                }
            }
            else {
                this.isDisableCount = false;
                this.showrecordcount = this.prevshowrecordcount || this.showrecordcount;
            }
        };
        /*Function to disable navigation based on the current and total pages.*/
        PaginationComponent.prototype.disableNavigation = function () {
            var isCurrentPageFirst = (this.dn.currentPage === 1), isCurrentPageLast = (this.dn.currentPage === this.pageCount);
            this.isDisableFirst = this.isDisablePrevious = isCurrentPageFirst;
            this.isDisableNext = this.isDisableLast = isCurrentPageLast;
            this.isDisableCurrent = isCurrentPageFirst && isCurrentPageLast;
        };
        /*Function to check if the variable bound to the data-navigator has paging.*/
        PaginationComponent.prototype.isDataSourceHasPaging = function () {
            return this.datasource && this.datasource.execute(core.DataSource.Operation.IS_PAGEABLE);
        };
        // Set the result for client side pagination
        PaginationComponent.prototype.setNonPageableData = function (newVal) {
            var dataSize, maxResults, currentPage, startIndex;
            dataSize = _.isArray(newVal) ? newVal.length : (_.isEmpty(newVal) ? 0 : 1);
            maxResults = (this.options && this.options.maxResults) || dataSize;
            // For static variable, keep the current page. For other variables without pagination reset the page to 1
            if (this.datasource && this.datasource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                currentPage = 1;
            }
            else {
                currentPage = this.dn.currentPage || 1;
            }
            this.setDefaultPagingValues(dataSize, maxResults, currentPage);
            this.disableNavigation();
            startIndex = (this.dn.currentPage - 1) * this.maxResults;
            this.setResult(_.isArray(newVal) ? newVal.slice(startIndex, startIndex + this.maxResults) : newVal);
        };
        /*Function to set the values needed for pagination*/
        PaginationComponent.prototype.setPagingValues = function (newVal) {
            var dataSize, maxResults, currentPage, dataSource;
            var variableOptions = {};
            // Store the data in __fullData. This is used for client side searching witvah out modifying the actual dataset.
            this.__fullData = newVal;
            /*Check for sanity*/
            if (this.binddataset) {
                dataSource = this.datasource || {};
                variableOptions = dataSource._options || {};
                /*Check for number of elements in the data set*/
                if (newVal) {
                    if (this.isDataSourceHasPaging()) {
                        this.pagination = this.datasource.execute(core.DataSource.Operation.GET_PAGING_OPTIONS) || {};
                        // If "filterFields" and "sortOptions" have been set, then set them so that the filters can be retained while fetching data upon page navigation.
                        this.filterFields = variableOptions.filterFields || {};
                        this.sortOptions = variableOptions.orderBy ||
                            (_.isArray(this.pagination.sort) ? getOrderByExpr(this.pagination.sort) : '');
                        dataSize = this.pagination.totalElements;
                        maxResults = this.pagination.size;
                        if (this.pagination.numberOfElements > 0) {
                            if (core.isDefined(this.pagination.number)) { // number is page number received from backend
                                this.dn.currentPage = this.pagination.number + 1;
                            }
                            currentPage = this.dn.currentPage || 1;
                        }
                        else {
                            currentPage = 1;
                        }
                        /* Sending pageCount undefined to calculate it again for query.*/
                        this.setDefaultPagingValues(dataSize, maxResults, currentPage);
                        this.disableNavigation();
                        this.checkDataSize(dataSize, this.pagination.numberOfElements, this.pagination.size);
                        this.setResult(newVal);
                    }
                    else if (!_.isString(newVal)) {
                        this.setNonPageableData(newVal);
                    }
                }
                else {
                    this.setResult(newVal);
                    this.resetPageNavigation();
                }
            }
            else {
                if (newVal && !_.isString(newVal)) {
                    this.setNonPageableData(newVal);
                }
            }
        };
        /*Function to check if the current page is the first page*/
        PaginationComponent.prototype.isFirstPage = function () {
            return (this.dn.currentPage === 1 || !this.dn.currentPage);
        };
        /*Function to check if the current page is the last page*/
        PaginationComponent.prototype.isLastPage = function () {
            return (this.dn.currentPage === this.pageCount);
        };
        /*Function to navigate to the last page*/
        PaginationComponent.prototype.goToLastPage = function (isRefresh, event, callback) {
            if (!this.isLastPage()) {
                this.dn.currentPage = this.pageCount;
                this.goToPage(event, callback);
            }
            else if (isRefresh) {
                this.goToPage(event, callback);
            }
        };
        /*Function to navigate to the first page*/
        PaginationComponent.prototype.goToFirstPage = function (isRefresh, event, callback) {
            if (!this.isFirstPage()) {
                this.dn.currentPage = 1;
                this.goToPage(event, callback);
            }
            else if (isRefresh) {
                this.goToPage(event, callback);
            }
        };
        /*Function to navigate to the current page*/
        PaginationComponent.prototype.goToPage = function (event, callback) {
            this.firstRow = (this.dn.currentPage - 1) * this.maxResults;
            this.getPageData(event, callback);
        };
        /*Function to be invoked after the data of the page has been fetched.*/
        PaginationComponent.prototype.onPageDataReady = function (event, data, callback) {
            this.disableNavigation();
            this.invokeSetRecord(event, data);
            core.triggerFn(callback);
        };
        /*Function to get data for the current page*/
        PaginationComponent.prototype.getPageData = function (event, callback) {
            var _this = this;
            var data, startIndex;
            if (this.isDataSourceHasPaging()) {
                this.datasource.execute(core.DataSource.Operation.LIST_RECORDS, {
                    'page': this.dn.currentPage,
                    'filterFields': this.filterFields,
                    'orderBy': this.sortOptions,
                    'matchMode': 'anywhereignorecase'
                }).then(function (response) {
                    _this.onPageDataReady(event, response && response.data, callback);
                    core.$appDigest();
                }, function (error) {
                });
            }
            else {
                startIndex = (this.dn.currentPage - 1) * this.maxResults;
                data = _.isArray(this.__fullData) ? this.__fullData.slice(startIndex, startIndex + this.maxResults) : this.__fullData;
                this.setResult(data);
                this.onPageDataReady(event, data, callback);
            }
        };
        PaginationComponent.prototype.invokeSetRecord = function (event, data) {
            // Trigger the event handler if exists.
            var pageInfo = {
                currentPage: this.dn.currentPage,
                size: this.maxResults,
                totalElements: this.dataSize,
                totalPages: this.pageCount
            };
            if (this.parent) {
                this.parent.invokeEventCallback('setrecord', { $event: event, $data: data, $index: this.dn.currentPage, pageInfo: pageInfo, data: data });
            }
            else {
                this.invokeEventCallback('setrecord', { $event: event, $data: data, $index: this.dn.currentPage, pageInfo: pageInfo, data: data });
            }
        };
        /*Function to validate the page input.
         In case of invalid input, navigate to the appropriate page; also return false.
         In case of valid input, return true.*/
        PaginationComponent.prototype.validateCurrentPage = function (event, callback) {
            /*If the value entered is greater than the last page number or invalid value, then highlighting the field showing error.*/
            if (event && (isNaN(this.dn.currentPage) || this.dn.currentPage <= 0 || (this.pageCount && (this.dn.currentPage > this.pageCount || _.isNull(this.dn.currentPage))))) {
                $(event.target).closest('a').addClass('ng-invalid');
                return false;
            }
            return true;
        };
        PaginationComponent.prototype.onModelChange = function (event) {
            if (!this.validateCurrentPage(event)) {
                return;
            }
            this.goToPage(event);
        };
        PaginationComponent.prototype.onKeyDown = function (event) {
            var targetEle = $(event.target).closest('a');
            if (event.code === 'KeyE') {
                targetEle.addClass('ng-invalid');
                return false;
            }
            targetEle.removeClass('ng-invalid');
            return true;
        };
        PaginationComponent.prototype.pageChanged = function (event) {
            this._debouncedPageChanged(event);
        };
        /*Function to navigate to the respective pages.*/
        PaginationComponent.prototype.navigatePage = function (index, event, isRefresh, callback) {
            this.invokeEventCallback('paginationchange', { $event: undefined, $index: this.dn.currentPage });
            // Convert the current page to a valid page number.
            this.dn.currentPage = +this.dn.currentPage;
            switch (index) {
                case 'first':
                    this.goToFirstPage(isRefresh, event, callback);
                    return;
                case 'prev':
                    /*Return if already on the first page.*/
                    if (this.isFirstPage() || !this.validateCurrentPage(event, callback)) {
                        return;
                    }
                    /*Decrement the current page by 1.*/
                    this.dn.currentPage -= 1;
                    break;
                case 'next':
                    /*Return if already on the last page.*/
                    if (this.isLastPage() || !this.validateCurrentPage(event, callback)) {
                        return;
                    }
                    /*Increment the current page by 1.*/
                    this.dn.currentPage += 1;
                    break;
                case 'last':
                    this.goToLastPage(isRefresh, event, callback);
                    return;
                default:
                    break;
            }
            /*Navigate to the current page.*/
            this.goToPage(event, callback);
        };
        PaginationComponent.prototype.setBindDataSet = function (binddataset, parent, dataSource, dataset, binddatasource) {
            var _this = this;
            var parts = binddataset.split('.');
            var bindPagingOptions;
            if (parts[0] === 'Variables' || parts[0] === 'Widgets') {
                bindPagingOptions = parts[0] + "." + parts[1] + ".pagination";
            }
            if (!binddatasource && dataset) {
                this.dataset = dataset;
                this._debouncedApplyDataset();
                return;
            }
            this.binddataset = binddataset;
            setTimeout(function () {
                _this.registerDestroyListener(core.$watch(binddataset, parent, {}, function (nv) {
                    _this.dataset = nv;
                    _this._debouncedApplyDataset();
                }));
                // Register a watch on paging options. Call dataset property change handler even if paging options changes to reflect pagination state
                if (!bindPagingOptions) {
                    return;
                }
                _this.registerDestroyListener(core.$watch(bindPagingOptions, parent, {}, function () { return _this._debouncedApplyDataset(); }));
            });
            this.datasource = dataSource;
        };
        // Set the datasource of pagination from the parent widget
        PaginationComponent.prototype.setDataSource = function (dataSource) {
            this.datasource = dataSource;
        };
        PaginationComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'dataset') {
                var data = void 0;
                if (this.parent && this.parent.onDataNavigatorDataSetChange) {
                    data = this.parent.onDataNavigatorDataSetChange(nv);
                }
                else {
                    data = nv;
                }
                this.setPagingValues(data);
            }
            else if (key === 'navigation') {
                if (nv === 'Advanced') { // Support for older projects where navigation type was advanced instead of clasic
                    this.navigation = 'Classic';
                }
                this.updateNavSize();
                this.navcontrols = nv;
            }
            else if (key === 'navigationsize') {
                this.updateNavSize();
            }
            else if (key === 'navigationalign') {
                core.switchClass(this.nativeElement, "text-" + nv, "text-" + ov);
            }
            else if (key === 'maxResults') {
                this.setPagingValues(this.dataset);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        PaginationComponent.prototype.ngAfterViewInit = function () {
            var paginationElem = this.nativeElement;
            paginationElem.onclick = function (event) {
                event.stopPropagation();
            };
        };
        PaginationComponent.initializeProps = registerProps$t();
        PaginationComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmPagination]',
                        template: "\n<ul class=\"pagination advanced {{navigationClass}}\" *ngIf=\"navcontrols === 'Classic'\">\n    <li [ngClass]=\"{'disabled':isDisableFirst}\">\n        <a [title]=\"appLocale.LABEL_FIRST\" name=\"first\" href=\"javascript:void(0);\" aria-label=\"First\"\n           (click)=\"navigatePage('first', $event)\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-first-page\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_FIRST}}</span>\n        </a>\n    </li>\n    <li [ngClass]=\"{'disabled':isDisablePrevious}\">\n        <a [title]=\"appLocale.LABEL_PREVIOUS\" name=\"prev\" href=\"javascript:void(0);\" aria-label=\"Previous\"\n           (click)=\"navigatePage('prev', $event)\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-chevron-left\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_PREVIOUS}}</span>\n        </a>\n    </li>\n    <li class=\"pagecount disabled\">\n        <a><input type=\"number\" [disabled]=\"isDisableCurrent\" [(ngModel)]=\"dn.currentPage\"\n                  (keydown)=\"onKeyDown($event)\" (change)=\"onModelChange($event)\" class=\"form-control\"/></a>\n    </li>\n    <li class=\"disabled\">\n        <a [hidden]=\"isDisableCount\"> / {{pageCount}}</a>\n    </li>\n    <li [ngClass]=\"{'disabled':isDisableNext}\">\n        <a [title]=\"appLocale.LABEL_NEXT\" name=\"next\" href=\"javascript:void(0);\" aria-label=\"Next\"\n           (click)=\"navigatePage('next', $event)\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-chevron-right\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_NEXT}}</span>\n        </a>\n    </li>\n    <li [ngClass]=\"{'disabled':isDisableLast}\">\n        <a [title]=\"appLocale.LABEL_LAST\" name=\"last\" href=\"javascript:void(0);\" aria-label=\"Last\"\n           (click)=\"navigatePage('last', $event)\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-last-page\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_LAST}}</span>\n        </a>\n    </li>\n    <li *ngIf=\"showrecordcount\" class=\"totalcount disabled\">\n        <a>{{appLocale.LABEL_TOTAL_RECORDS}}: {{dataSize}}</a>\n    </li>\n</ul>\n<ul class=\"pager {{navigationClass}}\" *ngIf=\"navcontrols === 'Pager'\">\n    <li class=\"previous\" [ngClass]=\"{'disabled':isDisablePrevious}\">\n        <a href=\"javascript:void(0);\" (click)=\"navigatePage('prev', $event)\" aria-label=\"Previous\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-chevron-left\"></i></span>\n            {{appLocale.LABEL_PREVIOUS}}\n            <span class=\"sr-only\">{{appLocale.LABEL_PREVIOUS}}</span>\n        </a>\n    </li>\n    <li class=\"next\" [ngClass]=\"{'disabled':isDisableNext}\">\n        <a href=\"javascript:void(0);\" (click)=\"navigatePage('next', $event)\" aria-label=\"Next\">\n            {{appLocale.LABEL_NEXT}}\n            <span aria-hidden=\"true\"><i class=\"wi wi-chevron-right\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_NEXT}}</span>\n        </a>\n    </li>\n</ul>\n\n<pagination class=\"pagination basic\" [ngClass]=\"navigationClass\" *ngIf=\"navcontrols === 'Basic'\"\n            [itemsPerPage]=\"maxResults\" [totalItems]=\"dataSize\"\n            [ngModel]=\"dn.currentPage\" (pageChanged)=\"pageChanged($event)\"\n            [boundaryLinks]=\"boundarylinks\" [maxSize]=\"maxsize\"\n            [directionLinks]=\"directionlinks\" previousText=\".\" nextText=\".\" firstText=\".\" lastText=\".\"></pagination>\n\n<ul *ngIf=\"navcontrols === 'Basic' && showrecordcount\" class=\"pagination\">\n    <li class=\"totalcount disabled basiccount\"><a>{{appLocale.LABEL_TOTAL_RECORDS}}: {{dataSize}}</a></li>\n</ul>",
                        providers: [
                            provideAsWidgetRef(PaginationComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        PaginationComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: undefined, decorators: [{ type: core$1.SkipSelf }, { type: core$1.Inject, args: [WidgetRef,] }] }
            ];
        };
        PaginationComponent.propDecorators = {
            resultEmitter: [{ type: core$1.Output }],
            maxResultsEmitter: [{ type: core$1.Output }]
        };
        return PaginationComponent;
    }(StylableComponent));

    var ListItemDirective = /** @class */ (function () {
        function ListItemDirective(inj, elRef, app) {
            this.inj = inj;
            this.app = app;
            this.destroy = new rxjs.Subject();
            this.destroy$ = this.destroy.asObservable();
            this.itemClass = '';
            this._currentItemWidgets = {};
            this.isActive = false;
            this.disableItem = false;
            this.nativeElement = elRef.nativeElement;
            this.listComponent = inj.view.component;
            this.context = inj.view.context;
            this.itemClassWatcher(this.listComponent);
            this.disableItemWatcher(this.listComponent);
            $(this.nativeElement).data('listItemContext', this);
        }
        ListItemDirective.prototype.onFocus = function () {
            // maintains which element is focused/selected most recently.
            this.listComponent.lastSelectedItem = this;
        };
        Object.defineProperty(ListItemDirective.prototype, "$index", {
            get: function () {
                return this.context.index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItemDirective.prototype, "$even", {
            get: function () {
                return this.context.even;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItemDirective.prototype, "$odd", {
            get: function () {
                return this.context.odd;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItemDirective.prototype, "$first", {
            get: function () {
                return this.context.first;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItemDirective.prototype, "$last", {
            get: function () {
                return this.context.last;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItemDirective.prototype, "currentItemWidgets", {
            get: function () {
                var componentElements = Array.from(this.nativeElement.querySelectorAll('[widget-id]'));
                return Object.assign(this._currentItemWidgets, componentElements.reduce(function (result, comp) {
                    result[comp.widget.name] = comp.widget;
                    return result;
                }, {}));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListItemDirective.prototype, "wmListItem", {
            set: function (val) {
                this.item = val;
            },
            enumerable: true,
            configurable: true
        });
        ListItemDirective.prototype.registerWatch = function (expression, callback) {
            // Removing ngFor context as the same properties are availble on listitem scope.
            // passing viewparent context for accessing varibales and widgets.
            this.destroy$.subscribe(core.$watch(expression, this.listComponent.viewParent, this, callback));
        };
        ListItemDirective.prototype.itemClassWatcher = function (listComponent) {
            var _this = this;
            if (listComponent.binditemclass) {
                this.registerWatch(listComponent.binditemclass, function (nv) { return _this.itemClass = nv || ''; });
            }
            else {
                this.itemClass = listComponent.itemclass;
            }
        };
        ListItemDirective.prototype.disableItemWatcher = function ($list) {
            var _this = this;
            if ($list.binddisableitem) {
                this.registerWatch($list.binddisableitem, function (nv) { return _this.disableItem = nv || false; });
            }
            else {
                this.disableItem = $list.disableitem || false;
            }
        };
        ListItemDirective.prototype.triggerWMEvent = function (eventName) {
            core.$invokeWatchers(true);
            // If we have multiselect for the livelist(List with form template), in run mode deleting a record is getting failed. Becuase the selecteditem will be array of objects. So consider the last object.
            var row = this.listComponent.multiselect ? _.last(this.listComponent.selecteditem) : this.listComponent.selecteditem;
            this.app.notify('wm-event', { eventName: eventName, widgetName: this.listComponent.name, row: row });
        };
        ListItemDirective.prototype.setUpCUDHandlers = function () {
            var _this = this;
            var $editItem = this.nativeElement.querySelector('.edit-list-item');
            var $deleteItem = this.nativeElement.querySelector('.delete-list-item');
            if ($editItem) {
                // Triggered on click of edit action
                $editItem.addEventListener('click', function (evt) {
                    _this.triggerWMEvent('update');
                });
            }
            if ($deleteItem) {
                // Triggered on click of delete action
                $deleteItem.addEventListener('click', function (evt) {
                    _this.triggerWMEvent('delete');
                });
            }
        };
        ListItemDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (this.listComponent.mouseEnterCB) {
                this.nativeElement.addEventListener('mouseenter', function ($event) {
                    _this.listComponent.invokeEventCallback('mouseenter', { widget: _this, $event: $event });
                });
            }
            if (this.listComponent.mouseLeaveCB) {
                this.nativeElement.addEventListener('mouseleave', function ($event) {
                    _this.listComponent.invokeEventCallback('mouseleave', { widget: _this, $event: $event });
                });
            }
        };
        ListItemDirective.prototype.ngAfterViewInit = function () {
            this.setUpCUDHandlers();
        };
        ListItemDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmListItem]',
                        exportAs: 'listItemRef'
                    },] }
        ];
        /** @nocollapse */
        ListItemDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.ElementRef },
                { type: core.App }
            ];
        };
        ListItemDirective.propDecorators = {
            isActive: [{ type: core$1.HostBinding, args: ['class.active',] }],
            disableItem: [{ type: core$1.HostBinding, args: ['class.disable-item',] }],
            onFocus: [{ type: core$1.HostListener, args: ['focus',] }],
            wmListItem: [{ type: core$1.Input }]
        };
        return ListItemDirective;
    }());

    var ListAnimator = /** @class */ (function (_super) {
        __extends(ListAnimator, _super);
        function ListAnimator(list) {
            var _this = _super.call(this) || this;
            _this.list = list;
            _this.$el = $(_this.list.getNativeElement()).find('ul.app-livelist-container:first');
            _this.leftChildrenCount = _this.$el.find('>.app-list-item-left-action-panel > button:visible').length;
            _this.rightChildrenCount = _this.$el.find('>.app-list-item-right-action-panel > button:visible').length;
            // when there are no children in both the templates then do not apply swipeAnimation;
            if (!_this.leftChildrenCount && !_this.rightChildrenCount) {
                return _this;
            }
            // initialise swipe animation on the list component.
            _this.init(_this.$el);
            // retrieves all the button components which are placed outside the listTemplate.
            _this.$btnSubscription = _this.list.btnComponents.changes.subscribe(function (items) { return _this.actionItems = items; });
            return _this;
        }
        // This method sets the css for left or right action panels based on the template. Appends the actionTemplate before li.
        ListAnimator.prototype.createActionPanel = function (li, actionPanelTemplate) {
            actionPanelTemplate.css({
                width: li.outerWidth() + 'px',
                height: li.outerHeight() + 'px',
                marginBottom: -1 * li.outerHeight() + 'px',
                float: 'left',
                padding: 0
            });
            return actionPanelTemplate.insertBefore(li);
        };
        // Returns the total width occupied by all the children inside the element
        ListAnimator.prototype.computeTotalChildrenWidth = function ($ele) {
            return _.reduce($ele.children(), function (totalWidth, el) {
                return totalWidth + $(el).outerWidth();
            }, 0);
        };
        // Returns amount of transition to be applied on element when swiped left or right
        ListAnimator.prototype.computeTransitionProportions = function ($ele) {
            var totalWidth = this.computeTotalChildrenWidth($ele);
            var reverse = this.position === 'right';
            var d = 0;
            return _.map($ele.children(), function (e) {
                var f = (totalWidth - d) / totalWidth;
                d += $(e).outerWidth();
                return reverse ? f : (d / totalWidth);
            });
        };
        // Resets the transform applied on the element.
        ListAnimator.prototype.resetElement = function (el) {
            if (el) {
                el.css({
                    transform: 'none',
                    transition: 'none'
                });
            }
        };
        ListAnimator.prototype.resetState = function () {
            this.resetElement(this.li);
            this.resetElement(this.actionPanel);
            if (this.actionPanel) {
                this.actionPanel = null;
            }
        };
        // Returns the target button (child element) inside the left and right actionPanels.
        ListAnimator.prototype.getChildActionElement = function (actionTemplate) {
            if (actionTemplate.children().length) {
                if (this.position === 'left') {
                    return actionTemplate.children().first();
                }
                return actionTemplate.children().last();
            }
        };
        // create the actionPanels and set the background-color for remaining panel as that of first child element
        // calculates the children's width and its transition proportionates.
        ListAnimator.prototype.initActionPanel = function (actionTemplate) {
            this.actionPanel = this.createActionPanel(this.li, actionTemplate);
            this.actionPanel.css({
                backgroundColor: this.getChildActionElement(this.actionPanel).css('background-color')
            });
            this.limit = this.computeTotalChildrenWidth(this.actionPanel);
            this.transitionProportions = this.computeTransitionProportions(this.actionPanel);
        };
        ListAnimator.prototype.bounds = function (e, $d) {
            var target = $(e.target).closest('li');
            // default bounds when action template markup is not available.
            var bounds = {
                strictUpper: true,
                strictLower: true,
                lower: 0,
                center: 0,
                upper: 0
            };
            // apply swipe animation only on list items having "app-list-item" class.
            if (!target.hasClass('app-list-item')) {
                return bounds;
            }
            if (!this.li || this.li[0] !== target[0]) {
                var selector = $d > 0 ? '.app-list-item-left-action-panel' : '.app-list-item-right-action-panel';
                var actionTemplate = this.$el.find('>' + selector);
                // when groupby is set select the action panel from the list group items.
                if (!actionTemplate.length && this.list.groupby) {
                    selector = 'li > ul.list-group >' + selector;
                    actionTemplate = this.$el.find('>' + selector);
                }
                // check for children visiblity. If children are visible then initiate the action panel.
                if (!actionTemplate.length || !actionTemplate.find('button:visible').length) {
                    return bounds;
                }
                this.resetState();
                this.li = target;
                this.position = actionTemplate.attr('position');
                this.initActionPanel(actionTemplate);
                if ($d > 0) {
                    // bounds while swiping from right to left to open left action panel. It can be moved upto limit value (Upper bound).
                    bounds = {
                        strictUpper: false,
                        lower: 0,
                        center: 0,
                        upper: this.limit
                    };
                }
                else {
                    // bounds while swiping from left to right to open right action panel. It can be moved in reverse direction with -limit value (lower bound).
                    bounds = {
                        strictLower: false,
                        lower: -this.limit,
                        center: 0,
                        upper: 0
                    };
                }
            }
            else if (this.position === 'left') {
                // when left action panel is visible (i.e. center at limit value) then this can be moved by distance (limit) in reverse direction to close the view.
                bounds = {
                    strictUpper: false,
                    lower: -this.limit,
                    center: this.limit
                };
            }
            else if (this.position === 'right') {
                // when right action panel is visible (i.e. center at -limit value) then this can be moved by distance (limit) to close the view.
                bounds = {
                    center: -this.limit,
                    upper: this.limit,
                    strictLower: false
                };
            }
            return bounds;
        };
        ListAnimator.prototype.context = function () {
            var _this = this;
            return {
                computeActionTransition: function (index, $d) {
                    var sign = $d > 0 ? 1 : -1;
                    if (sign * $d > _this.limit) {
                        // once the distance swiped is beyond the limit, then calculate the proportionate distance moved after the limit value.
                        return ($d - sign * _this.limit) + (_this.transitionProportions[index] * sign * _this.limit);
                    }
                    return _this.transitionProportions[index] * $d;
                }
            };
        };
        ListAnimator.prototype.animation = function () {
            var _this = this;
            return [{
                    target: function () { return _this.li; },
                    css: {
                        transform: 'translate3d(${{$D + $d}}px, 0, 0)'
                    }
                }, {
                    target: function () { return (_this.actionPanel && _this.actionPanel.children()); },
                    css: {
                        transform: 'translate3d(${{computeActionTransition($i, $D + $d)}}px, 0, 0)'
                    }
                }];
        };
        // Triggers full swipe event on the target element.
        ListAnimator.prototype.invokeFullSwipeEvt = function ($event) {
            var target, actions, index;
            // Check if button are visible or not, invoke the tap event of the last button which is visible.
            if (this.position === 'left') {
                actions = this.actionItems.filter(function (btn) {
                    return btn.getAttr('swipe-position') === 'left' && btn.$element.is(':visible');
                });
                index = 0;
            }
            else {
                actions = this.actionItems.filter(function (btn) {
                    return btn.getAttr('swipe-position') === 'right' && btn.$element.is(':visible');
                });
                index = actions.length - 1;
            }
            target = actions[index];
            if (target && target.hasEventCallback('tap')) {
                target.invokeEventCallback('tap', { $event: $event });
            }
            this.resetState();
            this.li = null;
        };
        // Called when swipeEnd is triggered. d contains the total distance covered by the element until touchEnd.
        ListAnimator.prototype.onAnimation = function ($event, d) {
            // set the selecteditem on the list component on swipe.
            this.list.triggerListItemSelection(this.li, $event);
            if (this.actionPanel && this.actionPanel.attr('enablefullswipe') === 'true') {
                var sign = d > 0 ? 1 : -1;
                var $el = this.getChildActionElement(this.actionPanel);
                if ($el) {
                    var index = this.position === 'right' ? this.rightChildrenCount - 1 : 0;
                    // proportionate amount of distance covered by the target element.
                    var distPercentage = this.transitionProportions[index] * sign * d * 100 / (this.li.outerWidth() - this.limit + $el.width());
                    // If distance travelled by the target button element is more than 50% of the list item width then invoke the fullswipe.
                    if (distPercentage > 50) {
                        // invoke fullswipe event
                        this.invokeFullSwipeEvt($event);
                    }
                }
            }
        };
        ListAnimator.prototype.onLower = function () {
            if (this.position === 'left') {
                this.resetState();
                this.li = null;
            }
        };
        ListAnimator.prototype.onUpper = function () {
            if (this.position === 'right') {
                this.resetState();
                this.li = null;
            }
        };
        ListAnimator.prototype.threshold = function () {
            return 10;
        };
        return ListAnimator;
    }(_swipey.SwipeAnimation));

    var DEFAULT_CLS$n = 'app-livelist app-panel';
    var WIDGET_CONFIG$r = { widgetType: 'wm-list', hostClass: DEFAULT_CLS$n };
    var ListComponent = /** @class */ (function (_super) {
        __extends(ListComponent, _super);
        function ListComponent(inj, cdRef, datePipe, app, appDefaults, ngZone, binditemclass, binddisableitem, binddataset, binddatasource, mouseEnterCB, mouseLeaveCB) {
            var _this = this;
            var resolveFn = core.noop;
            var propsInitPromise = new Promise(function (res) { return resolveFn = res; });
            _this = _super.call(this, inj, WIDGET_CONFIG$r, propsInitPromise) || this;
            _this.propsInitPromise = propsInitPromise;
            _this.promiseResolverFn = resolveFn;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.SHELL);
            _this.cdRef = cdRef;
            _this.ngZone = ngZone;
            _this.datePipe = datePipe;
            _this.binditemclass = binditemclass;
            _this.binddisableitem = binddisableitem;
            _this.binddataset = binddataset;
            _this.mouseEnterCB = mouseEnterCB;
            _this.mouseLeaveCB = mouseLeaveCB;
            _this.binddatasource = binddatasource;
            _this.app = app;
            _this.appDefaults = appDefaults;
            _this.variableInflight = false;
            _this.noDataFound = !binddataset;
            // Show loading status based on the variable life cycle
            _this.app.subscribe('toggle-variable-state', _this.handleLoading.bind(_this));
            return _this;
        }
        Object.defineProperty(ListComponent.prototype, "selecteditem", {
            get: function () {
                if (this.multiselect) {
                    return core.getClonedObject(this._items);
                }
                if (_.isEmpty(this._items)) {
                    return {};
                }
                return core.getClonedObject(this._items[0]);
            },
            set: function (items) {
                var _this = this;
                this._items.length = 0;
                this.deselectListItems();
                if (_.isArray(items)) {
                    items.forEach(function (item) { return _this.selectItem(item); });
                }
                else {
                    this.selectItem(items);
                }
                core.$appDigest();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns list of widgets present on list item by considering name and index of the widget.
         * If we did'nt pass index, it returns array of all the widgets which are matching to widget name
         * @param widgteName: Name of the widget
         * @param index: Index of the widget
         */
        ListComponent.prototype.getWidgets = function (widgteName, index) {
            var $target;
            var retVal = [];
            if (!widgteName) {
                return;
            }
            if (!core.isDefined(index)) {
                _.forEach(this.listItems.toArray(), function (el) {
                    $target = _.get(el.currentItemWidgets, widgteName);
                    if ($target) {
                        retVal.push($target);
                    }
                });
                return retVal;
            }
            index = +index || 0;
            $target = _.get(this.listItems.toArray(), index);
            if ($target) {
                return [_.get($target.currentItemWidgets, widgteName)];
            }
        };
        // returns listitem reference by index value. This refers to the same method getListItemByIndex.
        ListComponent.prototype.getItem = function (index) {
            return this.getListItemByIndex(index);
        };
        // return index of listItem(listItemDirective). This refers to the same method getListItemIndex.
        ListComponent.prototype.getIndex = function (item) {
            return this.getListItemIndex(item);
        };
        ListComponent.prototype.handleLoading = function (data) {
            var _this = this;
            var dataSource = this.datasource;
            if (dataSource && dataSource.execute(core.DataSource.Operation.IS_API_AWARE) && core.isDataSourceEqual(data.variable, dataSource)) {
                this.ngZone.run(function () {
                    _this.variableInflight = data.active;
                });
            }
        };
        ListComponent.prototype.resetNavigation = function () {
            this.showNavigation = false;
            this.navControls = undefined;
            this.infScroll = false;
            this.onDemandLoad = false;
        };
        ListComponent.prototype.enableBasicNavigation = function () {
            this.navControls = NAVIGATION_TYPE.BASIC;
            this.showNavigation = true;
        };
        ListComponent.prototype.enableInlineNavigation = function () {
            this.navControls = NAVIGATION_TYPE.INLINE;
        };
        ListComponent.prototype.enableClassicNavigation = function () {
            this.navControls = NAVIGATION_TYPE.CLASSIC;
            this.showNavigation = true;
        };
        ListComponent.prototype.enablePagerNavigation = function () {
            this.navControls = NAVIGATION_TYPE.PAGER;
            this.showNavigation = true;
        };
        ListComponent.prototype.setNavigationTypeNone = function () {
            this.navControls = NAVIGATION_TYPE.NONE;
            this.showNavigation = false;
        };
        ListComponent.prototype.enableInfiniteScroll = function () {
            this.infScroll = true;
        };
        ListComponent.prototype.enableOnDemandLoad = function () {
            this.onDemandLoad = true;
            this.showNavigation = true;
        };
        /* this function sets the itemclass depending on itemsperrow.
         * if itemsperrow is 2 for large device, then itemclass is 'col-xs-1 col-sm-1 col-lg-2'
         * if itemsperrow is 'lg-3' then itemclass is 'col-lg-3'
         */
        ListComponent.prototype.setListClass = function () {
            var temp = '';
            if (this.itemsperrow) {
                if (isNaN(parseInt(this.itemsperrow, 10))) {
                    // handling itemsperrow containing string of classes
                    _.split(this.itemsperrow, ' ').forEach(function (cls) {
                        var keys = _.split(cls, '-');
                        cls = keys[0] + "-" + (12 / parseInt(keys[1], 10));
                        temp += " col-" + cls;
                    });
                    this.itemsPerRowClass = temp.trim();
                }
                else {
                    // handling itemsperrow having integer value.
                    this.itemsPerRowClass = "col-xs-" + (12 / parseInt(this.itemsperrow, 10));
                }
            }
            else { // If itemsperrow is not specified make it full width
                this.itemsPerRowClass = 'col-xs-12';
            }
        };
        /**
         * Sets Navigation type for the list.
         * @param type
         */
        ListComponent.prototype.onNavigationTypeChange = function (type) {
            this.resetNavigation();
            switch (type) {
                case NAVIGATION_TYPE.BASIC:
                    this.enableBasicNavigation();
                    break;
                case NAVIGATION_TYPE.INLINE:
                    this.enableInlineNavigation();
                    break;
                case NAVIGATION_TYPE.ADVANCED:
                case NAVIGATION_TYPE.CLASSIC:
                    this.enableClassicNavigation();
                    break;
                case NAVIGATION_TYPE.PAGER:
                    this.enablePagerNavigation();
                    break;
                case NAVIGATION_TYPE.NONE:
                    this.setNavigationTypeNone();
                    break;
                case NAVIGATION_TYPE.SCROLL:
                    this.enableInfiniteScroll();
                    break;
                case NAVIGATION_TYPE.ONDEMAND:
                    this.enableOnDemandLoad();
                    break;
            }
        };
        ListComponent.prototype.fetchNextDatasetOnScroll = function () {
            this.dataNavigator.navigatePage('next');
        };
        ListComponent.prototype.setIscrollHandlers = function (el) {
            var _this = this;
            var lastScrollTop = 0;
            var wrapper = _.get(el.iscroll, 'wrapper');
            var self = el.iscroll;
            el.iscroll.on('scrollEnd', function () {
                var clientHeight = wrapper.clientHeight, totalHeight = wrapper.scrollHeight, scrollTop = Math.abs(el.iscroll.y);
                if ((lastScrollTop < scrollTop) && (totalHeight * 0.9 < scrollTop + clientHeight)) {
                    _this.debouncedFetchNextDatasetOnScroll();
                    if (self.indicatorRefresh) {
                        self.indicatorRefresh();
                    }
                }
                lastScrollTop = scrollTop;
            });
        };
        // Applying iscroll event to invoke the next calls for infinte scroll.
        ListComponent.prototype.bindIScrollEvt = function () {
            var _this = this;
            var $scrollParent = this.$element.closest('[wmsmoothscroll="true"]');
            var iScroll = _.get($scrollParent[0], 'iscroll');
            // when iscroll is not initialised the notify the smoothscroll and subscribe to the iscroll update
            if (!iScroll) {
                var iScrollSubscription_1 = this.app.subscribe('iscroll-update', function (_el) {
                    if (!_.isEmpty(_el) && _el.isSameNode($scrollParent[0])) {
                        _this.setIscrollHandlers($scrollParent[0]);
                        iScrollSubscription_1();
                    }
                });
                this.app.notify('no-iscroll', $scrollParent[0]);
                return;
            }
            this.setIscrollHandlers($scrollParent[0]);
        };
        ListComponent.prototype.bindScrollEvt = function () {
            var _this = this;
            var $el = this.$element;
            var $ul = $el.find('> ul');
            var $firstChild = $ul.children().first();
            var self = this;
            var $scrollParent;
            var scrollNode;
            var lastScrollTop = 0;
            if (!$firstChild.length) {
                return;
            }
            $scrollParent = $firstChild.scrollParent(false);
            if ($scrollParent[0] === document) {
                scrollNode = document.body;
            }
            else {
                scrollNode = $scrollParent[0];
            }
            // has scroll
            if (scrollNode.scrollHeight > scrollNode.clientHeight) {
                $scrollParent
                    .each(function (index, node) {
                    // scrollTop property is 0 or undefined for body in IE, safari.
                    lastScrollTop = node === document ? (node.body.scrollTop || $(window).scrollTop()) : node.scrollTop;
                })
                    .off('scroll.scroll_evt')
                    .on('scroll.scroll_evt', function (evt) {
                    var target = evt.target;
                    var clientHeight;
                    var totalHeight;
                    var scrollTop;
                    // scrollingElement is undefined for IE, safari. use body as target Element
                    target = target === document ? (target.scrollingElement || document.body) : target;
                    clientHeight = target.clientHeight;
                    totalHeight = target.scrollHeight;
                    scrollTop = target === document.body ? $(window).scrollTop() : target.scrollTop;
                    if ((lastScrollTop < scrollTop) && (totalHeight * 0.9 < scrollTop + clientHeight)) {
                        $(this).off('scroll.scroll_evt');
                        self.debouncedFetchNextDatasetOnScroll();
                    }
                    lastScrollTop = scrollTop;
                });
                $ul.off('wheel.scroll_evt');
            }
            else {
                // if there is no scrollable element register wheel event on ul element
                $ul.on('wheel.scroll_evt', function (e) {
                    if (e.originalEvent.deltaY > 0) {
                        $ul.off('wheel.scroll_evt');
                        _this.debouncedFetchNextDatasetOnScroll();
                    }
                });
            }
        };
        /**
         * Update fieldDefs property, fieldDefs is the model of the List Component.
         * fieldDefs is an Array type.
         * @param newVal
         */
        ListComponent.prototype.updateFieldDefs = function (newVal) {
            if (this.infScroll || this.onDemandLoad) {
                if (!core.isDefined(this.fieldDefs) || this.dataNavigator.isFirstPage()) {
                    this.fieldDefs = [];
                }
                this.fieldDefs = __spread(this.fieldDefs, newVal);
            }
            else {
                this.fieldDefs = newVal;
            }
            if (this.orderby) {
                this.fieldDefs = getOrderedDataset(this.fieldDefs, this.orderby);
            }
            if (this.groupby) {
                this.groupedData = groupData(this, this.fieldDefs, this.groupby, this.match, this.orderby, this.dateformat, this.datePipe, undefined, this.appDefaults);
            }
            if (!this.fieldDefs.length) {
                this.noDataFound = true;
                this.selecteditem = undefined;
            }
            core.$appDigest();
            this.listItems.setDirty();
        };
        ListComponent.prototype.onDataChange = function (newVal) {
            // Check for newVal is not empty
            if (!_.isEmpty(newVal)) {
                this.noDataFound = false;
                this.isDataChanged = true;
                if (this.datasource && this.datasource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                    // clone the the data in case of live and service variables to prevent the two-way binding for these variables.
                    newVal = _.cloneDeep(newVal);
                }
                if (core.isObject(newVal) && !_.isArray(newVal)) {
                    newVal = _.isEmpty(newVal) ? [] : [newVal];
                }
                if (_.isString(newVal)) {
                    newVal = newVal.split(',');
                }
                if (_.isArray(newVal)) {
                    if (newVal.length) {
                        this.invokeEventCallback('beforedatarender', { $data: newVal });
                    }
                    this.updateFieldDefs(newVal);
                }
            }
            else {
                this.updateFieldDefs([]);
            }
        };
        // Updates the dataSource when pagination is enabled for the Component.
        ListComponent.prototype.setupDataSource = function () {
            var _this = this;
            var dataNavigator = this.dataNavigator;
            dataNavigator.options = {
                maxResults: this.pagesize || 5
            };
            this.dataNavigatorWatched = true;
            if (this.navigatorResultWatch) {
                this.navigatorResultWatch.unsubscribe();
            }
            /*Register a watch on the "result" property of the "dataNavigator" so that the paginated data is displayed in the live-list.*/
            this.navigatorResultWatch = dataNavigator.resultEmitter.subscribe(function (newVal) {
                _this.onDataChange(newVal);
            }, true);
            /*De-register the watch if it is exists */
            if (this.navigatorMaxResultWatch) {
                this.navigatorMaxResultWatch.unsubscribe();
            }
            /*Register a watch on the "maxResults" property of the "dataNavigator" so that the "pageSize" is displayed in the live-list.*/
            this.navigatorMaxResultWatch = dataNavigator.maxResultsEmitter.subscribe(function (val) {
                _this.pagesize = val;
            });
            dataNavigator.maxResults = this.pagesize || 5;
            this.removePropertyBinding('dataset');
            this.dataNavigator.setBindDataSet(this.binddataset, this.viewParent, this.datasource, this.dataset, this.binddatasource);
        };
        ListComponent.prototype.onDataSetChange = function (newVal) {
            if (!this.dataNavigatorWatched) {
                if (this.navigation && this.navigation !== NAVIGATION_TYPE.NONE) {
                    this.setupDataSource();
                }
                else {
                    this.onDataChange(newVal);
                }
            }
            else if (this.navigation && this.navigation !== NAVIGATION_TYPE.NONE) {
                // If navigation is already setup and datasource is changed, update the datasource on navigation
                this.dataNavigator.setDataSource(this.datasource);
            }
        };
        // All the ListItem's Active state is set to false.
        ListComponent.prototype.deselectListItems = function () {
            this.listItems.forEach(function (item) { return item.isActive = false; });
        };
        // Deselect all the ListItems and clear the selecteditem(InOutBound Property model)
        ListComponent.prototype.clearSelectedItems = function () {
            this.deselectListItems();
            this._items.length = 0;
            core.$appDigest();
        };
        /**
         * return the ListItemDirective instance by checking the equality of the model.
         * @param listModel: model to be searched for
         * @returns ListItem if the model is matched else return null.
         */
        ListComponent.prototype.getListItemByModel = function (listModel) {
            var _this = this;
            return this.listItems.find(function (listItem) {
                var itemObj = listItem.item;
                if (_this.groupby && !_.has(listModel, '_groupIndex')) {
                    // If groupby is enabled, item contains _groupIndex property which should be excluded while comparing model.
                    itemObj = _.clone(itemObj);
                    delete itemObj._groupIndex;
                }
                if (_.isEqual(itemObj, listModel)) {
                    return true;
                }
            }) || null;
        };
        ListComponent.prototype.updateSelectedItemsWidgets = function () {
            var _this = this;
            if (this.multiselect) {
                this.selectedItemWidgets.length = 0;
            }
            this.listItems.forEach(function (item) {
                if (item.isActive) {
                    if (_this.multiselect) {
                        _this.selectedItemWidgets.push(item.currentItemWidgets);
                    }
                    else {
                        _this.selectedItemWidgets = item.currentItemWidgets;
                    }
                }
            });
        };
        /**
         * Selects the listItem and updates selecteditem property.
         * If the listItem is already a selected item then deselects the item.
         * @param {ListItemDirective} $listItem: Item to be selected of deselected.
         */
        ListComponent.prototype.toggleListItemSelection = function ($listItem) {
            // item is not allowed to get selected if it is disabled.
            if ($listItem && !$listItem.disableItem) {
                var item = $listItem.item;
                if (this.groupby && _.has(item, '_groupIndex')) {
                    // If groupby is enabled, item contains _groupIndex property which should be excluded from selecteditem.
                    item = _.clone(item);
                    delete item._groupIndex;
                }
                if ($listItem.isActive) {
                    this._items = _.pullAllWith(this._items, [item], _.isEqual);
                    $listItem.isActive = false;
                }
                else {
                    // if multiselect is false, clear the selectItem list before adding an item to the selectItem list.
                    if (!this.multiselect) {
                        this.clearSelectedItems();
                    }
                    this._items.push(item);
                    this.invokeEventCallback('select', { widget: $listItem, $data: item });
                    $listItem.isActive = true;
                }
                this.updateSelectedItemsWidgets();
            }
        };
        /**
         * Method is Invoked when the model for the List Widget is changed.
         * @param {QueryList<ListItemDirective>} listItems
         */
        ListComponent.prototype.onListRender = function (listItems) {
            var _this = this;
            // Added render callback event. This method(onListRender) is calling multiple times so checking isDatachanged flag because this falg is changed whenever new data is rendered.
            if (this.isDataChanged) {
                this.invokeEventCallback('render', { $data: this.fieldDefs });
            }
            var selectedItems = _.isArray(this.selecteditem) ? this.selecteditem : [this.selecteditem];
            this.firstSelectedItem = this.lastSelectedItem = null;
            // don't select first item if multi-select is enabled and at least item is already selected in the list.
            if (listItems.length && this.selectfirstitem && !(this._items.length && this.multiselect)) {
                var $firstItem = listItems.first;
                if (!$firstItem.disableItem &&
                    this.isDataChanged &&
                    // "infinite scroll" or "load on demand" is enabled and at least one item is selected then dont alter the selected list items.
                    !((this.infScroll || this.onDemandLoad) &&
                        this._items.length)) {
                    this.clearSelectedItems();
                    this.firstSelectedItem = this.lastSelectedItem = $firstItem;
                    // selecting the first record
                    this.selectItem(0);
                }
            }
            else {
                this.deselectListItems();
                selectedItems.forEach(function (selecteditem) {
                    var listItem = _this.getListItemByModel(selecteditem);
                    if (listItem) {
                        listItem.isActive = true;
                        _this.lastSelectedItem = listItem;
                        // focus the active element
                        listItem.nativeElement.focus();
                    }
                });
            }
            if (this.fieldDefs.length && this.infScroll) {
                if (core.isMobileApp()) {
                    this.bindIScrollEvt();
                }
                else {
                    this.bindScrollEvt();
                }
            }
            this.isDataChanged = false;
        };
        ListComponent.prototype.triggerListItemSelection = function ($el, $event) {
            if ($el && $el[0]) {
                var listItemContext = $el.data('listItemContext');
                // Trigger click event only if the list item is from the corresponding list.
                if (listItemContext.listComponent === this) {
                    this.onItemClick($event, listItemContext);
                }
            }
        };
        ListComponent.prototype.setupHandlers = function () {
            var _this = this;
            this.listItems.changes.subscribe(function (listItems) {
                _this.onListRender(listItems);
                _this.cdRef.detectChanges();
            });
            // handle click event in capturing phase.
            this.nativeElement.querySelector('ul.app-livelist-container').addEventListener('click', function ($event) {
                var target = $($event.target).closest('.app-list-item');
                // Recursively find the current list item
                while (target.get(0) && (target.closest('ul.app-livelist-container').get(0) !== $event.currentTarget)) {
                    target = target.parent().closest('.app-list-item');
                }
                _this.triggerListItemSelection(target, $event);
            }, true);
        };
        // Triggers on drag start while reordering.
        ListComponent.prototype.onReorderStart = function (evt, ui) {
            ui.placeholder.height(ui.item.height());
            this.$ulEle.data('oldIndex', ui.item.index());
        };
        // Triggers after the sorting.
        ListComponent.prototype.onUpdate = function (evt, ui) {
            var data = this.fieldDefs;
            var newIndex = ui.item.index();
            var oldIndex = this.$ulEle.data('oldIndex');
            var minIndex = _.min([newIndex, oldIndex]);
            var maxIndex = _.max([newIndex, oldIndex]);
            var draggedItem = _.pullAt(data, oldIndex)[0];
            this.reorderProps.minIndex = _.min([minIndex, this.reorderProps.minIndex]);
            this.reorderProps.maxIndex = _.max([maxIndex, this.reorderProps.maxIndex]);
            data.splice(newIndex, 0, draggedItem);
            this.cdRef.markForCheck();
            this.cdRef.detectChanges();
            var $changedItem = {
                oldIndex: oldIndex,
                newIndex: newIndex,
                item: data[newIndex]
            };
            this.invokeEventCallback('reorder', { $event: evt, $data: data, $changedItem: $changedItem });
            this.$ulEle.removeData('oldIndex');
        };
        // configures reordering the list items.
        ListComponent.prototype.configureDnD = function () {
            var options = {
                appendTo: 'body',
            };
            var $el = $(this.nativeElement);
            this.$ulEle = $el.find('.app-livelist-container');
            configureDnD(this.$ulEle, options, this.onReorderStart.bind(this), this.onUpdate.bind(this));
            this.$ulEle.droppable({ 'accept': '.app-list-item' });
        };
        // returns true if the selection limit is reached.
        ListComponent.prototype.checkSelectionLimit = function (count) {
            return (!this.selectionlimit || count < this.selectionlimit);
        };
        // returns listitem reference by index value.
        ListComponent.prototype.getListItemByIndex = function (index) {
            return this.listItems.toArray()[index];
        };
        /**
         * return index of an (listItemDirective) in the listItem
         * @param {ListItemDirective} item
         * @returns {number}
         */
        ListComponent.prototype.getListItemIndex = function (item) {
            return this.listItems.toArray().indexOf(item);
        };
        // this method is called form other data widgets like table.
        ListComponent.prototype.execute = function (operation, options) {
            if ([core.DataSource.Operation.IS_API_AWARE, core.DataSource.Operation.IS_PAGEABLE, core.DataSource.Operation.SUPPORTS_SERVER_FILTER].includes(operation)) {
                return false;
            }
            return this.datasource.execute(operation, options);
        };
        ListComponent.prototype.handleKeyDown = function ($event, action) {
            $event.stopPropagation();
            var listItems = this.listItems;
            var presentIndex = this.getListItemIndex(this.lastSelectedItem);
            if (this.multiselect) {
                var firstIndex = this.getListItemIndex(this.firstSelectedItem);
                var selectCount = _.isArray(this.selecteditem) ? this.selecteditem.length : (_.isObject(this.selecteditem) ? 1 : 0);
                if (action === 'selectPrev') {
                    if (presentIndex > 0) {
                        if ((presentIndex <= firstIndex) && this.checkSelectionLimit(selectCount)) {
                            this.lastSelectedItem = this.getListItemByIndex(presentIndex - 1);
                            this.toggleListItemSelection(this.lastSelectedItem);
                        }
                        else if (presentIndex > firstIndex) {
                            this.toggleListItemSelection(this.getListItemByIndex(presentIndex));
                            this.lastSelectedItem = this.getListItemByIndex(presentIndex - 1);
                        }
                        else {
                            this.invokeEventCallback('selectionlimitexceed', { $event: $event });
                        }
                    }
                }
                else if (action === 'selectNext') {
                    if (presentIndex < listItems.length - 1) {
                        if ((presentIndex >= firstIndex) && this.checkSelectionLimit(selectCount)) {
                            this.lastSelectedItem = this.getListItemByIndex(presentIndex + 1);
                            this.toggleListItemSelection(this.lastSelectedItem);
                        }
                        else if (presentIndex < firstIndex) {
                            this.toggleListItemSelection(this.getListItemByIndex(presentIndex));
                            this.lastSelectedItem = this.getListItemByIndex(presentIndex + 1);
                        }
                        else {
                            this.invokeEventCallback('selectionlimitexceed', { $event: $event });
                        }
                    }
                }
            }
            if (action === 'focusPrev') {
                presentIndex = presentIndex <= 0 ? 0 : (presentIndex - 1);
                this.lastSelectedItem = this.getListItemByIndex(presentIndex);
                this.lastSelectedItem.nativeElement.focus();
            }
            else if (action === 'focusNext') {
                presentIndex = presentIndex < (listItems.length - 1) ? (presentIndex + 1) : (listItems.length - 1);
                this.lastSelectedItem = this.getListItemByIndex(presentIndex);
                this.lastSelectedItem.nativeElement.focus();
            }
            else if (action === 'select') {
                // if the enter click is pressed on the item which is not the last selected item, the find the item from which the event is originated.
                if (presentIndex === -1 || !$($event.target).closest(this.lastSelectedItem.nativeElement)) {
                    var $li = $($event.target).closest('li.app-list-item');
                    var $ul = $li.closest('ul.app-livelist-container');
                    presentIndex = $ul.find('li.app-list-item').index($li);
                }
                this.onItemClick($event, this.getListItemByIndex(presentIndex));
            }
        };
        ListComponent.prototype.onPropertyChange = function (key, nv, ov) {
            var _this = this;
            if (key === 'dataset') {
                if (!nv && this.binddatasource && !this.datasource) {
                    return;
                }
                this.onDataSetChange(nv);
            }
            else if (key === 'datasource') {
                if (this.dataset) {
                    this.onDataSetChange(this.dataset);
                }
            }
            else if (key === 'navigation') {
                // Support for older projects where navigation type was advanced instead of classic
                if (nv === 'Advanced') {
                    this.navigation = 'Classic';
                    return;
                }
                core.switchClass(this.nativeElement, nv, ov);
                this.onNavigationTypeChange(nv);
                if (this.dataNavigator) {
                    this.dataNavigator.navigationClass = this.paginationclass;
                }
            }
            else if (key === 'itemsperrow') {
                this.setListClass();
            }
            else if (key === 'tabindex') {
                return;
            }
            else if (key === 'pulltorefresh' && nv) {
                this.app.notify('pullToRefresh:enable');
                this.subscribeToPullToRefresh();
            }
            else if (key === 'paginationclass') {
                if (this.dataNavigator) {
                    // Adding setTimeout because in pagination component updateNavSize method is overriding navigationclass
                    setTimeout(function () { return _this.dataNavigator.navigationClass = nv; });
                }
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        ListComponent.prototype.onItemClick = function (evt, $listItem) {
            var _this = this;
            var selectCount;
            if (!$listItem.disableItem) {
                this.firstSelectedItem = this.firstSelectedItem || $listItem;
                // Setting selectCount value based number of items selected.
                selectCount = _.isArray(this.selecteditem) ? this.selecteditem.length : (_.isObject(this.selecteditem) ? 1 : 0);
                // Handling multiselect for mobile applications
                if (this.multiselect && core.isMobileApp()) {
                    if (this.checkSelectionLimit(selectCount) || $listItem.isActive) {
                        this.toggleListItemSelection($listItem);
                    }
                    else {
                        this.invokeEventCallback('selectionlimitexceed', { $event: evt });
                    }
                }
                else if ((evt.ctrlKey || evt.metaKey) && this.multiselect) {
                    if (this.checkSelectionLimit(selectCount) || $listItem.isActive) {
                        this.firstSelectedItem = this.lastSelectedItem = $listItem;
                        this.toggleListItemSelection($listItem);
                    }
                    else {
                        this.invokeEventCallback('selectionlimitexceed', { $event: evt });
                    }
                }
                else if (evt.shiftKey && this.multiselect) {
                    var first_1 = $listItem.context.index;
                    var last_1 = this.firstSelectedItem.context.index;
                    // if first is greater than last, then swap values
                    if (first_1 > last_1) {
                        last_1 = [first_1, first_1 = last_1][0];
                    }
                    if (this.checkSelectionLimit(last_1 - first_1)) {
                        this.clearSelectedItems();
                        this.listItems.forEach(function ($liItem) {
                            var index = $liItem.context.index;
                            if (index >= first_1 && index <= last_1) {
                                _this.toggleListItemSelection($liItem);
                            }
                        });
                        this.lastSelectedItem = $listItem;
                    }
                    else {
                        this.invokeEventCallback('selectionlimitexceed', { $event: evt });
                    }
                }
                else {
                    if (!$listItem.isActive || selectCount > 1) {
                        this.clearSelectedItems();
                        this.toggleListItemSelection($listItem);
                        this.firstSelectedItem = this.lastSelectedItem = $listItem;
                    }
                }
                core.$appDigest();
            }
        };
        // Empty the list content on clear
        ListComponent.prototype.clear = function () {
            this.updateFieldDefs([]);
        };
        /**
         *  Returns ListItem Reference based on the input provided.
         * @param val: index | model of the list item.
         * @returns {ListItemDirective}
         */
        ListComponent.prototype.getItemRefByIndexOrModel = function (val) {
            var listItem;
            if (core.isNumber(val)) {
                listItem = this.getListItemByIndex(val);
            }
            else {
                listItem = this.getListItemByModel(val);
            }
            return listItem;
        };
        /**
         * deselects item in the list.
         * @param val: index | model of the list item.
         */
        ListComponent.prototype.deselectItem = function (val) {
            var listItem = this.getItemRefByIndexOrModel(val);
            if (listItem && listItem.isActive) {
                this.toggleListItemSelection(listItem);
            }
        };
        /**
         * selects item in the list.
         * @param val: index | model of the list item.
         */
        ListComponent.prototype.selectItem = function (val) {
            var listItem = this.getItemRefByIndexOrModel(val);
            if (!listItem) {
                return;
            }
            if (!listItem.isActive) {
                this.toggleListItemSelection(listItem);
            }
            // focus the element.
            listItem.nativeElement.focus();
        };
        ListComponent.prototype.beforePaginationChange = function ($event, $index) {
            this.invokeEventCallback('paginationchange', { $event: $event, $index: $index });
        };
        ListComponent.prototype.handleEvent = function (node, eventName, eventCallback, locals) {
            var _this = this;
            // tap and doubleTap events are not getting propagated.So, using mouse events instead.
            var touchToMouse = {
                tap: 'click',
                doubletap: 'dblclick'
            };
            if (_.includes(['click', 'tap', 'dblclick', 'doubletap'], eventName)) {
                this.eventManager.addEventListener(this.nativeElement, touchToMouse[eventName] || eventName, function (evt) {
                    var target = $(evt.target).closest('.app-list-item');
                    if (target.length) {
                        var listItemContext = target.data('listItemContext');
                        if (!listItemContext.disableItem) {
                            _this.invokeEventCallback(eventName, { widget: listItemContext, $event: evt, item: listItemContext.item });
                        }
                    }
                });
            }
        };
        // Invoke the datasource variable by default when pulltorefresh event is not specified.
        ListComponent.prototype.subscribeToPullToRefresh = function () {
            var _this = this;
            this.cancelSubscription = this.app.subscribe('pulltorefresh', function () {
                if (_this.datasource && _this.datasource.listRecords) {
                    _this.datasource.listRecords();
                }
            });
        };
        ListComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.handleHeaderClick = core.noop;
            this._items = [];
            this.fieldDefs = [];
            // When pagination is infinite scroll dataset is applying after debounce time(250ms) so making next call after previous data has rendered
            this.debouncedFetchNextDatasetOnScroll = _.debounce(this.fetchNextDatasetOnScroll, DEBOUNCE_TIMES.PAGINATION_DEBOUNCE_TIME);
            this.reorderProps = {
                minIndex: null,
                maxIndex: null
            };
        };
        ListComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.promiseResolverFn();
            this.propsInitPromise.then(function () {
                _super.prototype.ngAfterViewInit.call(_this);
                _this.selectedItemWidgets = _this.multiselect ? [] : {};
                if (_this.enablereorder && !_this.groupby) {
                    _this.configureDnD();
                }
                if (_this.groupby && _this.collapsible) {
                    _this.handleHeaderClick = handleHeaderClick;
                    _this.toggleAllHeaders = toggleAllHeaders.bind(undefined, _this);
                }
                _this.setListClass();
            });
            this.setupHandlers();
            var $ul = this.nativeElement.querySelector('ul.app-livelist-container');
            styler($ul, this, exports.APPLY_STYLES_TYPE.SCROLLABLE_CONTAINER);
            if (core.isMobileApp() && $ul.querySelector('.app-list-item-action-panel')) {
                this._listAnimator = new ListAnimator(this);
            }
        };
        ListComponent.prototype.ngOnDestroy = function () {
            if (this._listAnimator && this._listAnimator.$btnSubscription) {
                this._listAnimator.$btnSubscription.unsubscribe();
            }
            if (this.cancelSubscription) {
                this.cancelSubscription();
            }
        };
        ListComponent.initializeProps = registerProps$s();
        ListComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmList]',
                        template: "<div class=\"panel-heading\" *ngIf=\"title || subheading || iconclass\">\n    <h3 class=\"panel-title\">\n        <div class=\"pull-left\">\n            <i class=\"app-icon panel-icon {{iconclass}}\" aria-hidden=\"true\" [hidden]=\"!iconclass\"></i>\n        </div>\n        <div class=\"pull-left\">\n            <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\"></div>\n            <div class=\"description\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n        </div>\n    </h3>\n</div>\n\n<nav class=\"app-datanavigator\" aria-label=\"Page navigation\" *ngIf=\"navigation === 'Inline' && !noDataFound\">\n    <ul class=\"pager\">\n        <li class=\"previous\" [ngClass]=\"{'disabled': (dataNavigator ? dataNavigator.isDisablePrevious : true)}\">\n            <a href=\"javascript:void(0);\" (click)=\"dataNavigator.navigatePage('prev', $event)\">\n                <i class=\"wi wi-chevron-left\" aria-hidden=\"true\"></i>\n                <span class=\"sr-only\">Previous</span>\n            </a>\n        </li>\n    </ul>\n</nav>\n\n<ul tabindex=\"0\" class=\"app-livelist-container clearfix {{listclass}}\"\n    (keydown.enter)=\"handleKeyDown($event, 'select')\"\n\n    (keydown.arrowup)=\"handleKeyDown($event, 'focusPrev')\"\n    (keydown.arrowdown)=\"handleKeyDown($event, 'focusNext')\"\n    (keydown.arrowleft)=\"handleKeyDown($event, 'focusPrev')\"\n    (keydown.arrowright)=\"handleKeyDown($event, 'focusNext')\"\n\n    (keydown.shift.arrowup)=\"handleKeyDown($event, 'selectPrev')\"\n    (keydown.shift.arrowdown)=\"handleKeyDown($event, 'selectNext')\"\n    (keydown.shift.arrowleft)=\"handleKeyDown($event, 'selectPrev')\"\n    (keydown.shift.arrowright)=\"handleKeyDown($event, 'selectNext')\"\n>\n    <ng-template [ngIf]=\"!groupby\" [ngIfElse]=\"groupedListTemplate\">\n        <li *ngFor=\"let item of fieldDefs; index as $index; first as $first; last as $last;\" class=\"app-list-item {{itemsPerRowClass}}\" [ngClass]=\"listItemRef.itemClass\"\n            [wmListItem]=\"item\"\n            #listItemRef=\"listItemRef\"\n            tabindex=\"0\">\n            <ng-container [ngTemplateOutlet]=\"listTemplate\" [ngTemplateOutletContext]=\"{item: item, $index: $index, itemRef: listItemRef, $first: $first, $last: $last, currentItemWidgets: listItemRef.currentItemWidgets}\"></ng-container>\n        </li>\n    </ng-template>\n    <ng-container [ngTemplateOutlet]=\"listLeftActionTemplate\"></ng-container>\n    <ng-container [ngTemplateOutlet]=\"listRightActionTemplate\"></ng-container>\n</ul>\n\n<div class=\"no-data-msg\" *ngIf=\"noDataFound && !variableInflight\" [textContent]=\"nodatamessage\"></div>\n\n<div class=\"loading-data-msg\" *ngIf=\"variableInflight && !pulltorefresh\">\n    <span>\n        <i class=\"app-icon panel-icon fa-spin\" aria-hidden=\"true\" [ngClass]=\"loadingicon\"></i>\n        <span class=\"sr-only\">Loading</span>\n        <span class=\"loading-text\" [textContent]=\"loadingdatamsg\"></span>\n    </span>\n</div>\n\n<nav class=\"app-datanavigator\" *ngIf=\"navigation === 'Inline' && !noDataFound\">\n    <ul class=\"pager\">\n        <li class=\"next\" [ngClass]=\"{'disabled': (dataNavigator ? dataNavigator.isDisableNext  : true)}\">\n            <a href=\"javascript:void(0);\" (click)=\"dataNavigator.navigatePage('next', $event)\">\n                <i class=\"wi wi-chevron-right\" aria-hidden=\"true\"></i>\n                <span class=\"sr-only\">Next</span>\n            </a>\n        </li>\n    </ul>\n</nav>\n\n<div class=\"panel-footer\" *ngIf=\"navigation !== 'None'\" [hidden]=\"!showNavigation || (onDemandLoad && dataNavigator.isDisableNext) || (dataNavigator.dataSize <= pagesize) || !dataNavigator.dataSize\">\n    <nav wmPagination\n         navigationalign.bind=\"navigationalign\"\n         navigation.bind=\"navControls\"\n         showrecordcount.bind=\"showrecordcount\"\n         maxsize.bind=\"maxsize\"\n         boundarylinks.bind=\"boundarylinks\"\n         forceellipses.bind=\"forceellipses\"\n         directionlinks.bind=\"directionlinks\"\n         show.bind=\"!onDemandLoad\"\n         paginationchange.event=\"beforePaginationChange($event, $index)\"\n    ></nav>\n    <a *ngIf=\"onDemandLoad\" href=\"javascript:void(0);\"\n       (click)=\"dataNavigator.navigatePage('next', $event)\"\n       class=\"app-button btn btn-block\"\n       [ngClass]=\"paginationclass\"\n       [textContent]=\"ondemandmessage\"\n    ></a>\n</div>\n\n<!--This template will be displayed when groupby is specified-->\n<ng-template #groupedListTemplate>\n    <li *ngFor=\"let groupObj of groupedData\" class=\"app-list-item-group clearfix\">\n        <ul class=\"list-group item-group\" [ngClass]=\"listclass\">\n            <li class=\"app-list-item-header list-item list-group-header\" (click)=\"handleHeaderClick($event)\" [ngClass]=\"{'collapsible-content': collapsible}\">\n            <h4>{{groupObj.key}}\n                <div class=\"header-action\">\n                    <i class=\"app-icon wi action wi-chevron-up\" *ngIf=\"collapsible\"></i>\n                    <span *ngIf=\"showcount\" class=\"label label-default\">{{groupObj.data.length}}</span>\n                    </div>\n                </h4>\n            </li>\n            <li *ngFor=\"let item of groupObj.data; index as $index; first as $first; last as $last;\" tabindex=\"0\"\n                class=\"app-list-item group-list-item {{itemsPerRowClass}}\"\n                [ngClass]=\"listItemRef.itemClass\"\n                [wmListItem]=\"item\" #listItemRef=\"listItemRef\">\n                <ng-container [ngTemplateOutlet]=\"listTemplate\" [ngTemplateOutletContext]=\"{item: item, $index: $index, itemRef: listItemRef, $first: $first, $last: $last, currentItemWidgets: listItemRef.currentItemWidgets}\"></ng-container>\n            </li>\n        </ul>\n    </li>\n</ng-template>\n",
                        providers: [
                            provideAsWidgetRef(ListComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        ListComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.ChangeDetectorRef },
                { type: ToDatePipe },
                { type: core.App },
                { type: core.AppDefaults },
                { type: core$1.NgZone },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['itemclass.bind',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['disableitem.bind',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['dataset.bind',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['datasource.bind',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['mouseenter.event',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['mouseleave.event',] }] }
            ];
        };
        ListComponent.propDecorators = {
            listTemplate: [{ type: core$1.ContentChild, args: ['listTemplate',] }],
            listLeftActionTemplate: [{ type: core$1.ContentChild, args: ['listLeftActionTemplate',] }],
            listRightActionTemplate: [{ type: core$1.ContentChild, args: ['listRightActionTemplate',] }],
            btnComponents: [{ type: core$1.ContentChildren, args: [ButtonComponent,] }],
            dataNavigator: [{ type: core$1.ViewChild, args: [PaginationComponent,] }],
            listItems: [{ type: core$1.ViewChildren, args: [ListItemDirective,] }]
        };
        return ListComponent;
    }(StylableComponent));

    var WIDGET_CONFIG$s = { widgetType: 'wm-form', hostClass: 'panel app-panel app-form' };
    var LOGIN_FORM_CONFIG = { widgetType: 'wm-form', hostClass: 'app-form app-login-form' };
    var LIVE_FORM_CONFIG = { widgetType: 'wm-liveform', hostClass: 'panel app-panel app-liveform liveform-inline' };
    var LIVE_FILTER_CONFIG = { widgetType: 'wm-livefilter', hostClass: 'panel app-panel app-livefilter clearfix liveform-inline' };
    var getWidgetConfig = function (isLiveForm, isLiveFilter, role) {
        var config = WIDGET_CONFIG$s;
        if (isLiveForm !== null) {
            config = LIVE_FORM_CONFIG;
        }
        else if (isLiveFilter !== null) {
            config = LIVE_FILTER_CONFIG;
        }
        else if (role === 'app-login') {
            config = LOGIN_FORM_CONFIG;
        }
        return config;
    };
    // Generate the form field with given field definition. Add a grid column wrapper around the form field.
    var setMarkupForFormField = function (field, columnWidth) {
        var propsTmpl = '';
        _.forEach(field, function (value, key) {
            propsTmpl = propsTmpl + " " + key + "=\"" + value + "\"";
        });
        return "<wm-gridcolumn columnwidth=\"" + columnWidth + "\">\n                  <wm-form-field " + propsTmpl + "></wm-form-field>\n            </wm-gridcolumn>";
    };
    // Function to find out the first invalid element in form
    var findInvalidElement = function ($formEle, ngForm) {
        var $ele = $formEle.find('form.ng-invalid:visible, [formControlName].ng-invalid:visible').first();
        var formObj = ngForm;
        // If element is form, find out the first invalid element in this form
        if ($ele.is('form')) {
            formObj = ngForm && ngForm.controls[$ele.attr('formControlName') || $ele.attr('name')];
            if (formObj) {
                return findInvalidElement($ele, formObj);
            }
        }
        return {
            ngForm: formObj,
            $ele: $ele
        };
    };
    var setTouchedState = function (ngForm) {
        if (ngForm.valid) {
            return;
        }
        if (ngForm.controls) {
            _.forEach(ngForm.controls, function (ctrl) {
                setTouchedState(ctrl);
            });
        }
        else {
            ngForm.markAsTouched();
        }
    };
    var FormComponent = /** @class */ (function (_super) {
        __extends(FormComponent, _super);
        function FormComponent(inj, fb, app, dynamicComponentProvider, ngZone, parentList, parentForm, onBeforeSubmitEvt, onSubmitEvt, onBeforeRenderEvt, binddataset, bindformdata, isLiveForm, isLiveFilter, role, key, name) {
            var _this = _super.call(this, inj, getWidgetConfig(isLiveForm, isLiveFilter, role)) || this;
            _this.fb = fb;
            _this.app = app;
            _this.dynamicComponentProvider = dynamicComponentProvider;
            _this.ngZone = ngZone;
            _this.parentList = parentList;
            _this.parentForm = parentForm;
            _this.onBeforeSubmitEvt = onBeforeSubmitEvt;
            _this.onSubmitEvt = onSubmitEvt;
            _this.onBeforeRenderEvt = onBeforeRenderEvt;
            _this.binddataset = binddataset;
            _this.bindformdata = bindformdata;
            _this._widgetClass = '';
            _this._captionClass = '';
            _this.formFields = [];
            _this.formfields = {};
            _this.formWidgets = {};
            _this.filterWidgets = {};
            _this.buttonArray = [];
            _this.dataoutput = {};
            _this.formdata = {};
            _this.statusMessage = {
                caption: '',
                type: ''
            };
            _this.primaryKey = [];
            _this._debouncedUpdateFieldSource = _.debounce(_this.updateFieldSource, 350);
            _this.validationMessages = [];
            _this._debouncedSubmitForm = core.debounce(function ($event) {
                // calling submit event in ngZone as change detection is not triggered post the submit callback and actions like notification are not shown
                _this.ngZone.run(function () {
                    _this.submitForm($event);
                });
            }, 250);
            styler(_this.nativeElement, _this);
            _this.isUpdateMode = true;
            _this.dialogId = _this.nativeElement.getAttribute('dialogId');
            _this.ngform = fb.group({});
            _this.addInnerNgFormToForm(key || name);
            // On value change in form, update the dataoutput
            var onValueChangeSubscription = _this.ngform.valueChanges
                .subscribe(_this.updateDataOutput.bind(_this));
            _this.registerDestroyListener(function () { return onValueChangeSubscription.unsubscribe(); });
            _this.elScope = _this;
            _this.addEventsToContext(_this.context);
            return _this;
        }
        Object.defineProperty(FormComponent.prototype, "isLayoutDialog", {
            get: function () {
                return this._isLayoutDialog;
            },
            set: function (nv) {
                if (nv) {
                    core.removeClass(this.nativeElement, 'panel app-panel liveform-inline');
                }
                this._isLayoutDialog = nv;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormComponent.prototype, "isUpdateMode", {
            get: function () {
                return this._isUpdateMode;
            },
            set: function (nv) {
                this._isUpdateMode = nv;
                this.formFields.forEach(function (field) {
                    field.setReadOnlyState(nv);
                });
            },
            enumerable: true,
            configurable: true
        });
        FormComponent.prototype.submit = function ($event) {
            this._debouncedSubmitForm($event);
        };
        FormComponent.prototype.onReset = function () {
            this.reset();
        };
        FormComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            setTimeout(function () {
                _this.componentRefs.forEach(function (componentRef) {
                    if (componentRef.name) {
                        // Register widgets inside form with formWidgets
                        _this.formWidgets[componentRef.name] = componentRef;
                    }
                });
            }, 250);
        };
        FormComponent.prototype.findOperationType = function () { };
        FormComponent.prototype.addInnerNgFormToForm = function (binding) {
            if (this.parentForm && this.parentForm.ngform) {
                var counter = 1;
                var innerBinding = binding;
                // Inner forms may have same names. If same name is present, append unqiue identifier
                while (this.parentForm.ngform.controls.hasOwnProperty(innerBinding)) {
                    innerBinding = binding + "_" + counter;
                    counter++;
                }
                this.formGroupName = innerBinding;
                // If parent form is present, add the current form as as formGroup for parent form
                this.parentForm.ngform.addControl(innerBinding, this.ngform);
            }
        };
        // Expose the events on context so that they can be accessed by form actions
        FormComponent.prototype.addEventsToContext = function (context) {
            var _this = this;
            context.cancel = function () { return _this.cancel(); };
            context.reset = function () { return _this.reset(); };
            context.save = function (evt) { return _this.save(evt); };
            context.saveAndNew = function () { return _this.saveAndNew(); };
            context.saveAndView = function () { return _this.saveAndView(); };
            context.delete = function () { return _this.delete(); };
            context.new = function () { return _this.new(); };
            context.edit = function () { return _this.edit(); };
            context.highlightInvalidFields = function () { return _this.highlightInvalidFields(); };
            context.filter = function () { return _this.filter(); };
            context.clearFilter = function () { return _this.clearFilter(); };
            context.submit = function (evt) { return _this.submit(evt); };
        };
        // This method gets all the inner forms and validates each form.
        FormComponent.prototype.setValidationOnInnerForms = function (validateTouch) {
            var _this = this;
            var formEle = this.getNativeElement();
            var formObjs = formEle.querySelectorAll('.app-form');
            _.forEach(formObjs, function (e) {
                var formInstance = e.widget;
                // differentiating the validationMessages prefix based on the formGroupName
                // as the formName's are same when forms are in list
                var formName = _.get(formInstance, 'formGroupName') || formInstance.name;
                var current = formInstance;
                while (_.get(current, 'parentForm')) {
                    var parentName = current.parentForm.formGroupName || current.parentForm.name;
                    formName = parentName + '.' + formName;
                    current = current.parentForm;
                }
                _this.setValidationOnFields(formInstance, formName, validateTouch);
            });
        };
        /**
         * This method sets validation on formFields.
         * Applies to innerform and also sets innerform validation on parent form.
         * @param prefix contains the form name, which also includes its parents form name
         * @param {boolean} validateTouch
         */
        FormComponent.prototype.setValidationOnFields = function (form, prefix, validateTouch) {
            var _this = this;
            var controls = form.ngform.controls;
            var formFields = form.formFields;
            if (!formFields) {
                return;
            }
            _.forEach(controls, function (v, k) {
                var field = formFields.find(function (e) { return e.key === k; });
                if (!field || (validateTouch && !v.touched)) {
                    return;
                }
                // invoking the prepareValidation on both parent form and current form.
                _this.prepareValidationObj(v, k, field, prefix);
                _this.prepareValidationObj.call(form, v, k, field, prefix);
            });
        };
        // Assigns / updates validationMessages based on angular errors on field
        FormComponent.prototype.prepareValidationObj = function (v, k, field, prefix) {
            var index = this.validationMessages.findIndex(function (e) { return (e.field === k && e.fullyQualifiedFormName === prefix); });
            if (v.invalid) {
                if (index === -1) {
                    /**
                     * field contains the fieldName
                     * value contains the field value
                     * errorType contains the list of errors
                     * message contains the validation message
                     * getElement returns the element having focus-target
                     * formName returns the name of the form
                     */
                    this.validationMessages.push({
                        field: k,
                        value: field.value,
                        errorType: _.keys(v.errors),
                        message: field.validationmessage || '',
                        getElement: function () {
                            return field.$element.find('[focus-target]');
                        },
                        formName: _.last(prefix.split('.')),
                        fullyQualifiedFormName: prefix
                    });
                }
                else {
                    this.validationMessages[index].value = field.value;
                    this.validationMessages[index].errorType = _.keys(v.errors);
                }
            }
            else if (v.valid && index > -1) {
                this.validationMessages.splice(index, 1);
            }
        };
        // This will return a object containing the error details from the list of formFields that are invalid
        FormComponent.prototype.setValidationMsgs = function (validateTouch) {
            if (!this.formFields.length && _.isEmpty(this.ngform.controls)) {
                return;
            }
            this.setValidationOnFields(this, this.name, validateTouch);
            this.setValidationOnInnerForms(validateTouch);
        };
        // change and blur events are added from the template
        FormComponent.prototype.handleEvent = function (node, eventName, callback, locals) {
            if (eventName !== 'submit') {
                _super.prototype.handleEvent.call(this, this.nativeElement, eventName, callback, locals);
            }
        };
        FormComponent.prototype.updateFieldSource = function () {
            var _this = this;
            if (this.formdatasource && this.formdatasource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                return;
            }
            else if (this.formdatasource && !this.formdatasource.twoWayBinding) {
                return;
            }
            this.formFields.forEach(function (formField) {
                formField.setFormWidget('datavaluesource', _this.formdatasource);
                formField.setFormWidget('binddatavalue', _this.bindformdata + "." + formField.key);
            });
        };
        // This method loops through the form fields and highlights the invalid fields by setting state to touched
        FormComponent.prototype.highlightInvalidFields = function () {
            setTouchedState(this.ngform);
        };
        // Disable the form submit if form is in invalid state. Highlight all the invalid fields if validation type is default
        FormComponent.prototype.validateFieldsOnSubmit = function () {
            this.setValidationMsgs();
            // Disable the form submit if form is in invalid state. For delete operation, do not check the validation.
            if (this.operationType !== 'delete' && (this.validationtype === 'html' || this.validationtype === 'default')
                && this.ngform && this.ngform.invalid) {
                if (this.ngform.invalid) {
                    if (this.validationtype === 'default') {
                        this.highlightInvalidFields();
                    }
                    // Find the first invalid untoched element and set it to touched.
                    // Safari does not form validations. this will ensure that error is shown for user
                    var eleForm = findInvalidElement(this.$element, this.ngform);
                    var $invalidForm = eleForm.ngForm;
                    var $invalidEle = eleForm.$ele;
                    $invalidEle = $invalidEle.parent().find('[focus-target]');
                    if ($invalidEle.length) {
                        // on save click in page layout liveform, focus of autocomplete widget opens full-screen search.
                        if (!$invalidEle.hasClass('app-search-input')) {
                            $invalidEle.focus();
                        }
                        var ngEle = $invalidForm && $invalidForm.controls[$invalidEle.attr('formControlName') || $invalidEle.attr('name')];
                        if (ngEle && ngEle.markAsTouched) {
                            ngEle.markAsTouched();
                        }
                        core.$appDigest();
                        return true;
                    }
                    return true;
                }
                return false;
            }
            return false;
        };
        FormComponent.prototype.onPropertyChange = function (key, nv, ov) {
            switch (key) {
                case 'captionalign':
                    this.captionAlignClass = 'align-' + nv;
                    break;
                case 'captionposition':
                    this.setLayoutConfig();
                    break;
                case 'captionwidth':
                    this.setLayoutConfig();
                    break;
                case 'captionsize':
                    this.captionsize = nv;
                    break;
                case 'novalidate':
                    //  Set validation type based on the novalidate property
                    this.widget.validationtype = (nv === true || nv === 'true') ? 'none' : 'default';
                    break;
                case 'formdata':
                    // For livelist when multiselect is enabled, formdata will be array of objects. In this case consider the last object as formdata.
                    _.isArray(nv) ? this.setFormData(_.last(nv)) : this.setFormData(nv);
                    // if dataset on the formFields are not set as the datasourceChange is triggered before the formFields are registered.
                    if (!this.isDataSourceUpdated && this.datasource) {
                        this.onDataSourceChange();
                    }
                    break;
                case 'defaultmode':
                    if (!this.isLayoutDialog) {
                        if (nv && nv === 'Edit') {
                            this.updateMode = true;
                        }
                        else {
                            this.updateMode = false;
                        }
                        this.isUpdateMode = this.updateMode;
                    }
                    break;
                case 'datasource':
                    this.onDataSourceChange();
                    break;
                case 'formdatasource':
                    this.onFormDataSourceChange();
                    break;
                case 'metadata':
                    this.generateFormFields();
                    break;
                default:
                    _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        // Event callbacks on success/error
        FormComponent.prototype.onResult = function (data, status, event) {
            var params = { $event: event, $data: data, $operation: this.operationType };
            // whether service call success or failure call this method
            this.invokeEventCallback('result', params);
            if (status) {
                // if service call is success call this method
                this.invokeEventCallback('success', params);
            }
            else {
                // if service call fails call this method
                this.invokeEventCallback('error', params);
            }
        };
        // Display or hide the inline message/ toaster
        FormComponent.prototype.toggleMessage = function (show, msg, type, header) {
            var template;
            if (show && msg) {
                template = (type === 'error' && this.errormessage) ? this.errormessage : msg;
                if (this.messagelayout === 'Inline') {
                    this.statusMessage = { 'caption': template || '', type: type };
                    if (this.messageRef) {
                        this.messageRef.showMessage(this.statusMessage.caption, this.statusMessage.type);
                    }
                }
                else {
                    this.app.notifyApp(template, type, header);
                }
            }
            else {
                this.statusMessage.caption = '';
            }
        };
        // Hide the inline message/ toaster
        FormComponent.prototype.clearMessage = function () {
            this.toggleMessage(false);
        };
        // Set the classes on the form based on the captionposition and captionwidth properties
        FormComponent.prototype.setLayoutConfig = function () {
            var layoutConfig;
            layoutConfig = getFieldLayoutConfig(this.captionwidth, this.captionposition, _.get(this.app.selectedViewPort, 'os'));
            this._widgetClass = layoutConfig.widgetCls;
            this._captionClass = layoutConfig.captionCls;
            core.$appDigest();
        };
        FormComponent.prototype.registerFormWidget = function (widget) {
            var name = widget.name || widget.key;
            this.formWidgets[name] = widget;
        };
        FormComponent.prototype.registerFormFields = function (formField) {
            this.formFields.push(formField);
            this.formfields[formField.key] = formField;
            this.registerFormWidget(formField);
            this._debouncedUpdateFieldSource();
            if (this.parentForm) {
                this.parentForm.formFields.push(formField);
                this.parentForm.formfields[formField.key] = formField;
            }
        };
        FormComponent.prototype.registerActions = function (formAction) {
            this.buttonArray.push(formAction);
        };
        // Update the dataoutput whenever there is a change in inside form widget value
        FormComponent.prototype.updateFormDataOutput = function (dataObject) {
            var _this = this;
            // Set the values of the widgets inside the live form (other than form fields) in form data
            _.forEach(this.ngform.value, function (val, key) {
                if (!_.find(_this.formFields, { key: key })) {
                    dataObject[key] = val;
                }
            });
            this.dataoutput = dataObject;
        };
        // Construct the data object merging the form fields and custom widgets data
        FormComponent.prototype.constructDataObject = function () {
            var _this = this;
            var formData = {};
            var formFields = this.getFormFields();
            // Get all form fields and prepare form data as key value pairs
            formFields.forEach(function (field) {
                var fieldName, fieldValue;
                fieldValue = field.datavalue || field._control.value;
                fieldValue = (fieldValue === null || fieldValue === '') ? undefined : fieldValue;
                if (field.type === 'file') {
                    fieldValue = core.getFiles(_this.name, field.key + '_formWidget', field.multiple);
                }
                fieldName = field.key || field.target || field.name;
                // In case of update the field will be already present in form data
                _.set(formData, fieldName, fieldValue);
            });
            this.updateFormDataOutput(formData);
            return this.dataoutput;
        };
        FormComponent.prototype.updateDataOutput = function () {
            this.constructDataObject();
            if (this.ngform.touched) {
                this.setValidationMsgs(true);
            }
        };
        // FormFields will contain all the fields in parent and inner form also.
        // This returns the formFields in the form based on the form name.
        FormComponent.prototype.getFormFields = function () {
            var _this = this;
            return _.filter(this.formFields, function (formField) {
                return formField.form.name === _this.name;
            });
        };
        FormComponent.prototype.setFormData = function (data) {
            var formFields = this.getFormFields();
            formFields.forEach(function (field) {
                field.value = _.get(data, field.key || field.name);
            });
            this.constructDataObject();
        };
        FormComponent.prototype.resetFormState = function () {
            var _this = this;
            // clearing the validationMessages on reset.
            if (this.validationMessages.length) {
                this.validationMessages = [];
            }
            if (!this.ngform) {
                return;
            }
            setTimeout(function () {
                _this.ngform.markAsUntouched();
                _this.ngform.markAsPristine();
            });
        };
        FormComponent.prototype.reset = function () {
            this.resetFormState();
            this.formFields.forEach(function (field) {
                field.value = '';
            });
            this.constructDataObject();
            this.clearMessage();
        };
        FormComponent.prototype.submitForm = function ($event) {
            var _this = this;
            var formData, template, params;
            var dataSource = this.datasource;
            // Disable the form submit if form is in invalid state.
            if (this.validateFieldsOnSubmit()) {
                return;
            }
            this.resetFormState();
            formData = core.getClonedObject(this.constructDataObject());
            params = { $event: $event, $formData: formData, $data: formData };
            if (this.onBeforeSubmitEvt && (this.invokeEventCallback('beforesubmit', params) === false)) {
                return;
            }
            if (this.onSubmitEvt || dataSource) {
                // If on submit is there execute it and if it returns true do service variable invoke else return
                // If its a service variable call setInput and assign form data and invoke the service
                if (dataSource) {
                    performDataOperation(dataSource, formData, {})
                        .then(function (data) {
                        _this.onResult(data, true, $event);
                        _this.toggleMessage(true, _this.postmessage, 'success');
                        _this.invokeEventCallback('submit', params);
                    }, function (error) {
                        template = _this.errormessage || error.error || error;
                        _this.onResult(error, false, $event);
                        _this.toggleMessage(true, template, 'error');
                        _this.invokeEventCallback('submit', params);
                        core.$appDigest();
                    });
                }
                else {
                    this.onResult({}, true, $event);
                    this.invokeEventCallback('submit', params);
                }
            }
            else {
                this.onResult({}, true, $event);
            }
        };
        // Method to show/hide the panel header or footer based on the buttons
        FormComponent.prototype.showButtons = function (position) {
            var _this = this;
            return _.some(this.buttonArray, function (btn) {
                return _.includes(btn.position, position) && btn.updateMode === _this.isUpdateMode;
            });
        };
        // Expand or collapse the panel
        FormComponent.prototype.expandCollapsePanel = function () {
            if (this.collapsible) {
                // flip the active flag
                this.expanded = !this.expanded;
            }
        };
        // On form data source change. This method is overridden by live form and live filter
        FormComponent.prototype.onDataSourceChange = function () {
        };
        // On form data source change. This method is overridden by live form and live filter
        FormComponent.prototype.onFormDataSourceChange = function () {
            this.updateFieldSource();
        };
        // On form field default value change. This method is overridden by live form and live filter
        FormComponent.prototype.onFieldDefaultValueChange = function (field, nv) {
            field.value = parseValueByType(nv, undefined, field.widgettype);
        };
        // On form field value change. This method is overridden by live form and live filter
        FormComponent.prototype.onFieldValueChange = function () {
        };
        // Function to generate and compile the form fields from the metadata
        FormComponent.prototype.generateFormFields = function () {
            return __awaiter(this, void 0, void 0, function () {
                var noOfColumns, $gridLayout, columnWidth, fieldTemplate, colCount, index, userFields, fields, colTmpl, componentFactoryRef, component;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // Check if grid layout is present or not for first time
                            if (_.isUndefined(this._isGridLayoutPresent)) {
                                this._isGridLayoutPresent = this.$element.find('.panel-body [wmlayoutgrid]').length > 0;
                            }
                            if (this._isGridLayoutPresent) {
                                $gridLayout = this.$element.find('.form-elements [wmlayoutgrid]:first');
                                noOfColumns = Number($gridLayout.attr('columns')) || 1;
                            }
                            else {
                                $gridLayout = this.$element.find('.form-elements .dynamic-form-container');
                                if (!$gridLayout.length) {
                                    this.$element.find('.form-elements').prepend('<div class="dynamic-form-container"></div>');
                                    $gridLayout = this.$element.find('.form-elements .dynamic-form-container');
                                }
                                noOfColumns = 1;
                            }
                            columnWidth = 12 / noOfColumns;
                            fieldTemplate = '';
                            colCount = 0;
                            fields = this.metadata ? this.metadata.data || this.metadata : [];
                            this.formFields = []; // empty the form fields
                            if (_.isEmpty(fields)) {
                                return [2 /*return*/];
                            }
                            if (this.onBeforeRenderEvt) {
                                userFields = this.invokeEventCallback('beforerender', { $metadata: fields });
                                if (userFields) {
                                    fields = userFields;
                                }
                            }
                            if (!_.isArray(fields)) {
                                return [2 /*return*/];
                            }
                            while (fields[colCount]) {
                                colTmpl = '';
                                for (index = 0; index < noOfColumns; index++) {
                                    if (fields[colCount]) {
                                        colTmpl += setMarkupForFormField(fields[colCount], columnWidth);
                                    }
                                    colCount++;
                                }
                                fieldTemplate += "<wm-gridrow>" + colTmpl + "</wm-gridrow>";
                            }
                            if (!this._isGridLayoutPresent) {
                                fieldTemplate = "<wm-layoutgrid>" + fieldTemplate + "</wm-layoutgrid>";
                            }
                            this.dynamicFormRef.clear();
                            if (!this._dynamicContext) {
                                this._dynamicContext = Object.create(this.viewParent);
                                this._dynamicContext.form = this;
                            }
                            return [4 /*yield*/, this.dynamicComponentProvider.getComponentFactoryRef('app-form-dynamic-' + this.widgetId, fieldTemplate, {
                                    noCache: true,
                                    transpile: true
                                })];
                        case 1:
                            componentFactoryRef = _a.sent();
                            component = this.dynamicFormRef.createComponent(componentFactoryRef, 0, this.inj);
                            core.extendProto(component.instance, this._dynamicContext);
                            $gridLayout[0].appendChild(component.location.nativeElement);
                            this.setFormData(this.formdata);
                            return [2 /*return*/];
                    }
                });
            });
        };
        Object.defineProperty(FormComponent.prototype, "mode", {
            get: function () {
                return this.operationType || this.findOperationType();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormComponent.prototype, "dirty", {
            get: function () {
                return this.ngform && this.ngform.dirty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormComponent.prototype, "invalid", {
            get: function () {
                return this.ngform && this.ngform.invalid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormComponent.prototype, "touched", {
            get: function () {
                return this.ngform && this.ngform.touched;
            },
            enumerable: true,
            configurable: true
        });
        FormComponent.prototype.invokeActionEvent = function ($event, expression) {
            var fn = core.$parseEvent(expression);
            fn(this.viewParent, Object.assign(this.context, { $event: $event }));
        };
        FormComponent.initializeProps = registerFormProps();
        FormComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'form[wmForm]',
                        template: "<ng-template #content><ng-content></ng-content></ng-template>\n\n<ng-container *ngIf=\"formlayout === 'page'; then pageLayoutTemplate else defaultTemplate\">\n</ng-container>\n\n<ng-template #defaultTemplate>\n    <div class=\"panel-heading\" *ngIf=\"!isLayoutDialog && (title || subheading || iconclass || showButtons('header'))\">\n        <h3 class=\"panel-title\">\n            <div class=\"pull-left\">\n                <i class=\"app-icon panel-icon\" aria-hidden=\"true\" [ngClass]=\"iconclass\" *ngIf=\"iconclass\"></i>\n            </div>\n            <div class=\"pull-left\">\n                <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\"></div>\n                <div class=\"description\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n            </div>\n            <div class=\"form-action panel-actions basic-btn-grp\">\n                <ng-container *ngFor=\"let btn of buttonArray | filter : 'position' : 'header'\"\n                              [ngTemplateOutlet]=\"btn.widgetType === 'button' ? buttonRef : anchorRef\" [ngTemplateOutletContext]=\"{btn:btn}\">\n                </ng-container>\n                <button type=\"button\" class=\"app-icon wi panel-action\" *ngIf=\"collapsible\" title=\"Collapse/Expand\"\n                        [ngClass]=\"expanded ? 'wi-minus': 'wi-plus'\" (click)=\"expandCollapsePanel();\"></button>\n            </div>\n        </h3>\n    </div>\n    <div class=\"panel-body\" [ngClass]=\"{'form-elements': isLayoutDialog, 'form-body': !isLayoutDialog}\" [class.hidden]=\"!expanded\">\n        <p wmMessage [hidden]=\"!statusMessage.caption.toString()\" caption.bind=\"statusMessage.caption\" type.bind=\"statusMessage.type\"></p>\n        <div [ngClass]=\"{'form-elements': !isLayoutDialog, 'form-content': isLayoutDialog}\">\n            <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n        </div>\n        <div class=\"basic-btn-grp form-action panel-footer clearfix\" [ngClass]=\"{'modal-footer': isLayoutDialog}\" [class.hidden]=\"!expanded || !showButtons('footer')\">\n            <ng-container *ngFor=\"let btn of buttonArray | filter : 'position' : 'footer'\"\n                          [ngTemplateOutlet]=\"btn.widgetType === 'button' ? buttonRef : anchorRef\" [ngTemplateOutletContext]=\"{btn:btn}\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #pageLayoutTemplate>\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</ng-template>\n\n<ng-template #buttonRef let-btn=\"btn\">\n    <button  wmButton name=\"{{btn.key}}\" caption.bind=\"btn.displayName\" class.bind=\"btn.class\" iconclass.bind=\"btn.iconclass\" show.bind=\"btn.show\"\n             (click)=\"invokeActionEvent($event, btn.action)\" type.bind=\"btn.type\" hint.bind=\"btn.title\" shortcutkey.bind=\"btn.shortcutkey\" disabled.bind=\"btn.disabled\"\n             tabindex.bind=\"btn.tabindex\" [class.hidden]=\"btn.updateMode ? !isUpdateMode : isUpdateMode\"></button>\n</ng-template>\n\n<ng-template #anchorRef let-btn=\"btn\">\n    <a wmAnchor name=\"{{btn.key}}\" caption.bind=\"btn.displayName\" class.bind=\"btn.class\" iconclass.bind=\"btn.iconclass\" show.bind=\"btn.show\"\n             (click)=\"invokeActionEvent($event, btn.action)\" hint.bind=\"btn.title\" shortcutkey.bind=\"btn.shortcutkey\"\n             hyperlink.bind=\"btn.hyperlink\" target.bind=\"btn.target\"\n             tabindex.bind=\"btn.tabindex\" [class.hidden]=\"btn.updateMode ? !isUpdateMode : isUpdateMode\"></a>\n</ng-template>\n\n<ng-container #dynamicForm></ng-container>",
                        providers: [
                            provideAsWidgetRef(FormComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        FormComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: forms.FormBuilder },
                { type: core.App },
                { type: core.DynamicComponentRefProvider },
                { type: core$1.NgZone },
                { type: ListComponent, decorators: [{ type: core$1.Optional }] },
                { type: FormComponent, decorators: [{ type: core$1.SkipSelf }, { type: core$1.Optional }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['beforesubmit.event',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['submit.event',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['beforerender.event',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['dataset.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['formdata.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['wmLiveForm',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['wmLiveFilter',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['role',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['key',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['name',] }] }
            ];
        };
        FormComponent.propDecorators = {
            dynamicFormRef: [{ type: core$1.ViewChild, args: ['dynamicForm', { read: core$1.ViewContainerRef },] }],
            messageRef: [{ type: core$1.ViewChild, args: [MessageComponent,] }],
            componentRefs: [{ type: core$1.ContentChildren, args: [WidgetRef, { descendants: true },] }],
            action: [{ type: core$1.HostBinding, args: ['action',] }],
            submit: [{ type: core$1.HostListener, args: ['submit', ['$event'],] }],
            onReset: [{ type: core$1.HostListener, args: ['reset',] }]
        };
        return FormComponent;
    }(StylableComponent));

    var DependsonDirective = /** @class */ (function () {
        function DependsonDirective(dialogId, dependson, dialogService, app) {
            this.dialogService = dialogService;
            this.app = app;
            // If dialogId is present, form is in dialog mode
            if (dialogId) {
                this.isLayoutDialog = true;
                this.dialogId = dialogId;
            }
            this.dependson = dependson;
            // Listen to the wm-event called from subscribed widgets
            this.eventSubscription = this.app.subscribe('wm-event', this.handleEvent.bind(this));
        }
        DependsonDirective.prototype.openFormDialog = function () {
            this.dialogService.open(this.dialogId);
        };
        DependsonDirective.prototype.onUpdate = function () {
            this.form.operationType = Live_Operations.UPDATE;
            this.form.isSelected = true;
            this.form.edit();
        };
        DependsonDirective.prototype.onInsert = function () {
            this.form.operationType = Live_Operations.INSERT;
            this.form.isSelected = true;
            this.form.new();
        };
        DependsonDirective.prototype.handleEvent = function (options) {
            if (this.dependson !== options.widgetName) {
                return;
            }
            this.currentOp = options.eventName;
            switch (options.eventName) {
                case Live_Operations.UPDATE:
                    if (this.isLayoutDialog) {
                        this.openFormDialog();
                    }
                    else {
                        this.onUpdate();
                    }
                    break;
                case Live_Operations.INSERT:
                    if (this.isLayoutDialog) {
                        this.openFormDialog();
                    }
                    else {
                        this.onInsert();
                    }
                    break;
                case Live_Operations.DELETE:
                    this.app.Widgets[this.dependson].call('delete', { row: options.row });
                    break;
                case Live_Operations.READ:
                    if (!this.isLayoutDialog) {
                        this.form.isUpdateMode = false;
                    }
                    break;
            }
        };
        DependsonDirective.prototype.onFormRender = function () {
            var _this = this;
            // On opening the form in dialog mode, complete the pending operations
            if (this.form && this.isLayoutDialog) {
                setTimeout(function () {
                    if (_this.currentOp === Live_Operations.UPDATE) {
                        _this.onUpdate();
                    }
                    else if (_this.currentOp === Live_Operations.INSERT) {
                        _this.onInsert();
                    }
                }, 250);
            }
        };
        DependsonDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            // If form instance is present, form is in inline mode. Else, it is in dialog mode and listen to form instance changes
            if (this.formChildren.first) {
                this.form = this.formChildren.first;
            }
            else {
                this.formSubscription = this.formChildren.changes.subscribe(function (val) {
                    _this.form = val.first;
                    _this.onFormRender();
                });
            }
        };
        DependsonDirective.prototype.ngOnDestroy = function () {
            if (this.formSubscription) {
                this.formSubscription.unsubscribe();
            }
            if (this.eventSubscription) {
                this.eventSubscription();
            }
        };
        DependsonDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[dependson]'
                    },] }
        ];
        /** @nocollapse */
        DependsonDirective.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: core$1.Attribute, args: ['dialogid',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['dependson',] }] },
                { type: core.AbstractDialogService },
                { type: core.App }
            ];
        };
        DependsonDirective.propDecorators = {
            formChildren: [{ type: core$1.ContentChildren, args: [FormComponent, { descendants: true },] }]
        };
        return DependsonDirective;
    }());

    var registerProps$u = function () {
        register('wm-dialog', new Map([
            ['animation', PROP_STRING],
            ['class', PROP_STRING],
            ['closable', { value: true, PROP_BOOLEAN: PROP_BOOLEAN }],
            ['iconclass', { value: 'wi wi-file-text', PROP_STRING: PROP_STRING }],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['modal', __assign({ value: true }, PROP_BOOLEAN)],
            ['name', PROP_STRING],
            ['showheader', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', __assign({ value: 'Information' }, PROP_STRING)],
            ['eventsource', PROP_ANY]
        ]));
    };

    var DIALOG_CLS$2 = 'app-dialog modal-dialog';
    var WIDGET_INFO$2 = { widgetType: 'wm-dialog' };
    var ɵ0$e = {};
    var DialogComponent = /** @class */ (function (_super) {
        __extends(DialogComponent, _super);
        function DialogComponent(inj, dialogClass, modal, closable, contexts) {
            var _this = this;
            if (modal === null || modal === undefined) {
                modal = true;
            }
            if (closable === null || closable === undefined) {
                closable = true;
            }
            // contexts[0] will refer to the self context provided by this component
            contexts[0].closeDialog = function () { return _this.close(); };
            // setting the backdrop to 'static' will not close the dialog on backdrop click
            var backdrop = core.toBoolean(modal) ? 'static' : true;
            _this = _super.call(this, inj, WIDGET_INFO$2, {
                class: DIALOG_CLS$2 + " " + (dialogClass || ''),
                backdrop: backdrop,
                keyboard: !core.toBoolean(modal)
            }) || this;
            return _this;
        }
        DialogComponent.prototype.getTemplateRef = function () {
            return this.dialogTemplate;
        };
        DialogComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.register(this.viewParent);
        };
        DialogComponent.initializeProps = registerProps$u();
        DialogComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmDialog]',
                        template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"\n         *ngIf=\"showheader\"\n    ></div>\n    <div wmDialogBody>\n        <ng-container *ngTemplateOutlet=\"dialogBody\"></ng-container>\n    </div>\n    <ng-container *ngTemplateOutlet=\"dialogFooter\"></ng-container>\n</ng-template>",
                        providers: [
                            provideAsWidgetRef(DialogComponent),
                            provideAsDialogRef(DialogComponent),
                            { provide: Context, useValue: ɵ0$e, multi: true }
                        ]
                    }] }
        ];
        /** @nocollapse */
        DialogComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['class',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['modal',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['closable',] }] },
                { type: Array, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [Context,] }] }
            ];
        };
        DialogComponent.propDecorators = {
            dialogTemplate: [{ type: core$1.ViewChild, args: ['dialogTemplate', { read: core$1.TemplateRef },] }],
            dialogBody: [{ type: core$1.ContentChild, args: ['dialogBody', { read: core$1.TemplateRef },] }],
            dialogFooter: [{ type: core$1.ContentChild, args: ['dialogFooter', { read: core$1.TemplateRef },] }]
        };
        return DialogComponent;
    }(BaseDialog));

    var DEFAULT_CLS$o = 'app-dialog-body modal-body';
    var DialogBodyDirective = /** @class */ (function () {
        function DialogBodyDirective(elRef, dialogRef, bsModal) {
            var _this = this;
            this.dialogRef = dialogRef;
            core.addClass(elRef.nativeElement, DEFAULT_CLS$o);
            var subscription = bsModal.onShown.subscribe(function () {
                var dialogRoot = $(elRef.nativeElement).closest('.app-dialog')[0];
                var width = _this.dialogRef.width;
                if (dialogRoot) {
                    if (width) {
                        core.setCSS(dialogRoot, 'width', width);
                    }
                    core.setAttr(dialogRoot, 'tabindex', _this.dialogRef.tabindex);
                    core.setAttr(dialogRoot, 'name', _this.dialogRef.name);
                }
                subscription.unsubscribe();
            });
        }
        DialogBodyDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'div[wmDialogBody]',
                    },] }
        ];
        /** @nocollapse */
        DialogBodyDirective.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: undefined, decorators: [{ type: core$1.Inject, args: [DialogRef,] }] },
                { type: ngxBootstrap.BsModalService }
            ];
        };
        DialogBodyDirective.propDecorators = {
            height: [{ type: core$1.HostBinding, args: ['style.height',] }]
        };
        return DialogBodyDirective;
    }());

    var registerProps$v = function () {
        register('wm-dialogfooter', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var WIDGET_INFO$3 = {
        widgetType: 'wm-dialogfooter',
        hostClass: 'app-dialog-footer modal-footer'
    };
    var DialogFooterDirective = /** @class */ (function (_super) {
        __extends(DialogFooterDirective, _super);
        function DialogFooterDirective(inj) {
            return _super.call(this, inj, WIDGET_INFO$3) || this;
        }
        DialogFooterDirective.initializeProps = registerProps$v();
        DialogFooterDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'div[wmDialogFooter]',
                        providers: [
                            provideAsWidgetRef(DialogFooterDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        DialogFooterDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return DialogFooterDirective;
    }(BaseComponent));

    var DEFAULT_CLS$p = 'app-dialog-header modal-header';
    var DEFAULT_ICON_DIMENSIONS = '21px';
    var DialogHeaderComponent = /** @class */ (function () {
        function DialogHeaderComponent(elRef, dialogRef) {
            this.dialogRef = dialogRef;
            this.iconwidth = DEFAULT_ICON_DIMENSIONS;
            this.iconheight = DEFAULT_ICON_DIMENSIONS;
            this.closable = true;
            core.addClass(elRef.nativeElement, DEFAULT_CLS$p);
        }
        Object.defineProperty(DialogHeaderComponent.prototype, "isClosable", {
            get: function () {
                return core.toBoolean(this.closable);
            },
            enumerable: true,
            configurable: true
        });
        DialogHeaderComponent.prototype.closeDialog = function () {
            this.dialogRef.close();
        };
        DialogHeaderComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmDialogHeader]',
                        template: "<button *ngIf=\"isClosable\" aria-label=\"Close\" class=\"app-dialog-close close\" (click)=\"closeDialog();\" title=\"Close\">\n    <span aria-hidden=\"true\">&times;</span>\n</button>\n<h4 class=\"app-dialog-title modal-title\">\n    <i [ngClass]=\"iconclass\" [ngStyle]=\"{width: iconwidth, height: iconheight, margin: iconmargin}\"  *ngIf=\"iconclass && !iconurl\"></i>\n    <img data-identifier=\"img\" [src]=\"iconurl | image\" *ngIf=\"iconurl\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin}\"/>\n    <span class=\"dialog-heading\" [textContent]=\"heading\"></span>\n    <span class=\"dialog-sub-heading\" *ngIf=\"subheading\" [title]=\"subheading\" [textContent]=\"subheading\"></span>\n</h4>"
                    }] }
        ];
        /** @nocollapse */
        DialogHeaderComponent.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: BaseDialog, decorators: [{ type: core$1.Inject, args: [DialogRef,] }] }
            ];
        };
        DialogHeaderComponent.propDecorators = {
            iconwidth: [{ type: core$1.Input }],
            iconheight: [{ type: core$1.Input }],
            iconmargin: [{ type: core$1.Input }],
            iconclass: [{ type: core$1.Input }],
            iconurl: [{ type: core$1.Input }],
            closable: [{ type: core$1.Input }],
            heading: [{ type: core$1.Input }],
            subheading: [{ type: core$1.Input }]
        };
        return DialogHeaderComponent;
    }());

    var registerProps$w = function () {
        register('wm-footer', new Map([
            ['name', PROP_STRING],
            ['class', PROP_STRING],
            ['content', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$q = 'app-footer clearfix';
    var WIDGET_CONFIG$t = {
        widgetType: 'wm-footer',
        hostClass: DEFAULT_CLS$q
    };
    var FooterDirective = /** @class */ (function (_super) {
        __extends(FooterDirective, _super);
        function FooterDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$t) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        FooterDirective.initializeProps = registerProps$w();
        FooterDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmFooter]',
                        providers: [
                            provideAsWidgetRef(FooterDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        FooterDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return FooterDirective;
    }(StylableComponent));

    var registerProps$x = function () {
        register('wm-form-action', new Map([
            ['accessroles', PROP_STRING],
            ['action', PROP_STRING],
            ['class', PROP_STRING],
            ['binding', PROP_STRING],
            ['disabled', PROP_BOOLEAN],
            ['display-name', PROP_STRING],
            ['hyperlink', PROP_STRING],
            ['iconclass', PROP_STRING],
            ['iconname', PROP_STRING],
            ['key', PROP_STRING],
            ['position', __assign({ value: 'footer' }, PROP_STRING)],
            ['shortcutkey', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['target', PROP_STRING],
            ['title', PROP_STRING],
            ['type', __assign({ value: 'button' }, PROP_STRING)],
            ['update-mode', __assign({ value: true }, PROP_BOOLEAN)],
            ['widget-type', __assign({ value: 'button' }, PROP_STRING)]
        ]));
    };

    var WIDGET_CONFIG$u = { widgetType: 'wm-form-action', hostClass: '' };
    var FormActionDirective = /** @class */ (function (_super) {
        __extends(FormActionDirective, _super);
        function FormActionDirective(inj, form) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$u) || this;
            _this.form = form;
            return _this;
        }
        FormActionDirective.prototype.populateAction = function () {
            this.buttonDef = {
                key: this.key || this.binding,
                displayName: this['display-name'],
                show: this.show,
                class: this.class ? this.class : (this['widget-type'] === 'button' ? 'btn-secondary' : ''),
                iconclass: this.iconclass || '',
                title: _.isUndefined(this.title) ? (this['display-name'] || '') : this.title,
                action: this.action,
                accessroles: this.accessroles,
                shortcutkey: this.shortcutkey,
                disabled: this.disabled,
                tabindex: this.tabindex,
                iconname: this.iconname,
                type: this.type,
                updateMode: this['update-mode'],
                position: this.position,
                widgetType: this['widget-type'],
                hyperlink: this.hyperlink,
                target: this.target
            };
            this._propsInitialized = true;
        };
        FormActionDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.populateAction();
            this.form.registerActions(this.buttonDef);
        };
        FormActionDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (!this._propsInitialized) {
                return;
            }
            switch (key) {
                case 'display-name':
                    this.buttonDef.displayName = nv;
                default:
                    this.buttonDef[key] = nv;
                    break;
            }
        };
        FormActionDirective.initializeProps = registerProps$x();
        FormActionDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmFormAction]',
                        providers: [
                            provideAsWidgetRef(FormActionDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        FormActionDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: FormComponent, decorators: [{ type: core$1.Optional }] }
            ];
        };
        return FormActionDirective;
    }(BaseComponent));

    var colorPickerProps = new Map([
        ['class', PROP_STRING],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['name', PROP_STRING],
        ['placeholder', __assign({ value: 'Select Color' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)]
    ]);

    var numberProps = new Map([
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['localefilter', PROP_STRING],
        ['minvalue', PROP_NUMBER],
        ['maxvalue', PROP_NUMBER],
        ['name', PROP_STRING],
        ['numberfilter', PROP_STRING],
        ['placeholder', __assign({ value: 'Enter number' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['regexp', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['step', __assign({ value: 1 }, PROP_NUMBER)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['updateon', PROP_STRING]
    ]);
    var registerProps$z = function () {
        register('wm-number', numberProps);
    };

    var inputNumberTypeProps = new Map([
        ['autocomplete', __assign({ value: true }, PROP_BOOLEAN)],
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['maxchars', PROP_NUMBER],
        ['maxvalue', PROP_NUMBER],
        ['minvalue', PROP_NUMBER],
        ['name', PROP_STRING],
        ['placeholder', __assign({ value: 'Enter text' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['regexp', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['step', PROP_NUMBER],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['type', PROP_STRING],
        ['updateon', PROP_STRING]
    ]);
    var registerProps$A = function () {
        register('wm-input-number', inputNumberTypeProps);
    };

    var inputTextTypeProps = new Map([
        ['autocomplete', __assign({ value: true }, PROP_BOOLEAN)],
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['displayformat', PROP_STRING],
        ['hint', PROP_STRING],
        ['maxchars', PROP_NUMBER],
        ['name', PROP_STRING],
        ['placeholder', __assign({ value: 'Enter text' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['regexp', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['type', __assign({ value: 'text' }, PROP_STRING)],
        ['updateon', PROP_STRING]
    ]);
    var registerProps$B = function () {
        register('wm-input-text', inputTextTypeProps);
    };

    var inputCalendarTypeProps = new Map([
        ['autocomplete', __assign({ value: true }, PROP_BOOLEAN)],
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datasource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['maxvalue', PROP_NUMBER],
        ['minvalue', PROP_NUMBER],
        ['name', PROP_STRING],
        ['placeholder', __assign({ value: 'Enter text' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['step', PROP_NUMBER],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['type', PROP_STRING],
        ['updateon', PROP_STRING]
    ]);
    var registerProps$C = function () {
        register('wm-input-calendar', inputCalendarTypeProps);
    };

    var inputColorTypeProps = new Map([
        ['autocomplete', __assign({ value: true }, PROP_BOOLEAN)],
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['name', PROP_STRING],
        ['placeholder', __assign({ value: 'Enter text' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['type', PROP_STRING],
        ['updateon', PROP_STRING]
    ]);
    var registerProps$D = function () {
        register('wm-input-color', inputColorTypeProps);
    };

    var inputEmailTypeProps = new Map([
        ['autocomplete', __assign({ value: true }, PROP_BOOLEAN)],
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['maxchars', PROP_NUMBER],
        ['name', PROP_STRING],
        ['placeholder', __assign({ value: 'Enter text' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['regexp', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['type', PROP_STRING],
        ['updateon', PROP_STRING]
    ]);
    var registerProps$E = function () {
        register('wm-input-email', inputEmailTypeProps);
    };

    var radiosetProps = new Map([
        ['class', PROP_STRING],
        ['compareby', PROP_STRING],
        ['datafield', PROP_STRING],
        ['dataset', __assign({ value: 'Option 1, Option 2, Option 3' }, PROP_ANY)],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['displayexpression', PROP_STRING],
        ['displayfield', PROP_STRING],
        ['displayValue', PROP_STRING],
        ['itemclass', __assign({ value: '' }, PROP_STRING)],
        ['layout', __assign({ value: 'stacked' }, PROP_STRING)],
        ['listclass', __assign({ value: '' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['orderby', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showindevice', __assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['usekeys', PROP_BOOLEAN]
    ]);
    var registerProps$F = function () {
        register('wm-radioset', radiosetProps);
    };

    var ratingProps = new Map([
        ['caption', PROP_STRING],
        ['class', PROP_STRING],
        ['datafield', PROP_STRING],
        ['dataset', PROP_ANY],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['displayexpression', PROP_STRING],
        ['displayfield', PROP_STRING],
        ['hint', PROP_STRING],
        ['iconcolor', PROP_STRING],
        ['iconsize', PROP_STRING],
        ['maxvalue', __assign({ value: 5 }, PROP_NUMBER)],
        ['name', PROP_STRING],
        ['orderby', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showcaptions', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['usekeys', PROP_BOOLEAN]
    ]);

    var richTextProps = new Map([
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['height', PROP_STRING],
        ['name', PROP_STRING],
        ['placeholder', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showpreview', __assign({ value: false }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)]
    ]);
    var registerProps$H = function () {
        register('wm-richtexteditor', richTextProps);
    };

    var selectProps = new Map([
        ['autofocus', PROP_BOOLEAN],
        ['class', __assign({ value: '' }, PROP_STRING)],
        ['compareby', PROP_STRING],
        ['datafield', PROP_STRING],
        ['dataset', PROP_ANY],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['displayexpression', PROP_STRING],
        ['displayfield', PROP_STRING],
        ['displayValue', PROP_STRING],
        ['hint', PROP_STRING],
        ['multiple', __assign({ value: false }, PROP_BOOLEAN)],
        ['name', PROP_STRING],
        ['orderby', PROP_STRING],
        ['placeholder', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['usekeys', PROP_BOOLEAN]
    ]);
    var registerProps$I = function () {
        register('wm-select', selectProps);
    };

    var sliderProps = new Map([
        ['class', PROP_STRING],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['maxvalue', PROP_NUMBER],
        ['minvalue', PROP_NUMBER],
        ['name', PROP_STRING],
        ['readonly', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['step', PROP_NUMBER],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)]
    ]);

    var switchProps = new Map([
        ['class', PROP_STRING],
        ['compareby', PROP_STRING],
        ['datafield', PROP_STRING],
        ['dataset', __assign({ value: 'yes, no, maybe' }, PROP_ANY)],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['displayexpression', PROP_STRING],
        ['displayfield', PROP_STRING],
        ['hint', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['name', PROP_STRING],
        ['orderby', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)]
    ]);
    var registerProps$K = function () {
        register('wm-switch', switchProps);
    };

    var textareaProps = new Map([
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['maxchars', PROP_NUMBER],
        ['name', PROP_STRING],
        ['placeholder', __assign({ value: 'Place your text' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['updateon', PROP_STRING]
    ]);
    var registerProps$L = function () {
        register('wm-textarea', textareaProps);
    };

    var timeProps = new Map([
        ['autofocus', PROP_BOOLEAN],
        ['class', PROP_STRING],
        ['datavaluesource', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['hourstep', __assign({ value: 1 }, PROP_NUMBER)],
        ['maxtime', PROP_STRING],
        ['mintime', PROP_STRING],
        ['minutestep', __assign({ value: 15 }, PROP_NUMBER)],
        ['name', PROP_STRING],
        ['outputformat', __assign({ value: 'HH:mm:ss' }, PROP_STRING)],
        ['placeholder', __assign({ value: 'Select time' }, PROP_STRING)],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN],
        ['shortcutkey', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ['showdropdownon', __assign({ value: 'default' }, PROP_STRING)],
        ['secondsstep', __assign({ value: 1 }, PROP_NUMBER)],
        ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
        ['timepattern', PROP_STRING],
        ['timestamp', PROP_STRING]
    ]);
    var registerProps$M = function () {
        if (core.isMobileApp()) {
            timeProps.set('timepattern', __assign({ value: 'HH:mm' }, PROP_STRING));
        }
        register('wm-time', timeProps);
    };

    var registerProps$N = function () {
        var uploadProps = new Map([
            ['disabled', PROP_BOOLEAN],
            ['extensions', PROP_STRING],
            ['filetype', PROP_STRING],
            ['multiple', PROP_BOOLEAN],
            ['readonly', PROP_BOOLEAN],
            ['required', PROP_BOOLEAN]
        ]);
        var textProps = new Map(inputTextTypeProps);
        var mergeTextProps = function (typeProps) {
            typeProps.forEach(function (v, k) { return textProps.set(k, v); });
        };
        mergeTextProps(inputCalendarTypeProps);
        mergeTextProps(inputColorTypeProps);
        mergeTextProps(inputEmailTypeProps);
        mergeTextProps(inputNumberTypeProps);
        var widgetPropsMap = new Map([
            [core.FormWidgetType.AUTOCOMPLETE, searchProps],
            [core.FormWidgetType.CHECKBOX, checkboxProps],
            [core.FormWidgetType.CHECKBOXSET, checkboxsetProps],
            [core.FormWidgetType.CHIPS, chipsProps],
            [core.FormWidgetType.COLORPICKER, colorPickerProps],
            [core.FormWidgetType.CURRENCY, currencyProps],
            [core.FormWidgetType.DATE, dateProps],
            [core.FormWidgetType.DATETIME, dateTimeProps],
            [core.FormWidgetType.NUMBER, numberProps],
            [core.FormWidgetType.PASSWORD, inputTextTypeProps],
            [core.FormWidgetType.RADIOSET, radiosetProps],
            [core.FormWidgetType.RATING, ratingProps],
            [core.FormWidgetType.RICHTEXT, richTextProps],
            [core.FormWidgetType.SELECT, selectProps],
            [core.FormWidgetType.SLIDER, sliderProps],
            [core.FormWidgetType.SWITCH, switchProps],
            [core.FormWidgetType.TEXT, textProps],
            [core.FormWidgetType.TEXTAREA, textareaProps],
            [core.FormWidgetType.TIME, timeProps],
            [core.FormWidgetType.TIMESTAMP, dateTimeProps],
            [core.FormWidgetType.TOGGLE, checkboxProps],
            [core.FormWidgetType.TYPEAHEAD, searchProps],
            [core.FormWidgetType.UPLOAD, uploadProps]
        ]);
        var formFieldMap = new Map([
            ['debouncetime', __assign({ value: 250 }, PROP_NUMBER)],
            ['defaultvalue', PROP_STRING],
            ['displayname', PROP_STRING],
            ['display-name', PROP_STRING],
            ['field', PROP_STRING],
            ['filterexpressions', PROP_STRING],
            ['filter-on', PROP_STRING],
            ['generator', PROP_STRING],
            ['hint', PROP_STRING],
            ['inputtype', PROP_STRING],
            ['is-primary-key', PROP_BOOLEAN],
            ['is-range', PROP_BOOLEAN],
            ['is-related', PROP_BOOLEAN],
            ['isformfield', { value: true }],
            ['key', PROP_STRING],
            ['limit', PROP_NUMBER],
            ['lookup-type', PROP_STRING],
            ['lookup-field', PROP_STRING],
            ['name', PROP_STRING],
            ['matchmode', PROP_STRING],
            ['maxdefaultvalue', PROP_STRING],
            ['maxplaceholder', PROP_STRING],
            ['mobile-display', __assign({ value: true }, PROP_BOOLEAN)],
            ['period', PROP_BOOLEAN],
            ['pc-display', __assign({ value: true }, PROP_BOOLEAN)],
            ['placeholder', PROP_STRING],
            ['primary-key', PROP_BOOLEAN],
            ['related-entity-name', PROP_STRING],
            ['required', PROP_BOOLEAN],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['type', PROP_STRING],
            ['validationmessage', PROP_STRING],
            ['viewmodewidget', PROP_STRING],
            ['widgettype', PROP_STRING]
        ]);
        widgetPropsMap.forEach(function (val, key) {
            var propsMap = new Map(formFieldMap);
            var widgetProps = widgetPropsMap.get(key);
            widgetProps.forEach(function (v, k) { return propsMap.set(k, v); });
            register('wm-form-field-' + key, propsMap);
        });
    };

    // Custom validator to show validation error, if setValidationMessage method is used
    var customValidatorFn = function () {
        return { custom: true };
    };
    var FILE_TYPES = {
        'image': 'image/*',
        'video': 'video/*',
        'audio': 'audio/*'
    };
    var ɵ1$7 = {};
    var FormFieldDirective = /** @class */ (function (_super) {
        __extends(FormFieldDirective, _super);
        function FormFieldDirective(inj, form, fb, parentList, binddataset, binddisplayexpression, binddisplaylabel, _widgetType, name, key, isRange, pcDisplay, mobileDisplay, contexts) {
            var _this = this;
            var WIDGET_CONFIG = {
                widgetType: 'wm-form-field',
                hostClass: '',
                widgetSubType: 'wm-form-field-' + (_widgetType || core.FormWidgetType.TEXT).trim()
            };
            _this = _super.call(this, inj, WIDGET_CONFIG, new Promise(function (res) { return _this._initPropsRes = res; })) || this;
            _this._validators = [];
            _this.class = '';
            _this.binddataset = binddataset;
            _this.binddisplayexpression = binddisplayexpression;
            _this.binddisplaylabel = binddisplaylabel;
            _this.form = form;
            _this.fb = fb;
            _this._fieldName = key || name;
            _this.isRange = isRange;
            _this.excludeProps = new Set(['type', 'name']);
            _this.widgettype = _widgetType;
            _this.parentList = parentList;
            if (_this.binddataset || _this.$element.attr('dataset')) {
                _this.isDataSetBound = true;
            }
            contexts[0]._onFocusField = _this._onFocusField.bind(_this);
            contexts[0]._onBlurField = _this._onBlurField.bind(_this);
            _this._debounceSetUpValidators = core.debounce(function () { return _this.setUpValidators(); }, 500);
            return _this;
        }
        FormFieldDirective.prototype._onFocusField = function ($evt) {
            $($evt.target).closest('.live-field').addClass('active');
        };
        FormFieldDirective.prototype._onBlurField = function ($evt) {
            $($evt.target).closest('.live-field').removeClass('active');
            this.setUpValidators();
        };
        // Expression to be evaluated in view mode of form field
        FormFieldDirective.prototype.evaluateExpr = function (object, displayExpr) {
            if (!displayExpr) {
                displayExpr = Object.keys(object)[0];
                // If dataset is not ready, display expression will not be defined
                if (!displayExpr) {
                    return;
                }
            }
            return getEvaluatedData(object, {
                expression: displayExpr
            }, this.viewParent);
        };
        // Expression to be evaluated in view mode of form field
        FormFieldDirective.prototype.getDisplayExpr = function () {
            var _this = this;
            var caption = [];
            var value = this.value;
            var displayExpr = this.displayexpression || this.displayfield || this.displaylabel;
            if (_.isObject(value)) {
                if (_.isArray(value)) {
                    _.forEach(value, function (obj) {
                        if (_.isObject(obj)) {
                            caption.push(_this.evaluateExpr(obj, displayExpr));
                        }
                    });
                }
                else {
                    caption.push(this.evaluateExpr(value, displayExpr));
                }
                return _.join(caption, ',');
            }
            return (value === undefined || value === null) ? '' : this.value;
        };
        FormFieldDirective.prototype.getCaption = function () {
            return (this.value === undefined || this.value === null) ? (_.get(this.form.dataoutput, this._fieldName) || '') : this.value;
        };
        // Method to setup validators for reactive form control
        FormFieldDirective.prototype.setUpValidators = function (customValidator) {
            this._validators = [];
            if (this.required && this.show !== false) {
                // For checkbox/toggle widget, required validation should consider true value only
                if (this.widgettype === core.FormWidgetType.CHECKBOX || this.widgettype === core.FormWidgetType.TOGGLE) {
                    this._validators.push(forms.Validators.requiredTrue);
                }
                else {
                    this._validators.push(forms.Validators.required);
                }
            }
            if (this.maxchars) {
                this._validators.push(forms.Validators.maxLength(this.maxchars));
            }
            if (this.minvalue) {
                this._validators.push(forms.Validators.min(this.minvalue));
            }
            if (this.maxvalue && this.widgettype !== core.FormWidgetType.RATING) {
                this._validators.push(forms.Validators.max(this.maxvalue));
            }
            if (this.regexp) {
                this._validators.push(forms.Validators.pattern(this.regexp));
            }
            if (_.isFunction(this.formWidget.validate)) {
                this._validators.push(this.formWidget.validate.bind(this.formWidget));
            }
            if (customValidator) {
                this._validators.push(customValidator);
            }
            if (this.ngform) {
                this._control.setValidators(this._validators);
                var opt = {};
                // updating the value only when prevData is not equal to current value.
                // emitEvent flag will prevent from emitting the valueChanges when value is equal to the prevDatavalue.
                if (this.value === this.formWidget.prevDatavalue) {
                    opt['emitEvent'] = false;
                }
                this._control.updateValueAndValidity(opt);
            }
        };
        // Method to set the properties on inner form widget
        FormFieldDirective.prototype.setFormWidget = function (key, val) {
            if (this.formWidget && this.formWidget.widget) {
                this.formWidget.widget[key] = val;
            }
        };
        // Method to set the properties on inner max form widget (when range is selected)
        FormFieldDirective.prototype.setMaxFormWidget = function (key, val) {
            if (this.formWidgetMax) {
                this.formWidgetMax.widget[key] = val;
            }
        };
        FormFieldDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (key !== 'tabindex') {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
            if (this.excludeProps.has(key)) {
                return;
            }
            // As upload widget is an HTML widget, only required property is setup
            if (this.widgettype === core.FormWidgetType.UPLOAD) {
                if (key === 'required') {
                    this._debounceSetUpValidators();
                }
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
                return;
            }
            this.setFormWidget(key, nv);
            // Placeholder should not be setup on max widget
            if (key !== 'placeholder') {
                this.setMaxFormWidget(key, nv);
            }
            switch (key) {
                case 'defaultvalue':
                    this.form.onFieldDefaultValueChange(this, nv);
                    break;
                case 'maxdefaultvalue':
                    this.maxValue = nv;
                    this.setMaxFormWidget('datavalue', nv);
                    this.form.onMaxDefaultValueChange();
                    break;
                case 'maxplaceholder':
                    this.setMaxFormWidget('placeholder', nv);
                    break;
                case 'required':
                case 'maxchars':
                case 'minvalue':
                case 'maxvalue':
                case 'regexp':
                case 'show':
                    this._debounceSetUpValidators();
                    break;
                case 'primary-key':
                    if (nv) {
                        this.form.setPrimaryKey(this._fieldName);
                    }
                    break;
                case 'display-name':
                    this.displayname = nv;
                    break;
                case 'readonly':
                    this.setReadOnlyState();
                    break;
            }
        };
        FormFieldDirective.prototype.onStyleChange = function (key, nv, ov) {
            this.setFormWidget(key, nv);
            this.setMaxFormWidget(key, nv);
            _super.prototype.onStyleChange.call(this, key, nv, ov);
        };
        Object.defineProperty(FormFieldDirective.prototype, "datavalue", {
            get: function () {
                return this.formWidget && this.formWidget.datavalue;
            },
            set: function (val) {
                if (this._control && this.widgettype !== core.FormWidgetType.UPLOAD) {
                    this._control.setValue(val);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormFieldDirective.prototype, "value", {
            get: function () {
                return this.datavalue;
            },
            set: function (val) {
                this.datavalue = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormFieldDirective.prototype, "maxValue", {
            get: function () {
                return this.formWidgetMax && this.formWidgetMax.datavalue;
            },
            set: function (val) {
                if (this._maxControl) {
                    this._maxControl.setValue(val);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormFieldDirective.prototype, "minValue", {
            get: function () {
                return this.value;
            },
            set: function (val) {
                this.value = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormFieldDirective.prototype, "_control", {
            // Get the reactive form control
            get: function () {
                return this.ngform && this.ngform.controls[this._fieldName];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormFieldDirective.prototype, "_maxControl", {
            // Get the reactive max form control
            get: function () {
                return this.ngform && this.ngform.controls[this._fieldName + '_max'];
            },
            enumerable: true,
            configurable: true
        });
        // Create the reactive form control
        FormFieldDirective.prototype.createControl = function () {
            return this.fb.control(undefined, {
                validators: this._validators
            });
        };
        // On field value change, propagate event to parent form
        FormFieldDirective.prototype.onValueChange = function (val) {
            if (!this.isDestroyed) {
                this.form.onFieldValueChange(this, val);
            }
        };
        // Method to expose validation message and set control to invalid
        FormFieldDirective.prototype.setValidationMessage = function (val) {
            var _this = this;
            setTimeout(function () {
                _this.validationmessage = val;
                _this.setUpValidators(customValidatorFn);
            });
        };
        FormFieldDirective.prototype.setReadOnlyState = function () {
            var readOnly;
            if (this.form.isUpdateMode) {
                if (this['primary-key'] && !this['is-related'] && !this.period) {
                    /*If the field is primary but is assigned set readonly false.
                       Assigned is where the user inputs the value while a new entry.
                       This is not editable(in update mode) once entry is successful*/
                    readOnly = !(this.generator === 'assigned' && this.form.operationType !== 'update');
                }
                else {
                    readOnly = this.readonly;
                }
            }
            else {
                // In view mode, set widget state to readonly always
                readOnly = true;
            }
            this.setFormWidget('readonly', readOnly);
        };
        FormFieldDirective.prototype.resetDisplayInput = function () {
            if ((!core.isDefined(this.value) || this.value === '')) {
                this.formWidget && this.formWidget.resetDisplayInput && this.formWidget.resetDisplayInput();
            }
        };
        FormFieldDirective.prototype.triggerUploadEvent = function ($event, eventName) {
            var params = { $event: $event };
            if (eventName === 'change') {
                params.newVal = $event.target.files;
                params.oldVal = this._oldUploadVal;
                this._oldUploadVal = params.newVal;
            }
            this.invokeEventCallback(eventName, params);
        };
        FormFieldDirective.prototype.registerFormField = function () {
            var fieldName = this._fieldName;
            if (this.parentList && !(this.form.parentList === this.parentList)) {
                var counter = 1;
                var _fieldName = fieldName;
                while (this.ngform.controls.hasOwnProperty(_fieldName)) {
                    _fieldName = fieldName + "_" + counter;
                    counter++;
                }
                this.ngform.addControl(_fieldName, this.createControl());
                this._fieldName = _fieldName;
            }
            else {
                this.ngform.addControl(fieldName, this.createControl());
            }
            var onValueChangeSubscription = this._control.valueChanges
                .pipe(operators.debounceTime(200))
                .subscribe(this.onValueChange.bind(this));
            this.registerDestroyListener(function () { return onValueChangeSubscription.unsubscribe(); });
            if (this.isRange === 'true') {
                this.ngform.addControl(fieldName + '_max', this.createControl());
                // registering for valueChanges on MaxformWidget
                var onMaxValueChangeSubscription_1 = this._maxControl.valueChanges
                    .pipe(operators.debounceTime(200))
                    .subscribe(this.onValueChange.bind(this));
                this.registerDestroyListener(function () { return onMaxValueChangeSubscription_1.unsubscribe(); });
            }
            this.value = _.get(this.form.formdata, this._fieldName);
        };
        FormFieldDirective.prototype.ngOnInit = function () {
            this.ngform = this.form.ngform;
            this.registerFormField();
            _super.prototype.ngOnInit.call(this);
        };
        FormFieldDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            _super.prototype.ngAfterContentInit.call(this);
            if (this.formWidget) {
                this._initPropsRes();
                // setting displayExpressions on the formwidget explicitly as expr was evaluated to "".
                this.setFormWidget('binddisplaylabel', this.binddisplaylabel);
                this.setFormWidget('binddisplayexpression', this.binddisplayexpression);
            }
            this.registerReadyStateListener(function () {
                _this.key = _this._fieldName || _this.target || _this.binding;
                _this.viewmodewidget = _this.viewmodewidget || getDefaultViewModeWidget(_this.widgettype);
                // For upload widget, generate the permitted field
                if (_this.widgettype === core.FormWidgetType.UPLOAD) {
                    var fileType = void 0;
                    // Create the accepts string from file type and extensions
                    fileType = _this.filetype ? FILE_TYPES[_this.filetype] : '';
                    _this.permitted = fileType + (_this.extensions ? (fileType ? ',' : '') + _this.extensions : '');
                }
                if (core.isMobile()) {
                    if (!_this['mobile-display']) {
                        _this.widget.show = false;
                    }
                }
                else {
                    if (!_this['pc-display']) {
                        _this.widget.show = false;
                    }
                }
                // Register the form field with parent form
                _this.form.registerFormFields(_this.widget);
                core.addForIdAttributes(_this.nativeElement);
                _this.setReadOnlyState();
            });
        };
        FormFieldDirective.initializeProps = registerProps$N();
        FormFieldDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmFormField]',
                        exportAs: 'wmFormField',
                        providers: [
                            provideAsWidgetRef(FormFieldDirective),
                            provideAsNgValueAccessor(FormFieldDirective),
                            { provide: Context, useValue: ɵ1$7, multi: true }
                        ]
                    },] }
        ];
        /** @nocollapse */
        FormFieldDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: FormComponent },
                { type: forms.FormBuilder },
                { type: ListComponent, decorators: [{ type: core$1.Optional }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['dataset.bind',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['displayexpression.bind',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['displaylabel.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['widgettype',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['name',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['key',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['is-range',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['pc-display',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['mobile-display',] }] },
                { type: Array, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [Context,] }] }
            ];
        };
        FormFieldDirective.propDecorators = {
            formWidget: [{ type: core$1.ContentChild, args: ['formWidget',] }],
            formWidgetMax: [{ type: core$1.ContentChild, args: ['formWidgetMax',] }]
        };
        return FormFieldDirective;
    }(StylableComponent));

    var registerProps$O = function () {
        register('wm-header', new Map([
            ['name', PROP_STRING],
            ['class', PROP_STRING],
            ['content', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$r = 'app-header clearfix';
    var WIDGET_CONFIG$v = {
        widgetType: 'wm-header',
        hostClass: DEFAULT_CLS$r
    };
    var HeaderComponent = /** @class */ (function (_super) {
        __extends(HeaderComponent, _super);
        function HeaderComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$v) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        HeaderComponent.initializeProps = registerProps$O();
        HeaderComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmHeader]',
                        template: "<div class=\"app-header-menu\" data-role=\"page-left-panel-icon\">\n    <a class=\"app-header-action\">\n        <i class=\"wi wi-menu\"></i>\n    </a>\n</div>\n<div class=\"app-header-container\" partial-container-target></div>",
                        providers: [
                            provideAsWidgetRef(HeaderComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        HeaderComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return HeaderComponent;
    }(StylableComponent));

    var registerProps$P = function () {
        register('wm-html', new Map([
            ['class', PROP_STRING],
            ['content', PROP_STRING],
            ['hint', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var TrustAsPipe = /** @class */ (function () {
        function TrustAsPipe(domSanitizer) {
            this.domSanitizer = domSanitizer;
        }
        TrustAsPipe.prototype.transform = function (content, as) {
            if (as === 'resource' || as === core$1.SecurityContext.RESOURCE_URL) {
                if (!content) {
                    return '';
                }
                return this.domSanitizer.bypassSecurityTrustResourceUrl(content);
            }
            if (as === 'html' || as === core$1.SecurityContext.HTML) {
                if (content === null || content === undefined) {
                    return '';
                }
                return this.domSanitizer.sanitize(core$1.SecurityContext.HTML, content);
            }
        };
        TrustAsPipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'trustAs'
                    },] }
        ];
        /** @nocollapse */
        TrustAsPipe.ctorParameters = function () {
            return [
                { type: platformBrowser.DomSanitizer }
            ];
        };
        return TrustAsPipe;
    }());

    var DEFAULT_CLS$s = 'app-html-container';
    var WIDGET_CONFIG$w = {
        widgetType: 'wm-html',
        hostClass: DEFAULT_CLS$s
    };
    var HtmlDirective = /** @class */ (function (_super) {
        __extends(HtmlDirective, _super);
        function HtmlDirective(inj, height, boundContent, trustAsPipe) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$w) || this;
            _this.boundContent = boundContent;
            _this.trustAsPipe = trustAsPipe;
            // if the height is provided set the overflow to auto
            if (height) {
                core.setCSS(_this.nativeElement, 'overflow', 'auto');
            }
            styler(_this.nativeElement, _this);
            return _this;
        }
        HtmlDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            if (this.boundContent) {
                this.nativeElement.innerHTML = '';
            }
            if (!this.content && this.nativeElement.innerHTML) {
                this.content = this.nativeElement.innerHTML;
            }
        };
        HtmlDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'content') {
                core.setProperty(this.nativeElement, 'innerHTML', this.trustAsPipe.transform(nv, core$1.SecurityContext.HTML));
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        HtmlDirective.initializeProps = registerProps$P();
        HtmlDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmHtml]',
                        providers: [
                            provideAsWidgetRef(HtmlDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        HtmlDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['height',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['content.bind',] }] },
                { type: TrustAsPipe }
            ];
        };
        return HtmlDirective;
    }(StylableComponent));

    var registerProps$Q = function () {
        register('wm-icon', new Map([
            ['caption', PROP_STRING],
            ['class', PROP_STRING],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['hint', PROP_STRING],
            ['iconclass', __assign({ value: 'wi wi-star-border' }, PROP_STRING)],
            ['iconposition', __assign({ value: 'left' }, PROP_STRING)],
            ['iconsize', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$t = 'app-icon-wrapper';
    var WIDGET_CONFIG$x = {
        widgetType: 'wm-icon',
        hostClass: DEFAULT_CLS$t
    };
    var IconComponent = /** @class */ (function (_super) {
        __extends(IconComponent, _super);
        function IconComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$x) || this;
            styler(_this.nativeElement, _this);
            return _this;
        }
        IconComponent.initializeProps = registerProps$Q();
        IconComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmIcon]',
                        template: "<i class=\"app-icon {{iconclass}}\"></i>\n<span class=\"sr-only\" *ngIf=\"iconclass\">{{caption}} {{appLocale.LABEL_ICON}}</span>\n<label class=\"app-label\" [textContent]=\"caption\" *ngIf=\"caption\"></label>",
                        providers: [
                            provideAsWidgetRef(IconComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        IconComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        IconComponent.propDecorators = {
            iconposition: [{ type: core$1.HostBinding, args: ['attr.icon-position',] }],
            iconsize: [{ type: core$1.HostBinding, args: ['style.fontSize',] }]
        };
        return IconComponent;
    }(StylableComponent));

    var registerProps$R = function () {
        register('wm-iframe', new Map([
            ['class', PROP_STRING],
            ['encodeurl', PROP_BOOLEAN],
            ['height', __assign({ value: '150px' }, PROP_STRING)],
            ['iframesrc', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['width', __assign({ value: '300px' }, PROP_STRING)]
        ]));
    };

    var DEFAULT_CLS$u = 'embed-responsive app-iframe';
    var WIDGET_CONFIG$y = {
        widgetType: 'wm-iframe',
        hostClass: DEFAULT_CLS$u
    };
    var IframeComponent = /** @class */ (function (_super) {
        __extends(IframeComponent, _super);
        function IframeComponent(inj, trustAsPipe) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$y) || this;
            _this.trustAsPipe = trustAsPipe;
            /**
             * this property member is set to true when the content request url doesn't match windows protocol
             */
            _this.showContentLoadError = false;
            styler(_this.nativeElement, _this);
            return _this;
        }
        IframeComponent.prototype.computeIframeSrc = function () {
            this.showContentLoadError = false;
            this._iframesrc = undefined;
            if (this.iframesrc) {
                var url = this.iframesrc;
                if (this.encodeurl) {
                    url = core.encodeUrl(this.iframesrc);
                }
                var trustedUrl = this.trustAsPipe.transform(url, core$1.SecurityContext.RESOURCE_URL);
                if (core.isInsecureContentRequest(url)) {
                    this.showContentLoadError = true;
                    this.errorMsg = this.appLocale.MESSAGE_ERROR_CONTENT_DISPLAY + " " + this.iframesrc;
                    this.hintMsg = this.errorMsg;
                }
                this._iframesrc = trustedUrl;
            }
        };
        IframeComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'iframesrc' || key === 'encodeurl') {
                this.computeIframeSrc();
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        IframeComponent.initializeProps = registerProps$R();
        IframeComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmIframe]',
                        template: "<iframe title=\"\" class=\"embed-responsive-item iframe-content\" role=\"document\"\n        scrolling=\"auto\"\n        marginheight=\"0\"\n        marginwidth=\"0\"\n        frameborder=\"0\"\n        [name]=\"name\"\n        [attr.src]=\"_iframesrc\"\n        seamless=\"seamless\">\n</iframe>\n<div class=\"wm-content-info readonly-wrapper\" *ngIf=\"showContentLoadError\">\n    <p class=\"wm-message\" [title]=\"hintMsg\" [textContent]=\"errMsg\"></p>\n</div>",
                        providers: [
                            provideAsWidgetRef(IframeComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        IframeComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: TrustAsPipe }
            ];
        };
        return IframeComponent;
    }(StylableComponent));

    var registerProps$S = function () {
        register('wm-iframedialog', new Map([
            ['animation', PROP_STRING],
            ['class', PROP_STRING],
            ['closable', { value: true, PROP_BOOLEAN: PROP_BOOLEAN }],
            ['encodeurl', __assign({ value: false }, PROP_BOOLEAN)],
            ['height', __assign({ value: '400px' }, PROP_STRING)],
            ['iconclass', { value: 'wi wi-globe', PROP_STRING: PROP_STRING }],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['modal', __assign({ value: false }, PROP_BOOLEAN)],
            ['name', PROP_STRING],
            ['oktext', __assign({ value: 'OK' }, PROP_STRING)],
            ['showactions', __assign({ value: true }, PROP_BOOLEAN)],
            ['showheader', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', __assign({ value: 'External Content' }, PROP_STRING)],
            ['url', __assign({ value: '//www.wavemaker.com' }, PROP_STRING)]
        ]));
    };

    var DIALOG_CLS$3 = 'app-dialog modal-dialog app-iframe-dialog';
    var WIDGET_INFO$4 = { widgetType: 'wm-iframedialog' };
    var IframeDialogComponent = /** @class */ (function (_super) {
        __extends(IframeDialogComponent, _super);
        function IframeDialogComponent(inj, dialogClass, modal, closable) {
            var _this = this;
            if (modal === null || modal === undefined) {
                modal = false;
            }
            if (closable === null || closable === undefined) {
                closable = true;
            }
            // setting the backdrop to 'static' will not close the dialog on backdrop click
            var backdrop = core.toBoolean(modal) ? 'static' : true;
            _this = _super.call(this, inj, WIDGET_INFO$4, {
                class: DIALOG_CLS$3 + " " + (dialogClass || ''),
                backdrop: backdrop,
                keyboard: !core.toBoolean(modal)
            }) || this;
            return _this;
        }
        IframeDialogComponent.prototype.getTemplateRef = function () {
            return this.dialogTemplate;
        };
        /**
         * Click event handler for the ok button
         * invokes on-ok event callback
         * @param {Event} $event
         */
        IframeDialogComponent.prototype.onOk = function ($event) {
            this.invokeEventCallback('ok', { $event: $event });
        };
        IframeDialogComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.register(this.viewParent);
        };
        IframeDialogComponent.initializeProps = registerProps$S();
        IframeDialogComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmIframeDialog]',
                        template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"\n         *ngIf=\"showheader\"\n    ></div>\n    <div wmDialogBody>\n        <div wmIframe encodeurl.bind=\"encodeurl\" iframesrc.bind=\"url\" height.bind=\"height\" width.bind=\"width\" hint.bind=\"hint\"></div>\n    </div>\n    <div wmDialogFooter *ngIf=\"showactions\">\n        <button wmButton class=\"btn-primary ok-action\" caption.bind=\"oktext\" aria-label=\"Submit button\" (click)=\"onOk($event)\"></button>\n    </div>\n</ng-template>\n",
                        providers: [
                            provideAsWidgetRef(IframeDialogComponent),
                            provideAsDialogRef(IframeDialogComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        IframeDialogComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['class',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['modal',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['closable',] }] }
            ];
        };
        IframeDialogComponent.propDecorators = {
            dialogTemplate: [{ type: core$1.ViewChild, args: ['dialogTemplate',] }]
        };
        return IframeDialogComponent;
    }(BaseDialog));

    var ImagePipe = /** @class */ (function () {
        function ImagePipe() {
        }
        ImagePipe.prototype.transform = function (url, encode, defaultImageUrl) {
            return getImageUrl(url, encode, defaultImageUrl);
        };
        ImagePipe.decorators = [
            { type: core$1.Pipe, args: [{
                        name: 'image'
                    },] }
        ];
        return ImagePipe;
    }());

    var WIDGET_CONFIG$z = {
        widgetType: 'wm-input-calendar',
        hostClass: 'app-input-wrapper'
    };
    var InputCalendarComponent = /** @class */ (function (_super) {
        __extends(InputCalendarComponent, _super);
        function InputCalendarComponent(inj) {
            return _super.call(this, inj, WIDGET_CONFIG$z) || this;
        }
        InputCalendarComponent.initializeProps = registerProps$C();
        InputCalendarComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'wm-input[type="date"], wm-input[type="datetime-local"], wm-input[type="month"], wm-input[type="time"], wm-input[type="week"]',
                        template: "<input class=\"form-control app-textbox\"\n       focus-target\n       role=\"input\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [min]=\"minvalue\"\n       [max]=\"maxvalue\"\n       [step]=\"step\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"handleChange($event)\"\n       [autocomplete]=\"autocomplete ? 'on' : 'off'\"\n       #input>\n",
                        providers: [
                            provideAsNgValueAccessor(InputCalendarComponent),
                            provideAsWidgetRef(InputCalendarComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        InputCalendarComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        InputCalendarComponent.propDecorators = {
            inputEl: [{ type: core$1.ViewChild, args: ['input',] }],
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }]
        };
        return InputCalendarComponent;
    }(BaseInput));

    var WIDGET_CONFIG$A = {
        widgetType: 'wm-input-color',
        hostClass: 'app-input-wrapper'
    };
    var InputColorComponent = /** @class */ (function (_super) {
        __extends(InputColorComponent, _super);
        function InputColorComponent(inj) {
            return _super.call(this, inj, WIDGET_CONFIG$A) || this;
        }
        InputColorComponent.initializeProps = registerProps$D();
        InputColorComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'wm-input[type="color"]',
                        template: "<input class=\"form-control app-textbox\"\n       focus-target\n       type=\"color\"\n       role=\"input\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [maxlength]=\"maxchars\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"handleChange($event)\"\n       #input>",
                        providers: [
                            provideAsNgValueAccessor(InputColorComponent),
                            provideAsWidgetRef(InputColorComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        InputColorComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        InputColorComponent.propDecorators = {
            inputEl: [{ type: core$1.ViewChild, args: ['input',] }],
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }]
        };
        return InputColorComponent;
    }(BaseInput));

    var WIDGET_CONFIG$B = {
        widgetType: 'wm-input-email',
        hostClass: 'app-input-wrapper'
    };
    var InputEmailComponent = /** @class */ (function (_super) {
        __extends(InputEmailComponent, _super);
        function InputEmailComponent(inj) {
            return _super.call(this, inj, WIDGET_CONFIG$B) || this;
        }
        InputEmailComponent.initializeProps = registerProps$E();
        InputEmailComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'wm-input[type="email"]',
                        template: "<input class=\"form-control app-textbox\"\n       focus-target\n       role=\"input\"\n       type=\"email\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [ngModelOptions]=\"ngModelOptions\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [maxlength]=\"maxchars\"\n       [pattern]=\"regexp\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"handleChange($event)\"\n       [autocomplete]=\"autocomplete ? 'on' : 'off'\"\n       (keyup.enter)=\"flushViewChanges(input.value)\"\n       email\n       #input>",
                        providers: [
                            provideAsNgValueAccessor(InputEmailComponent),
                            provideAsWidgetRef(InputEmailComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        InputEmailComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        InputEmailComponent.propDecorators = {
            inputEl: [{ type: core$1.ViewChild, args: ['input',] }],
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }]
        };
        return InputEmailComponent;
    }(BaseInput));

    var WIDGET_CONFIG$C = {
        widgetType: 'wm-input-number',
        hostClass: 'app-input-wrapper'
    };
    var InputNumberComponent = /** @class */ (function (_super) {
        __extends(InputNumberComponent, _super);
        function InputNumberComponent(inj) {
            return _super.call(this, inj, WIDGET_CONFIG$C) || this;
        }
        InputNumberComponent.prototype.onArrowPress = function ($event) {
            if (this.step === 0) {
                $event.preventDefault();
            }
        };
        InputNumberComponent.prototype.validateInputEntry = function ($event) {
            if ($event.key === 'e' && $event.target.value.indexOf($event.key) !== -1) {
                return false;
            }
        };
        InputNumberComponent.initializeProps = registerProps$A();
        InputNumberComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'wm-input[type="number"]',
                        template: "<input class=\"form-control app-textbox\"\n       [ngClass]=\"{'step-hidden': step === 0}\"\n       focus-target\n       role=\"input\"\n       type=\"number\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [ngModelOptions]=\"ngModelOptions\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [maxlength]=\"maxchars\"\n       [min]=\"minvalue\"\n       [max]=\"maxvalue\"\n       [step]=\"step\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"handleChange($event)\"\n       [autocomplete]=\"autocomplete ? 'on' : 'off'\"\n       (keyup.enter)=\"flushViewChanges(input.value)\"\n       (keydown.ArrowUp)=\"onArrowPress($event)\"\n       (keydown.ArrowDown)=\"onArrowPress($event)\"\n       (keypress)=\"validateInputEntry($event)\"\n       #input>",
                        providers: [
                            provideAsNgValueAccessor(InputNumberComponent),
                            provideAsWidgetRef(InputNumberComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        InputNumberComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        InputNumberComponent.propDecorators = {
            inputEl: [{ type: core$1.ViewChild, args: ['input',] }],
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }]
        };
        return InputNumberComponent;
    }(BaseInput));

    var WIDGET_CONFIG$D = {
        widgetType: 'wm-input-text',
        hostClass: 'app-input-wrapper'
    };
    var InputTextComponent = /** @class */ (function (_super) {
        __extends(InputTextComponent, _super);
        function InputTextComponent(inj) {
            return _super.call(this, inj, WIDGET_CONFIG$D) || this;
        }
        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        InputTextComponent.prototype.onPropertyChange = function (key, nv, ov) {
            var _this = this;
            /*Monitoring changes for styles or properties and accordingly handling respective changes.*/
            switch (key) {
                case 'displayformat':
                    this.maskVal = [];
                    _.forEach(this.displayformat, function (dF) {
                        // This condition is used to support all numbers from 0-9
                        if (dF === '9') {
                            _this.maskVal.push(/\d/);
                        }
                        // This condition is used to support all capital and small alphabets
                        else if (dF === 'A') {
                            _this.maskVal.push(/[A-Z, a-z]/);
                        }
                        // This condition is used to support all small alphabets
                        else if (dF === 'a') {
                            _this.maskVal.push(/[a-z]/);
                        }
                        // This condition is used to support all characters except new line
                        else if (dF === '*') {
                            _this.maskVal.push(/\w/);
                        }
                        else {
                            _this.maskVal.push(dF);
                        }
                    });
                    break;
                default:
                    _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        Object.defineProperty(InputTextComponent.prototype, "mask", {
            get: function () {
                if (this.displayformat) {
                    return { mask: this.maskVal, showMask: true };
                }
                else {
                    return { mask: false };
                }
            },
            enumerable: true,
            configurable: true
        });
        InputTextComponent.initializeProps = registerProps$B();
        InputTextComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'wm-input[type="text"], wm-input:not([type]), wm-input[type="password"], wm-input[type="search"], wm-input[type="tel"], wm-input[type="url"]',
                        template: "<input class=\"form-control app-textbox\"\n       focus-target\n       role=\"input\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [textMask]=\"mask\"\n       [ngModelOptions]=\"ngModelOptions\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [maxlength]=\"maxchars\"\n       [pattern]=\"regexp\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (ngModelChange)=\"handleChange($event)\"\n       (blur)=\"handleBlur($event)\"\n       [autocomplete]=\"autocomplete ? 'on' : 'off'\"\n       (keyup.enter)=\"flushViewChanges(input.value)\"\n       #input>",
                        providers: [
                            provideAsNgValueAccessor(InputTextComponent),
                            provideAsWidgetRef(InputTextComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        InputTextComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        InputTextComponent.propDecorators = {
            inputEl: [{ type: core$1.ViewChild, args: ['input',] }],
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }]
        };
        return InputTextComponent;
    }(BaseInput));

    var registerProps$T = function () {
        register('wm-table', new Map([
            ['boundarylinks', __assign({ value: false }, PROP_BOOLEAN)],
            ['class', PROP_STRING],
            ['confirmdelete', __assign({ value: 'Are you sure you want to delete this?' }, PROP_STRING)],
            ['datasource', PROP_STRING],
            ['dataset', PROP_ANY],
            ['deletecanceltext', PROP_STRING],
            ['deleteoktext', PROP_STRING],
            ['deletemessage', __assign({ value: 'Record deleted successfully' }, PROP_STRING)],
            ['directionlinks', __assign({ value: true }, PROP_BOOLEAN)],
            ['editmode', PROP_STRING],
            ['enablecolumnselection', __assign({ value: false }, PROP_BOOLEAN)],
            ['enablesort', __assign({ value: true }, PROP_BOOLEAN)],
            ['errormessage', PROP_STRING],
            ['exportformat', PROP_STRING],
            ['exportdatasize', __assign({ value: 100 }, PROP_NUMBER)],
            ['filtermode', PROP_STRING],
            ['filternullrecords', __assign({ value: true }, PROP_BOOLEAN)],
            ['forceellipses', __assign({ value: true }, PROP_BOOLEAN)],
            ['formposition', PROP_STRING],
            ['gridclass', __assign({ value: 'table-bordered table-striped table-hover' }, PROP_STRING)],
            ['gridfirstrowselect', PROP_BOOLEAN],
            ['iconclass', PROP_STRING],
            ['insertmessage', __assign({ value: 'Record added successfully' }, PROP_STRING)],
            ['isdynamictable', PROP_BOOLEAN],
            ['loadingdatamsg', __assign({ value: 'Loading...' }, PROP_STRING)],
            ['loadingicon', __assign({ value: 'fa fa-circle-o-notch fa-spin' }, PROP_STRING)],
            ['maxsize', __assign({ value: 5 }, PROP_NUMBER)],
            ['multiselect', PROP_BOOLEAN],
            ['name', PROP_STRING],
            ['navigation', __assign({ value: 'Basic' }, PROP_STRING)],
            ['navigationalign', __assign({ value: 'left' }, PROP_STRING)],
            ['nodatamessage', __assign({ value: 'No data found.' }, PROP_STRING)],
            ['pagesize', PROP_NUMBER],
            ['radioselect', PROP_BOOLEAN],
            ['rowclass', PROP_STRING],
            ['rowngclass', PROP_STRING],
            ['searchlabel', __assign({ value: 'Search' }, PROP_STRING)],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['showheader', __assign({ value: true }, PROP_BOOLEAN)],
            ['shownewrow', __assign({ value: true }, PROP_BOOLEAN)],
            ['showrecordcount', PROP_BOOLEAN],
            ['showrowindex', PROP_BOOLEAN],
            ['spacing', __assign({ value: 'normal' }, PROP_STRING)],
            ['subheading', PROP_STRING],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', PROP_STRING],
            ['updatemessage', __assign({ value: 'Record updated successfully' }, PROP_STRING)]
        ]));
    };

    var DEFAULT_CLS$v = 'app-grid app-panel panel';
    var WIDGET_CONFIG$E = { widgetType: 'wm-table', hostClass: DEFAULT_CLS$v };
    var exportIconMapping = {
        EXCEL: 'fa fa-file-excel-o',
        CSV: 'fa fa-file-text-o'
    };
    var ROW_OPS_FIELD = 'rowOperations';
    var noop$1 = function () { };
    var isInputBodyWrapper = function (target) {
        var classes = ['.dropdown-menu', '.uib-typeahead-match', '.modal-dialog', '.toast'];
        var isInput = false;
        classes.forEach(function (cls) {
            if (target.closest(cls).length) {
                isInput = true;
                return false;
            }
        });
        var attrs = ['bsdatepickerdaydecorator'];
        if (!isInput) {
            attrs.forEach(function (attr) {
                if (target[0].hasAttribute(attr)) {
                    isInput = true;
                    return false;
                }
            });
        }
        return isInput;
    };
    var TableComponent = /** @class */ (function (_super) {
        __extends(TableComponent, _super);
        function TableComponent(inj, fb, app, dynamicComponentProvider, binddataset, binddatasource, readonlygrid, ngZone) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$E) || this;
            _this.inj = inj;
            _this.fb = fb;
            _this.app = app;
            _this.dynamicComponentProvider = dynamicComponentProvider;
            _this.binddataset = binddataset;
            _this.binddatasource = binddatasource;
            _this.readonlygrid = readonlygrid;
            _this.ngZone = ngZone;
            _this.rowActionsCompiledTl = {};
            _this.rowFilterCompliedTl = {};
            _this.inlineCompliedTl = {};
            _this.inlineNewCompliedTl = {};
            _this.customExprCompiledTl = {};
            _this.rowDefInstances = {};
            _this.rowDefMap = {};
            _this.rowExpansionActionTl = {};
            _this.columns = {};
            _this.formfields = {};
            _this.enablesort = true;
            _this.selectedItems = [];
            _this.selectedItemChange = new rxjs.Subject();
            _this.selectedItemChange$ = _this.selectedItemChange.asObservable();
            _this.actions = [];
            _this._actions = {
                'header': [],
                'footer': []
            };
            _this.exportOptions = [];
            _this.headerConfig = [];
            _this.items = [];
            _this.rowActions = [];
            _this.shownavigation = false;
            _this.documentClickBind = noop$1;
            _this.fieldDefs = [];
            _this.rowDef = {};
            _this.rowInstance = {};
            _this.fullFieldDefs = [];
            _this.applyProps = new Map();
            _this.redraw = _.debounce(_this._redraw, 150);
            _this.debouncedHandleLoading = _.debounce(_this.handleLoading, 350);
            // Filter and Sort Methods
            _this.rowFilter = {};
            _this._searchSortHandler = noop$1;
            _this.searchSortHandler = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                _this._searchSortHandler.apply(_this, args);
            };
            _this.onRowFilterChange = noop$1;
            _this.onFilterConditionSelect = noop$1;
            _this.showClearIcon = noop$1;
            _this.clearRowFilter = noop$1;
            _this.gridOptions = {
                data: [],
                colDefs: [],
                startRowIndex: 1,
                sortInfo: {
                    field: '',
                    direction: ''
                },
                filtermode: '',
                searchLabel: '',
                rowActions: [],
                headerConfig: [],
                rowClass: '',
                editmode: '',
                formPosition: '',
                isMobile: false,
                rowExpansionEnabled: false,
                rowDef: {
                    position: '0'
                },
                name: '',
                messages: {
                    selectField: 'Select Field'
                },
                onDataRender: function () {
                    _this.ngZone.run(function () {
                        if (_this.gridData.length) {
                            _this.invokeEventCallback('datarender', { $data: _this.gridData, data: _this.gridData });
                        }
                        // select rows selected in previous pages. (Not finding intersection of data and selecteditems as it will be heavy)
                        if (!_this.multiselect) {
                            _this.items.length = 0;
                        }
                        _this.callDataGridMethod('selectRows', _this.items);
                        _this.selectedItems = _this.callDataGridMethod('getSelectedRows');
                        _this.selectedItemChange.next(_this.selectedItems);
                        // On render, apply the filters set for query service variable
                        if (_this._isPageSearch && _this.filterInfo) {
                            _this.searchSortHandler(_this.filterInfo, undefined, 'search');
                        }
                    });
                },
                onRowSelect: function (row, e) {
                    _this.ngZone.run(function () {
                        _this.selectedItems = _this.callDataGridMethod('getSelectedRows');
                        _this.selectedItemChange.next(_this.selectedItems);
                        var rowData = _this.addRowIndex(row);
                        _this.invokeEventCallback('rowselect', { $data: rowData, $event: e, row: rowData });
                    });
                },
                // assigns the items on capture phase of the click handler.
                assignSelectedItems: function (row, e) {
                    _this.ngZone.run(function () {
                        /*
                         * in case of single select, update the items with out changing the reference.
                         * for multi select, keep old selected items in tact
                         */
                        if (_this.multiselect) {
                            if (_.findIndex(_this.items, row) === -1) {
                                _this.items.push(row);
                            }
                        }
                        else {
                            _this.items.length = 0;
                            _this.items.push(row);
                        }
                    });
                },
                onRowDblClick: function (row, e) {
                    var rowData = _this.addRowIndex(row);
                    _this.invokeEventCallback('rowdblclick', { $data: rowData, $event: e, row: rowData });
                },
                onRowDeselect: function (row, e) {
                    if (_this.multiselect) {
                        _this.ngZone.run(function () {
                            _this.items = _.pullAllWith(_this.items, [row], _.isEqual);
                            _this.selectedItems = _this.callDataGridMethod('getSelectedRows');
                            _this.invokeEventCallback('rowdeselect', { $data: row, $event: e, row: row });
                        });
                    }
                },
                callOnRowDeselectEvent: function (row, e) {
                    _this.invokeEventCallback('rowdeselect', { $data: row, $event: e, row: row });
                },
                callOnRowClickEvent: function (row, e) {
                    // Call row click only if click is triggered by user
                    if (e && e.hasOwnProperty('originalEvent')) {
                        var rowData = _this.addRowIndex(row);
                        _this.invokeEventCallback('rowclick', { $data: rowData, $event: e, row: rowData });
                    }
                },
                closePopover: core.closePopover,
                onColumnSelect: function (col, e) {
                    _this.selectedColumns = _this.callDataGridMethod('getSelectedColumns');
                    _this.invokeEventCallback('columnselect', { $data: col, $event: e });
                },
                onColumnDeselect: function (col, e) {
                    _this.selectedColumns = _this.callDataGridMethod('getSelectedColumns');
                    _this.invokeEventCallback('columndeselect', { $data: col, $event: e });
                },
                onHeaderClick: function (col, e) {
                    // if onSort function is registered invoke it when the column header is clicked
                    _this.invokeEventCallback('headerclick', { $event: e, $data: col, column: col });
                },
                onRowDelete: function (row, cancelRowDeleteCallback, e, callBack, options) {
                    _this.ngZone.run(function () {
                        _this.deleteRecord(_.extend({}, options, { row: row, 'cancelRowDeleteCallback': cancelRowDeleteCallback, 'evt': e, 'callBack': callBack }));
                    });
                },
                onRowInsert: function (row, e, callBack, options) {
                    _this.insertRecord(_.extend({}, options, { row: row, event: e, 'callBack': callBack }));
                },
                beforeRowUpdate: function (row, eventName) {
                    if (_this._liveTableParent) {
                        _this._liveTableParent.updateRow(row, eventName);
                    }
                    _this.prevData = core.getClonedObject(row);
                },
                afterRowUpdate: function (row, e, callBack, options) {
                    _this.updateRecord(_.extend({}, options, { row: row, 'prevData': _this.prevData, 'event': e, 'callBack': callBack }));
                },
                onBeforeRowUpdate: function (row, e, options) {
                    return _this.invokeEventCallback('beforerowupdate', { $event: e, $data: row, row: row, options: options });
                },
                onBeforeRowInsert: function (row, e, options) {
                    return _this.invokeEventCallback('beforerowinsert', { $event: e, $data: row, row: row, options: options });
                },
                onBeforeRowDelete: function (row, e, options) {
                    var rowData = _this.addRowIndex(row);
                    return _this.invokeEventCallback('beforerowdelete', { $event: e, row: rowData, options: options });
                },
                onFormRender: function ($row, e, operation, alwaysNewRow) {
                    var widget = alwaysNewRow ? 'inlineInstanceNew' : 'inlineInstance';
                    setTimeout(function () {
                        _this.formWidgets = {};
                        _this.fieldDefs.forEach(function (col) {
                            if (col[widget]) {
                                _this.formWidgets[col.field] = col[widget];
                                _this.setDisabledOnField(operation, col, widget);
                            }
                        });
                        _this.invokeEventCallback('formrender', { $event: e, formWidgets: _this.formWidgets, $operation: operation });
                    }, 250);
                },
                onBeforeFormRender: function (row, e, operation) {
                    return _this.invokeEventCallback('beforeformrender', { $event: e, row: row, $operation: operation });
                },
                registerRowNgClassWatcher: function (rowData, index) {
                    if (!_this.rowngclass) {
                        return;
                    }
                    var row = _this.getClonedRowObject(rowData);
                    var watchName = _this.widgetId + "_rowNgClass_" + index;
                    core.$unwatch(watchName);
                    _this.registerDestroyListener(core.$watch(_this.rowngclass, _this.viewParent, { row: row }, function (nv, ov) {
                        _this.callDataGridMethod('applyRowNgClass', getConditionalClasses(nv, ov), index);
                    }, watchName));
                },
                registerColNgClassWatcher: function (rowData, colDef, rowIndex, colIndex) {
                    if (!colDef['col-ng-class']) {
                        return;
                    }
                    var row = _this.getClonedRowObject(rowData);
                    var watchName = _this.widgetId + "_colNgClass_" + rowIndex + "_" + colIndex;
                    core.$unwatch(watchName);
                    _this.registerDestroyListener(core.$watch(colDef['col-ng-class'], _this.viewParent, { row: row }, function (nv, ov) {
                        _this.callDataGridMethod('applyColNgClass', getConditionalClasses(nv, ov), rowIndex, colIndex);
                    }, watchName));
                },
                clearCustomExpression: function () {
                    _this.customExprViewRef.clear();
                    _this.customExprCompiledTl = {};
                },
                clearRowDetailExpression: function () {
                    _this.rowDetailViewRef.clear();
                    _this.rowDefMap = {};
                    _this.rowDefInstances = {};
                },
                generateCustomExpressions: function (rowData, index) {
                    var row = _this.getClonedRowObject(rowData);
                    var compileTemplate = function (tmpl) {
                        if (!tmpl) {
                            return;
                        }
                        var colDef = {};
                        var context = {
                            row: row,
                            colDef: colDef
                        };
                        _this.addEventsToContext(context);
                        var customExprView = _this.customExprViewRef.createEmbeddedView(tmpl, context);
                        var rootNode = customExprView.rootNodes[0];
                        var fieldName = rootNode.getAttribute('data-col-identifier');
                        _.extend(colDef, _this.columns[fieldName]);
                        _this.customExprCompiledTl[fieldName + index] = rootNode;
                    };
                    if (_this.isdynamictable) {
                        _this.fieldDefs.forEach(function (col) {
                            compileTemplate(col.customExprTmpl);
                        });
                        return;
                    }
                    // For all the columns inside the table, generate the custom expression
                    _this.customExprTmpl.forEach(compileTemplate.bind(_this));
                },
                generateRowExpansionCell: function (rowData, index) {
                    var row = _this.getClonedRowObject(rowData);
                    // For all the columns inside the table, generate the inline widget
                    _this.rowExpansionActionTmpl.forEach(function (tmpl) {
                        _this.rowExpansionActionTl[index] = _this.rowExpansionActionViewRef.createEmbeddedView(tmpl, { row: row }).rootNodes;
                    });
                },
                getRowExpansionAction: function (index) {
                    return _this.rowExpansionActionTl[index];
                },
                generateRowDetailView: function ($event, rowData, rowId, $target, $overlay, callback) {
                    var row = _this.getClonedRowObject(rowData);
                    var rowDef = core.getClonedObject(_this.rowDef);
                    if (_this.rowInstance.invokeEventCallback('beforerowexpand', { $event: $event, $data: rowDef, row: row }) === false) {
                        return;
                    }
                    if (!rowDef.content) {
                        return;
                    }
                    // Expand the row detail
                    callback();
                    // Row is already rendered. Return here
                    if (_this.rowDefMap[rowId] && _this.rowDefMap[rowId].content === rowDef.content) {
                        _this.rowInstance.invokeEventCallback('rowexpand', { $event: $event, row: row, $data: _this.rowDefInstances[rowId] });
                        return;
                    }
                    _this.rowDefMap[rowId] = rowDef;
                    $target.empty();
                    $target.hide();
                    $overlay.show();
                    var context = {
                        row: row,
                        rowDef: rowDef,
                        containerLoad: function (widget) {
                            setTimeout(function () {
                                $overlay.hide();
                                $target.show();
                                _this.rowDefInstances[rowId] = widget;
                                _this.rowInstance.invokeEventCallback('rowexpand', { $event: $event, row: row, $data: widget });
                            }, 500);
                        }
                    };
                    var rootNode = _this.rowDetailViewRef.createEmbeddedView(_this.rowExpansionTmpl, context).rootNodes[0];
                    $target[0].appendChild(rootNode);
                    core.$appDigest();
                },
                onBeforeRowCollapse: function ($event, row, rowId) {
                    return _this.rowInstance.invokeEventCallback('beforerowcollapse', { $event: $event, row: row, $data: _this.rowDefInstances[rowId] });
                },
                onRowCollapse: function ($event, row) {
                    _this.rowInstance.invokeEventCallback('rowcollapse', { $event: $event, row: row });
                },
                getCustomExpression: function (fieldName, index) {
                    return _this.customExprCompiledTl[fieldName + index] || '';
                },
                clearRowActions: function () {
                    _this.rowActionsViewRef.clear();
                    _this.rowActionsCompiledTl = {};
                    _this.rowExpansionActionViewRef.clear();
                    _this.rowExpansionActionTl = {};
                },
                generateRowActions: function (rowData, index) {
                    var row = _this.getClonedRowObject(rowData);
                    _this.rowActionsCompiledTl[index] = [];
                    // For all the columns inside the table, generate the inline widget
                    _this.rowActionTmpl.forEach(function (tmpl) {
                        var _a;
                        (_a = _this.rowActionsCompiledTl[index]).push.apply(_a, __spread(_this.rowActionsViewRef.createEmbeddedView(tmpl, { row: row }).rootNodes));
                    });
                },
                getRowAction: function (index) {
                    return _this.rowActionsCompiledTl[index];
                },
                generateInlineEditRow: function (rowData, alwaysNewRow) {
                    var row = _this.getClonedRowObject(rowData);
                    if (alwaysNewRow) {
                        // Clear the view container ref
                        _this.inlineEditNewViewRef.clear();
                        _this.inlineNewCompliedTl = {};
                        // For all the columns inside the table, generate the inline widget
                        _this.inlineWidgetNewTmpl.forEach(function (tmpl) {
                            var fieldName;
                            var context = {
                                row: row,
                                getControl: function () {
                                    return _this.ngform.controls[fieldName + '_new'] || {};
                                },
                                getValidationMessage: function () {
                                    return _this.columns[fieldName] && _this.columns[fieldName].validationmessage;
                                }
                            };
                            var rootNode = _this.inlineEditNewViewRef.createEmbeddedView(tmpl, context).rootNodes[0];
                            fieldName = rootNode.getAttribute('data-col-identifier');
                            _this.inlineNewCompliedTl[fieldName] = rootNode;
                        });
                        _this.clearForm(true);
                        return;
                    }
                    // Clear the view container ref
                    _this.inlineEditViewRef.clear();
                    _this.inlineCompliedTl = {};
                    _this.clearForm();
                    // For all the columns inside the table, generate the inline widget
                    _this.inlineWidgetTmpl.forEach(function (tmpl) {
                        var fieldName;
                        var context = {
                            row: row,
                            getControl: function () {
                                return _this.ngform.controls[fieldName] || {};
                            },
                            getValidationMessage: function () {
                                return _this.columns[fieldName] && _this.columns[fieldName].validationmessage;
                            }
                        };
                        var rootNode = _this.inlineEditViewRef.createEmbeddedView(tmpl, context).rootNodes[0];
                        fieldName = rootNode.getAttribute('data-col-identifier');
                        _this.inlineCompliedTl[fieldName] = rootNode;
                    });
                },
                getInlineEditWidget: function (fieldName, value, alwaysNewRow) {
                    if (alwaysNewRow) {
                        _this.gridOptions.setFieldValue(fieldName + '_new', value);
                        return _this.inlineNewCompliedTl[fieldName];
                    }
                    _this.gridOptions.setFieldValue(fieldName, value);
                    return _this.inlineCompliedTl[fieldName];
                },
                setFieldValue: function (fieldName, value) {
                    var control = _this.ngform.controls && _this.ngform.controls[fieldName];
                    if (control) {
                        control.setValue(value);
                    }
                },
                getFieldValue: function (fieldName) {
                    var control = _this.ngform.controls && _this.ngform.controls[fieldName];
                    return control && control.value;
                },
                generateFilterRow: function () {
                    // Clear the view container ref
                    _this.filterViewRef.clear();
                    _this.rowFilterCompliedTl = {};
                    // For all the columns inside the table, generate the compiled filter template
                    _this.filterTmpl.forEach(function (tmpl) {
                        var rootNode = _this.filterViewRef.createEmbeddedView(tmpl, {
                            changeFn: _this.onRowFilterChange.bind(_this),
                            isDisabled: function (fieldName) {
                                return _this.emptyMatchModes.indexOf(_this.rowFilter[fieldName] && _this.rowFilter[fieldName].matchMode) > -1;
                            }
                        }).rootNodes[0];
                        _this.rowFilterCompliedTl[rootNode.getAttribute('data-col-identifier')] = rootNode;
                    });
                },
                getFilterWidget: function (fieldName) {
                    // Move the generated filter template to the filter row
                    return _this.rowFilterCompliedTl[fieldName];
                },
                setGridEditMode: function (val) {
                    _this.ngZone.run(function () {
                        _this.isGridEditMode = val;
                        core.$appDigest();
                    });
                },
                setGridState: function (val) {
                    _this.isLoading = val === 'loading';
                },
                noChangesDetected: function () {
                    _this.toggleMessage(true, 'info', 'No Changes Detected');
                },
                // Function to redraw the widgets on resize of columns
                redrawWidgets: function () {
                    _this.fieldDefs.forEach(function (col) {
                        core.triggerFn(col.inlineInstance && col.inlineInstance.redraw);
                        core.triggerFn(col.inlineInstanceNew && col.inlineInstanceNew.redraw);
                        core.triggerFn(col.filterInstance && col.filterInstance.redraw);
                    });
                },
                searchHandler: _this.searchSortHandler.bind(_this),
                sortHandler: _this.searchSortHandler.bind(_this),
                timeoutCall: function (fn, delay) {
                    setTimeout(fn, delay);
                },
                runInNgZone: function (fn) {
                    _this.ngZone.run(fn);
                },
                safeApply: function () {
                    core.$appDigest();
                },
                setTouched: function (name) {
                    var ctrl = _this.ngform.controls[name];
                    if (ctrl) {
                        ctrl.markAsTouched();
                    }
                },
                clearForm: _this.clearForm.bind(_this)
            };
            _this._onChange = function () { };
            _this._onTouched = function () { };
            styler(_this.nativeElement, _this);
            _this.ngform = fb.group({});
            _this.addEventsToContext(_this.context);
            // Show loading status based on the variable life cycle
            _this.app.subscribe('toggle-variable-state', function (options) {
                if (_this.datasource && _this.datasource.execute(core.DataSource.Operation.IS_API_AWARE) && core.isDataSourceEqual(options.variable, _this.datasource)) {
                    core.isDefined(_this.variableInflight) ? _this.debouncedHandleLoading(options) : _this.handleLoading(options);
                }
            });
            _this.deleteoktext = _this.appLocale.LABEL_OK;
            _this.deletecanceltext = _this.appLocale.LABEL_CANCEL;
            return _this;
        }
        Object.defineProperty(TableComponent.prototype, "gridData", {
            get: function () {
                return this._gridData || [];
            },
            set: function (newValue) {
                this._gridData = newValue;
                var startRowIndex = 0;
                var gridOptions;
                this._onChange(newValue);
                this._onTouched();
                if (core.isDefined(newValue)) {
                    /*Setting the serial no's only when show navigation is enabled and data navigator is compiled
                     and its current page is set properly*/
                    if (this.isNavigationEnabled() && this.dataNavigator.dn.currentPage) {
                        startRowIndex = ((this.dataNavigator.dn.currentPage - 1) * (this.dataNavigator.maxResults || 1)) + 1;
                        this.setDataGridOption('startRowIndex', startRowIndex);
                    }
                    /* If colDefs are available, but not already set on the datagrid, then set them.
                     * This will happen while switching from markup to design tab. */
                    gridOptions = this.callDataGridMethod('getOptions');
                    if (!gridOptions) {
                        return;
                    }
                    if (!gridOptions.colDefs.length && this.fieldDefs.length) {
                        this.setDataGridOption('colDefs', core.getClonedObject(this.fieldDefs));
                    }
                    // If data and colDefs are present, call on before data render event
                    if (!this.isdynamictable && !_.isEmpty(newValue) && gridOptions.colDefs.length) {
                        this.invokeEventCallback('beforedatarender', { $data: newValue, $columns: this.columns, data: newValue, columns: this.columns });
                    }
                    this.setDataGridOption('data', core.getClonedObject(newValue));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "selecteditem", {
            get: function () {
                if (this.multiselect) {
                    return core.getClonedObject(this.items);
                }
                if (_.isEmpty(this.items)) {
                    return {};
                }
                return core.getClonedObject(this.items[0]);
            },
            set: function (val) {
                // Select the rows in the table based on the new selected items passed
                this.items.length = 0;
                this.callDataGridMethod('selectRows', val);
            },
            enumerable: true,
            configurable: true
        });
        TableComponent.prototype.onKeyPress = function ($event) {
            if ($event.which === 13) {
                this.invokeEventCallback('enterkeypress', { $event: $event, $data: this.gridData });
            }
        };
        TableComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            _super.prototype.ngAfterContentInit.call(this);
            var runModeInitialProperties = {
                showrowindex: 'showRowIndex',
                multiselect: 'multiselect',
                radioselect: 'showRadioColumn',
                filternullrecords: 'filterNullRecords',
                enablesort: 'enableSort',
                showheader: 'showHeader',
                enablecolumnselection: 'enableColumnSelection',
                shownewrow: 'showNewRow',
                gridfirstrowselect: 'selectFirstRow'
            };
            if (this._liveTableParent) {
                this.isPartOfLiveGrid = true;
            }
            if (this.readonlygrid || !this.editmode) {
                if (this.readonlygrid === 'true') {
                    this.editmode = '';
                }
                else {
                    if (this.isPartOfLiveGrid) {
                        this.editmode = this.isPartOfLiveGrid.formlayout === 'inline' ? EDIT_MODE.FORM : EDIT_MODE.DIALOG;
                    }
                    else {
                        this.editmode = this.readonlygrid ? EDIT_MODE.INLINE : '';
                    }
                }
            }
            this.gridOptions.colDefs = this.fullFieldDefs;
            this.gridOptions.rowActions = this.rowActions;
            this.gridOptions.headerConfig = this.headerConfig;
            this.gridOptions.rowClass = this.rowclass;
            this.gridOptions.editmode = this.editmode;
            this.gridOptions.formPosition = this.formposition;
            this.gridOptions.filtermode = this.filtermode;
            this.gridOptions.searchLabel = this.searchlabel;
            this.gridOptions.isMobile = core.isMobile();
            this.gridOptions.name = this.name;
            // When loadondemand property is enabled(deferload="true") and show is true, only the column titles of the datatable are rendered, the data(body of the datatable) is not at all rendered.
            // Because the griddata is setting before the datatable dom is rendered but we are sending empty data to the datatable.
            if (!_.isEmpty(this.gridData)) {
                this.gridOptions.data = core.getClonedObject(this.gridData);
            }
            this.gridOptions.messages = {
                'selectField': 'Select Field'
            };
            this.datagridElement = $(this._tableElement.nativeElement);
            this.gridElement = this.$element;
            this.$element.css({ 'position': 'relative' });
            _.forEach(runModeInitialProperties, function (value, key) {
                if (core.isDefined(_this[key])) {
                    _this.gridOptions[value] = (_this[key] === 'true' || _this[key] === true);
                }
            });
            this.renderOperationColumns();
            this.gridOptions.colDefs = this.fieldDefs;
            this.datagridElement.datatable(this.gridOptions);
            this.callDataGridMethod('setStatus', 'loading', this.loadingdatamsg);
            this.applyProps.forEach(function (args) { return _this.callDataGridMethod.apply(_this, __spread(args)); });
            if (this.editmode === EDIT_MODE.QUICK_EDIT) {
                this.documentClickBind = this._documentClickBind.bind(this);
                document.addEventListener('click', this.documentClickBind);
            }
        };
        TableComponent.prototype.ngOnDestroy = function () {
            document.removeEventListener('click', this.documentClickBind);
            if (this.navigatorResultWatch) {
                this.navigatorResultWatch.unsubscribe();
            }
            if (this.navigatorMaxResultWatch) {
                this.navigatorMaxResultWatch.unsubscribe();
            }
            _super.prototype.ngOnDestroy.call(this);
        };
        TableComponent.prototype.addRowIndex = function (row) {
            var rowData = core.getClonedObject(row);
            var rowIndex = _.indexOf(this.gridOptions.data, row);
            if (rowIndex < 0) {
                return row;
            }
            rowData.$index = rowIndex + 1;
            rowData.$isFirst = rowData.$index === 1;
            rowData.$isLast = this.gridData.length === rowData.$index;
            return rowData;
        };
        TableComponent.prototype.addEventsToContext = function (context) {
            var _this = this;
            context.addNewRow = function () { return _this.addNewRow(); };
            context.deleteRow = function () { return _this.deleteRow(); };
            context.editRow = function () { return _this.editRow(); };
        };
        TableComponent.prototype.execute = function (operation, options) {
            if ([core.DataSource.Operation.IS_API_AWARE, core.DataSource.Operation.IS_PAGEABLE, core.DataSource.Operation.SUPPORTS_SERVER_FILTER].includes(operation)) {
                return false;
            }
            return this.datasource ? this.datasource.execute(operation, options) : {};
        };
        TableComponent.prototype.isNavigationEnabled = function () {
            return this.shownavigation && this.dataNavigator && this.dataNavigatorWatched;
        };
        TableComponent.prototype.getClonedRowObject = function (rowData) {
            var row = core.getClonedObject(rowData);
            row.getProperty = function (field) {
                return _.get(row, field);
            };
            row.$isFirst = row.$index === 1;
            row.$isLast = this.gridData.length === row.$index;
            delete row.$$index;
            delete row.$$pk;
            return row;
        };
        TableComponent.prototype.handleLoading = function (data) {
            this.variableInflight = data.active;
            // based on the active state and response toggling the 'loading data...' and 'no data found' messages.
            if (data.active) {
                this.callDataGridMethod('setStatus', 'loading', this.loadingdatamsg);
            }
            else {
                // If grid is in edit mode or grid has data, dont show the no data message
                if (!this.isGridEditMode && _.isEmpty(this.dataset)) {
                    this.callDataGridMethod('setStatus', 'nodata', this.nodatamessage);
                }
                else {
                    this.callDataGridMethod('setStatus', 'ready');
                }
            }
        };
        TableComponent.prototype.setDisabledOnField = function (operation, colDef, widgetType) {
            if (operation !== 'new' && colDef['primary-key'] && colDef.generator === 'assigned' && !colDef['related-entity-name'] && !colDef.period) {
                colDef[widgetType].disabled = true;
            }
        };
        TableComponent.prototype.resetFormControl = function (ctrl) {
            ctrl.markAsUntouched();
            ctrl.markAsPristine();
        };
        TableComponent.prototype.clearForm = function (newRow) {
            var _this = this;
            var ctrls = this.ngform.controls;
            _.keys(this.ngform.controls).forEach(function (key) {
                // If new row, clear the controls in the new row. Else, clear the controls in edit row
                if (!key.endsWith('_filter') && ((key.endsWith('_new') && newRow) || (!key.endsWith('_new') && !newRow))) {
                    ctrls[key].setValue('');
                    _this.resetFormControl(ctrls[key]);
                }
            });
        };
        /* Check whether it is non-empty row. */
        TableComponent.prototype.isEmptyRecord = function (record) {
            var _this = this;
            var properties = Object.keys(record);
            var data, isDisplayed;
            return properties.every(function (prop, index) {
                data = record[prop];
                /* If fieldDefs are missing, show all columns in data. */
                isDisplayed = (_this.fieldDefs.length && core.isDefined(_this.fieldDefs[index]) &&
                    (core.isMobile() ? _this.fieldDefs[index].mobileDisplay : _this.fieldDefs[index].pcDisplay)) || true;
                /*Validating only the displayed fields*/
                if (isDisplayed) {
                    return (data === null || data === undefined || data === '');
                }
                return true;
            });
        };
        /* Function to remove the empty data. */
        TableComponent.prototype.removeEmptyRecords = function (serviceData) {
            var _this = this;
            var allRecords = serviceData;
            var filteredData = [];
            if (allRecords && allRecords.length) {
                /*Comparing and pushing the non-empty data columns*/
                filteredData = allRecords.filter(function (record) {
                    return record && !_this.isEmptyRecord(record);
                });
            }
            return filteredData;
        };
        TableComponent.prototype.setGridData = function (serverData) {
            var data = this.filternullrecords ? this.removeEmptyRecords(serverData) : serverData;
            if (!this.variableInflight) {
                if (data && data.length === 0) {
                    this.callDataGridMethod('setStatus', 'nodata', this.nodatamessage);
                }
                else {
                    this.callDataGridMethod('setStatus', 'ready');
                }
            }
            this.gridData = data;
        };
        TableComponent.prototype.setDataGridOption = function (optionName, newVal, forceSet) {
            if (forceSet === void 0) {
                forceSet = false;
            }
            if (!this.datagridElement || !this.datagridElement.datatable || !this.datagridElement.datatable('instance')) {
                return;
            }
            var option = {};
            if (core.isDefined && (!_.isEqual(newVal, this.gridOptions[optionName]) || forceSet)) {
                option[optionName] = newVal;
                this.datagridElement.datatable('option', option);
                this.gridOptions[optionName] = newVal;
            }
        };
        TableComponent.prototype.callDataGridMethod = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this.datagridElement || !this.datagridElement.datatable('instance')) {
                this.applyProps.set(args[1], args);
                return; // If datagrid is not initiliazed or destroyed, return here
            }
            return this.datagridElement.datatable.apply(this.datagridElement, args);
        };
        TableComponent.prototype.renderOperationColumns = function () {
            var rowActionCol, insertPosition;
            var rowOperationsColumn = getRowOperationsColumn(), config = {
                'name': rowOperationsColumn.field,
                'field': rowOperationsColumn.field,
                'isPredefined': true
            };
            // Return if no fieldDefs are present
            if (!this.fieldDefs.length) {
                return;
            }
            rowActionCol = _.find(this.fullFieldDefs, { 'field': ROW_OPS_FIELD, type: 'custom' }); // Check if column is fetched from markup
            _.remove(this.fieldDefs, { type: 'custom', field: ROW_OPS_FIELD }); // Removing operations column
            _.remove(this.headerConfig, { field: rowOperationsColumn.field });
            /*Add the column for row operations only if at-least one operation has been enabled.*/
            if (this.rowActions.length) {
                if (rowActionCol) { // If column is present in markup, push the column or push the default column
                    insertPosition = rowActionCol.rowactionsposition ? _.toNumber(rowActionCol.rowactionsposition) : this.fieldDefs.length;
                    this.fieldDefs.splice(insertPosition, 0, rowActionCol);
                    if (insertPosition === 0) {
                        this.headerConfig.unshift(config);
                    }
                    else {
                        this.headerConfig.push(config);
                    }
                }
                else {
                    this.fieldDefs.push(rowOperationsColumn);
                    this.headerConfig.push(config);
                }
            }
            this.setDataGridOption('headerConfig', this.headerConfig);
        };
        TableComponent.prototype.enablePageNavigation = function () {
            var _this = this;
            if (this.dataset && this.binddataset && this.dataNavigator) {
                /*Check for sanity*/
                this.dataNavigatorWatched = true;
                if (this.navigatorResultWatch) {
                    this.navigatorResultWatch.unsubscribe();
                }
                /*Register a watch on the "result" property of the "dataNavigator" so that the paginated data is displayed in the live-list.*/
                this.navigatorResultWatch = this.dataNavigator.resultEmitter.subscribe(function (newVal) {
                    /* Check for sanity. */
                    if (core.isDefined(newVal)) {
                        // Watch will not be triggered if dataset and new value are equal. So trigger the property change handler manually
                        // This happens in case, if dataset is directly updated.
                        if (_.isEqual(_this.dataset, newVal)) {
                            _this.watchVariableDataSet(newVal);
                        }
                        else {
                            if (_.isArray(newVal)) {
                                _this.widget.dataset = [].concat(newVal);
                            }
                            else if (_.isObject(newVal)) {
                                _this.widget.dataset = _.extend({}, newVal);
                            }
                            else {
                                _this.widget.dataset = newVal;
                            }
                        }
                    }
                    else {
                        _this.widget.dataset = undefined;
                    }
                }, true);
                /*De-register the watch if it is exists */
                if (this.navigatorMaxResultWatch) {
                    this.navigatorMaxResultWatch.unsubscribe();
                }
                /*Register a watch on the "maxResults" property of the "dataNavigator" so that the "pageSize" is displayed in the live-list.*/
                this.navigatorMaxResultWatch = this.dataNavigator.maxResultsEmitter.subscribe(function (newVal) {
                    _this.pagesize = newVal;
                });
                // If dataset is a pageable object, data is present inside the content property
                this.__fullData = this.dataset;
                this.dataNavigator.widget.maxResults = this.pagesize || 5;
                this.dataNavigator.options = {
                    maxResults: this.pagesize || 5
                };
                this.removePropertyBinding('dataset');
                this.dataNavigator.setBindDataSet(this.binddataset, this.viewParent, this.datasource, this.dataset, this.binddatasource);
            }
        };
        TableComponent.prototype.resetPageNavigation = function () {
            /*Check for sanity*/
            if (this.dataNavigator) {
                this.dataNavigator.resetPageNavigation();
            }
        };
        TableComponent.prototype.isDataValid = function () {
            var error;
            var dataset = this.dataset || {};
            /*In case "data" contains "error" & "errorMessage", then display the error message in the grid.*/
            if (dataset.error) {
                error = dataset.error;
            }
            if (dataset.data && dataset.data.error) {
                if (dataset.data.errorMessage) {
                    error = dataset.data.errorMessage;
                }
            }
            if (error) {
                this.setGridData([]);
                this.callDataGridMethod('setStatus', 'error', error);
                return false;
            }
            return true;
        };
        // Function to populate the grid with data.
        TableComponent.prototype.populateGridData = function (serviceData) {
            var data;
            serviceData = transformData(serviceData, this.name);
            // Apply filter and sort, if data is refreshed through Refresh data method
            if (!this.isNavigationEnabled() && this._isClientSearch) {
                data = core.getClonedObject(serviceData);
                data = this.getSearchResult(data, this.filterInfo);
                data = this.getSortResult(data, this.sortInfo);
                this.serverData = data;
            }
            else {
                this.serverData = serviceData;
            }
            // If fielddefs are not present, generate fielddefs from data
            // Removing fielddefs check because When loadondemand property is enabled(deferload="true"), the dataset propertychangehanlder is triggered first before the dom is getting rendered.
            // So at that time fielddefs length is zero, due to this the columns are created dynamically.
            if (this.isdynamictable) {
                this.createGridColumns(this.serverData);
            }
            else {
                this.setGridData(this.serverData);
            }
        };
        // Function to generate and compile the form fields from the metadata
        TableComponent.prototype.generateDynamicColumns = function (columns) {
            return __awaiter(this, void 0, void 0, function () {
                var tmpl, componentFactoryRef, component;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.fieldDefs = []; // empty the form fields
                            // empty the filter field template refs.
                            this.filterTmpl._results = [];
                            if (_.isEmpty(columns)) {
                                return [2 /*return*/];
                            }
                            tmpl = '';
                            columns.forEach(function (col) {
                                var attrsTmpl = '';
                                var customTmpl = '';
                                _.forEach(col, function (val, key) {
                                    if (val) {
                                        // If custom expression is present, keep it inside table column. Else, keep as attribute
                                        if (key === 'customExpression') {
                                            customTmpl = val;
                                        }
                                        else {
                                            attrsTmpl += " " + key + "=\"" + val + "\"";
                                        }
                                    }
                                });
                                tmpl += "<wm-table-column " + attrsTmpl + " tableName=\"" + _this.name + "\">" + customTmpl + "</wm-table-column>";
                            });
                            this.dynamicTableRef.clear();
                            if (!this._dynamicContext) {
                                this._dynamicContext = Object.create(this.viewParent);
                                this._dynamicContext[this.getAttr('wmTable')] = this;
                            }
                            this.noOfColumns = columns.length;
                            return [4 /*yield*/, this.dynamicComponentProvider.getComponentFactoryRef('app-table-dynamic-' + this.widgetId, tmpl, {
                                    noCache: true,
                                    transpile: true
                                })];
                        case 1:
                            componentFactoryRef = _a.sent();
                            component = this.dynamicTableRef.createComponent(componentFactoryRef, 0, this.inj);
                            core.extendProto(component.instance, this._dynamicContext);
                            this.$element.find('.dynamic-table-container')[0].appendChild(component.location.nativeElement);
                            return [2 /*return*/];
                    }
                });
            });
        };
        TableComponent.prototype.prepareColDefs = function (data) {
            var _this = this;
            var defaultFieldDefs;
            var properties;
            this.fieldDefs = [];
            this.headerConfig = [];
            this.columns = {};
            /* if properties map is existed then fetch the column configuration for all nested levels using util function */
            properties = data;
            /*call utility function to prepare fieldDefs for grid against given data (A MAX OF 10 COLUMNS ONLY)*/
            defaultFieldDefs = prepareFieldDefs(properties);
            /*append additional properties*/
            _.forEach(defaultFieldDefs, function (columnDef) {
                columnDef.binding = columnDef.field;
                columnDef.caption = columnDef.displayName;
                columnDef.pcDisplay = true;
                columnDef.mobileDisplay = true;
                columnDef.searchable = true;
                columnDef.type = 'string';
            });
            defaultFieldDefs.forEach(function (col) {
                _this.columns[col.field] = col;
            });
            this.invokeEventCallback('beforedatarender', { $data: data, $columns: this.columns, data: data, columns: this.columns });
            defaultFieldDefs = [];
            // Apply the changes made by the user
            _.forEach(this.columns, function (val) {
                defaultFieldDefs.push(val);
            });
            this.generateDynamicColumns(defaultFieldDefs);
        };
        TableComponent.prototype.createGridColumns = function (data) {
            /* this call back function receives the data from the variable */
            /* check whether data is valid or not */
            var dataValid = data && !data.error;
            /*if the data is type json object, make it an array of the object*/
            if (dataValid && !_.isArray(data)) {
                data = [data];
            }
            /* if the data is empty, show nodatamessage */
            if (_.isEmpty(data)) {
                this.setGridData(data);
                return;
            }
            if (!dataValid) {
                return;
            }
            /* if new columns to be rendered, prepare default fieldDefs for the data provided*/
            this.prepareColDefs(data);
            this.serverData = data;
            this.setGridData(this.serverData);
        };
        TableComponent.prototype.getSortExpr = function () {
            var sortExp;
            var pagingOptions;
            if (this.datasource && this.datasource.execute(core.DataSource.Operation.IS_PAGEABLE)) {
                pagingOptions = this.datasource.execute(core.DataSource.Operation.GET_PAGING_OPTIONS);
                sortExp = _.isEmpty(pagingOptions) ? '' : getOrderByExpr(pagingOptions.sort);
            }
            return sortExp || '';
        };
        TableComponent.prototype.watchVariableDataSet = function (newVal) {
            var result;
            // After the setting the watch on navigator, dataset is triggered with undefined. In this case, return here.
            if (this.dataNavigatorWatched && _.isUndefined(newVal) && this.__fullData) {
                return;
            }
            // If variable is in loading state, show loading icon
            if (this.variableInflight) {
                this.callDataGridMethod('setStatus', 'loading', this.loadingdatamsg);
            }
            result = core.getValidJSON(newVal);
            // Converting newval to object if it is an Object that comes as a string "{"data" : 1}"
            if (result) {
                newVal = result;
            }
            /*Return if data is invalid.*/
            if (!this.isDataValid()) {
                return;
            }
            // If value is empty or in studio mode, dont enable the navigation
            if (newVal) {
                if (this.shownavigation && !this.dataNavigatorWatched) {
                    this.enablePageNavigation();
                    return;
                }
            }
            else {
                this.resetPageNavigation();
                /*for run mode, disabling the loader and showing no data found message if dataset is not valid*/
                if (!this.variableInflight) {
                    this.callDataGridMethod('setStatus', 'nodata', this.nodatamessage);
                }
                this.setDataGridOption('selectFirstRow', this.gridfirstrowselect);
            }
            if (!this.isNavigationEnabled() && newVal) {
                this.checkFiltersApplied(this.getSortExpr());
            }
            if (!_.isObject(newVal) || newVal === '' || (newVal && newVal.dataValue === '')) {
                if (!this.variableInflight) {
                    // If variable has finished loading and resultSet is empty, ender empty data
                    this.setGridData([]);
                }
                return;
            }
            if (newVal) {
                this.populateGridData(newVal);
            }
        };
        TableComponent.prototype.onDataSourceChange = function () {
            this.fieldDefs.forEach(function (col) {
                core.triggerFn(col.onDataSourceChange && col.onDataSourceChange.bind(col));
            });
        };
        TableComponent.prototype.onPropertyChange = function (key, nv, ov) {
            var _this = this;
            var enableNewRow;
            switch (key) {
                case 'datasource':
                    this.watchVariableDataSet(this.dataset);
                    this.onDataSourceChange();
                    break;
                case 'dataset':
                    if (this.binddatasource && !this.datasource) {
                        return;
                    }
                    this.watchVariableDataSet(nv);
                    break;
                case 'filtermode':
                    this.setDataGridOption('filtermode', nv);
                    break;
                case 'searchlabel':
                    this.setDataGridOption('searchLabel', nv);
                    break;
                case 'navigation':
                    if (nv === 'Advanced') { // Support for older projects where navigation type was advanced instead of clasic
                        this.navigation = 'Classic';
                        return;
                    }
                    if (nv !== 'None') {
                        this.shownavigation = true;
                    }
                    this.navControls = nv;
                    break;
                case 'gridfirstrowselect':
                    this.setDataGridOption('selectFirstRow', nv);
                    break;
                case 'gridclass':
                    this.callDataGridMethod('option', 'cssClassNames.grid', nv);
                    break;
                case 'nodatamessage':
                    this.callDataGridMethod('option', 'dataStates.nodata', nv);
                    break;
                case 'loadingdatamsg':
                    this.callDataGridMethod('option', 'dataStates.loading', nv);
                    break;
                case 'loadingicon':
                    this.callDataGridMethod('option', 'loadingicon', nv);
                    break;
                case 'spacing':
                    this.callDataGridMethod('option', 'spacing', nv);
                    if (nv === 'condensed') {
                        this.navigationSize = 'small';
                    }
                    else {
                        this.navigationSize = '';
                    }
                    break;
                case 'exportformat':
                    this.exportOptions = [];
                    if (nv) {
                        // Populate options for export drop down menu
                        _.forEach(_.split(nv, ','), function (type) {
                            _this.exportOptions.push({
                                label: type,
                                icon: exportIconMapping[type]
                            });
                        });
                    }
                    break;
                case 'shownewrow':
                    // Enable new row if shownew is true or addNewRow buton is present
                    enableNewRow = nv || _.some(this.actions, function (act) { return _.includes(act.action, 'addNewRow()'); });
                    this.callDataGridMethod('option', 'actionsEnabled.new', enableNewRow);
                    break;
                case 'show':
                    if (nv) {
                        this.invokeEventCallback('show');
                    }
                    else {
                        this.invokeEventCallback('hide');
                    }
                default:
                    _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        TableComponent.prototype.onStyleChange = function (key, nv, ov) {
            switch (key) {
                case 'width':
                    this.callDataGridMethod('setGridDimensions', 'width', nv);
                    break;
                case 'height':
                    this.callDataGridMethod('setGridDimensions', 'height', nv);
                    break;
            }
            _super.prototype.onStyleChange.call(this, key, nv, ov);
        };
        TableComponent.prototype.populateActions = function () {
            var _this = this;
            this._actions.header = [];
            this._actions.footer = [];
            _.forEach(this.actions, function (action) {
                if (_.includes(action.position, 'header')) {
                    _this._actions.header.push(action);
                }
                if (_.includes(action.position, 'footer')) {
                    _this._actions.footer.push(action);
                }
            });
        };
        // this method will render the filter row.
        TableComponent.prototype.renderDynamicFilterColumn = function (filteTemRef) {
            // For dynamic table manually pushing the filtertemplateRef as templateRef will not be available prior.
            if (this.isdynamictable) {
                this.filterTmpl._results.push(filteTemRef);
            }
        };
        TableComponent.prototype.registerColumns = function (tableColumn) {
            var _this = this;
            if (core.isMobile()) {
                if (!tableColumn.mobileDisplay) {
                    return;
                }
            }
            else {
                if (!tableColumn.pcDisplay) {
                    return;
                }
            }
            var colCount = this.fieldDefs.push(tableColumn);
            this.fullFieldDefs.push(tableColumn);
            this.rowFilter[tableColumn.field] = {
                value: undefined
            };
            this.fieldDefs.forEach(function (col) {
                _this.columns[col.field] = col;
            });
            // If dynamic datatable and last column, pass the columns to jquery datatable
            if (this.isdynamictable && colCount === this.noOfColumns) {
                this.renderOperationColumns();
                this.setDataGridOption('colDefs', this.fieldDefs);
            }
        };
        TableComponent.prototype.registerFormField = function (name, formField) {
            this.formfields[name] = formField;
        };
        TableComponent.prototype.registerActions = function (tableAction) {
            this.actions.push(tableAction);
            this.populateActions();
        };
        TableComponent.prototype.registerRow = function (tableRow, rowInstance) {
            this.rowDef = tableRow;
            this.rowInstance = rowInstance;
            this.callDataGridMethod('option', 'cssClassNames.rowExpandIcon', this.rowDef.expandicon);
            this.callDataGridMethod('option', 'cssClassNames.rowCollapseIcon', this.rowDef.collapseicon);
            this.gridOptions.rowExpansionEnabled = true;
            this.gridOptions.rowDef = this.rowDef;
        };
        TableComponent.prototype.registerRowActions = function (tableRowAction) {
            this.rowActions.push(tableRowAction);
        };
        TableComponent.prototype.selectItem = function (item, data) {
            /* server is not updating immediately, so set the server data to success callback data */
            if (data) {
                this.serverData = data;
            }
            if (_.isObject(item)) {
                item = _.omitBy(item, function (value) {
                    return _.isArray(value) && _.isEmpty(value);
                });
            }
            this.callDataGridMethod('selectRow', item, true);
        };
        /* deselect the given item*/
        TableComponent.prototype.deselectItem = function (item) {
            this.callDataGridMethod('deselectRow', item);
        };
        TableComponent.prototype.onDataNavigatorDataSetChange = function (nv) {
            var data;
            this.__fullData = nv;
            this.checkFiltersApplied(this.getSortExpr());
            if (this._isClientSearch) {
                data = core.getClonedObject(this.__fullData);
                if (_.isObject(data) && !_.isArray(data)) {
                    data = [data];
                }
                data = this.getSearchResult(data, this.filterInfo);
                data = this.getSortResult(data, this.sortInfo);
                return data;
            }
            return nv;
        };
        TableComponent.prototype.toggleMessage = function (show, type, msg, header) {
            if (show && msg) {
                this.app.notifyApp(msg, type, header);
            }
        };
        TableComponent.prototype.export = function ($item) {
            var filterFields;
            var sortOptions = _.isEmpty(this.sortInfo) ? '' : this.sortInfo.field + ' ' + this.sortInfo.direction;
            var columns = {};
            var isValid;
            var requestData;
            this.fieldDefs.forEach(function (fieldDef) {
                // Do not add the row operation actions column to the exported file.
                if (fieldDef.field === ROW_OPS_FIELD || !fieldDef.show) {
                    return;
                }
                var option = {
                    'header': fieldDef.displayName
                };
                // If column has exportexpression, then send form the expression as required by backend.
                // otherwise send the field name.
                if (fieldDef.exportexpression) {
                    option.expression = fieldDef.exportexpression;
                }
                else {
                    option.field = fieldDef.field;
                }
                columns[fieldDef.field] = option;
            });
            filterFields = this.getFilterFields(this.filterInfo);
            requestData = {
                matchMode: 'anywhereignorecase',
                filterFields: filterFields,
                orderBy: sortOptions,
                exportType: $item.label,
                logicalOp: 'AND',
                exportSize: this.exportdatasize,
                columns: columns
            };
            isValid = this.invokeEventCallback('beforeexport', { $data: requestData });
            if (isValid === false) {
                return;
            }
            requestData.fields = _.values(requestData.columns);
            this.datasource.execute(core.DataSource.Operation.DOWNLOAD, { data: requestData });
        };
        TableComponent.prototype.expandRow = function (rowId) {
            this.callDataGridMethod('expandRow', rowId);
        };
        TableComponent.prototype.collapseRow = function (rowId) {
            this.callDataGridMethod('collapseRow', rowId);
        };
        TableComponent.prototype._documentClickBind = function (event) {
            var $target = event.target;
            // If click triggered from same grid or a dialog, do not save the row
            if (this.$element[0].contains($target) || event.target.doctype || isInputBodyWrapper($($target))) {
                return;
            }
            this.callDataGridMethod('saveRow');
        };
        TableComponent.prototype._redraw = function (forceRender) {
            var _this = this;
            if (forceRender) {
                this.datagridElement.datatable(this.gridOptions);
            }
            else {
                setTimeout(function () {
                    _this.callDataGridMethod('setColGroupWidths');
                    _this.callDataGridMethod('addOrRemoveScroll');
                });
            }
        };
        TableComponent.prototype.invokeActionEvent = function ($event, expression) {
            var fn = core.$parseEvent(expression);
            fn(this.viewParent, Object.assign(this.context, { $event: $event }));
        };
        // change and blur events are added from the template
        TableComponent.prototype.handleEvent = function (node, eventName, callback, locals) {
            if (eventName !== 'select') {
                _super.prototype.handleEvent.call(this, this.nativeElement, eventName, callback, locals);
            }
        };
        TableComponent.prototype.triggerUploadEvent = function ($event, eventName, fieldName, row) {
            var params = { $event: $event, row: row };
            if (!this.columns[fieldName]) {
                return;
            }
            if (eventName === 'change') {
                params.newVal = $event.target.files;
                params.oldVal = this.columns[fieldName]._oldUploadVal;
                this.columns[fieldName]._oldUploadVal = params.newVal;
            }
            this.columns[fieldName].invokeEventCallback(eventName, params);
        };
        TableComponent.prototype.registerFormWidget = function () { };
        // Form control accessor methods. This will be used for table inside form
        TableComponent.prototype.writeValue = function () { };
        TableComponent.prototype.registerOnChange = function (fn) {
            this._onChange = fn;
        };
        TableComponent.prototype.registerOnTouched = function (fn) {
            this._onTouched = fn;
        };
        TableComponent.initializeProps = registerProps$T();
        TableComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmTable]',
                        template: "<div class=\"panel-heading\" *ngIf=\"title || subheading || iconclass || exportOptions.length || _actions.header.length\">\n    <h3 class=\"panel-title\">\n        <div class=\"pull-left\">\n            <i class=\"app-icon panel-icon {{iconclass}}\" *ngIf=\"iconclass\"></i>\n        </div>\n        <div class=\"pull-left\">\n            <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\"></div>\n            <div class=\"description\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n        </div>\n        <div class=\"panel-actions app-datagrid-actions\" *ngIf=\"exportOptions.length || _actions.header.length\">\n            <ng-container *ngFor=\"let btn of _actions.header\"\n                          [ngTemplateOutlet]=\"btn.widgetType === 'button' ? buttonRef : anchorRef\" [ngTemplateOutletContext]=\"{btn:btn}\">\n            </ng-container>\n            <div wmMenu dropdown caption.bind=\"appLocale.LABEL_EXPORT\" *ngIf=\"exportOptions.length\"  autoclose=\"always\" attr.name=\"{{name}}-export\"\n                dataset.bind=\"exportOptions\" select.event=\"export($item)\" menuposition=\"down,left\"></div>\n        </div>\n    </h3>\n</div>\n<div class=\"app-datagrid\" #datagridElement></div>\n<div class=\"panel-footer clearfix\" [hidden]=\"!_actions.footer.length && (!shownavigation || dataNavigator?.dataSize <= pagesize)\">\n    <div class=\"app-datagrid-paginator\" [hidden]=\"!dataNavigator?.dataSize || !shownavigation || dataNavigator?.dataSize <= pagesize\">\n        <nav wmPagination show.bind=\"shownavigation\" navigationalign.bind=\"navigationalign\"\n             navigationsize.bind=\"navigationSize\"\n             navigation.bind=\"navControls\" showrecordcount.bind=\"showrecordcount\" maxsize.bind=\"maxsize\"\n             boundarylinks.bind=\"boundarylinks\"\n             forceellipses.bind=\"forceellipses\" directionlinks.bind=\"directionlinks\"></nav>\n    </div>\n    <div class=\"app-datagrid-actions\" *ngIf=\"_actions.footer.length\">\n        <ng-container *ngFor=\"let btn of _actions.footer\"\n                      [ngTemplateOutlet]=\"btn.widgetType === 'button' ? buttonRef : anchorRef\" [ngTemplateOutletContext]=\"{btn:btn}\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #buttonRef let-btn=\"btn\">\n    <button wmButton caption.bind=\"btn.displayName\" show.bind=\"btn.show\" class.bind=\"btn.class\"  iconclass.bind=\"btn.iconclass\" (click)=\"invokeActionEvent($event, btn.action)\"\n            [ngClass]=\"{'btn-sm': spacing === 'condensed', 'disabled-new': btn.key === 'addNewRow' && (isGridEditMode || isLoading)}\"\n            type=\"button\" shortcutkey.bind=\"btn.shortcutkey\" tabindex.bind=\"btn.tabindex\" hint.bind=\"btn.title\" disabled.bind=\"btn.disabled\" conditionalclass.bind=\"btn.conditionalclass\" conditionalstyle.bind=\"btn.conditionalstyle\"></button>\n</ng-template>\n\n<ng-template #anchorRef let-btn=\"btn\">\n    <a wmAnchor caption.bind=\"btn.displayName\" show.bind=\"btn.show\" class.bind=\"btn.class\"  iconclass.bind=\"btn.iconclass\" (click)=\"invokeActionEvent($event, btn.action)\"\n            [ngClass]=\"{'btn-sm': spacing === 'condensed', 'disabled-new': btn.key === 'addNewRow' && (isGridEditMode || isLoading)}\"\n            shortcutkey.bind=\"btn.shortcutkey\" tabindex.bind=\"btn.tabindex\" hint.bind=\"btn.title\"\n            hyperlink.bind=\"btn.hyperlink\" target.bind=\"btn.target\" conditionalclass.bind=\"btn.conditionalclass\" conditionalstyle.bind=\"btn.conditionalstyle\"></a>\n</ng-template>\n\n<div hidden>\n    <ng-container #multiColumnFilterView></ng-container>\n\n    <ng-container #inlineEditView></ng-container>\n\n    <ng-container #inlineEditNewView></ng-container>\n\n    <ng-container #rowActionsView></ng-container>\n\n    <ng-container #rowExpansionActionView></ng-container>\n\n    <ng-container #customExprView></ng-container>\n\n    <ng-container #dynamicTable></ng-container>\n\n    <ng-container #rowDetailView></ng-container>\n\n    <div class=\"dynamic-table-container\"></div>\n</div>\n",
                        providers: [
                            provideAsNgValueAccessor(TableComponent),
                            provideAsWidgetRef(TableComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        TableComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: forms.FormBuilder },
                { type: core.App },
                { type: core.DynamicComponentRefProvider },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['dataset.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['datasource.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['readonlygrid',] }] },
                { type: core$1.NgZone }
            ];
        };
        TableComponent.propDecorators = {
            dataNavigator: [{ type: core$1.ViewChild, args: [PaginationComponent,] }],
            _tableElement: [{ type: core$1.ViewChild, args: ['datagridElement',] }],
            rowActionTmpl: [{ type: core$1.ContentChildren, args: ['rowActionTmpl',] }],
            rowActionsViewRef: [{ type: core$1.ViewChild, args: ['rowActionsView', { read: core$1.ViewContainerRef },] }],
            filterTmpl: [{ type: core$1.ContentChildren, args: ['filterTmpl', { descendants: true },] }],
            filterViewRef: [{ type: core$1.ViewChild, args: ['multiColumnFilterView', { read: core$1.ViewContainerRef },] }],
            inlineWidgetTmpl: [{ type: core$1.ContentChildren, args: ['inlineWidgetTmpl', { descendants: true },] }],
            inlineEditViewRef: [{ type: core$1.ViewChild, args: ['inlineEditView', { read: core$1.ViewContainerRef },] }],
            inlineWidgetNewTmpl: [{ type: core$1.ContentChildren, args: ['inlineWidgetTmplNew', { descendants: true },] }],
            inlineEditNewViewRef: [{ type: core$1.ViewChild, args: ['inlineEditNewView', { read: core$1.ViewContainerRef },] }],
            customExprTmpl: [{ type: core$1.ContentChildren, args: ['customExprTmpl', { descendants: true },] }],
            customExprViewRef: [{ type: core$1.ViewChild, args: ['customExprView', { read: core$1.ViewContainerRef },] }],
            rowExpansionActionTmpl: [{ type: core$1.ContentChildren, args: ['rowExpansionActionTmpl',] }],
            rowExpansionTmpl: [{ type: core$1.ContentChild, args: ['rowExpansionTmpl',] }],
            rowDetailViewRef: [{ type: core$1.ViewChild, args: ['rowDetailView', { read: core$1.ViewContainerRef },] }],
            rowExpansionActionViewRef: [{ type: core$1.ViewChild, args: ['rowExpansionActionView', { read: core$1.ViewContainerRef },] }],
            dynamicTableRef: [{ type: core$1.ViewChild, args: ['dynamicTable', { read: core$1.ViewContainerRef },] }],
            onKeyPress: [{ type: core$1.HostListener, args: ['keypress', ['$event'],] }]
        };
        return TableComponent;
    }(StylableComponent));

    var FormWidgetDirective = /** @class */ (function () {
        function FormWidgetDirective(form, table, componentInstance, fb, name, key) {
            var _this = this;
            this.componentInstance = componentInstance;
            this.name = name;
            this.key = key;
            this.fb = fb;
            this.parent = form || table;
            this.ngform = this.parent.ngform;
            this.componentInstance.registerPropertyChangeListener(function (k, nv) {
                if (k === 'datavalue' && _this._control) {
                    _this._control.setValue(nv);
                }
                else if (k === 'name' && !_this._control) {
                    _this.addControl(_this.key || nv);
                }
            });
        }
        Object.defineProperty(FormWidgetDirective.prototype, "_control", {
            get: function () {
                var fieldName = this.key || this.name;
                if (!fieldName) {
                    return undefined;
                }
                return this.ngform && this.ngform.controls[fieldName];
            },
            enumerable: true,
            configurable: true
        });
        FormWidgetDirective.prototype.addControl = function (fieldName) {
            this.ngform.addControl(fieldName, this.createControl());
        };
        FormWidgetDirective.prototype.createControl = function () {
            return this.fb.control(this.componentInstance.datavalue);
        };
        FormWidgetDirective.prototype.ngOnInit = function () {
            var fieldName = this.key || this.name;
            if (fieldName && !this._control) {
                this.addControl(fieldName);
                this.parent.registerFormWidget(this.componentInstance);
            }
        };
        FormWidgetDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmFormWidget]'
                    },] }
        ];
        /** @nocollapse */
        FormWidgetDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Optional }, { type: core$1.Inject, args: [FormComponent,] }] },
                { type: undefined, decorators: [{ type: core$1.Optional }, { type: core$1.Inject, args: [TableComponent,] }] },
                { type: undefined, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [WidgetRef,] }] },
                { type: forms.FormBuilder },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['name',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['key',] }] }
            ];
        };
        return FormWidgetDirective;
    }());

    var registerProps$U = function () {
        register('wm-label', new Map([
            ['caption', __assign({ value: 'Label' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['hint', PROP_STRING],
            ['name', PROP_STRING],
            ['required', PROP_BOOLEAN],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$w = 'app-label';
    var WIDGET_CONFIG$F = {
        widgetType: 'wm-label',
        hostClass: DEFAULT_CLS$w,
        displayType: DISPLAY_TYPE.INLINE_BLOCK
    };
    var LabelDirective = /** @class */ (function (_super) {
        __extends(LabelDirective, _super);
        function LabelDirective(inj, trustAsPipe) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$F) || this;
            _this.trustAsPipe = trustAsPipe;
            styler(_this.nativeElement, _this);
            return _this;
        }
        LabelDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'caption') {
                if (_.isObject(nv)) {
                    core.setProperty(this.nativeElement, 'textContent', JSON.stringify(nv));
                }
                else {
                    core.setProperty(this.nativeElement, 'innerHTML', this.trustAsPipe.transform(nv, core$1.SecurityContext.HTML));
                }
            }
            else if (key === 'required') {
                core.toggleClass(this.nativeElement, 'required', nv);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        LabelDirective.initializeProps = registerProps$U();
        LabelDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmLabel]',
                        providers: [
                            provideAsWidgetRef(LabelDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        LabelDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: TrustAsPipe }
            ];
        };
        return LabelDirective;
    }(StylableComponent));

    var registerProps$V = function () {
        register('wm-gridcolumn', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['columnwidth', PROP_NUMBER],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$x = 'app-grid-column';
    var WIDGET_CONFIG$G = {
        widgetType: 'wm-gridcolumn',
        hostClass: DEFAULT_CLS$x
    };
    var LayoutGridColumnDirective = /** @class */ (function (_super) {
        __extends(LayoutGridColumnDirective, _super);
        function LayoutGridColumnDirective(inj, height) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$G) || this;
            // if the height is provided set the overflow to auto
            if (height) {
                core.setCSS(_this.nativeElement, 'overflow', 'auto');
            }
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        LayoutGridColumnDirective.prototype.onPropertyChange = function (key, nv, ov) {
            var prefix = core.isMobileApp() ? 'xs' : 'sm';
            if (key === 'columnwidth') {
                core.switchClass(this.nativeElement, "col-" + prefix + "-" + nv, ov ? "col-" + prefix + "-" + ov : '');
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        LayoutGridColumnDirective.initializeProps = registerProps$V();
        LayoutGridColumnDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmLayoutGridColumn]',
                        providers: [
                            provideAsWidgetRef(LayoutGridColumnDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        LayoutGridColumnDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['height',] }] }
            ];
        };
        return LayoutGridColumnDirective;
    }(StylableComponent));

    var registerProps$W = function () {
        register('wm-layoutgrid', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$y = 'app-grid-layout clearfix';
    var WIDGET_CONFIG$H = {
        widgetType: 'wm-layoutgrid',
        hostClass: DEFAULT_CLS$y
    };
    var LayoutgridDirective = /** @class */ (function (_super) {
        __extends(LayoutgridDirective, _super);
        function LayoutgridDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$H) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        LayoutgridDirective.initializeProps = registerProps$W();
        LayoutgridDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmLayoutGrid]',
                        providers: [
                            provideAsWidgetRef(LayoutgridDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        LayoutgridDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return LayoutgridDirective;
    }(StylableComponent));

    var registerProps$X = function () {
        register('wm-layout-grid-row', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$z = 'app-grid-row clearfix';
    var WIDGET_CONFIG$I = {
        widgetType: 'wm-layout-grid-row',
        hostClass: DEFAULT_CLS$z
    };
    var LayoutGridRowDirective = /** @class */ (function (_super) {
        __extends(LayoutGridRowDirective, _super);
        function LayoutGridRowDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$I) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        LayoutGridRowDirective.initializeProps = registerProps$X();
        LayoutGridRowDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmLayoutGridRow]',
                        providers: [
                            provideAsWidgetRef(LayoutGridRowDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        LayoutGridRowDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return LayoutGridRowDirective;
    }(StylableComponent));

    var LazyLoadDirective = /** @class */ (function () {
        function LazyLoadDirective(inj, templateRef, viewContainer) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.viewParent = inj.view.component;
            this.context = inj.view.context;
        }
        Object.defineProperty(LazyLoadDirective.prototype, "lazyLoad", {
            set: function (expr) {
                var _this = this;
                this.unSubscribeFn = core.$watch(expr, this.viewParent, this.context, function (val) {
                    if (!_this.embeddedView && val) {
                        _this.embeddedView = _this.viewContainer.createEmbeddedView(_this.templateRef, _this.context);
                        _this.unSubscribeFn();
                    }
                });
            },
            enumerable: true,
            configurable: true
        });
        LazyLoadDirective.prototype.ngOnDestroy = function () {
            this.unSubscribeFn();
        };
        LazyLoadDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[lazyLoad]'
                    },] }
        ];
        /** @nocollapse */
        LazyLoadDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.TemplateRef },
                { type: core$1.ViewContainerRef }
            ];
        };
        LazyLoadDirective.propDecorators = {
            lazyLoad: [{ type: core$1.Input }]
        };
        return LazyLoadDirective;
    }());

    var registerProps$Y = function () {
        register('wm-left-panel', new Map([
            ['animation', __assign({ value: 'slide-in' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['columnwidth', __assign({ value: 3 }, PROP_NUMBER)],
            ['content', PROP_STRING],
            ['gestures', __assign({ value: 'on' }, PROP_STRING)],
            ['name', PROP_STRING],
            ['xscolumnwidth', __assign({ value: 10 }, PROP_NUMBER)]
        ]));
    };

    var LeftPanelAnimator = /** @class */ (function (_super) {
        __extends(LeftPanelAnimator, _super);
        function LeftPanelAnimator(leftPanel) {
            var _this = _super.call(this) || this;
            _this.leftPanel = leftPanel;
            _this.init(_this.leftPanel.$ele, _this.leftPanel.$page);
            return _this;
        }
        LeftPanelAnimator.prototype.bounds = function () {
            var offset = 0;
            this.setGesturesEnabled(this.leftPanel.isGesturesEnabled());
            if (!this._width) {
                this._pageContainerWidth = this.leftPanel.$page.width();
                this._leftPanelWidth = this.leftPanel.$ele.width();
                this._maxX = this._leftPanelWidth / this._pageContainerWidth * 100;
                this._width = this.leftPanel.animation === exports.AnimationType.SLIDE_IN ? this._pageContainerWidth : this._leftPanelWidth;
            }
            this._expanded = this.leftPanel.expanded;
            if (this._expanded) {
                return {
                    'center': this._leftPanelWidth,
                    'lower': -(this._leftPanelWidth - offset)
                };
            }
            if (this.leftPanel.app.isTabletApplicationType) {
                offset = 53.32;
            }
            return {
                'center': 0,
                'upper': this._leftPanelWidth - offset
            };
        };
        LeftPanelAnimator.prototype.context = function () {
            return {
                'w': this._width,
                'pageW': this._pageContainerWidth,
                'leftW': this._leftPanelWidth,
                'maxX': this._maxX,
                'limit': function (min, v, max) {
                    if (v < min) {
                        return min;
                    }
                    if (v > max) {
                        return max;
                    }
                    return v;
                }
            };
        };
        LeftPanelAnimator.prototype.animation = function () {
            this._$animatedElements = this.leftPanel.$ele;
            if (this.leftPanel.animation === exports.AnimationType.SLIDE_IN) {
                this._$animatedElements = this._$animatedElements.add(this.leftPanel.$page);
                if (this.leftPanel.app.isTabletApplicationType) {
                    return [
                        {
                            'target': this.leftPanel.$ele,
                            'css': {
                                'transform': 'translate3d(${{ limit(-100, -($d * 100 / leftW), 0) + \'%\' }}, 0, 0)'
                            }
                        },
                        {
                            'target': this.leftPanel.$page,
                            'css': {
                                'transform': 'translate3d(${{ (($d) * 100 / pageW) + \'%\' }}, 0, 0)',
                                'width': '${{ (pageW - $d) + \'px\' }}',
                                'z-index': 101
                            }
                        }
                    ];
                }
                return [
                    {
                        'target': this.leftPanel.$ele,
                        'css': {
                            'transform': 'translate3d(-100%, 0, 0)',
                            'opacity': 1,
                            'z-index': 101
                        }
                    },
                    {
                        'target': this.leftPanel.$page,
                        'css': {
                            'transform': 'translate3d(${{ limit( 0, ((($D + $d) * 100 / w)), maxX ) + \'%\' }}, 0, 0)',
                            'opacity': 1,
                            'z-index': 101
                        }
                    }
                ];
            }
            else {
                return {
                    'transform': 'translate3d(${{ limit( -100, ((($D + $d) * 100 / w) - 100), 0 ) + \'%\'}}, 0, 0)',
                    'opacity': 1,
                    'z-index': 101
                };
            }
        };
        LeftPanelAnimator.prototype.onLower = function () {
            this._expanded = false;
            this.leftPanel.collapse();
            this.resetTransition();
            core.$appDigest();
        };
        LeftPanelAnimator.prototype.onUpper = function () {
            this._expanded = true;
            this.leftPanel.expand();
            this.resetTransition();
            core.$appDigest();
        };
        LeftPanelAnimator.prototype.resetTransition = function () {
            var _this = this;
            if (this._$animatedElements) {
                /*
                 * This timeout is for preventing UI flicker at the end of animation.
                 */
                setTimeout(function () {
                    _this._$animatedElements.css({
                        'transform': '',
                        'opacity': '',
                        'z-index': '',
                        'width': ''
                    });
                }, 100);
            }
        };
        return LeftPanelAnimator;
    }(_swipey.SwipeAnimation));

    var registerProps$Z = function () {
        register('wm-page', new Map([
            ['pagetitle', PROP_STRING]
        ]));
    };

    var _this = this;
    var CLASS_NAME;
    (function (CLASS_NAME) {
        CLASS_NAME["LEFT_PANEL"] = "page-left-panel";
        CLASS_NAME["RIGHT_PANEL"] = "page-right-panel";
        CLASS_NAME["SWIPE_ELEM"] = "page-left-panel-icon";
        CLASS_NAME["CONTENT"] = "app-content-column";
        CLASS_NAME["HEADER"] = "page-header";
        CLASS_NAME["SEARCH"] = "app-search";
    })(CLASS_NAME || (CLASS_NAME = {}));
    /**
     * method returns jquery class selector for given roleName
     * @param roleName
     * @returns {string}
     */
    var roleSelector = function (roleName) { return "[data-role='" + roleName + "']"; };
    /*setup touch event handler*/
    var bindTapEvtHandler = function (selector, handler) {
        /*
         * In Iphone safari browser, tap event of HammerJs is breaking
         * functionalities of other controls like input[type="range"].
         * So, replaced the hammer Js handler with click event handler.
         */
        $(selector).off('click.deviceview').on('click.deviceview', handler);
    };
    /**
     * hide the mobile toolbar actions
     */
    var hidePageContainers = function (leftNavEle, searchEle) {
        if (core.isMobile()) {
            if (leftNavEle) {
                try {
                    leftNavEle.widget.collapse();
                }
                catch (e) {
                    //
                }
            }
            if (searchEle) {
                core.setCSS(searchEle, 'display', 'none');
            }
        }
    };
    /**
     * binds the touch event for content
     */
    var bindContentEvents = function (leftNavEle, pageContainer, searchContainer, isTablet) {
        if (isTablet === void 0) {
            isTablet = false;
        }
        if (!isTablet) {
            // touch content to hide nav pane and left panel
            bindTapEvtHandler(pageContainer, hidePageContainers.bind(_this, leftNavEle, searchContainer));
        }
    };
    var bindLeftPanelEvents = function (leftNavEle, searchEle) {
        // tap left to show/hide left panel
        bindTapEvtHandler(roleSelector(CLASS_NAME.SWIPE_ELEM), function () {
            if (leftNavEle) {
                leftNavEle.widget.toggle();
                // Hide search container when left panel is open
                if (leftNavEle.classList.contains('visible')) {
                    if (searchEle) {
                        core.setCSS(searchEle, 'display', 'none');
                    }
                }
            }
        });
    };
    /**
     * binds the touch event for content
     */
    var bindRightPanelEvents = function (rightNavEle) {
        bindTapEvtHandler(rightNavEle, hidePageContainers);
    };
    /**
     * toggles the search container
     */
    var toggleSearchContainer = function (searchEle, leftNavEle) {
        if ($(searchEle).css('display') === 'none') {
            hidePageContainers(leftNavEle);
            core.setCSS(searchEle, 'display', 'inline-table');
        }
        else {
            hidePageContainers(leftNavEle, searchEle);
        }
    };
    /**
     * Bind event with Search icon in header
     */
    var bindSearchIconEvent = function (searchElements, leftNavEle) {
        $(searchElements).each(function (index, ele) {
            var searchEle = $('<a class="app-header-action"><i class="wi wi-search"></i></a>');
            $(ele).before(searchEle);
            // Tap icon to show/hide search box
            bindTapEvtHandler(searchEle, function () { return toggleSearchContainer(ele, leftNavEle); });
        });
    };
    var updateDeviceView = function (element, isTablet) {
        if (isTablet === void 0) {
            isTablet = false;
        }
        var leftNavEle = element.querySelector(roleSelector(CLASS_NAME.LEFT_PANEL));
        var rightNavEle = element.querySelector(roleSelector(CLASS_NAME.RIGHT_PANEL));
        var headerEle = element.querySelector(roleSelector(CLASS_NAME.HEADER));
        var searchEle = headerEle && headerEle.querySelector("." + CLASS_NAME.SEARCH);
        var pageEle = element.querySelector("." + CLASS_NAME.CONTENT);
        bindContentEvents(leftNavEle, pageEle, searchEle, isTablet);
        if (leftNavEle) {
            bindLeftPanelEvents(leftNavEle, searchEle);
        }
        else {
            // remove the icon
            $(headerEle).find(roleSelector(CLASS_NAME.SWIPE_ELEM)).remove();
        }
        if (rightNavEle) {
            bindRightPanelEvents(rightNavEle);
        }
        if (searchEle) {
            bindSearchIconEvent(searchEle, leftNavEle);
        }
    };

    var DEFAULT_CLS$A = 'app-page container';
    var WIDGET_CONFIG$J = { widgetType: 'wm-page', hostClass: DEFAULT_CLS$A };
    var PageDirective = /** @class */ (function (_super) {
        __extends(PageDirective, _super);
        function PageDirective(inj, titleService) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$J) || this;
            _this.titleService = titleService;
            _this._eventNotifier = new core.EventNotifier(false);
            return _this;
        }
        PageDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'pagetitle') {
                this.titleService.setTitle(nv);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        /**
         * A child component can notify page using this method. Notified event will be passed to
         * subscribed children only after page initialization.
         *
         * @param {string} eventName
         * @param data
         */
        PageDirective.prototype.notify = function (eventName) {
            var data = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                data[_i - 1] = arguments[_i];
            }
            this._eventNotifier.notify.apply(this._eventNotifier, arguments);
        };
        /**
         * The main purpose of this function is to provide communication between page children objects.
         * Child component can subscribe for an event that will be emitted by another child component.
         *
         * @param eventName
         * @param {(data: any) => void} callback
         * @returns {any}
         */
        PageDirective.prototype.subscribe = function (eventName, callback) {
            return this._eventNotifier.subscribe(eventName, callback);
        };
        PageDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            setTimeout(function () {
                _this._eventNotifier.start();
                updateDeviceView(_this.nativeElement, _this.getAppInstance().isTabletApplicationType);
            }, 1);
        };
        PageDirective.prototype.ngOnDestroy = function () {
            this._eventNotifier.destroy();
        };
        PageDirective.initializeProps = registerProps$Z();
        PageDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmPage]',
                        providers: [
                            provideAsWidgetRef(PageDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        PageDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: platformBrowser.Title }
            ];
        };
        return PageDirective;
    }(StylableComponent));

    var DEFAULT_CLS$B = 'app-left-panel left-panel-collapsed';
    var WIDGET_CONFIG$K = {
        widgetType: 'wm-left-panel',
        hostClass: DEFAULT_CLS$B
    };
    (function (AnimationType) {
        AnimationType["SLIDE_IN"] = "slide-in";
        AnimationType["SLIDE_OVER"] = "slide-over";
    })(exports.AnimationType || (exports.AnimationType = {}));
    var LeftPanelDirective = /** @class */ (function (_super) {
        __extends(LeftPanelDirective, _super);
        function LeftPanelDirective(app, page, inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$K) || this;
            _this.app = app;
            _this.page = page;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            _this.$ele = _this.$element;
            _this.$page = page.$element;
            core.addClass(_this.$page[0], 'left-panel-collapsed-container');
            if (_this.columnwidth) {
                _this.setLeftPanelWidth(['md', 'sm'], _this.columnwidth);
            }
            if (_this.app.isTabletApplicationType) {
                core.addClass(_this.nativeElement, 'wm-tablet-app-left-panel');
            }
            return _this;
        }
        LeftPanelDirective.prototype.collapse = function () {
            core.addClass(this.nativeElement, 'swipee-transition');
            core.switchClass(this.nativeElement, 'left-panel-collapsed', 'left-panel-expanded');
            this.expanded = false;
            core.switchClass(this.$page[0], 'left-panel-collapsed-container', 'left-panel-expanded-container');
            if (this.animation === exports.AnimationType.SLIDE_IN) {
                this.setPageWidthAndPosition(['md', 'sm'], null, this.columnwidth);
                this.setPageWidthAndPosition(['xs'], null, this.xscolumnwidth);
            }
            if (this._destroyCollapseActionListener) {
                this._destroyCollapseActionListener();
            }
            this.page.notify('wmLeftPanel:collapse');
        };
        LeftPanelDirective.prototype.expand = function () {
            core.removeClass(this.nativeElement, 'swipee-transition');
            core.switchClass(this.nativeElement, 'left-panel-expanded', 'left-panel-collapsed');
            this.expanded = true;
            if (!(this.app.isTabletApplicationType && this.animation === exports.AnimationType.SLIDE_IN)) {
                this._destroyCollapseActionListener = this.listenForCollapseAction();
            }
            core.switchClass(this.$page[0], 'left-panel-expanded-container', 'left-panel-collapsed-container');
            if (this.animation === exports.AnimationType.SLIDE_IN) {
                this.setPageWidthAndPosition(['md', 'sm'], this.columnwidth);
                this.setPageWidthAndPosition(['xs'], this.xscolumnwidth);
            }
            this.page.notify('wmLeftPanel:expand');
        };
        LeftPanelDirective.prototype.isGesturesEnabled = function () {
            return this.gestures === 'on';
        };
        LeftPanelDirective.prototype.isVisible = function () {
            return this.expanded;
        };
        LeftPanelDirective.prototype.onPropertyChange = function (key, nv, ov) {
            switch (key) {
                case 'animation':
                    if (nv === exports.AnimationType.SLIDE_IN) {
                        core.removeClass(this.$page[0], 'slide-over-left-panel-container');
                        core.addClass(this.$page[0], 'slide-in-left-panel-container');
                        this.setPageWidthAndPosition(['md', 'sm'], this.columnwidth);
                        this.setPageWidthAndPosition(['xs'], this.xscolumnwidth);
                    }
                    else if (nv === exports.AnimationType.SLIDE_OVER) {
                        core.removeClass(this.$page[0], 'slide-in-left-panel-container');
                        core.addClass(this.$page[0], 'slide-over-left-panel-container');
                    }
                    this._leftPanelAnimator = new LeftPanelAnimator(this);
                    core.switchClass(this.nativeElement, nv, ov);
                    break;
                case 'columnwidth':
                    this.setLeftPanelWidth(['md', 'sm'], nv, ov);
                    if (this.animation === exports.AnimationType.SLIDE_IN) {
                        this.setPageWidthAndPosition(['md', 'sm'], nv, ov);
                    }
                    break;
                case 'expanded':
                    core.toggleClass(this.nativeElement, 'left-panel-expanded', nv);
                    core.toggleClass(this.nativeElement, 'left-panel-collapsed', !nv);
                    break;
                case 'xscolumnwidth':
                    this.setLeftPanelWidth(['xs'], nv, ov);
                    if (this.animation === exports.AnimationType.SLIDE_IN) {
                        this.setPageWidthAndPosition(['xs'], nv, ov);
                    }
                    break;
                default:
                    _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        LeftPanelDirective.prototype.toggle = function () {
            var _this = this;
            if (this.app.isTabletApplicationType) {
                setTimeout(function () {
                    _this.expanded ? _this.collapse() : _this.expand();
                }, 50);
            }
            else {
                this.$ele.swipeAnimation(this.expanded ? 'gotoLower' : 'gotoUpper');
            }
        };
        LeftPanelDirective.prototype.listenForCollapseAction = function () {
            var _this = this;
            var eventName = 'click.leftNavToggle';
            var skipEvent = false;
            this.$ele.on(eventName, function () {
                skipEvent = true;
            });
            this.$page.on(eventName, function () {
                if (!skipEvent) {
                    _this.toggle();
                }
                skipEvent = false;
            });
            return function () {
                _this.$ele.off(eventName);
                _this.$page.off(eventName);
            };
        };
        LeftPanelDirective.prototype.setLeftPanelWidth = function (devices, newVal, oldVal) {
            var _this = this;
            devices.forEach(function (device) {
                if (newVal) {
                    core.addClass(_this.nativeElement, "col-" + device + "-" + newVal);
                }
                if (oldVal) {
                    core.removeClass(_this.nativeElement, "col-" + device + "-" + oldVal);
                }
            });
        };
        LeftPanelDirective.prototype.setPageWidthAndPosition = function (devices, newVal, oldVal) {
            var _this = this;
            devices.forEach(function (device) {
                if (newVal) {
                    core.addClass(_this.$page[0], "left-panel-container-" + device + "-" + (12 - newVal));
                }
                if (oldVal) {
                    core.removeClass(_this.$page[0], "left-panel-container-" + device + "-" + (12 - oldVal));
                }
            });
        };
        LeftPanelDirective.initializeProps = registerProps$Y();
        LeftPanelDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmLeftPanel]',
                        providers: [
                            provideAsWidgetRef(LeftPanelDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        LeftPanelDirective.ctorParameters = function () {
            return [
                { type: core.App },
                { type: PageDirective },
                { type: core$1.Injector }
            ];
        };
        return LeftPanelDirective;
    }(StylableComponent));

    var LiveActionsDirective = /** @class */ (function () {
        function LiveActionsDirective(subscribedWidget, app, dialogService) {
            this.subscribedWidget = subscribedWidget;
            this.app = app;
            this.dialogService = dialogService;
            subscribedWidget.addRow = this.addRow.bind(this);
            subscribedWidget.updateRow = this.updateRow.bind(this);
            subscribedWidget.deleteRow = this.deleteRow.bind(this);
            subscribedWidget.call = this.call.bind(this);
        }
        LiveActionsDirective.prototype.addRow = function () {
            this.app.notify('wm-event', { eventName: Live_Operations.INSERT, widgetName: this.subscribedWidget.name, row: this.subscribedWidget.selecteditem });
        };
        LiveActionsDirective.prototype.updateRow = function () {
            this.app.notify('wm-event', { eventName: Live_Operations.UPDATE, widgetName: this.subscribedWidget.name, row: this.subscribedWidget.selecteditem });
        };
        LiveActionsDirective.prototype.deleteRow = function () {
            this.app.notify('wm-event', { eventName: Live_Operations.DELETE, widgetName: this.subscribedWidget.name, row: this.subscribedWidget.selecteditem });
        };
        LiveActionsDirective.prototype.successHandler = function (options, response) {
            core.triggerFn(options.success, response);
        };
        LiveActionsDirective.prototype.errorHandler = function (options, error) {
            this.app.notifyApp(error, 'error', 'ERROR');
            core.triggerFn(options.error, error);
        };
        LiveActionsDirective.prototype.getRecords = function (options, operation) {
            var _this = this;
            var index;
            var dataNavigator;
            if (this.subscribedWidget.navigation !== 'None' && this.subscribedWidget.dataNavigator) {
                dataNavigator = this.subscribedWidget.dataNavigator;
                // If operation is delete, decrease the data size and check if navigation to previous page is required
                if (operation === Live_Operations.DELETE) {
                    dataNavigator.dataSize -= 1;
                    dataNavigator.calculatePagingValues();
                    index = dataNavigator.pageCount < dataNavigator.dn.currentPage ? 'prev' : undefined;
                }
                else {
                    // If operation is insert, go to last page. If update operation, stay on current page
                    index = operation === Live_Operations.INSERT ? 'last' : 'current';
                    if (index === 'last') {
                        dataNavigator.dataSize += 1;
                    }
                    dataNavigator.calculatePagingValues();
                }
                dataNavigator.navigatePage(index, null, true, function (response) {
                    _this.successHandler(options, response);
                });
            }
            else {
                this.subscribedWidget.datasource.execute(core.DataSource.Operation.LIST_RECORDS, {
                    'skipToggleState': true
                }).then(function (response) {
                    _this.successHandler(options, response);
                }, function (err) {
                    _this.errorHandler(options, err);
                });
            }
        };
        LiveActionsDirective.prototype.performCUDOperation = function (requestData, operation, options) {
            var _this = this;
            performDataOperation(this.subscribedWidget.datasource, requestData, {
                operationType: operation
            }).then(function (response) {
                if (response.error) {
                    _this.errorHandler(options, response.error);
                    return;
                }
                _this.getRecords(options, operation);
                // show delete success toaster
                if (operation === 'delete') {
                    _this.app.notifyApp(_this.app.appLocale.MESSAGE_DELETE_RECORD_SUCCESS, 'success');
                }
            }, function (error) {
                _this.errorHandler(options, error);
            });
        };
        LiveActionsDirective.prototype.insertRecord = function (requestData, operation, options) {
            this.performCUDOperation(requestData, operation, options);
        };
        LiveActionsDirective.prototype.updateRecord = function (requestData, operation, options) {
            this.performCUDOperation(requestData, operation, options);
        };
        LiveActionsDirective.prototype.deleteRecord = function (requestData, operation, options) {
            var _this = this;
            // Show the delete confirmation dialog. On Ok, delete the record.
            this.dialogService.showAppConfirmDialog({
                title: this.app.appLocale.MESSAGE_DELETE_RECORD || 'Delete Record',
                iconclass: 'wi wi-delete fa-lg',
                message: this.subscribedWidget.confirmdelete || 'Are you sure you want to delete this?',
                oktext: this.subscribedWidget.deleteoktext || 'Ok',
                canceltext: this.subscribedWidget.deletecanceltext || 'Cancel',
                onOk: function () {
                    _this.performCUDOperation(requestData, operation, options);
                    _this.dialogService.closeAppConfirmDialog();
                },
                onCancel: function () {
                    core.triggerFn(options.cancelDeleteCallback);
                    _this.dialogService.closeAppConfirmDialog();
                }
            });
        };
        LiveActionsDirective.prototype.performOperation = function (operation, options) {
            var requestData = {
                row: options.row,
                prevData: {},
                rowData: {},
                transform: true,
                skipNotification: true
            };
            if (operation === Live_Operations.UPDATE) {
                requestData.rowData = options.rowData;
                requestData.prevData = options.prevData;
            }
            /* decide routine based on CRUD operation to be performed */
            switch (operation) {
                case Live_Operations.INSERT:
                    this.insertRecord(requestData, operation, options);
                    break;
                case Live_Operations.UPDATE:
                    this.updateRecord(requestData, operation, options);
                    break;
                case Live_Operations.DELETE:
                    this.deleteRecord(requestData, operation, options);
                    break;
                case Live_Operations.READ:
                    this.getRecords(options, operation);
                    break;
            }
        };
        // API exposed to make CRUD operations
        LiveActionsDirective.prototype.call = function (operation, options, success, error) {
            options.success = success;
            options.error = error;
            this.performOperation(operation, options);
        };
        LiveActionsDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmLiveActions]'
                    },] }
        ];
        /** @nocollapse */
        LiveActionsDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [ListComponent,] }] },
                { type: core.App },
                { type: core.AbstractDialogService }
            ];
        };
        return LiveActionsDirective;
    }());

    var registerProps$_ = function () {
        register('wm-livetable', new Map([
            ['class', PROP_STRING],
            ['formlayout', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ]));
    };

    var DEFAULT_CLS$C = 'app-livegrid';
    var WIDGET_CONFIG$L = { widgetType: 'wm-livetable', hostClass: DEFAULT_CLS$C };
    var LiveTableComponent = /** @class */ (function (_super) {
        __extends(LiveTableComponent, _super);
        function LiveTableComponent(inj, elRef, cdr, dialogService, app, layoutType, dialogId) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$L) || this;
            _this.dialogService = dialogService;
            _this.app = app;
            _this.$queue = [];
            _this.tableOptions = {
                'multiselect': false,
                'setGridEditMode': ''
            };
            styler(_this.nativeElement, _this);
            if (layoutType === 'dialog') {
                _this.isLayoutDialog = true;
                _this.dialogId = dialogId;
            }
            return _this;
        }
        LiveTableComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            _super.prototype.ngAfterContentInit.call(this);
            if (this.table) {
                this.table._liveTableParent = this;
                this.table.datagridElement.datatable('option', this.tableOptions);
                this.table.selectedItemChange$
                    .pipe(operators.debounceTime(250))
                    .subscribe(this.onSelectedItemChange.bind(this));
                if (!this.isLayoutDialog && !this.form) {
                    this.table.datagridElement.datatable('option', {
                        'beforeRowUpdate': function () {
                            _this.showErrorMessage();
                        },
                        'beforeRowDelete': function () {
                            _this.showErrorMessage();
                        },
                        'beforeRowInsert': function () {
                            _this.showErrorMessage();
                        }
                    });
                }
            }
        };
        LiveTableComponent.prototype.openDialog = function () {
            this.dialogService.open(this.dialogId);
            core.$appDigest();
        };
        LiveTableComponent.prototype.closeDialog = function () {
            this.dialogService.close(this.dialogId);
        };
        LiveTableComponent.prototype.focusFirstInput = function () {
            var $firstInput = $(this.form.$element).find('[role="input"]:first');
            $firstInput.focus();
            $firstInput.select();
        };
        LiveTableComponent.prototype.onDialogOpen = function () {
            this.focusFirstInput();
        };
        LiveTableComponent.prototype.setFormData = function (val) {
            if (!this.form.isDestroyed) {
                this.form.getWidget().formdata = val;
            }
        };
        LiveTableComponent.prototype._addNewRow = function () {
            this.form.isSelected = true;
            this.setFormData('');
            this.form.new();
            if (this.isLayoutDialog) {
                this.onDialogOpen();
            }
        };
        LiveTableComponent.prototype.addNewRow = function () {
            if (this.isLayoutDialog) {
                this.openDialog();
                this.$queue.push(this._addNewRow.bind(this));
                return;
            }
            this._addNewRow();
        };
        LiveTableComponent.prototype._updateRow = function (row, eventName) {
            this.setFormData(row);
            this.form.isSelected = true;
            this.form.edit();
            if (this.isLayoutDialog) {
                this.form.isUpdateMode = (eventName === 'dblclick') ? this.form.updateMode : true;
                this.onDialogOpen();
            }
        };
        LiveTableComponent.prototype.updateRow = function (row, eventName) {
            if (this.isLayoutDialog) {
                this.openDialog();
                this.$queue.push(this._updateRow.bind(this, row, eventName));
                return;
            }
            this._updateRow(row, eventName);
        };
        LiveTableComponent.prototype.onSelectedItemChange = function (newValue) {
            var rowData;
            if (!this.form || !this.table) {
                return;
            }
            if (newValue && newValue.length > 0 && !this.form.isSelected) {
                this.form.isSelected = true;
            }
            /*Update the rowdata of only that grid form that is associated with the specific grid on which row selection is being performed...
             * Since both the grid & gridform are associated with the same "parentgrid", match the same*/
            if (newValue && newValue.length > 0) {
                if (this.table.multiselect) {
                    rowData = newValue[0];
                }
                else {
                    rowData = newValue[newValue.length - 1];
                }
                this.setFormData(core.getClonedObject(rowData));
                /*If the form is already in update mode, call the form update function*/
                if (this.form.isUpdateMode) {
                    this.form.edit();
                }
            }
            else {
                this.form.isSelected = false;
                this.setFormData('');
                this.form.clearData();
            }
        };
        LiveTableComponent.prototype.onCancel = function () {
            this.form.isUpdateMode = false;
            if (this.isLayoutDialog) {
                this.closeDialog();
            }
        };
        LiveTableComponent.prototype.onResult = function (operation, response, newForm, updateMode) {
            this.form.isUpdateMode = core.isDefined(updateMode) ? updateMode : newForm ? true : false;
            switch (operation) {
                case 'insert':
                    if (newForm) {
                        /*if new form is to be shown after insert, skip the highlight of the row*/
                        this.table.gridfirstrowselect = false;
                        this.table.initiateSelectItem(this.table.getNavigationTargetBySortInfo(), response, true);
                    }
                    else {
                        /*The new row would always be inserted at the end of all existing records. Hence navigate to the last page and highlight the inserted row.*/
                        this.table.initiateSelectItem(this.table.getNavigationTargetBySortInfo(), response);
                    }
                    break;
                case 'update':
                    /*The updated row would be found in the current page itself. Hence simply highlight the row in the current page.*/
                    if (newForm) {
                        this.table.gridfirstrowselect = false;
                        this.table.initiateSelectItem('current', response, true);
                    }
                    else {
                        this.table.initiateSelectItem('current', response);
                    }
                    break;
                case 'delete':
                    this.table.onRecordDelete();
                    break;
            }
            this.table.updateVariable();
            if (this.isLayoutDialog) {
                /*if new form is to be shown after update or insert, don't close the dialog*/
                if (newForm) {
                    if (operation === 'insert') {
                        this.form.new();
                    }
                    else if (operation === 'update') {
                        this.form.edit();
                    }
                }
                else {
                    this.closeDialog();
                }
            }
        };
        LiveTableComponent.prototype.showErrorMessage = function () {
            this.app.notifyApp(this.appLocale.LABEL_ACCESS_DENIED, 'error');
        };
        // In dialog mode, on form render call the queued functions
        LiveTableComponent.prototype.onFormReady = function (form) {
            var _this = this;
            this.form = form;
            setTimeout(function () {
                core.triggerFn(_this.$queue.pop());
            });
        };
        LiveTableComponent.initializeProps = registerProps$_();
        LiveTableComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmLiveTable]',
                        template: "<ng-content></ng-content>",
                        providers: [
                            provideAsWidgetRef(LiveTableComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        LiveTableComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.ElementRef },
                { type: core$1.ChangeDetectorRef },
                { type: core.AbstractDialogService },
                { type: core.App },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['formlayout',] }] },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['dialogid',] }] }
            ];
        };
        LiveTableComponent.propDecorators = {
            table: [{ type: core$1.ContentChild, args: [TableComponent,] }]
        };
        return LiveTableComponent;
    }(StylableComponent));

    var isTimeType = function (field) { return field.widgettype === core.DataType.TIME || (field.type === core.DataType.TIME && !field.widgettype); };
    var getValidTime = function (val) {
        if (val) {
            var date = (new Date()).toDateString();
            return (new Date(date + " " + val)).getTime();
        }
        return undefined;
    };
    var LiveFormDirective = /** @class */ (function () {
        function LiveFormDirective(form, liveTable, datePipe, dialogService, formlayout) {
            var _this = this;
            this.form = form;
            this.datePipe = datePipe;
            this.dialogService = dialogService;
            this._debouncedSavePrevDataValues = core.debounce(function () {
                _this.savePrevDataValues();
            }, 250);
            // If parent live table is present and this form is first child of live table, set this form instance on livetable
            if (liveTable && !this.form.parentForm) {
                this.form._liveTableParent = liveTable;
                this.form.isLayoutDialog = liveTable.isLayoutDialog;
                liveTable.onFormReady(this.form);
            }
            else {
                this.form.isLayoutDialog = formlayout === 'dialog';
            }
            // CUD operations
            form.edit = this.edit.bind(this);
            form.cancel = this.cancel.bind(this);
            form.reset = this.reset.bind(this);
            form.new = this.new.bind(this);
            form.delete = this.delete.bind(this);
            form.save = this.save.bind(this);
            form.saveAndNew = this.saveAndNew.bind(this);
            form.saveAndView = this.saveAndView.bind(this);
            form.setPrimaryKey = this.setPrimaryKey.bind(this);
            form.constructDataObject = this.constructDataObject.bind(this);
            form.changeDataObject = this.setFormData.bind(this);
            form.setFormData = this.setFormData.bind(this);
            form.findOperationType = this.findOperationType.bind(this);
            form.clearData = this.clearData.bind(this);
            form.onFieldDefaultValueChange = this.onFieldDefaultValueChange.bind(this);
            form.onDataSourceChange = this.onDataSourceChange.bind(this);
            form.onFieldValueChange = this.onFieldValueChange.bind(this);
            form.submitForm = this.submitForm.bind(this);
        }
        LiveFormDirective.prototype.onDataSourceChange = function () {
            var _this = this;
            if (_.get(this.form.formFields, 'length')) {
                this.form.isDataSourceUpdated = true;
            }
            var formFields = this.form.getFormFields();
            formFields.forEach(function (field) {
                if (!field.isDataSetBound && isDataSetWidget(field.widgettype)) {
                    if (field['is-related']) {
                        field.isDataSetBound = true;
                        fetchRelatedFieldData(_this.form.datasource, field.widget, {
                            relatedField: field.key,
                            datafield: ALLFIELDS,
                            widget: 'widgettype',
                        });
                    }
                    else {
                        getDistinctValuesForField(_this.form.datasource, field.widget, {
                            widget: 'widgettype',
                            enableemptyfilter: _this.form.enableemptyfilter
                        });
                        applyFilterOnField(_this.form.datasource, field.widget, formFields, field.value, { isFirst: true });
                    }
                }
            });
        };
        LiveFormDirective.prototype.onFieldDefaultValueChange = function (field, nv) {
            // In Edit, do  not set default values
            if (this.form.operationType === 'update') {
                return;
            }
            // Set the default value only if it exists.
            if (core.isDefined(nv) && nv !== null && nv !== '' && nv !== 'null') {
                field.value = parseValueByType(nv, field.type, field.widgettype);
            }
            else {
                field.value = undefined;
            }
            this._debouncedSavePrevDataValues();
        };
        LiveFormDirective.prototype.onFieldValueChange = function (field, nv) {
            applyFilterOnField(this.form.datasource, field.widget, this.form.formFields, nv);
        };
        LiveFormDirective.prototype.getBlobURL = function (dataObj, key, value) {
            var href = '';
            var primaryKeys;
            var primaryKey;
            if (value === null || value === undefined || !this.form.datasource) {
                return href;
            }
            primaryKeys = this.form.datasource.execute(core.DataSource.Operation.GET_PRIMARY_KEY) || [];
            primaryKey = dataObj[primaryKeys[0]];
            // TODO: Handle mobile case
            // if (CONSTANTS.hasCordova && CONSTANTS.isRunMode) {
            //     href += $rootScope.project.deployedUrl;
            // }
            href += this.form.datasource.execute(core.DataSource.Operation.GET_BLOB_URL, {
                primaryValue: primaryKey,
                columnName: key
            });
            href += '?' + Math.random();
            return href;
        };
        LiveFormDirective.prototype.resetFileUploadWidget = function (field, skipValueSet) {
            var $formEle = this.form.$element;
            $formEle.find('[name="' + field.key + '_formWidget"]').val('');
            field._control.reset();
            if (!skipValueSet) {
                field.href = '';
                field.value = null;
            }
        };
        LiveFormDirective.prototype.setDefaultValues = function () {
            var _this = this;
            this.form.formFields.forEach(function (field) {
                _this.onFieldDefaultValueChange(field, field.defaultvalue);
            });
        };
        LiveFormDirective.prototype.setFormData = function (dataObj) {
            var _this = this;
            if (!dataObj) {
                return;
            }
            var formFields = this.form.getFormFields();
            formFields.forEach(function (field) {
                var value = _.get(dataObj, field.key || field.name);
                if (isTimeType(field)) {
                    field.value = getValidTime(value);
                }
                else if (field.type === core.DataType.BLOB) {
                    _this.resetFileUploadWidget(field, true);
                    field.href = _this.getBlobURL(dataObj, field.key, value);
                    field.value = _.isString(value) ? '' : value;
                }
                else {
                    field.value = value;
                }
            });
            this.savePrevDataValues();
            this.form.constructDataObject();
        };
        LiveFormDirective.prototype.onDataSourceUpdate = function (response, newForm, updateMode) {
            if (newForm) {
                this.form.new();
            }
            else {
                this.form.setFormData(response);
                this.closeDialog();
            }
            this.form.isUpdateMode = core.isDefined(updateMode) ? updateMode : true;
        };
        LiveFormDirective.prototype.savePrevformFields = function () {
            this.form.prevformFields = core.getClonedObject(this.form.formFields.map(function (field) {
                return {
                    'key': field.key,
                    'type': field.type,
                    'widgettype': field.widgettype,
                    'outputformat': field.outputformat,
                    'value': field.value
                };
            }));
        };
        LiveFormDirective.prototype.getPrevformFields = function () {
            var _this = this;
            this.form.formFields.map(function (field) {
                var prevField = _this.form.prevformFields.find(function (pField) { return pField.key === field.key; });
                field.value = prevField.value;
            });
        };
        LiveFormDirective.prototype.getDataObject = function () {
            if (this.form.operationType === Live_Operations.INSERT) {
                return {};
            }
            if (core.isDefined(this.form.prevDataObject) && !core.isEmptyObject(this.form.prevDataObject)) {
                return core.getClonedObject(this.form.prevDataObject);
            }
            return core.getClonedObject(this.form.formdata || {});
        };
        LiveFormDirective.prototype.constructDataObject = function (isPreviousData) {
            var _this = this;
            var dataObject = this.getDataObject();
            var formName = this.form.name;
            var formFields;
            formFields = isPreviousData ? this.form.prevformFields : this.form.getFormFields();
            formFields.forEach(function (field) {
                var dateTime, fieldValue;
                var fieldTarget = _.split(field.key, '.');
                var fieldName = fieldTarget[0] || field.key;
                /*collect the values from the fields and construct the object*/
                /*Format the output of date time widgets to the given output format*/
                if ((field.widgettype && core.isDateTimeType(field.widgettype)) || core.isDateTimeType(field.type)) {
                    if (field.value) {
                        dateTime = core.getValidDateObject(field.value);
                        if (field.outputformat === core.DataType.TIMESTAMP || field.type === core.DataType.TIMESTAMP) {
                            fieldValue = field.value ? dateTime : null;
                        }
                        else if (field.outputformat) {
                            fieldValue = _this.datePipe.transform(dateTime, field.outputformat);
                        }
                        else {
                            fieldValue = field.value;
                        }
                    }
                    else {
                        fieldValue = undefined;
                    }
                }
                else if (field.type === core.DataType.BLOB) {
                    fieldValue = core.getFiles(formName, fieldName + '_formWidget', field.multiple);
                }
                else if (field.type === core.DataType.LIST) {
                    fieldValue = field.value || undefined;
                }
                else {
                    fieldValue = (field.value === null || field.value === '') ? undefined : field.value;
                }
                if (fieldTarget.length === 1) {
                    dataObject[fieldName] = fieldValue;
                }
                else {
                    dataObject[fieldName] = dataObject[fieldName] || {};
                    dataObject[fieldName][fieldTarget[1]] = fieldValue;
                }
            });
            if (!isPreviousData) {
                this.form.updateFormDataOutput(dataObject);
                return this.form.dataoutput;
            }
            return dataObject;
        };
        LiveFormDirective.prototype.setPrimaryKey = function (fieldName) {
            /*Store the primary key of data*/
            this.form.primaryKey = this.form.primaryKey || [];
            if (this.form.primaryKey.indexOf(fieldName) === -1) {
                this.form.primaryKey.push(fieldName);
            }
        };
        LiveFormDirective.prototype.findOperationType = function () {
            var _this = this;
            var operation;
            var isPrimary = false;
            var sourceOperation = this.form.datasource && this.form.datasource.execute(core.DataSource.Operation.GET_OPERATION_TYPE);
            if (sourceOperation && sourceOperation !== 'read') {
                return sourceOperation;
            }
            /*If OperationType is not set then based on the formdata object return the operation type,
                this case occurs only if the form is outside a livegrid*/
            /*If the formdata object has primary key value then return update else insert*/
            if (this.form.primaryKey && !_.isEmpty(this.form.formdata)) {
                /*If only one column is primary key*/
                if (this.form.primaryKey.length === 1) {
                    if (this.form.formdata[this.form.primaryKey[0]]) {
                        operation = Live_Operations.UPDATE;
                    }
                    /*If only no column is primary key*/
                }
                else if (this.form.primaryKey.length === 0) {
                    _.forEach(this.form.formdata, function (value) {
                        if (value) {
                            isPrimary = true;
                        }
                    });
                    if (isPrimary) {
                        operation = Live_Operations.UPDATE;
                    }
                    /*If multiple columns are primary key*/
                }
                else {
                    isPrimary = _.some(this.form.primaryKey, function (primaryKey) {
                        if (_this.form.formdata[primaryKey]) {
                            return true;
                        }
                    });
                    if (isPrimary) {
                        operation = Live_Operations.UPDATE;
                    }
                }
            }
            return operation || Live_Operations.INSERT;
        };
        LiveFormDirective.prototype.getPrevDataValues = function () {
            var prevDataValues = _.fromPairs(_.map(this.form.prevDataValues, function (item) {
                return [item.key, item.value];
            })); // Convert of array of values to an object
            this.form.formFields.forEach(function (field) {
                field.value = prevDataValues[field.key] || '';
                field.resetDisplayInput();
            });
            return prevDataValues;
        };
        LiveFormDirective.prototype.savePrevDataValues = function () {
            this.form.prevDataValues = this.form.formFields.map(function (obj) {
                return { 'key': obj.key, 'value': obj.value };
            });
        };
        LiveFormDirective.prototype.emptyDataModel = function () {
            var _this = this;
            this.form.formFields.forEach(function (field) {
                if (core.isDefined(field)) {
                    if (field.type === core.DataType.BLOB) {
                        _this.resetFileUploadWidget(field);
                    }
                    else {
                        field.datavalue = '';
                    }
                }
            });
        };
        LiveFormDirective.prototype.clearData = function () {
            this.form.toggleMessage(false);
            this.emptyDataModel();
        };
        LiveFormDirective.prototype.setReadonlyFields = function () {
            this.form.formFields.forEach(function (field) {
                field.setReadOnlyState();
            });
        };
        LiveFormDirective.prototype.edit = function () {
            this.form.resetFormState();
            this.form.clearMessage();
            this.form.operationType = Live_Operations.UPDATE;
            if (this.form.isSelected) {
                this.savePrevformFields();
                this.savePrevDataValues();
            }
            this.form.prevDataObject = core.getClonedObject(this.form.formdata || {});
            this.setReadonlyFields();
            this.form.isUpdateMode = true;
            core.$appDigest();
        };
        LiveFormDirective.prototype.reset = function () {
            var _this = this;
            var prevDataValues;
            this.form.resetFormState();
            prevDataValues = this.getPrevDataValues();
            this.form.formFields.forEach(function (field) {
                if (field.type === core.DataType.BLOB) {
                    _this.resetFileUploadWidget(field, true);
                    field.href = _this.getBlobURL(prevDataValues, field.key, field.value);
                }
            });
            this.form.constructDataObject();
        };
        LiveFormDirective.prototype.closeDialog = function () {
            if (this.form.isLayoutDialog) {
                this.dialogService.close(this.form.dialogId);
            }
        };
        LiveFormDirective.prototype.cancel = function () {
            this.form.clearMessage();
            this.form.isUpdateMode = false;
            this.form.reset();
            /*Show the previous selected data*/
            if (this.form.isSelected) {
                this.getPrevformFields();
            }
            this.form.isUpdateMode = false;
            this.closeDialog();
            if (this.form._liveTableParent) {
                this.form._liveTableParent.onCancel();
            }
            core.$appDigest();
        };
        LiveFormDirective.prototype.new = function () {
            var _this = this;
            this.form.resetFormState();
            this.form.operationType = Live_Operations.INSERT;
            this.form.clearMessage();
            if (this.form.isSelected) {
                this.savePrevformFields();
            }
            this.emptyDataModel();
            setTimeout(function () {
                _this.setDefaultValues();
                _this.savePrevDataValues();
                _this.form.constructDataObject();
            });
            this.form.isUpdateMode = true;
        };
        LiveFormDirective.prototype.delete = function (callBackFn) {
            this.form.resetFormState();
            this.form.operationType = Live_Operations.DELETE;
            this.form.prevDataObject = core.getClonedObject(this.form.formdata || {});
            this.form.save(undefined, undefined, undefined, callBackFn);
        };
        // Function use to save the form and open new form after save
        LiveFormDirective.prototype.saveAndNew = function () {
            this.save(undefined, true, true);
        };
        // Function use to save the form and open new form after save
        LiveFormDirective.prototype.saveAndView = function () {
            this.save(undefined, false);
        };
        LiveFormDirective.prototype.submitForm = function ($event) {
            this.save($event);
        };
        LiveFormDirective.prototype.save = function (event, updateMode, newForm) {
            var _this = this;
            if (!this.form.datasource) {
                return;
            }
            var data, prevData, operationType, isValid;
            var requestData = {};
            operationType = this.form.operationType = this.form.operationType || this.findOperationType();
            // Disable the form submit if form is in invalid state.
            if (this.form.validateFieldsOnSubmit()) {
                return;
            }
            data = core.getClonedObject(this.form.constructDataObject());
            prevData = this.form.prevformFields ? this.form.constructDataObject(true) : data;
            try {
                isValid = this.form.invokeEventCallback('beforeservicecall', { $event: event, $operation: this.form.operationType, $data: data, options: requestData });
                if (isValid === false) {
                    return;
                }
                if (isValid && isValid.error) {
                    this.form.toggleMessage(true, isValid.error, 'error');
                    return;
                }
            }
            catch (err) {
                if (err.message === 'Abort') {
                    return;
                }
            }
            // If operation is update, form is not touched and current data and previous data is same, Show no changes detected message
            if (this.form.operationType === Live_Operations.UPDATE && this.form.ngform && this.form.ngform.pristine &&
                (this.form.isSelected && _.isEqual(data, prevData))) {
                this.form.toggleMessage(true, this.form.appLocale.MESSAGE_NO_CHANGES, 'info', '');
                core.$appDigest();
                return;
            }
            this.form.resetFormState();
            requestData.row = data;
            requestData.transform = true;
            requestData.skipNotification = true;
            if (operationType === Live_Operations.UPDATE) {
                requestData.rowData = this.form.formdata;
                requestData.prevData = prevData;
            }
            performDataOperation(this.form.datasource, requestData, {
                operationType: operationType
            }).then(function (response) {
                var msg = operationType === Live_Operations.INSERT ? _this.form.insertmessage : (operationType === Live_Operations.UPDATE ?
                    _this.form.updatemessage : _this.form.deletemessage);
                if (operationType === Live_Operations.DELETE) {
                    _this.form.onResult(requestData.row, true, event);
                    _this.emptyDataModel();
                    _this.form.prevDataValues = [];
                    _this.form.isSelected = false;
                }
                else {
                    _this.form.onResult(response, true, event);
                }
                _this.form.toggleMessage(true, msg, 'success');
                if (_this.form._liveTableParent) {
                    // highlight the current updated row
                    _this.form._liveTableParent.onResult(operationType, response, newForm, updateMode);
                }
                else {
                    /*get updated data without refreshing page*/
                    _this.form.datasource.execute(core.DataSource.Operation.LIST_RECORDS, {
                        'skipToggleState': true
                    });
                    _this.onDataSourceUpdate(response, newForm, updateMode);
                }
            }, function (error) {
                _this.form.onResult(error, false, event);
                _this.form.toggleMessage(true, error, 'error');
                core.$appDigest();
            });
        };
        LiveFormDirective.initializeProps = registerLiveFormProps();
        LiveFormDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmLiveForm]'
                    },] }
        ];
        /** @nocollapse */
        LiveFormDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [FormComponent,] }] },
                { type: LiveTableComponent, decorators: [{ type: core$1.Optional }] },
                { type: ToDatePipe },
                { type: core.AbstractDialogService },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['formlayout',] }] }
            ];
        };
        return LiveFormDirective;
    }());

    var FILTER_CONSTANTS = {
        'EMPTY_KEY': 'EMPTY_NULL_FILTER'
    };
    var LiveFilterDirective = /** @class */ (function () {
        function LiveFilterDirective(form) {
            var _this = this;
            this.form = form;
            // debounce the filter function. If multiple filter calls are made at same time, calls will be delayed and last call is fired
            this._filter = core.debounce(function (options) {
                _this.filter(options);
            }, 250);
            form.clearFilter = this.clearFilter.bind(this);
            form.applyFilter = this.applyFilter.bind(this);
            form.filter = this.filter.bind(this);
            form.filterOnDefault = this.filterOnDefault.bind(this);
            form.execute = this.execute.bind(this);
            form.onFieldDefaultValueChange = this.onFieldDefaultValueChange.bind(this);
            form.onMaxDefaultValueChange = this.onMaxDefaultValueChange.bind(this);
            form.onDataSourceChange = this.onDataSourceChange.bind(this);
            form.onFieldValueChange = this.onFieldValueChange.bind(this);
            form.submitForm = this.submitForm.bind(this);
            form.registerFormWidget = this.registerFormWidget.bind(this);
        }
        LiveFilterDirective.prototype.execute = function (operation, options) {
            if (operation === core.DataSource.Operation.LIST_RECORDS || operation === core.DataSource.Operation.DOWNLOAD) {
                return this.applyFilter(options);
            }
            if (operation === core.DataSource.Operation.GET_OPTIONS) {
                return this._options || {};
            }
            if (operation === core.DataSource.Operation.GET_PAGING_OPTIONS) {
                return this.form.pagination;
            }
            if (!this.form.datasource) {
                return {};
            }
            if (operation === core.DataSource.Operation.FETCH_DISTINCT_VALUES) {
                return fetchDistinctValues(this.form.datasource, this.form.formFields, {
                    widget: 'widgettype',
                    enableemptyfilter: this.form.enableemptyfilter,
                    EMPTY_VALUE: this.form.appLocale.LABEL_NO_VALUE
                });
            }
            return this.form.datasource.execute(operation, options);
        };
        LiveFilterDirective.prototype.onFieldDefaultValueChange = function (field, nv) {
            field.minValue = nv;
            field.value = nv;
            this.filterOnDefault();
        };
        LiveFilterDirective.prototype.onFieldValueChange = function (field, nv) {
            applyFilterOnField(this.form.datasource, field.widget, this.form.formFields, nv, {
                EMPTY_VALUE: this.form.appLocale.LABEL_NO_VALUE
            });
            if (this.form.autoupdate && core.isDefined(nv)) {
                this._filter();
            }
        };
        LiveFilterDirective.prototype.onMaxDefaultValueChange = function () {
            var _this = this;
            setTimeout(function () {
                _this.filterOnDefault();
            });
        };
        LiveFilterDirective.prototype.onDataSourceChange = function () {
            var _this = this;
            var dataSource = this.form.datasource;
            if (!dataSource) {
                return;
            }
            this.form.formFields.forEach(function (field) {
                if (isDataSetWidget(field.widgettype)) {
                    getDistinctValuesForField(dataSource, field.widget, {
                        widget: 'widgettype',
                        enableemptyfilter: _this.form.enableemptyfilter,
                        EMPTY_VALUE: _this.form.appLocale.LABEL_NO_VALUE
                    });
                    applyFilterOnField(dataSource, field.widget, _this.form.formFields, field.value, {
                        isFirst: true,
                        EMPTY_VALUE: _this.form.appLocale.LABEL_NO_VALUE
                    });
                }
            });
            // On load check if default value exists and apply filter, Call the filter with the result options
            this._filter(this._options);
        };
        LiveFilterDirective.prototype.clearFilter = function () {
            var _this = this;
            this.form.resetFormState();
            this.form.formFields.forEach(function (filterField) {
                // Added check for range field
                if (!filterField.readonly && filterField.show) {
                    if (filterField.widgettype === core.FormWidgetType.AUTOCOMPLETE || filterField.widgettype === core.FormWidgetType.TYPEAHEAD) {
                        _this.form.$element.find('div[name=' + filterField.name + '] input').val('');
                    }
                    if (filterField['is-range']) {
                        filterField.minValue = '';
                        filterField.maxValue = '';
                    }
                    else {
                        filterField.value = '';
                        filterField.resetDisplayInput();
                    }
                }
            });
            // If variable has any bindings, wait for the bindings to be updated
            setTimeout(function () {
                // Setting result to the default data
                _this._filter();
            });
        };
        LiveFilterDirective.prototype.submitForm = function () {
            this.filter();
        };
        LiveFilterDirective.prototype.applyFilter = function (options) {
            options = options ? (options.data || options) : {};
            options.page = options.page || 1;
            options.orderBy = core.isDefined(options.orderBy) ? options.orderBy : this.orderBy;
            return this.filter(options);
        };
        LiveFilterDirective.prototype.filter = function (options) {
            var _this = this;
            if (!this.form.datasource) {
                return;
            }
            var filterFields = {};
            var dataModel = {};
            var page = 1, orderBy, isValid;
            options = options || {};
            page = options.page || page;
            orderBy = core.isDefined(options.orderBy) ? options.orderBy : (this.orderBy || '');
            this.orderBy = orderBy; // Store the order by in scope. This can be used to retain the sort after filtering
            // Copy the values to be sent to the user as '$data' before servicecall
            this.form.formFields.forEach(function (field) {
                var fieldSelector = 'div[name=' + field.name + '] input';
                var $el = _this.form.$element;
                var fieldEle;
                if ((field.widgettype === core.FormWidgetType.AUTOCOMPLETE || field.widgettype === core.FormWidgetType.TYPEAHEAD) && $el) {
                    fieldEle = $el.find(fieldSelector);
                    if (!field['is-range']) {
                        dataModel[field.field] = {
                            'value': core.isDefined(field.value) ? field.value : fieldEle.val() // For autocomplete, set the datavalue. If not present, set query value
                        };
                    }
                    else {
                        dataModel[field.field] = {
                            'minValue': core.isDefined(field.minValue) ? field.minValue : fieldEle.first().val(),
                            'maxValue': core.isDefined(field.maxValue) ? field.maxValue : fieldEle.last().val()
                        };
                    }
                    return;
                }
                if (!field['is-range']) {
                    dataModel[field.field] = {
                        'value': field.value
                    };
                }
                else {
                    dataModel[field.field] = {
                        'minValue': field.minValue,
                        'maxValue': field.maxValue
                    };
                }
            });
            /*Perform this function for the event onBeforeservicecall*/
            try {
                isValid = this.form.invokeEventCallback('beforeservicecall', { $data: dataModel });
                if (isValid === false) {
                    return;
                }
                if (isValid && isValid.error) {
                    this.form.toggleMessage(true, isValid.error, 'error', 'ERROR');
                    return;
                }
                /*Update these values in the formFields with new reference, inorder to maintain the UI values*/
                this.form.formFields.forEach(function (filterField) {
                    if (!filterField['is-range']) {
                        filterField._value = dataModel[filterField.field].value;
                    }
                    else {
                        filterField._minValue = dataModel[filterField.field].minValue;
                        filterField._maxValue = dataModel[filterField.field].maxValue;
                    }
                });
            }
            catch (err) {
                if (err.message === 'Abort') {
                    return;
                }
            }
            /* Construct the formFields Variable to send it to the queryBuilder */
            this.form.formFields.forEach(function (filterField) {
                var fieldValue;
                var matchMode;
                var colName = filterField.field;
                var minValue = filterField._minValue;
                var maxvalue = filterField._maxValue;
                /* if field is part of a related entity, column name will be 'entity.fieldName' */
                if (filterField['is-related']) {
                    colName += '.' + filterField['lookup-field'];
                }
                if (filterField['is-range']) {
                    /*Based on the min and max values, decide the matchmode condition*/
                    fieldValue = getRangeFieldValue(minValue, maxvalue);
                    matchMode = getRangeMatchMode(minValue, maxvalue);
                    if (core.isDefined(fieldValue)) {
                        filterFields[colName] = {
                            'value': fieldValue,
                            'matchMode': matchMode,
                            'logicalOp': 'AND'
                        };
                    }
                }
                else {
                    switch (filterField.widgettype) {
                        case core.FormWidgetType.SELECT:
                        case core.FormWidgetType.RADIOSET:
                            if (getEnableEmptyFilter(_this.form.enableemptyfilter) && filterField._value === FILTER_CONSTANTS.EMPTY_KEY) {
                                matchMode = getEmptyMatchMode(_this.form.enableemptyfilter);
                                fieldValue = filterField._value;
                            }
                            else {
                                if (filterField.type === core.DataType.BOOLEAN) {
                                    if (core.isDefined(filterField._value) && filterField._value !== '') {
                                        fieldValue = JSON.parse(filterField._value);
                                    }
                                }
                                else {
                                    fieldValue = filterField._value;
                                }
                            }
                            break;
                        case core.FormWidgetType.CHECKBOXSET:
                        case core.FormWidgetType.CHIPS:
                            if (filterField._value && filterField._value.length) {
                                fieldValue = filterField._value;
                            }
                            break;
                        case core.FormWidgetType.CHECKBOX:
                        case core.FormWidgetType.TOGGLE:
                            if (core.isDefined(filterField._value) && filterField._value !== '') {
                                fieldValue = filterField.type === core.DataType.BOOLEAN ? JSON.parse(filterField._value) : filterField._value;
                            }
                            break;
                        default:
                            fieldValue = filterField._value;
                            break;
                    }
                    if (core.isDefined(fieldValue) && fieldValue !== '' && fieldValue !== null) {
                        filterFields[colName] = {};
                        if (matchMode) {
                            filterFields[colName].matchMode = matchMode;
                            fieldValue = undefined;
                        }
                        else if (filterField.type === core.DataType.STRING || filterField.isRelated) { // Only for string types and related fields, custom match modes are enabled.
                            filterFields[colName].matchMode = matchMode || filterField.matchmode ||
                                _this.form.datasource.execute(core.DataSource.Operation.GET_MATCH_MODE);
                        }
                        filterFields[colName].value = fieldValue;
                        filterFields[colName].logicalOp = 'AND';
                        filterFields[colName].type = filterField.type;
                    }
                }
            });
            if (options.exportType) {
                return this.form.datasource.execute(core.DataSource.Operation.DOWNLOAD, {
                    data: {
                        matchMode: 'anywhereignorecase',
                        filterFields: filterFields,
                        orderBy: orderBy,
                        exportType: options.exportType,
                        logicalOp: 'AND',
                        exportSize: options.exportSize,
                        fields: options.fields,
                        fileName: options.fileName
                    }
                });
            }
            return this.form.datasource.execute(core.DataSource.Operation.LIST_RECORDS, {
                filterFields: filterFields,
                orderBy: orderBy,
                page: page,
                pagesize: this.form.pagesize || 20,
                skipDataSetUpdate: true,
                inFlightBehavior: 'executeAll'
            }).then(function (response) {
                var data = response.data;
                _this.form.pagination = response.pagination;
                if (data.error) {
                    // disable readonly and show the appropriate error
                    _this.form.toggleMessage(true, data.error, 'error', 'ERROR');
                    _this.form.onResult(data, false);
                }
                else {
                    _this._options = {
                        'page': page,
                        'orderBy': orderBy
                    };
                    _this.form.result = core.getClonedObject(data);
                    _this.form.onResult(data, true);
                }
                core.$appDigest();
                return _this.form.result;
            }, function (error) {
                _this.form.toggleMessage(true, error, 'error', 'ERROR');
                _this.form.onResult(error, false);
                return error;
            });
        };
        // Calls the filter function if default values are present
        LiveFilterDirective.prototype.filterOnDefault = function () {
            /*Check if default value is present for any filter field*/
            var defaultObj = _.find(this.form.formFields, function (obj) {
                return core.isDefined(obj.value) || core.isDefined(obj.minValue) || core.isDefined(obj.maxValue);
            });
            /*If default value exists and data is loaded, apply the filter*/
            if (defaultObj) {
                this._filter(this._options);
            }
        };
        LiveFilterDirective.prototype.registerFormWidget = function (widget) {
            var name = widget.key || widget.name;
            this.form.filterWidgets[name] = widget;
        };
        LiveFilterDirective.initializeProps = registerLiveFilterProps();
        LiveFilterDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmLiveFilter]'
                    },] }
        ];
        /** @nocollapse */
        LiveFilterDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [FormComponent,] }] }
            ];
        };
        return LiveFilterDirective;
    }());

    var registerProps$10 = function () {
        register('wm-marquee', new Map([
            ['class', PROP_STRING],
            ['direction', PROP_STRING],
            ['name', PROP_STRING],
            ['scrollamount', PROP_NUMBER],
            ['scrolldelay', PROP_NUMBER],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$D = 'app-marquee app-container';
    var WIDGET_CONFIG$M = {
        widgetType: 'wm-marquee',
        hostClass: DEFAULT_CLS$D
    };
    var MarqueeDirective = /** @class */ (function (_super) {
        __extends(MarqueeDirective, _super);
        function MarqueeDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$M) || this;
            styler(_this.nativeElement, _this);
            return _this;
        }
        MarqueeDirective.initializeProps = registerProps$10();
        MarqueeDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmMarquee]',
                        providers: [
                            provideAsWidgetRef(MarqueeDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        MarqueeDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return MarqueeDirective;
    }(StylableComponent));

    var animationClasses = {
        scale: {
            'name': 'wmScaleInLeft',
            'down,right': 'wmScaleInLeft',
            'down,left': 'wmScaleInRight',
            'up,right': 'wmScaleInTopLeft',
            'up,left': 'wmScaleInTopRight'
        },
        fade: {
            'name': 'fadeIn',
            'down,right': 'fadeIn',
            'down,left': 'fadeIn',
            'up,right': 'fadeIn',
            'up,left': 'fadeIn'
        },
        slide: {
            'name': 'wmSlideInDown',
            'down,right': 'wmSlideInDown',
            'down,left': 'wmSlideInDown',
            'up,right': 'wmSlideInUp',
            'up,left': 'wmSlideInUp'
        }
    };
    var DEFAULT_CLS$E = 'dropdown-menu';
    var MenuDropdownComponent = /** @class */ (function () {
        function MenuDropdownComponent(elRef, menuRef) {
            this.menuRef = menuRef;
            this.nativeElement = elRef.nativeElement;
            core.addClass(this.nativeElement, DEFAULT_CLS$E);
        }
        MenuDropdownComponent.prototype.ngAfterViewInit = function () {
            var animateItems = this.menuRef.animateitems;
            var animationClass = '';
            if (animateItems) {
                animationClass = "animated " + (animationClasses[animateItems][this.menuRef.menuposition] || animationClasses[animateItems].name);
            }
            core.addClass(this.nativeElement, "dropdown-menu " + this.menuRef.menualign + " " + animationClass, true);
        };
        MenuDropdownComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'ul[wmMenuDropdown]',
                        template: "<li wmMenuDropdownItem *ngFor=\"let item of items\"\n    [item]=\"item\"\n    [ngClass]=\"{disabled: item.disabled, 'dropdown-submenu': item.children.length > 0}\"\n    class=\"{{item.class}}\">\n</li>"
                    }] }
        ];
        /** @nocollapse */
        MenuDropdownComponent.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: MenuComponent }
            ];
        };
        MenuDropdownComponent.propDecorators = {
            items: [{ type: core$1.Input }]
        };
        return MenuDropdownComponent;
    }());

    var menuAlignClass = {
        'pull-right': 'fa-caret-left',
        'dropinline-menu': 'fa-caret-down',
        'pull-left': 'fa-caret-right'
    };
    var MENU_LAYOUT_TYPE = {
        HORIZONTAL: 'horizontal',
        VERTICAL: 'vertical'
    };
    var MenuDropdownItemComponent = /** @class */ (function () {
        function MenuDropdownItemComponent(menuRef, userDefinedExecutionContext, parentNav, elRef) {
            var _this = this;
            this.menuRef = menuRef;
            this.userDefinedExecutionContext = userDefinedExecutionContext;
            this.parentNav = parentNav;
            this.onSelect = function ($event, item) {
                if (_this.nativeElement !== $($event.target).closest('.app-menu-item').get(0)) {
                    return;
                }
                // prevent event event propagation if auto close is outside click.
                if (_this.menuRef.autoclose === 'outsideClick') {
                    $event.stopPropagation();
                }
                $event.preventDefault();
                var args = { $event: $event, $item: item };
                var linkTarget = item.target || _this.menuRef.linktarget;
                var itemAction = item.action;
                var menuLink = item.link;
                _this.menuRef.onMenuItemSelect(args);
                if (itemAction) {
                    if (!_this.itemActionFn) {
                        _this.itemActionFn = core.$parseEvent(itemAction);
                    }
                    _this.itemActionFn(_this.userDefinedExecutionContext, Object.create(item));
                }
                if (menuLink) {
                    if (menuLink.startsWith('#/') && (!linkTarget || linkTarget === '_self')) {
                        var queryParams = core.getUrlParams(menuLink);
                        menuLink = core.getRouteNameFromLink(menuLink);
                        _this.menuRef.route.navigate([menuLink], { queryParams: queryParams });
                    }
                    else {
                        core.openLink(menuLink, linkTarget);
                    }
                }
            };
            this.nativeElement = elRef.nativeElement;
            core.addClass(this.nativeElement, 'app-menu-item');
            this.menualign = menuAlignClass[this.menuRef.menualign] || menuAlignClass['pull-left'];
        }
        MenuDropdownItemComponent.prototype.ngOnInit = function () {
            // add active class to the item only if it is in nav component.
            if (this.parentNav) {
                if (isActiveNavItem(this.item.link, this.menuRef.route.url)) {
                    // add active class to the li, if the menu item's link is same as the current page name.
                    core.addClass(this.nativeElement, 'active');
                }
            }
        };
        MenuDropdownItemComponent.prototype.getInitialKeyMovements = function () {
            var KEY_MOVEMENTS = _.clone(KEYBOARD_MOVEMENTS);
            if (this.menuRef.menulayout === MENU_LAYOUT_TYPE.HORIZONTAL) {
                KEY_MOVEMENTS.MOVE_UP = 'LEFT-ARROW';
                KEY_MOVEMENTS.MOVE_LEFT = 'UP-ARROW';
                KEY_MOVEMENTS.MOVE_RIGHT = 'DOWN-ARROW';
                KEY_MOVEMENTS.MOVE_DOWN = 'RIGHT-ARROW';
            }
            else {
                if (this.menuRef.menuposition === MENU_POSITION.DOWN_LEFT || this.menuRef.menuposition === MENU_POSITION.UP_LEFT) {
                    KEY_MOVEMENTS.MOVE_LEFT = 'RIGHT-ARROW';
                    KEY_MOVEMENTS.MOVE_RIGHT = 'LEFT-ARROW';
                }
                else if (this.menuRef.menuposition === 'inline') {
                    KEY_MOVEMENTS.MOVE_UP = 'LEFT-ARROW';
                    KEY_MOVEMENTS.MOVE_LEFT = 'UP-ARROW';
                    KEY_MOVEMENTS.MOVE_RIGHT = 'DOWN-ARROW';
                    KEY_MOVEMENTS.MOVE_DOWN = 'RIGHT-ARROW';
                }
            }
            return KEY_MOVEMENTS;
        };
        MenuDropdownItemComponent.prototype.onKeyDown = function ($event, eventAction) {
            var $li = $(this.nativeElement);
            var $ul = $(this.nativeElement).closest('ul.dropdown-menu');
            var $parentUl = this.menuRef.$element.find('> ul.dropdown-menu');
            var ARROW_KEYS = ['LEFT-ARROW', 'RIGHT-ARROW', 'UP-ARROW', 'DOWN-ARROW'];
            var KEY_MOVEMENTS = this.getInitialKeyMovements();
            if (_.includes(ARROW_KEYS, eventAction)) {
                // preventing from page scroll when up/down arrow is pressed, in case of menu is opened.
                $event.preventDefault();
            }
            if ((eventAction === KEY_MOVEMENTS.ON_TAB && $parentUl.children().last()[0] === this.nativeElement) || eventAction === KEY_MOVEMENTS.ON_ESCAPE) {
                /*closing all the children elements when
                * 1. Tab is clicked on the last $element
                * 2. When Escape key is clicked*/
                $event.preventDefault();
                this.menuRef.bsDropdown.hide();
            }
            else if ((eventAction === KEY_MOVEMENTS.ON_ENTER && !this.item.link) || eventAction === KEY_MOVEMENTS.MOVE_RIGHT) {
                // when there is no link for the menu, on enter open the inner child elements and focus the first $element
                $event.stopPropagation();
                if (this.item.children.length) {
                    $li.toggleClass('open');
                    $li.find('li:first > a').focus();
                }
                else {
                    $li.find('> a').focus();
                }
            }
            else if (eventAction === KEY_MOVEMENTS.MOVE_LEFT || (eventAction === KEY_MOVEMENTS.ON_TAB && $ul.children().last()[0] === this.nativeElement)) {
                if ($parentUl[0] !== $ul[0]) {
                    var $parentItem = $ul.parent();
                    $parentItem.toggleClass('open').find('li.open').removeClass('open');
                    $parentItem.find('> a').focus();
                    $event.preventDefault();
                    $event.stopPropagation();
                }
            }
            else if (eventAction === KEY_MOVEMENTS.MOVE_UP) {
                if ($parentUl[0] !== $ul[0] || $parentUl.find('> li:first')[0] !== this.nativeElement) {
                    $event.stopPropagation();
                    $li.prev().find('> a').focus();
                }
            }
            else if (eventAction === KEY_MOVEMENTS.MOVE_DOWN) {
                $event.stopPropagation();
                if ($parentUl.find('> li:last')[0] === this.nativeElement && (this.menuRef.menulayout !== MENU_LAYOUT_TYPE.HORIZONTAL && this.menuRef.menuposition === MENU_POSITION.UP_RIGHT || this.menuRef.menuposition === MENU_POSITION.UP_LEFT)) {
                    this.menuRef.bsDropdown.hide();
                }
                else {
                    $li.next().find('> a').focus();
                }
            }
            else if (eventAction === KEY_MOVEMENTS.ON_ENTER) {
                this.onSelect($event, this.item);
            }
            else {
                $event.stopPropagation();
            }
        };
        MenuDropdownItemComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'li[wmMenuDropdownItem]',
                        template: "<a href=\"javascript:void(0);\" [title]=\"item.label\" [wmNavigationControl]=\"item.link\" [disableMenuContext]=\"menuRef.disableMenuContext || !!item.action\">\n    <span *ngIf=\"item.children.length\" class=\"pull-right fa caret {{menualign}}\"></span>\n    <i class=\"app-icon {{item.icon}}\"></i>\n    <span class=\"anchor-caption\">{{item.label}}</span>\n\n</a>\n<ng-container [ngTemplateOutlet]=\"nestedMenuDropdown\" *ngIf=\"item.children.length\" [ngTemplateOutletContext]=\"{item: item}\"></ng-container>\n\n<ng-template #nestedMenuDropdown let-item=\"item\">\n    <ul wmMenuDropdown [items]=\"item.children\"></ul>\n</ng-template>\n"
                    }] }
        ];
        /** @nocollapse */
        MenuDropdownItemComponent.ctorParameters = function () {
            return [
                { type: MenuComponent },
                { type: core.UserDefinedExecutionContext },
                { type: NavComponent, decorators: [{ type: core$1.Optional }] },
                { type: core$1.ElementRef }
            ];
        };
        MenuDropdownItemComponent.propDecorators = {
            item: [{ type: core$1.Input }],
            onKeyDown: [{ type: core$1.HostListener, args: ['keydown.tab', ['$event', '"TAB"'],] }, { type: core$1.HostListener, args: ['keydown.escape', ['$event', '"ESC"'],] }, { type: core$1.HostListener, args: ['keydown.enter', ['$event', '"ENTER"'],] }, { type: core$1.HostListener, args: ['keydown.arrowup', ['$event', '"UP-ARROW"'],] }, { type: core$1.HostListener, args: ['keydown.arrowdown', ['$event', '"DOWN-ARROW"'],] }, { type: core$1.HostListener, args: ['keydown.arrowright', ['$event', '"RIGHT-ARROW"'],] }, { type: core$1.HostListener, args: ['keydown.arrowleft', ['$event', '"LEFT-ARROW"'],] }],
            onSelect: [{ type: core$1.HostListener, args: ['click', ['$event', 'item'],] }]
        };
        return MenuDropdownItemComponent;
    }());

    var registerProps$11 = function () {
        register('wm-navbar', new Map([
            ['class', __assign({ value: '' }, PROP_STRING)],
            ['homelink', PROP_STRING],
            ['imgsrc', PROP_STRING],
            ['menuiconclass', __assign({ value: 'wi wi-more-vert' }, PROP_STRING)],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['title', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$F = 'navbar navbar-default app-navbar';
    var WIDGET_CONFIG$N = { widgetType: 'wm-navbar', hostClass: DEFAULT_CLS$F };
    var NavbarComponent = /** @class */ (function (_super) {
        __extends(NavbarComponent, _super);
        function NavbarComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$N) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        NavbarComponent.prototype.toggleCollapse = function () {
            var _this = this;
            var $navContent = $(this.navContent.nativeElement);
            $navContent.animate({ 'height': 'toggle' });
            if ($navContent.hasClass('in')) {
                setTimeout(function () { return _this.toggleNavCollapse(); }, 500);
            }
            else {
                this.toggleNavCollapse();
            }
        };
        NavbarComponent.prototype.toggleNavCollapse = function () {
            this.navContent.nativeElement.classList.toggle('in');
        };
        NavbarComponent.initializeProps = registerProps$11();
        NavbarComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmNavbar]',
                        template: "<div class=\"container-fluid\">\n    <div class=\"navbar-header\">\n        <button type=\"button\" class=\"btn-transparent navbar-toggle collapsed\" data-toggle=\"collapse\" (click)=\"toggleCollapse()\" aria-expanded=\"false\">\n            <span class=\"sr-only\">Toggle navigation</span>\n            <i [ngClass]=\"menuiconclass\"></i>\n        </button>\n        <a class=\"navbar-brand\" [href]=\"(homelink | trustAs: 'resource') || '#/'\" *ngIf=\"title || imgsrc\">\n            <img data-identifier=\"img\" class=\"brand-image\" [alt]=\"Brand\" height=\"20\" *ngIf=\"imgsrc\" [src]=\"imgsrc | image\"/>\n            <span class=\"title\" [textContent]=\"title\"></span>\n        </a>\n    </div>\n    <div class=\"collapse navbar-collapse\" #navContent>\n        <ng-content></ng-content>\n    </div>\n</div>",
                        providers: [
                            provideAsWidgetRef(NavbarComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        NavbarComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        NavbarComponent.propDecorators = {
            navContent: [{ type: core$1.ViewChild, args: ['navContent',] }]
        };
        return NavbarComponent;
    }(StylableComponent));

    var WIDGET_CONFIG$O = {
        widgetType: 'wm-number',
        hostClass: 'app-input-wrapper'
    };
    var NumberComponent = /** @class */ (function (_super) {
        __extends(NumberComponent, _super);
        function NumberComponent(inj, i18nService, decimalPipe) {
            return _super.call(this, inj, WIDGET_CONFIG$O, i18nService, decimalPipe) || this;
        }
        NumberComponent.initializeProps = registerProps$z();
        NumberComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmNumber]',
                        template: "<input class=\"form-control app-textbox app-number-input\"\n       inputmode=\"numeric\"\n       focus-target\n       [attr.name]=\"name\"\n       role=\"input\"\n       type=\"text\"\n       [ngModel]=\"displayValue\"\n       [readonly]=\"readonly\"\n       [disabled]=\"disabled\"\n       [pattern]=\"regexp\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (ngModelChange)=\"datavalue=$event\"\n       (blur)=\"handleBlur($event)\"\n       [ngModelOptions]=\"ngModelOptions\"\n       [required]=\"required\"\n       (keypress)=\"validateInputEntry($event)\"\n       (keydown.enter)=\"onEnter($event)\"\n       (keydown.ArrowUp)=\"onArrowPress($event, 'UP')\"\n       (keydown.ArrowDown)=\"onArrowPress($event, 'DOWN')\"\n       #input>",
                        providers: [
                            provideAsNgValueAccessor(NumberComponent),
                            provideAsNgValidators(NumberComponent),
                            provideAsWidgetRef(NumberComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        NumberComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core.AbstractI18nService },
                { type: common.DecimalPipe }
            ];
        };
        NumberComponent.propDecorators = {
            inputEl: [{ type: core$1.ViewChild, args: ['input',] }],
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }]
        };
        return NumberComponent;
    }(NumberLocale));

    var registerProps$12 = function () {
        register('wm-page-content', new Map([
            ['class', PROP_STRING],
            ['columnwidth', PROP_NUMBER],
            ['content', PROP_STRING],
            ['name', PROP_STRING],
            ['pulltorefresh', __assign({ value: core.isMobileApp() }, PROP_BOOLEAN)]
        ]));
    };

    var PullToRefresh = /** @class */ (function (_super) {
        __extends(PullToRefresh, _super);
        function PullToRefresh($el, app, onPullToRefresh) {
            var _this = _super.call(this) || this;
            _this.$el = $el;
            _this.app = app;
            _this.onPullToRefresh = onPullToRefresh;
            _this.count = 0;
            var template = '<div class="refresh-container"></div>';
            _this.$el.prepend(template);
            _this.infoContainer = _this.$el.find('.refresh-container');
            if (core.isIos()) {
                _this.infoContainer.addClass('ios-refresh-container');
            }
            _this.init(_this.$el);
            return _this;
        }
        PullToRefresh.prototype.threshold = function () {
            return 10;
        };
        PullToRefresh.prototype.direction = function () {
            return $.fn.swipey.DIRECTIONS.VERTICAL;
        };
        PullToRefresh.prototype.subscribe = function () {
            var _this = this;
            // Subscribing for variable updates, wait till the response and stop the animation.
            this.cancelSubscription = this.app.subscribe('toggle-variable-state', function (data) {
                // data.active is true means the variable update has just started whereas false means update has ended.
                if (data.active && _this.animationInProgress) {
                    _this.count++;
                    _this.wait();
                }
                else if (_this.count > 0) {
                    _this.count--;
                }
                // call stop animation only when animation has started.
                if (!_this.count && _this.animationInProgress) {
                    _this.stopAnimation();
                }
            });
        };
        PullToRefresh.prototype.bounds = function ($event, $d) {
            var pageIscroll = this.$el[0].iscroll;
            // If scroll position is not at the top of the page then do not trigger the animation.
            if ($d < 0 || (pageIscroll && !isNaN(pageIscroll.y) && pageIscroll.y !== 0)) {
                return {
                    lower: undefined,
                    upper: undefined
                };
            }
            if (!this.spinner) {
                this.spinner = core.isIos() ? new IOSSpinner(this.infoContainer) : new AndroidSpinner(this.infoContainer);
                this.subscribe();
            }
            return {
                lower: 0,
                center: 0,
                upper: core.isIos() ? 0 : 150,
                strict: !core.isIos()
            };
        };
        PullToRefresh.prototype.context = function () {
            var _this = this;
            this.infoContainer.show();
            if (core.isIos()) {
                this.infoContainer.addClass('entry');
            }
            return {
                spin: function ($d) {
                    _this.spinner.setRotation($d * 2);
                }
            };
        };
        PullToRefresh.prototype.animation = function () {
            if (core.isIos()) {
                return {
                    css: {
                        transform: 'translate3d(0, ${{$D + $d}}px, 0)',
                        spin: '${{spin($d)}}'
                    }
                };
            }
            return {
                target: this.infoContainer,
                css: {
                    transform: 'translate3d(0, ${{$D + $d}}px, 0)',
                    spin: '${{spin($d)}}',
                    opacity: '${{min(($D + $d) / 100, 1)}}'
                }
            };
        };
        // Start the spinner animation and invokes the pulltorefresh event. Stops the animation after the wait time.
        PullToRefresh.prototype.onAnimation = function () {
            var _this = this;
            this.animationInProgress = true;
            this.spinner.start();
            if (this.onPullToRefresh) {
                this.onPullToRefresh();
            }
            setTimeout(function () {
                // if listenToAnimation is set, then wait for stopAnimation to be invoked. Otherwise call stopAnimation manually.
                if (_this.runAnimation) {
                    return;
                }
                _this.stopAnimation();
            });
        };
        PullToRefresh.prototype.stopAnimation = function () {
            var _this = this;
            setTimeout(function () {
                _this.runAnimation = false;
                _this.animationInProgress = false;
                _this.spinner.stop();
                _this.infoContainer.hide();
                core.setCSS(_this.infoContainer[0], 'transform', 'none');
                if (!core.isIos()) {
                    core.setCSS(_this.infoContainer[0], 'opacity', 0);
                }
                _this.infoContainer.removeClass('entry');
            }, 800);
        };
        PullToRefresh.prototype.wait = function () {
            this.runAnimation = true;
        };
        return PullToRefresh;
    }(_swipey.SwipeAnimation));
    // Android Spinner implementation
    var AndroidSpinner = /** @class */ (function () {
        function AndroidSpinner($el, options) {
            this.$el = $el;
            this.options = options || {};
        }
        AndroidSpinner.prototype.polarToCartesian = function (centerX, centerY, radius, angleInDegrees) {
            var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        };
        AndroidSpinner.prototype.describeArc = function (x, y, radius, startAngle, endAngle) {
            var start = this.polarToCartesian(x, y, radius, endAngle);
            var end = this.polarToCartesian(x, y, radius, startAngle);
            var arcSweep = endAngle - startAngle <= 180 ? '0' : '1';
            return [
                'M', start.x, start.y,
                'A', radius, radius, 0, arcSweep, 0, end.x, end.y,
                'L', end.x, end.y
            ].join(' ');
        };
        AndroidSpinner.prototype.init = function () {
            if (this.initialized) {
                return;
            }
            // append the svg to the element on which spinner has to be shown.
            var androidTemplate = $('<svg><path id="arc1"/></svg>');
            var container = $('<div class="android-spinner"></div>');
            container.append(androidTemplate);
            this.$el.append(container);
            this.cx = container.outerWidth() / 2;
            this.cy = container.outerHeight() / 2;
            this.r = this.cx * 0.6;
            this.path = container.find('path');
            this.initialized = true;
            this.container = container;
        };
        // sets rotation to the path
        AndroidSpinner.prototype.setRotation = function (deg) {
            this.init();
            this.path.attr('d', this.describeArc(this.cx, this.cy, this.r, 0, deg));
        };
        // animate the path to rotate continuously with some interval
        AndroidSpinner.prototype.start = function () {
            var _this = this;
            this.init();
            var self = this, totalTime = this.options.time || 1800, degreesToTraverse = 10;
            var i = 0;
            this.container.addClass('spin');
            this.intervalId = setInterval(function () {
                var deg;
                i = i + degreesToTraverse;
                if (i > 720) {
                    deg = i = 0;
                }
                else if (i > 360) {
                    deg = 720 - i;
                }
                else {
                    deg = i;
                }
                self.path.attr('d', _this.describeArc(self.cx, self.cy, self.r, 0, deg));
            }, (totalTime * degreesToTraverse / 360));
        };
        // Removes the animation by clearing the intervals
        AndroidSpinner.prototype.stop = function () {
            if (this.intervalId) {
                clearInterval(this.intervalId);
                this.intervalId = 0;
            }
            this.container.removeClass('spin');
        };
        return AndroidSpinner;
    }());
    // iOS spinner implementation
    var IOSSpinner = /** @class */ (function () {
        function IOSSpinner($el) {
            this.$el = $el;
        }
        // create the iOS spinner using svg
        IOSSpinner.prototype.init = function () {
            if (this.svg) {
                return;
            }
            var container = $('<div class="ios-spinner"><svg></svg></div>');
            var svg = container.find('svg');
            this.$el.append(container);
            var d = container.width();
            for (var i = 0; i < 12; i++) {
                svg[0].innerHTML += "<line y1=\"" + 0.15 * d + "\" y2=\"" + 0.3 * d + "\"\n                                    transform=\"translate(" + 0.5 * d + ", " + 0.5 * d + ") rotate(" + i * 30 + ")\">\n                                </line>";
            }
            container.append(svg);
            this.svg = svg;
        };
        // Sets the svg to rotate depending on "d" value
        IOSSpinner.prototype.setRotation = function (d) {
            this.init();
            this.svg.css('transform', "rotateZ( " + Math.round(d / 30) * 30 + "deg)");
        };
        // Triggers the rotation with some interval
        IOSSpinner.prototype.start = function () {
            var _this = this;
            this.init();
            var i = 0;
            this.intervalId = setInterval(function () {
                i += 10;
                _this.setRotation(i);
            }, 20);
        };
        // Removes the animation by clearing the intervals
        IOSSpinner.prototype.stop = function () {
            if (this.intervalId) {
                clearInterval(this.intervalId);
                this.intervalId = 0;
            }
        };
        return IOSSpinner;
    }());

    var DEFAULT_CLS$G = 'app-page-content app-content-column';
    var WIDGET_CONFIG$P = { widgetType: 'wm-page-content', hostClass: DEFAULT_CLS$G };
    var PageContentComponent = /** @class */ (function (_super) {
        __extends(PageContentComponent, _super);
        function PageContentComponent(inj, app) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$P) || this;
            _this.app = app;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            _this.registerDestroyListener(_this.app.subscribe('pullToRefresh:enable', function () {
                _this.childPullToRefresh = true;
                _this.initPullToRefresh();
            }));
            return _this;
        }
        PageContentComponent.prototype.onPropertyChange = function (key, nv, ov) {
            var _this = this;
            if (key === 'columnwidth') {
                core.switchClass(this.nativeElement, "col-md-" + nv + " col-sm-" + nv, "col-md-" + ov + " col-sm-" + ov);
            }
            else if (key === 'pulltorefresh' && nv) {
                // creating instance after timeout as the smoothscroll styles where getting added on pull refresh-container
                setTimeout(function () {
                    _this.initPullToRefresh();
                });
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        // when list component is ready, pulltorefresh instance is created and this appends pullToRefresh element on the page content.
        PageContentComponent.prototype.initPullToRefresh = function () {
            var _this = this;
            var hasPullToRefreshEvent = this.hasEventCallback('pulltorefresh');
            if (!this.pullToRefreshIns && (this.childPullToRefresh || hasPullToRefreshEvent) && this.pulltorefresh) {
                this.pullToRefreshIns = new PullToRefresh($(this.nativeElement), this.app, function () {
                    if (hasPullToRefreshEvent) {
                        _this.invokeEventCallback('pulltorefresh');
                    }
                    else {
                        _this.app.notify('pulltorefresh');
                    }
                });
                this.registerDestroyListener(function () {
                    if (_this.pullToRefreshIns.cancelSubscription) {
                        _this.pullToRefreshIns.cancelSubscription();
                    }
                });
            }
        };
        PageContentComponent.initializeProps = registerProps$12();
        PageContentComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmPageContent]',
                        template: "<ng-content></ng-content>",
                        providers: [
                            provideAsWidgetRef(PageContentComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        PageContentComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core.App }
            ];
        };
        return PageContentComponent;
    }(StylableComponent));

    var registerProps$13 = function () {
        register('wm-panel', new Map([
            ['actions', {}],
            ['badgetype', __assign({ value: 'default' }, PROP_STRING)],
            ['badgevalue', PROP_STRING],
            ['class', PROP_STRING],
            ['closable', PROP_BOOLEAN],
            ['collapsible', PROP_BOOLEAN],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['content', PROP_STRING],
            ['datafield', PROP_STRING],
            ['enablefullscreen', PROP_BOOLEAN],
            ['expanded', __assign({ value: true }, PROP_BOOLEAN)],
            ['fullscreen', PROP_BOOLEAN],
            ['helptext', PROP_STRING],
            ['iconclass', PROP_STRING],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['itemaction', PROP_STRING],
            ['itemchildren', PROP_STRING],
            ['itemicon', PROP_STRING],
            ['itemlabel', PROP_STRING],
            ['itemlink', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['subheading', PROP_STRING],
            ['title', PROP_STRING],
            ['userrole', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$H = 'app-panel panel';
    var WIDGET_CONFIG$Q = { widgetType: 'wm-panel', hostClass: DEFAULT_CLS$H };
    var PanelComponent = /** @class */ (function (_super) {
        __extends(PanelComponent, _super);
        function PanelComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$Q) || this;
            _this.$lazyLoad = core.noop;
            _this.expanded = true;
            _this.helpClass = '';
            _this.helptext = '';
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.SHELL);
            _this.fullScreenTitle = _this.appLocale.LABEL_FULLSCREEN + "/" + _this.appLocale.LABEL_EXITFULLSCREEN;
            _this.expandCollapseTitle = _this.appLocale.LABEL_COLLAPSE + "/" + _this.appLocale.LABEL_EXPAND;
            core.removeAttr(_this.nativeElement, 'title');
            return _this;
        }
        Object.defineProperty(PanelComponent.prototype, "hideFooter", {
            // conditions to show the footer
            get: function () {
                return !this.hasFooter || !this.expanded;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PanelComponent.prototype, "showHeader", {
            // conditions to show header
            get: function () {
                return this.iconurl || this.iconclass || this.collapsible || this.actions || this.title || this.subheading || this.enablefullscreen;
            },
            enumerable: true,
            configurable: true
        });
        // toggle the panel state between collapsed - expanded. invoke the respective callbacks
        PanelComponent.prototype.toggle = function ($event) {
            if (this.collapsible) {
                this.invokeEventCallback(this.expanded ? 'collapse' : 'expand', { $event: $event });
                this.expanded = !this.expanded;
                if (this.expanded) {
                    this.$lazyLoad();
                    this.reDrawChildren();
                }
            }
        };
        PanelComponent.prototype.expand = function ($event) {
            if (!this.expanded) {
                this.toggle($event);
            }
        };
        PanelComponent.prototype.collapse = function ($event) {
            if (this.expanded) {
                this.toggle($event);
            }
        };
        // toggle the fullscreen state of the panel. invoke the respective callbacks
        PanelComponent.prototype.toggleFullScreen = function ($event) {
            if (this.enablefullscreen) {
                this.invokeEventCallback(this.fullscreen ? 'exitfullscreen' : 'fullscreen', { $event: $event });
                this.fullscreen = !this.fullscreen;
                core.toggleClass(this.nativeElement, 'fullscreen', this.fullscreen);
                // Re-plot the widgets inside panel
                this.reDrawChildren();
            }
            this.computeDimensions();
        };
        // show/hide help
        PanelComponent.prototype.toggleHelp = function () {
            this.helpClass = this.helpClass ? '' : 'show-help';
            core.toggleClass(this.nativeElement, 'show-help', !!this.helpClass);
            core.$appDigest();
        };
        // hide the panel and invoke the respective event handler
        PanelComponent.prototype.close = function ($event) {
            this.getWidget().show = false;
            this.invokeEventCallback('close', { $event: $event });
        };
        // calculation of dimensions when the panel the panel state changes from/to fullscreen
        PanelComponent.prototype.computeDimensions = function () {
            var headerHeight = this.panelHeader.nativeElement.offsetHeight;
            var footer = this.nativeElement.querySelector('.panel-footer');
            var content = this.panelContent.nativeElement;
            var vHeight = window.innerHeight;
            var inlineHeight;
            if (this.fullscreen) {
                inlineHeight = this.hideFooter ? (vHeight - headerHeight) : vHeight - (footer.offsetHeight + headerHeight);
            }
            else {
                inlineHeight = this.height || '';
            }
            core.setCSS(content, 'height', inlineHeight);
        };
        // notify the redrawable components(charts, grid)
        PanelComponent.prototype.reDrawChildren = function () {
            var _this = this;
            setTimeout(function () {
                if (_this.reDrawableComponents) {
                    _this.reDrawableComponents.forEach(function (c) { return c.redraw(); });
                }
            }, 100);
        };
        PanelComponent.prototype.onPropertyChange = function (key, nv, ov) {
            var _this = this;
            if (key === 'expanded') {
                this.expanded = nv;
            }
            else if (key === 'content') {
                setTimeout(function () {
                    if (_this.expanded || !_this.collapsible) {
                        _this.$lazyLoad();
                    }
                }, 20);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        PanelComponent.prototype.ngAfterContentInit = function () {
            _super.prototype.ngAfterContentInit.call(this);
            this.hasFooter = !!this.nativeElement.querySelector('[wmPanelFooter]');
            styler(this.panelBody.nativeElement, this, exports.APPLY_STYLES_TYPE.INNER_SHELL);
        };
        PanelComponent.initializeProps = registerProps$13();
        PanelComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmPanel]',
                        template: "<div class=\"panel-heading {{helpClass}}\" *ngIf=\"showHeader\" #panelHeading>\n    <h3 class=\"panel-title\">\n        <a href=\"javascript:void(0)\" class=\"panel-toggle\" (click)=\"toggle($event)\">\n            <div class=\"pull-left\">\n                <i class=\"app-icon panel-icon {{iconclass}}\" *ngIf=\"iconclass && !iconurl\"></i>\n                <img data-identifier=\"img\" title=\"iconurl\" alt=\"Panel icon\" class=\"panel-image-icon\" [src]=\"iconurl | image\" *ngIf=\"iconurl\"\n                     [ngStyle]=\"{width: iconwidth ,height: iconheight, margin: iconmargin}\"/>\n            </div>\n            <div class=\"pull-left\">\n                <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\" [title]=\"title\"></div>\n                <div class=\"description\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n            </div>\n        </a>\n        <div class=\"panel-actions\">\n            <span *ngIf=\"badgevalue\" aria-label=\"badge\" class=\"app-badge label label-{{badgetype}}\">{{badgevalue}}</span>\n            <div wmMenu aria-label=\"dropdown\"\n                 dropdown\n                 type=\"anchor\"\n                 class=\"panel-action\"\n                 dataset.bind=\"actions\"\n                 *ngIf=\"actions\"\n                 caption=\"\"\n                 menuposition=\"down,left\"\n                 iconclass=\"wi wi-more-vert\"\n                 datafield.bind=\"datafield\"\n                ></div>\n            <button type=\"button\" aria-label=\"Help\" class=\"app-icon panel-action wi\" [title]=\"appLocale.LABEL_HELP\" *ngIf=\"helptext\"\n                    (click)=\"toggleHelp()\"><i class=\"wi-question\"></i></button>\n            <button type=\"button\" aria-label=\"Collapse/Expand\" class=\"app-icon wi panel-action\" *ngIf=\"collapsible\" [title]=\"expandCollapseTitle\"\n                    (click)=\"toggle($event);\"><i [ngClass]=\"expanded ? 'wi-minus' : 'wi-plus'\"></i></button>\n            <button type=\"button\" aria-label=\"Fullscreen/Exit\" class=\"app-icon panel-action wi\" *ngIf=\"enablefullscreen\"\n                    [title]=\"fullScreenTitle\"\n                    (click)=\"toggleFullScreen($event);\"><i [ngClass]=\"fullscreen ? 'wi-fullscreen-exit' : 'wi-fullscreen'\"></i></button>\n            <button type=\"button\" aria-label=\"Close button\" class=\"app-icon panel-action\" title=\"{{appLocale.LABEL_CLOSE}}\" *ngIf=\"closable\"\n                    (click)=\"close($event)\"><i class=\"wi wi-close\"></i></button>\n        </div>\n    </h3>\n</div>\n<div class=\"panel-content\" [hidden]=\"!expanded\" #panelContent>\n    <!-- Todo Bandhavya - implement smooth scroll -->\n    <div partial-container-target #panelBody [ngClass]=\"['panel-body', helpClass]\">\n        <ng-content></ng-content>\n    </div>\n    <aside class=\"panel-help-message\" [ngClass]=\"helpClass\">\n        <h5 class=\"panel-help-header\" [textContent]=\"appLocale.LABEL_HELP\"></h5>\n        <div class=\"panel-help-content\" [innerHTML]=\"helptext | trustAs : 'html'\"></div>\n    </aside>\n</div>\n<div class=\"app-panel-footer panel-footer clearfix\" [hidden]=\"hideFooter\">\n    <ng-content select=\"[wmPanelFooter]\"></ng-content>\n</div>",
                        providers: [
                            provideAsWidgetRef(PanelComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        PanelComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        PanelComponent.propDecorators = {
            panelHeader: [{ type: core$1.ViewChild, args: ['panelHeading',] }],
            panelContent: [{ type: core$1.ViewChild, args: ['panelContent',] }],
            panelBody: [{ type: core$1.ViewChild, args: ['panelBody',] }],
            reDrawableComponents: [{ type: core$1.ContentChildren, args: [RedrawableDirective, { descendants: true },] }]
        };
        return PanelComponent;
    }(MenuAdapterComponent));

    var registerProps$14 = function () {
        register('wm-partialdialog', new Map([
            ['animation', PROP_STRING],
            ['class', PROP_STRING],
            ['closable', { value: true, PROP_BOOLEAN: PROP_BOOLEAN }],
            ['content', PROP_STRING],
            ['iconclass', { value: 'wi wi-file', PROP_STRING: PROP_STRING }],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['modal', __assign({ value: false }, PROP_BOOLEAN)],
            ['name', PROP_STRING],
            ['oktext', __assign({ value: 'OK' }, PROP_STRING)],
            ['showactions', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', __assign({ value: 'Page Content' }, PROP_STRING)]
        ]));
    };

    var DIALOG_CLS$4 = 'app-dialog modal-dialog app-page-dialog';
    var WIDGET_INFO$5 = { widgetType: 'wm-partialdialog' };
    var PartialDialogComponent = /** @class */ (function (_super) {
        __extends(PartialDialogComponent, _super);
        function PartialDialogComponent(inj, dialogClass, modal, closable) {
            var _this = this;
            if (modal === null || modal === undefined) {
                modal = false;
            }
            if (closable === null || closable === undefined) {
                closable = true;
            }
            // setting the backdrop to 'static' will not close the dialog on backdrop click
            var backdrop = core.toBoolean(modal) ? 'static' : true;
            _this = _super.call(this, inj, WIDGET_INFO$5, {
                class: DIALOG_CLS$4 + " " + (dialogClass || ''),
                backdrop: backdrop,
                keyboard: !core.toBoolean(modal)
            }) || this;
            return _this;
        }
        PartialDialogComponent.prototype.getTemplateRef = function () {
            return this.dialogTemplate;
        };
        /**
         * Click event handler for the ok button
         * invokes on-ok event callback
         * @param {Event} $event
         */
        PartialDialogComponent.prototype.onOk = function ($event) {
            this.invokeEventCallback('ok', { $event: $event });
        };
        PartialDialogComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.register(this.viewParent);
        };
        PartialDialogComponent.initializeProps = registerProps$14();
        PartialDialogComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmPartialDialog]',
                        template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"\n    ></div>\n    <div wmDialogBody>\n        <ng-container *ngTemplateOutlet=\"dialogContent\"></ng-container>\n    </div>\n    <div wmDialogFooter *ngIf=\"showactions\">\n        <button wmButton class=\"btn-primary ok-action\" caption.bind=\"oktext\" aria-label=\"Submit button\" (click)=\"onOk($event)\"></button>\n    </div>\n</ng-template>\n",
                        providers: [
                            provideAsWidgetRef(PartialDialogComponent),
                            provideAsDialogRef(PartialDialogComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        PartialDialogComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['class',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['modal',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['closable',] }] }
            ];
        };
        PartialDialogComponent.propDecorators = {
            dialogTemplate: [{ type: core$1.ViewChild, args: ['dialogTemplate',] }],
            dialogContent: [{ type: core$1.ContentChild, args: [core$1.TemplateRef,] }]
        };
        return PartialDialogComponent;
    }(BaseDialog));

    var registerProps$15 = function () {
        register('wm-partial', new Map([
            ['name', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$I = 'app-partial clearfix';
    var WIDGET_CONFIG$R = { widgetType: 'wm-partial', hostClass: DEFAULT_CLS$I };
    var PartialDirective = /** @class */ (function (_super) {
        __extends(PartialDirective, _super);
        function PartialDirective(inj) {
            return _super.call(this, inj, WIDGET_CONFIG$R) || this;
        }
        PartialDirective.initializeProps = registerProps$15();
        PartialDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmPartial]',
                        providers: [
                            provideAsWidgetRef(PartialDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        PartialDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return PartialDirective;
    }(StylableComponent));

    var PartialParamHandlerDirective = /** @class */ (function () {
        function PartialParamHandlerDirective(widgetRef) {
            this.widgetRef = widgetRef;
            this.widgetRef.partialParams = {};
            this.widgetRef.pageParams = this.widgetRef.partialParams;
            this.widgetRef.params$ = new rxjs.Subject();
        }
        PartialParamHandlerDirective.prototype.registerParams = function (name, value, bindExpr, type) {
            var _this = this;
            this.widgetRef.partialParams[name] = value;
            if (!value && bindExpr) {
                this.widgetRef.registerDestroyListener(core.$watch(bindExpr, this.widgetRef.getViewParent(), _.get(this.widgetRef, 'context'), function (nv) {
                    _this.widgetRef.partialParams[name] = nv;
                    // notify the partial container of the param changes
                    _this.widgetRef.params$.next();
                }));
            }
            else {
                this.widgetRef.params$.next();
            }
        };
        PartialParamHandlerDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[partialContainer]',
                    },] }
        ];
        /** @nocollapse */
        PartialParamHandlerDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [WidgetRef,] }] }
            ];
        };
        return PartialParamHandlerDirective;
    }());
    var PartialParamDirective = /** @class */ (function () {
        function PartialParamDirective(bindValue, type, partialParamsProvider) {
            this.bindValue = bindValue;
            this.type = type;
            this.partialParamsProvider = partialParamsProvider;
        }
        PartialParamDirective.prototype.ngOnInit = function () {
            this.partialParamsProvider.registerParams(this.name, this.value, this.bindValue, this.type);
        };
        PartialParamDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmParam]',
                    },] }
        ];
        /** @nocollapse */
        PartialParamDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['value.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['type',] }] },
                { type: PartialParamHandlerDirective }
            ];
        };
        PartialParamDirective.propDecorators = {
            name: [{ type: core$1.Input }],
            value: [{ type: core$1.Input }]
        };
        return PartialParamDirective;
    }());

    var registerProps$16 = function () {
        register('wm-prefab-container', new Map([
            ['class', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
        ]));
    };

    var DEFAULT_CLS$J = 'app-prefab-container full-height';
    var WIDGET_CONFIG$S = {
        widgetType: 'wm-prefab-container',
        hostClass: DEFAULT_CLS$J
    };
    var PrefabContainerDirective = /** @class */ (function (_super) {
        __extends(PrefabContainerDirective, _super);
        function PrefabContainerDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$S) || this;
            styler(_this.nativeElement, _this);
            return _this;
        }
        PrefabContainerDirective.initializeProps = registerProps$16();
        PrefabContainerDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmPrefabContainer]',
                        providers: [
                            provideAsWidgetRef(PrefabContainerDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        PrefabContainerDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return PrefabContainerDirective;
    }(StylableComponent));

    var registerProps$17 = function () {
        var props = new Map([
            ['class', PROP_STRING],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['encodeurl', PROP_STRING],
            ['hint', PROP_STRING],
            ['name', PROP_STRING],
            ['pictureaspect', __assign({ value: 'None' }, PROP_STRING)],
            ['pictureplaceholder', PROP_STRING],
            ['picturesource', PROP_STRING],
            ['shape', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)]
        ]);
        if (core.isMobileApp()) {
            props.set('offline', __assign({ value: true }, PROP_BOOLEAN));
        }
        register('wm-picture', props);
    };

    var DEFAULT_CLS$K = 'app-picture';
    var WIDGET_CONFIG$T = {
        widgetType: 'wm-picture',
        hostClass: DEFAULT_CLS$K,
        displayType: DISPLAY_TYPE.INLINE_BLOCK
    };
    var PictureDirective = /** @class */ (function (_super) {
        __extends(PictureDirective, _super);
        function PictureDirective(inj, imagePipe) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$T) || this;
            _this.imagePipe = imagePipe;
            styler(_this.nativeElement, _this);
            return _this;
        }
        PictureDirective.prototype.setImgSource = function () {
            this.imgSource = this.imagePipe.transform(this.picturesource, this.encodeurl, this.pictureplaceholder);
        };
        PictureDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'pictureaspect') {
                var width = '';
                var height = '';
                switch (nv) {
                    case 'None':
                        width = this.width;
                        height = this.height;
                        break;
                    case 'H':
                        width = '100%';
                        break;
                    case 'V':
                        height = '100%';
                        break;
                    case 'Both':
                        width = '100%';
                        height = '100%';
                        break;
                }
                core.setCSS(this.nativeElement, 'width', width, true);
                core.setCSS(this.nativeElement, 'height', height, true);
            }
            else if (key === 'encodeurl' || key === 'pictureplaceholder') {
                this.setImgSource();
            }
            else if (key === 'shape') {
                core.switchClass(this.nativeElement, "img-" + nv, "img-" + ov);
            }
            else if (key === 'hint') {
                core.setAttr(this.nativeElement, 'alt', nv);
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        PictureDirective.prototype.onStyleChange = function (key, nv, ov) {
            if (key === 'picturesource') {
                this.setImgSource();
            }
            else {
                _super.prototype.onStyleChange.call(this, key, nv, ov);
            }
        };
        PictureDirective.prototype.ngOnInit = function () {
            this.setImgSource();
            _super.prototype.ngOnInit.call(this);
        };
        PictureDirective.initializeProps = registerProps$17();
        PictureDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'img[wmPicture]',
                        providers: [
                            provideAsWidgetRef(PictureDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        PictureDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: ImagePipe }
            ];
        };
        PictureDirective.propDecorators = {
            imgSource: [{ type: core$1.HostBinding, args: ['src',] }]
        };
        return PictureDirective;
    }(StylableComponent));

    var registerProps$18 = function () {
        register('wm-popover', new Map([
            ['badgevalue', PROP_STRING],
            ['caption', __assign({ value: 'Link' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['conditionalclass', PROP_ANY],
            ['content', PROP_STRING],
            ['contentanimation', PROP_STRING],
            ['contentsource', __assign({ value: 'partial' }, PROP_STRING)],
            ['encodeurl', PROP_BOOLEAN],
            ['hint', PROP_STRING],
            ['hyperlink', PROP_STRING],
            ['iconclass', PROP_STRING],
            ['iconheight', PROP_STRING],
            ['iconmargin', PROP_STRING],
            ['iconposition', PROP_STRING],
            ['iconurl', PROP_STRING],
            ['iconwidth', PROP_STRING],
            ['interaction', __assign({ value: 'click' }, PROP_STRING)],
            ['name', PROP_STRING],
            ['popoverarrow', __assign({ value: true }, PROP_BOOLEAN)],
            ['popoverheight', PROP_STRING],
            ['popoverplacement', __assign({ value: 'bottom' }, PROP_STRING)],
            ['popoverwidth', PROP_STRING],
            ['shortcutkey', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$L = 'app-popover-wrapper';
    var WIDGET_CONFIG$U = {
        widgetType: 'wm-popover',
        hostClass: DEFAULT_CLS$L
    };
    var eventsMap = {
        click: 'click',
        hover: 'mouseenter:click',
        default: 'click mouseenter'
    };
    var activePopover;
    var PopoverComponent = /** @class */ (function (_super) {
        __extends(PopoverComponent, _super);
        function PopoverComponent(inj, app, evtMngrPlugins) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$U) || this;
            _this.app = app;
            _this.isOpen = false;
            _this.canPopoverOpen = true;
            // KeyEventsPlugin
            _this.keyEventPlugin = evtMngrPlugins[1];
            _this.popoverContainerCls = "app-popover-" + _this.widgetId;
            return _this;
        }
        // This mehtod is used to show/open the popover. This refers to the same method showPopover.
        PopoverComponent.prototype.open = function () {
            this.showPopover();
        };
        // This mehtod is used to hide/close the popover.
        PopoverComponent.prototype.close = function () {
            this.isOpen = false;
        };
        // Trigger on hiding popover
        PopoverComponent.prototype.onHidden = function () {
            this.invokeEventCallback('hide', { $event: { type: 'hide' } });
        };
        PopoverComponent.prototype.setFocusToPopoverLink = function () {
            var _this = this;
            setTimeout(function () { return _this.anchorRef.nativeElement.focus(); }, 10);
        };
        PopoverComponent.prototype.adjustPopoverPosition = function (popoverElem, parentDimesion, popoverLeftShift) {
            var arrowLeftShift = (parentDimesion.left + (parentDimesion.width / 2)) - popoverLeftShift;
            this.bsPopoverDirective._popover._ngZone.onStable.subscribe(function () {
                popoverElem.css('left', popoverLeftShift + 'px');
                popoverElem.find('.popover-arrow').css('left', arrowLeftShift + 'px');
            });
        };
        PopoverComponent.prototype.calculatePopoverPostion = function (element) {
            var popoverElem = $(element);
            var popoverLeft = _.parseInt(popoverElem.css('left'));
            var popoverWidth = _.parseInt(popoverElem.css('width'));
            var viewPortWidth = $(window).width();
            var parentDimesion = this.anchorRef.nativeElement.getBoundingClientRect();
            // Adjusting popover position, if it is not visible at left side
            if (popoverLeft < 0) {
                var popoverLeftShift = 4;
                this.adjustPopoverPosition(popoverElem, parentDimesion, popoverLeftShift);
            }
            // Adjusting popover position, if it is not visible at right side
            if (popoverLeft + popoverWidth > viewPortWidth) {
                var popoverLeftAdjust = (popoverLeft + popoverWidth) - viewPortWidth;
                var popoverLeftShift = popoverLeft - popoverLeftAdjust - 50;
                this.adjustPopoverPosition(popoverElem, parentDimesion, popoverLeftShift);
            }
        };
        // Trigger on showing popover
        PopoverComponent.prototype.onShown = function () {
            var _this = this;
            if (activePopover && activePopover.isOpen) {
                activePopover.isOpen = false;
            }
            activePopover = this;
            activePopover.isOpen = true;
            var popoverContainer = document.querySelector("." + this.popoverContainerCls);
            core.setCSSFromObj(popoverContainer, {
                height: this.popoverheight,
                minWidth: this.popoverwidth
            });
            if (!this.popoverarrow) {
                core.addClass(popoverContainer.querySelector('.arrow'), 'hidden');
            }
            if (this.interaction === 'hover' || this.interaction === 'default') {
                // do not use addEventListener here
                // attaching the event this way will override the existing event handlers
                popoverContainer.onmouseenter = function () { return clearTimeout(_this.closePopoverTimeout); };
                popoverContainer.onmouseleave = function () { return _this.hidePopover(); };
                this.anchorRef.nativeElement.onmouseenter = function () { return clearTimeout(_this.closePopoverTimeout); };
                this.anchorRef.nativeElement.onmouseleave = function () { return _this.hidePopover(); };
            }
            var deRegister = this.eventManager.addEventListener(popoverContainer, 'keydown.esc', function () {
                _this.isOpen = false;
                _this.setFocusToPopoverLink();
                deRegister();
            });
            var popoverStartBtn = popoverContainer.querySelector('.popover-start');
            var popoverEndBtn = popoverContainer.querySelector('.popover-end');
            popoverStartBtn.onkeydown = function (event) {
                var action = _this.keyEventPlugin.constructor.getEventFullKey(event);
                // Check for Shift+Tab key
                if (action === 'shift.tab') {
                    _this.bsPopoverDirective.hide();
                    _this.setFocusToPopoverLink();
                }
            };
            popoverEndBtn.onkeydown = function (event) {
                var action = _this.keyEventPlugin.constructor.getEventFullKey(event);
                // Check for Tab key
                if (action === 'tab') {
                    _this.bsPopoverDirective.hide();
                    _this.setFocusToPopoverLink();
                }
            };
            core.setAttr(popoverContainer, 'tabindex', 0);
            setTimeout(function () { return popoverStartBtn.focus(); }, 50);
            // Adjusting popover position if the popover placement is top or bottom
            setTimeout(function () {
                if (_this.popoverplacement === 'bottom' || _this.popoverplacement === 'top') {
                    _this.calculatePopoverPostion(popoverContainer);
                }
                // triggering onload and onshow events after popover content has rendered
                _this.triggerPopoverEvents();
            });
        };
        PopoverComponent.prototype.triggerPopoverEvents = function () {
            var _this = this;
            if (this.contentsource === 'partial') {
                var cancelSubscription_1 = this.app.subscribe('partialLoaded', function (data) {
                    var parEle = _this.partialRef.nativeElement;
                    var partialScope;
                    if (parEle) {
                        partialScope = parEle.widget;
                        _this.Widgets = partialScope.Widgets;
                        _this.Variables = partialScope.Variables;
                        _this.Actions = partialScope.Actions;
                        _this.invokeEventCallback('load');
                        _this.invokeEventCallback('show', { $event: { type: 'show' } });
                    }
                    cancelSubscription_1();
                });
            }
            else {
                this.Widgets = this.viewParent.Widgets;
                this.Variables = this.viewParent.Variables;
                this.Actions = this.viewParent.Actions;
                this.invokeEventCallback('show', { $event: { type: 'show' } });
            }
        };
        PopoverComponent.prototype.hidePopover = function () {
            var _this = this;
            this.closePopoverTimeout = setTimeout(function () { return _this.isOpen = false; }, 500);
        };
        PopoverComponent.prototype.showPopover = function () {
            this.bsPopoverDirective.show();
        };
        PopoverComponent.prototype.onPopoverAnchorKeydown = function ($event) {
            // if there is no content available, the popover should not open through enter key. So checking whether the canPopoverOpen flag is true or not.
            if (!this.canPopoverOpen) {
                return;
            }
            var action = this.keyEventPlugin.constructor.getEventFullKey(event);
            if (action === 'enter') {
                $event.stopPropagation();
                this.showPopover();
            }
        };
        PopoverComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'class' || key === 'tabindex') {
                return;
            }
            if (key === 'contentsource') {
                // if there is no partial content available, the popover should not open
                if (this.contentsource === 'partial' && !this.content) {
                    this.canPopoverOpen = false;
                }
            }
            if (key === 'content' && nv) {
                this.canPopoverOpen = true;
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        PopoverComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.event = eventsMap[this.interaction];
        };
        PopoverComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.anchorRef.nativeElement, this);
        };
        PopoverComponent.initializeProps = registerProps$18();
        PopoverComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'wm-popover',
                        template: "<a [popover]=\"popoverTemplate\"\n   [popoverContext]=\"context\"\n   [popoverTitle]=\"title\"\n   [placement]=\"popoverplacement\"\n   [outsideClick]=\"true\"\n   [triggers]=\"event\"\n   (onShown)=\"onShown()\"\n   (onHidden)=\"onHidden()\"\n   containerClass=\"app-popover animated {{contentanimation}} {{popoverContainerCls}}\"\n   container=\"body\"\n   [isOpen]=\"isOpen\"\n   [tabindex]=\"tabindex\"\n   [name]=\"name\"\n   [class] = \"class\"\n   [ngClass]=\"{'disable-popover': !canPopoverOpen}\"\n\n   #anchor\n   name.bind=\"name\"\n   wmAnchor\n   animation.bind=\"animation\"\n   badgevalue.bind=\"badgevalue\"\n   caption.bind=\"caption\"\n   encodeurl.bind=\"encodeurl\"\n   hint.bind=\"hint\"\n   hyperlink.bind=\"hyperlink\"\n   iconurl.bind=\"iconurl\"\n   iconwidth.bind=\"iconwidth\"\n   iconheight.bind=\"iconheight\"\n   iconmargin.bind=\"iconmargin\"\n   iconclass.bind=\"iconclass\"\n   iconposition.bind=\"iconposition\"\n   shortcutkey.bind=\"shortcutkey\"\n   tabindex.bind=\"tabindex\"\n   (keydown)=\"onPopoverAnchorKeydown($event)\">\n</a>",
                        providers: [
                            provideAsWidgetRef(PopoverComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        PopoverComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core.App },
                { type: undefined, decorators: [{ type: core$1.Inject, args: [platformBrowser.EVENT_MANAGER_PLUGINS,] }] }
            ];
        };
        PopoverComponent.propDecorators = {
            bsPopoverDirective: [{ type: core$1.ViewChild, args: [ngxBootstrap.PopoverDirective,] }],
            anchorRef: [{ type: core$1.ViewChild, args: ['anchor',] }],
            popoverTemplate: [{ type: core$1.ContentChild, args: [core$1.TemplateRef,] }],
            partialRef: [{ type: core$1.ContentChild, args: ['partial',] }]
        };
        return PopoverComponent;
    }(StylableComponent));

    var prefabProps = new Map([
        ['class', __assign({ value: '' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['show', __assign({ value: true }, PROP_BOOLEAN)]
    ]);

    var DEFAULT_CLS$M = 'app-prefab';
    var registeredPropsSet = new Set();
    var PrefabDirective = /** @class */ (function (_super) {
        __extends(PrefabDirective, _super);
        function PrefabDirective(inj, elRef, cdr, prefabName) {
            var _this = this;
            var widgetType = "wm-prefab-" + prefabName;
            var WIDGET_CONFIG = { widgetType: widgetType, hostClass: DEFAULT_CLS$M };
            _this = _super.call(this, inj, WIDGET_CONFIG, new Promise(function (res) { return _this.propsReady = res; })) || this;
            _this.prefabName = prefabName;
            _this.widgetType = widgetType;
            _this.name = elRef.nativeElement.getAttribute('name');
            styler(_this.nativeElement, _this);
            // Call on property change on name to set name attribute on element.
            _this.registerReadyStateListener(function () {
                _super.prototype.onPropertyChange.call(_this, 'name', _this.name);
            });
            return _this;
        }
        PrefabDirective.prototype.onStyleChange = function (key, nv, ov) {
            if (key === 'height') {
                core.setCSS(this.nativeElement, 'overflow', 'auto');
            }
        };
        PrefabDirective.prototype.setProps = function (config) {
            if (!config || !config.properties) {
                return;
            }
            if (!registeredPropsSet.has(this.widgetType)) {
                register(this.widgetType, this.prepareProps(config.properties));
            }
            this.propsReady();
        };
        PrefabDirective.prototype.handleEvent = function () {
            // do not call the super;
            // prevent events from getting registered
        };
        PrefabDirective.prototype.prepareProps = function (props) {
            if (props === void 0) {
                props = {};
            }
            var propsMap = new Map(prefabProps);
            Object.entries(props).forEach(function (_a) {
                var _b = __read(_a, 2), k = _b[0], v = _b[1];
                var type = exports.PROP_TYPE.STRING;
                if (v.type === 'boolean') {
                    type = exports.PROP_TYPE.BOOLEAN;
                }
                else if (v.type === 'number') {
                    type = exports.PROP_TYPE.NUMBER;
                }
                else if (v.type !== 'string') {
                    type = v.type;
                }
                // Do not set the 'bind:*' values
                propsMap.set(k, { type: type, value: _.startsWith(v.value, 'bind:') ? undefined : v.value });
            });
            registeredPropsSet.add(this.widgetType);
            return propsMap;
        };
        PrefabDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'section[wmPrefab]',
                        providers: [
                            provideAsWidgetRef(PrefabDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        PrefabDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.ElementRef },
                { type: core$1.ChangeDetectorRef },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['prefabname',] }] }
            ];
        };
        return PrefabDirective;
    }(StylableComponent));

    var DEFAULT_CLS$N = 'app-radioset list-group';
    var WIDGET_CONFIG$V = { widgetType: 'wm-radioset', hostClass: DEFAULT_CLS$N };
    var RadiosetComponent = /** @class */ (function (_super) {
        __extends(RadiosetComponent, _super);
        function RadiosetComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$V) || this;
            _this.layout = '';
            styler(_this.nativeElement, _this);
            _this.multiple = false;
            return _this;
        }
        /**
         * On click of the option, update the datavalue
         */
        RadiosetComponent.prototype.onRadioLabelClick = function ($event, key) {
            if (!$($event.target).is('input')) {
                return;
            }
            this.modelByKey = key;
            this.invokeOnTouched();
            // invoke on datavalue change.
            this.invokeOnChange(this.datavalue, $event || {}, true);
        };
        // change and blur events are added from the template
        RadiosetComponent.prototype.handleEvent = function (node, eventName, callback, locals) {
            if (eventName === 'click') {
                this.eventManager.addEventListener(node, eventName, function (e) {
                    if (!$(e.target).is('input')) {
                        return;
                    }
                    locals.$event = e;
                    return callback();
                });
            }
            else if (!_.includes(['change'], eventName)) {
                _super.prototype.handleEvent.call(this, node, eventName, callback, locals);
            }
        };
        RadiosetComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'tabindex') {
                return;
            }
            if (key === 'layout') {
                core.switchClass(this.nativeElement, nv, ov);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        RadiosetComponent.initializeProps = registerProps$F();
        RadiosetComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmRadioset]',
                        exportAs: 'wmRadioset',
                        template: "<li [ngClass]=\"['radio', 'app-radio', itemclass]\"\n    [class.active]=\"item.selected\"\n    *ngFor=\"let item of datasetItems;let i = index\"\n    (click)=\"onRadioLabelClick($event, item.key)\">\n    <label class=\"app-radioset-label\"\n           [ngClass]=\"{'disabled':disabled || readonly}\"\n           [title]=\"item.label\">\n        <input [name]=\"'radioset_' + widgetId\" type=\"radio\" [attr.aria-checked]=\"item.selected\" [attr.data-attr-index]=\"i\"\n               [value]=\"item.key\" [disabled]=\"disabled || readonly\" [tabindex]=\"tabindex\" [checked]=\"item.selected\"/>\n        <span class=\"caption\" [textContent]=\"item.label\"></span>\n    </label>\n</li>\n\n<input [disabled]=\"disabled || readonly\" hidden class=\"model-holder\">\n<div *ngIf=\"readonly || disabled\" aria-readonly=\"true\" class=\"readonly-wrapper\"></div>",
                        providers: [
                            provideAsNgValueAccessor(RadiosetComponent),
                            provideAsWidgetRef(RadiosetComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        RadiosetComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return RadiosetComponent;
    }(DatasetAwareFormComponent));

    var WIDGET_INFO$6 = { widgetType: 'wm-richtexteditor', hostClass: 'app-richtexteditor clearfix' };
    var getChangeEvt = function () {
        var changeEvt;
        // for IE the event constructor doesn't work so use the createEvent proto
        if (typeof (Event) === 'function') {
            changeEvt = new Event('change');
        }
        else {
            changeEvt = document.createEvent('Event');
            changeEvt.initEvent('change', true, true);
        }
        return changeEvt;
    };
    // override summernote methods
    var origFn = $.summernote.ui.button.bind($.summernote);
    $.summernote.ui.button = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var retVal = origFn.apply(void 0, __spread(args));
        var origCallback = retVal.callback;
        retVal.callback = function ($node, options) {
            // add bs3 btn class to the buttons
            $node.addClass('btn');
            return origCallback($node, options);
        };
        return retVal;
    };
    //
    var RichTextEditorComponent = /** @class */ (function (_super) {
        __extends(RichTextEditorComponent, _super);
        function RichTextEditorComponent(inj, domSanitizer, ngZone) {
            var _this = _super.call(this, inj, WIDGET_INFO$6) || this;
            _this.domSanitizer = domSanitizer;
            _this.ngZone = ngZone;
            _this._operationStack = [];
            _this.isEditorLoaded = false;
            _this.EDITOR_DEFAULT_OPTIONS = {
                toolbar: [
                    // [groupName, [list of button]]
                    ['misc', ['undo', 'redo']],
                    ['style', ['style']],
                    ['fontname', ['fontname']],
                    ['fontsize', ['fontsize']],
                    ['height', ['height']],
                    ['style', ['bold', 'italic', 'underline', 'clear']],
                    ['font', ['strikethrough', 'superscript', 'subscript']],
                    ['color', ['color']],
                    ['insert', ['table', 'picture', 'link', 'video', 'hr']],
                    ['para', ['ul', 'ol', 'paragraph']],
                    ['misc', ['codeview', 'fullscreen', 'help']]
                ],
                callbacks: {
                    onInit: function () {
                        _this.isEditorLoaded = true;
                        if (_this._operationStack.length) {
                            _this._operationStack.forEach(function (operationParam) {
                                var key = Array.from(operationParam.keys())[0], val = operationParam.get(key);
                                _this.performEditorOperation(key, val);
                            });
                            _this._operationStack = [];
                        }
                    },
                    onChange: function (contents, editable) {
                        _this.proxyModel = _this.domSanitizer.sanitize(core$1.SecurityContext.HTML, contents.toString());
                        _this.invokeOnChange(contents, getChangeEvt(), true);
                        _this.invokeOnTouched();
                    }
                },
                fontNames: ['Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Merriweather'],
                placeholder: '',
                height: 100,
                disableResizeEditor: true
            };
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER, ['height']);
            return _this;
        }
        Object.defineProperty(RichTextEditorComponent.prototype, "htmlcontent", {
            get: function () {
                return this.performEditorOperation('code');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RichTextEditorComponent.prototype, "datavalue", {
            get: function () {
                return this.htmlcontent;
            },
            set: function (nv) {
                if (nv !== undefined && nv !== null) {
                    this.$hiddenInputEle.val(nv);
                    this.performEditorOperation('reset');
                    this.performEditorOperation('insertText', nv);
                }
            },
            enumerable: true,
            configurable: true
        });
        RichTextEditorComponent.prototype.ngOnInit = function () {
            this.$richTextEditor = $(this.nativeElement.querySelector('[richTextEditor]'));
            this.$hiddenInputEle = $(this.nativeElement.querySelector('input.model-holder'));
            _super.prototype.ngOnInit.call(this);
            this.initEditor();
        };
        RichTextEditorComponent.prototype.initEditor = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                _this.$richTextEditor.summernote(_this.EDITOR_DEFAULT_OPTIONS);
            });
        };
        RichTextEditorComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'placeholder') {
                this.EDITOR_DEFAULT_OPTIONS.placeholder = nv;
                this.performEditorOperation({
                    placeholder: nv
                });
            }
            else if (key === 'disabled' || key === 'readonly') {
                this.performEditorOperation(nv ? 'disable' : 'enable');
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        RichTextEditorComponent.prototype.onStyleChange = function (key, nv, ov) {
            if (key === 'height') {
                this.EDITOR_DEFAULT_OPTIONS.height = nv;
                this.performEditorOperation({
                    height: nv
                });
            }
        };
        RichTextEditorComponent.prototype.performEditorOperation = function (key, value) {
            if (this.isEditorLoaded) {
                return this.$richTextEditor.summernote(key, value);
            }
            else {
                var op = new Map();
                op.set(key, value);
                this._operationStack.push(op);
                return;
            }
        };
        RichTextEditorComponent.prototype.getCurrentPosition = function () {
            return this.performEditorOperation('createRange');
        };
        RichTextEditorComponent.prototype.undo = function () {
            this.performEditorOperation('undo');
        };
        RichTextEditorComponent.prototype.focus = function () {
            this.performEditorOperation('focus');
        };
        RichTextEditorComponent.prototype.ngOnDestroy = function () {
            this.performEditorOperation('destroy');
            _super.prototype.ngOnDestroy.call(this);
        };
        RichTextEditorComponent.initializeProps = registerProps$H();
        RichTextEditorComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmRichTextEditor]',
                        template: "<div richTextEditor></div>\n<div [innerHTML]=\"proxyModel\" class=\"ta-preview\" *ngIf=\"showpreview\"></div>\n<input class=\"model-holder\" [disabled]=\"disabled\" hidden>\n",
                        providers: [
                            provideAsNgValueAccessor(RichTextEditorComponent),
                            provideAsWidgetRef(RichTextEditorComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        RichTextEditorComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: platformBrowser.DomSanitizer },
                { type: core$1.NgZone }
            ];
        };
        return RichTextEditorComponent;
    }(BaseFormCustomComponent));

    var registerProps$19 = function () {
        register('wm-right-panel', new Map([
            ['class', PROP_STRING],
            ['columnwidth', PROP_NUMBER],
            ['content', PROP_STRING],
            ['name', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$O = 'app-right-panel';
    var WIDGET_CONFIG$W = {
        widgetType: 'wm-right-panel',
        hostClass: DEFAULT_CLS$O
    };
    var RightPanelDirective = /** @class */ (function (_super) {
        __extends(RightPanelDirective, _super);
        function RightPanelDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$W) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        RightPanelDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'columnwidth') {
                core.switchClass(this.nativeElement, "col-sm-" + nv, ov ? " col-sm-" + ov : '');
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        RightPanelDirective.initializeProps = registerProps$19();
        RightPanelDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmRightPanel]',
                        providers: [
                            provideAsWidgetRef(RightPanelDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        RightPanelDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return RightPanelDirective;
    }(StylableComponent));

    var ScrollableDirective = /** @class */ (function () {
        function ScrollableDirective(inj, searchRef) {
            this.searchRef = searchRef;
            this.elementRef = inj.get(core$1.ElementRef);
        }
        ScrollableDirective.prototype.ngAfterContentInit = function () {
            // add the scroll event listener on the ul element.
            this.elementRef.nativeElement.addEventListener('scroll', this.notifyParent.bind(this));
            this.searchRef.dropdownEl = $(this.elementRef.nativeElement);
            this.searchRef.onDropdownOpen();
        };
        ScrollableDirective.prototype.ngAfterViewInit = function () {
            // assigning width for the dropdown.
            var typeAheadInput = this.searchRef.$element.find('input:first');
            this.searchRef.dropdownEl.width(typeAheadInput.outerWidth());
        };
        ScrollableDirective.prototype.notifyParent = function (evt) {
            this.searchRef.onScroll(this.elementRef.nativeElement, evt);
        };
        ScrollableDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[scrollable]'
                    },] }
        ];
        /** @nocollapse */
        ScrollableDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: SearchComponent }
            ];
        };
        return ScrollableDirective;
    }());

    var WIDGET_CONFIG$X = { widgetType: 'wm-select', hostClass: 'app-select-wrapper' };
    var SelectComponent = /** @class */ (function (_super) {
        __extends(SelectComponent, _super);
        function SelectComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$X) || this;
            _this.acceptsArray = true;
            return _this;
        }
        Object.defineProperty(SelectComponent.prototype, "datasource", {
            set: function (ds) {
                if (ds && ds.execute && ds.execute(core.DataSource.Operation.IS_BOUND_TO_LOCALE)) {
                    this.datavalue = ds.execute(core.DataSource.Operation.GET_DEFAULT_LOCALE);
                }
            },
            enumerable: true,
            configurable: true
        });
        SelectComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.selectEl.nativeElement, this);
        };
        // Change event is registered from the template, Prevent the framework from registering one more event
        SelectComponent.prototype.handleEvent = function (node, eventName, eventCallback, locals) {
            if (!_.includes(['blur', 'change'], eventName)) {
                _super.prototype.handleEvent.call(this, this.selectEl.nativeElement, eventName, eventCallback, locals);
            }
        };
        SelectComponent.prototype.onSelectValueChange = function ($event) {
            if (this.readonly) {
                if (this.placeholder) {
                    this.selectEl.nativeElement.value = this.placeholder;
                }
                else {
                    this.selectEl.nativeElement.value = '';
                }
                this.datavalue = this.prevDatavalue;
                return;
            }
            this.invokeOnTouched();
            // invoke on datavalue change.
            this.invokeOnChange(this.datavalue, $event || {}, true);
        };
        SelectComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'class' || key === 'tabindex') {
                return;
            }
            else if (key === 'readonly') {
                (nv === true) ? core.setAttr(this.selectEl.nativeElement, 'readonly', 'readonly') : core.removeAttr(this.selectEl.nativeElement, 'readonly');
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        SelectComponent.initializeProps = registerProps$I();
        SelectComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'wm-select',
                        template: "<select role=\"input\" aria-haspopup=\"true\" aria-expanded=\"false\" #select\n        focus-target\n        [ngClass]=\"['app-select form-control', class]\"\n        [disabled]=\"disabled\"\n        [required]=\"required\"\n        [tabindex]=\"tabindex\"\n        [(ngModel)]=\"modelByKey\"\n        [multiple]=\"multiple\"\n        (change)=\"onSelectValueChange($event)\"\n        (blur)=\"invokeOnTouched($event)\"\n        [attr.name]=\"name\"\n        [autofocus]=\"autofocus\"\n>\n  <option selected value=\"undefined\" [textContent]=\"placeholder\" [hidden]=\"!placeholder\" ></option>\n  <option\n          *ngFor=\"let item of datasetItems\"\n          [value]=\"item.key\" [selected]=\"item.selected\" [textContent]=\"item.label\"></option>\n</select>\n",
                        providers: [
                            provideAsNgValueAccessor(SelectComponent),
                            provideAsWidgetRef(SelectComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        SelectComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        SelectComponent.propDecorators = {
            selectEl: [{ type: core$1.ViewChild, args: ['select', { read: core$1.ElementRef },] }]
        };
        return SelectComponent;
    }(DatasetAwareFormComponent));

    var ShowInDeviceDirective = /** @class */ (function () {
        function ShowInDeviceDirective(elRef, showInDevice, widget) {
            var displayType = widget.getDisplayType();
            if (showInDevice) {
                showInDevice.split(',').forEach(function (deviceType) {
                    core.addClass(elRef.nativeElement, "visible-" + deviceType + "-" + displayType);
                });
            }
        }
        ShowInDeviceDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[showInDevice]'
                    },] }
        ];
        /** @nocollapse */
        ShowInDeviceDirective.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['showInDevice',] }] },
                { type: BaseComponent, decorators: [{ type: core$1.Inject, args: [WidgetRef,] }] }
            ];
        };
        return ShowInDeviceDirective;
    }());

    var SmoothScrollDirective = /** @class */ (function () {
        function SmoothScrollDirective(inj, elRef, app) {
            this._isEnabled = false;
            this._lastScrollY = -1;
            this._waitRefreshTill = -1;
            this.pendingIscrolls = [];
            this._$el = $(elRef.nativeElement);
            this.app = app;
        }
        SmoothScrollDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.cancelSubscription = this.app.subscribe('no-iscroll', function (el) {
                _this.pendingIscrolls.push(el);
            });
        };
        SmoothScrollDirective.prototype.ngDoCheck = function () {
            if (this._isEnabled) {
                if (!this._smoothScrollInstance) {
                    this._smoothScrollInstance = this.applySmoothScroll();
                }
                else {
                    this.refreshIScroll();
                }
            }
            else if (this._smoothScrollInstance && this._smoothScrollInstance.destroy) {
                this._smoothScrollInstance.destroy();
            }
        };
        SmoothScrollDirective.prototype.ngOnDestroy = function () {
            if (this._smoothScrollInstance && this._smoothScrollInstance.destroy) {
                this._smoothScrollInstance.destroy();
            }
            if (this.cancelSubscription) {
                this.cancelSubscription();
            }
        };
        Object.defineProperty(SmoothScrollDirective.prototype, "wmSmoothscroll", {
            set: function (val) {
                this._isEnabled = (val === true || val === 'true');
                if (this._isEnabled) {
                    if (!this._smoothScrollInstance) {
                        this._smoothScrollInstance = this.applySmoothScroll();
                    }
                }
                else {
                    this.ngOnDestroy();
                }
            },
            enumerable: true,
            configurable: true
        });
        SmoothScrollDirective.prototype.applySmoothScroll = function ($events, activeEl) {
            var _this = this;
            if (!core.isMobileApp() || core.isKitkatDevice()) {
                return null;
            }
            // Set the fadeScrollbars to true only when content is scrollable inside the smoothscroll-container
            var scrollOptions = {
                scrollbars: true,
                preventDefault: false,
                momentum: true,
                bounce: false,
                mouseWheel: true,
                disablePointer: true,
                disableTouch: false,
                disableMouse: false // false to be usable with a mouse (desktop)
            }, el = this._$el[0];
            if (!el.children.length) {
                return null;
            }
            this._$el.addClass('smoothscroll-wrapper');
            if (activeEl && activeEl.tagName === 'INPUT') {
                activeEl.focus();
            }
            // Add fadeScrollbars options only when smoothscroll container is included, which means content is scrollable.
            if ($events) {
                scrollOptions['fadeScrollbars'] = true;
            }
            var iScroll = new IScroll(el, scrollOptions);
            if ($events) {
                // map all events on previous iscroll to the newly created iscroll.
                _.forEach($events, function (listeners, key) {
                    _.forEach(listeners, function (l) {
                        iScroll.on(key, l);
                    });
                });
                iScroll.on('scrollStart', function () {
                    this._scrolling = true;
                });
                iScroll.on('scrollEnd', function () {
                    this._scrolling = false;
                });
                iScroll.refresh();
            }
            // refresh the indicators.
            iScroll.indicatorRefresh = function () {
                var indicators = _this._$el[0].iscroll.indicators;
                var i;
                if (indicators.length) {
                    for (i = 0; i < indicators.length; i++) {
                        indicators[i].refresh();
                    }
                }
            };
            this._$el[0].iscroll = iScroll;
            _.forEach(this.pendingIscrolls, function (_el, index) {
                if (_el.isSameNode(_this._$el[0])) {
                    _this.app.notify('iscroll-update', { el: _el });
                    _this.pendingIscrolls.splice(index, 1);
                    return;
                }
            });
            this.app.notify('iscroll-update', {});
            return {
                iScroll: iScroll,
                destroy: function () {
                    iScroll.destroy();
                    $(iScroll.scroller).css({
                        'transition-timing-function': '',
                        'transition-duration': '',
                        'transform': ''
                    });
                    iScroll = null;
                    delete el.iscroll;
                }
            };
        };
        /*
         * When element has scroll (i.e. scrollHeight > clientHeight), a div with smoothscroll-container class will be added.
         * new iScroll will be initialised on the element after the div addition, by removing the existing iscroll on the element.
         * This div will have no height, so the elements inside this div will inherit this height, i.e. no height,
         * Scenario: tabs with 100% height, as it covers the pageContent with no scroll, this div will not be added.
         * TODO: Scenario: tabs with 100% height and add others widgets after/before, as it has scroll, this div will be added.
         *          But tabs having 100% height will not be honoured as div is having no height.
         */
        SmoothScrollDirective.prototype.refreshIScroll = function () {
            var iScroll = this._smoothScrollInstance.iScroll;
            var waitTime = 500;
            if (iScroll._scrolling || this._waitRefreshTill > Date.now()) {
                return;
            }
            // Check for scrollable content and if smoothscroll-container div is already added.
            if (iScroll.wrapper
                && !_.includes(iScroll.wrapper.children[0].classList, 'smoothscroll-container')
                && iScroll.wrapper.scrollHeight > iScroll.wrapper.clientHeight) {
                var cloneEvents = iScroll._events;
                var prevActiveEl = document.activeElement;
                // Adds the smoothscroll container div wrapper only when element has scrollable content.
                $(iScroll.wrapper.children).wrapAll('<div class="smoothscroll-container"></div>');
                this._smoothScrollInstance.destroy();
                // create new iscroll instance on the element
                this._smoothScrollInstance = this.applySmoothScroll(cloneEvents, prevActiveEl);
            }
            if (this._lastScrollY !== this._$el[0].iscroll.maxScrollY) {
                refreshIscrolls(this._smoothScrollInstance.iScroll);
                this._lastScrollY = this._$el[0].iscroll.maxScrollY;
            }
            else {
                this._smoothScrollInstance.iScroll.refresh();
            }
            this._waitRefreshTill = Date.now() + waitTime;
        };
        SmoothScrollDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmSmoothscroll]'
                    },] }
        ];
        /** @nocollapse */
        SmoothScrollDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.ElementRef },
                { type: core.App }
            ];
        };
        SmoothScrollDirective.propDecorators = {
            wmSmoothscroll: [{ type: core$1.Input }]
        };
        return SmoothScrollDirective;
    }());
    /**
     * Refreshes the given iScorll or all iScrolls in the page.
     * @param iScroll
     */
    var refreshIscrolls = function (iScroll) {
        var scrollContainer = !iScroll && $('.smoothscroll-container');
        // Fix for issue: keyboard hides the input on focus.
        // On input focus or window resize, keypad in device has to adjust.
        if (($(document.activeElement).offset().top + document.activeElement.clientHeight) > window.innerHeight * 0.9) {
            document.activeElement.scrollIntoView({ behavior: 'auto', block: 'end', inline: 'end' });
        }
        if (iScroll) {
            // refresh specify iscroll on change.
            if (iScroll.indicatorRefresh) {
                iScroll.indicatorRefresh();
            }
            if (iScroll.refresh) {
                iScroll.refresh();
            }
        }
        else if (scrollContainer.length) {
            // refresh all the iscrolls in pagecontent.
            scrollContainer.parent().each(function (i, el) {
                el.iscroll.indicatorRefresh();
                el.iscroll.refresh();
            });
        }
    };
    // on window resize, recalculate the iscroll position and refresh scrollers.
    window.addEventListener('resize', core.debounce(refreshIscrolls, 200));

    var registerProps$1a = function () {
        register('wm-spinner', new Map([
            ['animation', { value: 'spin', PROP_STRING: PROP_STRING }],
            ['caption', __assign({ value: 'Loading...' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['iconclass', __assign({ value: 'fa fa-circle-o-notch fa-spin' }, PROP_STRING)],
            ['iconsize', PROP_STRING],
            ['image', PROP_STRING],
            ['imageheight', PROP_STRING],
            ['imagewidth', __assign({ value: '20px' }, PROP_STRING)],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['type', __assign({ value: 'icon' }, PROP_STRING)],
            ['servicevariabletotrack', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$P = 'app-spinner';
    var WIDGET_CONFIG$Y = { widgetType: 'wm-spinner', hostClass: DEFAULT_CLS$P };
    var SpinnerComponent = /** @class */ (function (_super) {
        __extends(SpinnerComponent, _super);
        function SpinnerComponent(inj, imagePipe) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$Y) || this;
            _this.imagePipe = imagePipe;
            _this.iconclass = '';
            _this.animation = '';
            _this.showCaption = true;
            styler(_this.nativeElement, _this);
            return _this;
        }
        Object.defineProperty(SpinnerComponent.prototype, "spinnerMessages", {
            get: function () {
                return this._spinnerMessages;
            },
            set: function (newVal) {
                this.showCaption = _.isEmpty(newVal);
                this._spinnerMessages = newVal;
            },
            enumerable: true,
            configurable: true
        });
        SpinnerComponent.prototype.listenOnDataSource = function () {
            var _this = this;
            var variables = _.split(this.servicevariabletotrack, ',');
            this.getAppInstance().subscribe('toggle-variable-state', function (data) {
                var name = data.variable.execute(core.DataSource.Operation.GET_NAME);
                if (_.includes(variables, name) && core.validateDataSourceCtx(data.variable, _this.getViewParent())) {
                    _this.widget.show = data.active;
                }
            });
        };
        SpinnerComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'image') {
                this.picture = this.imagePipe.transform(nv);
            }
            else if (key === 'animation') {
                if (nv === 'spin') {
                    this.animation = 'fa-spin';
                }
                else {
                    this.animation = nv || '';
                }
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        SpinnerComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            // if variables are to be listened to, hide the widget and set the listener
            if (this.servicevariabletotrack) {
                this.widget.show = false;
                this.listenOnDataSource();
            }
        };
        SpinnerComponent.initializeProps = registerProps$1a();
        SpinnerComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmSpinner]',
                        template: "<div class=\"spinner-message\" aria-label=\"loading gif\">\n    <span class=\"spinner-image animated infinite\" [ngClass]=\"animation\" aria-hidden=\"true\"\n        [ngStyle]=\"{width: imagewidth, height: imageheight, backgroundImage: 'url(' + picture + ')', backgroundSize: imagewidth}\"\n        *ngIf=\"type === 'image'\"></span>\n    <i class=\"spinner-image animated infinite\" [ngClass]=\"[iconclass, animation]\" [style.fonSize]=\"iconsize\" *ngIf=\"type === 'icon'\"></i>\n    <span class=\"spinner-text\" [innerHTML]=\"caption | trustAs: 'html'\" *ngIf=\"showCaption\"></span>\n    <div class=\"spinner-messages\" *ngIf=\"!showCaption && spinnerMessages\">\n        <p *ngFor=\"let value of spinnerMessages\" [textContent]=\"value\"></p>\n    </div>\n</div>",
                        providers: [
                            provideAsWidgetRef(SpinnerComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        SpinnerComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: ImagePipe }
            ];
        };
        return SpinnerComponent;
    }(StylableComponent));

    var DEFAULT_CLS$Q = 'app-switch';
    var WIDGET_CONFIG$Z = { widgetType: 'wm-switch', hostClass: DEFAULT_CLS$Q };
    var SwitchComponent = /** @class */ (function (_super) {
        __extends(SwitchComponent, _super);
        function SwitchComponent(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$Z) || this;
            _this.options = [];
            _this._debounceSetSelectedValue = core.debounce(function (val) {
                _this.setSelectedValue();
                _this.updateHighlighter(val);
                // only for default value trigger app digest to apply the selectedItem
                if (val) {
                    core.$appDigest();
                }
            }, 200);
            var datasetSubscription = _this.dataset$.subscribe(function () { return _this.updateSwitchOptions(); });
            _this.registerDestroyListener(function () { return datasetSubscription.unsubscribe(); });
            var datavalueSubscription = _this.datavalue$.subscribe(function () {
                _this._debounceSetSelectedValue(true);
            });
            _this.registerDestroyListener(function () { return datavalueSubscription.unsubscribe(); });
            return _this;
        }
        SwitchComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.nativeElement, this);
        };
        SwitchComponent.prototype.onStyleChange = function (key, nv, ov) {
            if (key === 'height') {
                core.setCSS(this.nativeElement, 'overflow', nv ? 'auto' : '');
            }
            else {
                _super.prototype.onStyleChange.call(this, key, nv, ov);
            }
        };
        // This function sets the selectedItem by either using compareby fields or selected flag on datasetItems.
        SwitchComponent.prototype.setSelectedValue = function () {
            if (core.isDefined(this.datavalue) || core.isDefined(this.toBeProcessedDatavalue)) {
                this.selectedItem = _.find(this.datasetItems, { selected: true });
                return;
            }
            // If no value is provided, set first value as default if options are available else set -1 ie no selection
            this.selectOptAtIndex(0);
        };
        // set the css for switch overlay element.
        // set the selected index from the datasetItems and highlight the datavalue on switch.
        SwitchComponent.prototype.updateSwitchOptions = function () {
            if (this.datasetItems.length) {
                this.btnwidth = (100 / this.datasetItems.length);
                core.setCSS(this.nativeElement.querySelector('.app-switch-overlay'), 'width', this.btnwidth + '%');
            }
            this._debounceSetSelectedValue(true);
        };
        // This function animates the highlighted span on to the selected value.
        SwitchComponent.prototype.updateHighlighter = function (skipAnimation) {
            var handler = $(this.nativeElement).find('span.app-switch-overlay');
            this.setSelectedValue();
            var left, index = this.selectedItem ? _.findIndex(this.datasetItems, { key: this.selectedItem.key }) : -1;
            if (index === undefined || index === null) {
                index = -1;
            }
            left = index * this.btnwidth;
            if (skipAnimation) {
                handler.css('left', left + '%');
            }
            else {
                handler.animate({
                    left: left + '%'
                }, 300);
            }
        };
        SwitchComponent.prototype.selectOptAtIndex = function ($index) {
            if (!this.datasetItems.length) {
                return;
            }
            var opt = this.datasetItems[$index];
            this._modelByValue = opt.value;
        };
        // Triggered on selected the option from the switch.
        // set the index and highlight the default value. Invoke onchange event handler.
        SwitchComponent.prototype.selectOpt = function ($event, $index, option) {
            this.modelByKey = option.key;
            this.invokeOnTouched();
            $event.preventDefault();
            if (this.disabled) {
                return;
            }
            if (this.selectedItem && $index === _.findIndex(this.datasetItems, { key: this.selectedItem.key })) {
                if (this.datasetItems.length === 2) {
                    $index = $index === 1 ? 0 : 1;
                }
                else {
                    return;
                }
            }
            this.selectedItem = this.datasetItems[$index];
            this.updateHighlighter();
            // invoke on datavalue change.
            this.invokeOnChange(this.datavalue, $event || {}, true);
            core.$appDigest();
        };
        SwitchComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'disabled' && !core.toBoolean(nv)) {
                this.nativeElement.removeAttribute(key);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        SwitchComponent.initializeProps = registerProps$K();
        SwitchComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmSwitch]',
                        template: "<div role=\"group\" aria-label=\"button switch\" class=\"btn-group btn-group-justified\">\n    <a *ngFor=\"let opt of datasetItems; let $index = index;\"\n       [title]=\"opt.label\" focus-target\n       href=\"javascript:void(0);\"\n       class=\"btn btn-default\"\n       [name]=\"'wm-switch-' + opt.key\"\n       [ngClass]=\"{'selected': opt.selected, 'disabled': disabled}\"\n       (click)=\"selectOpt($event, $index, opt)\"\n    >\n        <i *ngIf=\"opt.dataObject && opt.dataObject[iconclass]\" aria-hidden=\"true\" [ngClass]=\"['app-icon', opt.dataObject[iconclass] || opt['icon']]\"></i>\n        <span class=\"caption\" [textContent]=\"opt[displayfield] || opt.label\"></span>\n    </a>\n</div>\n<span [title]=\"selectedItem ? selectedItem.label : modelByKey\"\n      class=\"btn btn-primary app-switch-overlay switch-handle\">\n    <i *ngIf=\"iconclass\"\n       class=\"app-icon {{(selectedItem && selectedItem.dataObject) && selectedItem.dataObject[iconclass]}}\"></i>\n    {{selectedItem ? selectedItem.label : modelByKey}}\n</span>\n<input [name]=\"name\" class=\"model-holder ng-hide\" [disabled]=\"disabled\" [value]=\"modelByKey\" [required]=\"required\">\n",
                        providers: [
                            provideAsNgValueAccessor(SwitchComponent),
                            provideAsWidgetRef(SwitchComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        SwitchComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return SwitchComponent;
    }(DatasetAwareFormComponent));

    var registerProps$1b = function () {
        register('wm-table-action', new Map([
            ['accessroles', PROP_STRING],
            ['action', PROP_STRING],
            ['caption', PROP_STRING],
            ['class', PROP_STRING],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['disabled', __assign({ value: false }, PROP_BOOLEAN)],
            ['display-name', PROP_STRING],
            ['hyperlink', PROP_STRING],
            ['icon', PROP_STRING],
            ['iconclass', PROP_STRING],
            ['key', PROP_STRING],
            ['position', __assign({ value: 'footer' }, PROP_STRING)],
            ['shortcutkey', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['title', PROP_STRING],
            ['target', PROP_STRING],
            ['widget-type', __assign({ value: 'button' }, PROP_STRING)]
        ]));
    };

    var WIDGET_CONFIG$_ = { widgetType: 'wm-table-action', hostClass: '' };
    var TableActionDirective = /** @class */ (function (_super) {
        __extends(TableActionDirective, _super);
        function TableActionDirective(inj, table) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$_) || this;
            _this.table = table;
            return _this;
        }
        TableActionDirective.prototype.populateAction = function () {
            this.buttonDef = {
                key: this.key,
                displayName: this['display-name'] || this.caption || '',
                show: this.show,
                class: this.class || '',
                iconclass: this.iconclass || '',
                title: _.isUndefined(this.title) ? (this['display-name'] || '') : this.title,
                action: this.action,
                accessroles: this.accessroles,
                shortcutkey: this.shortcutkey,
                disabled: this.disabled,
                tabindex: this.tabindex,
                icon: this.icon,
                position: this.position,
                widgetType: this['widget-type'],
                hyperlink: this.hyperlink,
                target: this.target,
                conditionalclass: this.conditionalclass || '',
                conditionalstyle: this.conditionalstyle || {}
            };
            this._propsInitialized = true;
        };
        TableActionDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.populateAction();
            this.table.registerActions(this.buttonDef);
        };
        TableActionDirective.prototype.onPropertyChange = function (key, nv) {
            if (!this._propsInitialized) {
                return;
            }
            if (key === 'display-name') {
                this.buttonDef.displayName = nv;
            }
            else {
                this.buttonDef[key] = nv;
            }
        };
        TableActionDirective.initializeProps = registerProps$1b();
        TableActionDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTableAction]',
                        providers: [
                            provideAsWidgetRef(TableActionDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        TableActionDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: TableComponent, decorators: [{ type: core$1.Optional }] }
            ];
        };
        return TableActionDirective;
    }(BaseComponent));

    var registerProps$1c = function () {
        register('wm-table-column', new Map([
            ['accessroles', PROP_STRING],
            ['backgroundcolor', PROP_STRING],
            ['binding', PROP_STRING],
            ['caption', PROP_STRING],
            ['checkedvalue', PROP_STRING],
            ['col-class', PROP_STRING],
            ['col-ng-class', PROP_STRING],
            ['currencypattern', PROP_STRING],
            ['customExpression', PROP_BOOLEAN],
            ['datafield', PROP_STRING],
            ['dataoptions', PROP_ANY],
            ['dataset', PROP_ANY],
            ['datasource', PROP_STRING],
            ['datepattern', PROP_STRING],
            ['debouncetime', __assign({ value: 250 }, PROP_NUMBER)],
            ['defaultvalue', PROP_STRING],
            ['disabled', PROP_BOOLEAN],
            ['displayfield', PROP_STRING],
            ['displaylabel', PROP_STRING],
            ['editdatepattern', PROP_STRING],
            ['edit-widget-type', PROP_STRING],
            ['editinputtype', PROP_STRING],
            ['exportexpression', PROP_STRING],
            ['filterdataset', PROP_STRING],
            ['filterdatafield', PROP_STRING],
            ['filterdisplayfield', PROP_STRING],
            ['filterdisplaylabel', PROP_STRING],
            ['filterexpressions', __assign({ value: '{}' }, PROP_STRING)],
            ['filtersearchkey', PROP_STRING],
            ['filter-on', PROP_STRING],
            ['filteronfilter', PROP_STRING],
            ['filterplaceholder', PROP_STRING],
            ['filterwidget', PROP_STRING],
            ['filterinputtype', PROP_STRING],
            ['formatpattern', PROP_STRING],
            ['fractionsize', PROP_STRING],
            ['generator', PROP_STRING],
            ['limit', PROP_NUMBER],
            ['matchmode', PROP_STRING],
            ['maxchars', PROP_NUMBER],
            ['maxvalue', PROP_NUMBER],
            ['mobiledisplay', __assign({ value: true }, PROP_BOOLEAN)],
            ['minvalue', PROP_NUMBER],
            ['pcdisplay', __assign({ value: true }, PROP_BOOLEAN)],
            ['period', PROP_BOOLEAN],
            ['placeholder', PROP_STRING],
            ['prefix', PROP_STRING],
            ['primary-key', PROP_BOOLEAN],
            ['readonly', PROP_BOOLEAN],
            ['regexp', PROP_ANY],
            ['related-entity-name', PROP_STRING],
            ['required', PROP_BOOLEAN],
            ['rowactionsposition', PROP_STRING],
            ['searchkey', PROP_STRING],
            ['searchable', __assign({ value: true }, PROP_BOOLEAN)],
            ['suffix', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['showdropdownon', __assign({ value: 'default' }, PROP_STRING)],
            ['sortable', __assign({ value: true }, PROP_BOOLEAN)],
            ['textalignment', __assign({ value: 'left' }, PROP_STRING)],
            ['textcolor', PROP_STRING],
            ['type', __assign({ value: 'string' }, PROP_STRING)],
            ['uncheckedvalue', PROP_STRING],
            ['validationmessage', PROP_STRING],
            ['widget-type', PROP_STRING],
            ['width', PROP_STRING],
        ]));
    };

    var registerProps$1d = function () {
        register('wm-table-column-group', new Map([
            ['backgroundcolor', PROP_STRING],
            ['caption', PROP_STRING],
            ['col-class', PROP_STRING],
            ['name', PROP_STRING],
            ['textalignment', __assign({ value: 'center' }, PROP_STRING)]
        ]));
    };

    var WIDGET_CONFIG$10 = { widgetType: 'wm-table-column-group', hostClass: '' };
    var TableColumnGroupDirective = /** @class */ (function (_super) {
        __extends(TableColumnGroupDirective, _super);
        function TableColumnGroupDirective(inj, group, table) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$10) || this;
            _this.group = group;
            _this.table = table;
            _this.config = {};
            return _this;
        }
        TableColumnGroupDirective.prototype.populateConfig = function () {
            this.config = {
                field: this.name,
                displayName: this.caption || '',
                columns: [],
                isGroup: true,
                accessroles: this.accessroles,
                textAlignment: this.textalignment || 'center',
                backgroundColor: this.backgroundcolor,
                class: this['col-class']
            };
        };
        TableColumnGroupDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'caption') {
                this.config.displayName = nv || '';
                this.table.callDataGridMethod('setColumnProp', this.config.field, 'displayName', nv, true);
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        TableColumnGroupDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.populateConfig();
            setHeaderConfigForTable(this.table.headerConfig, this.config, this.group && this.group.name);
        };
        TableColumnGroupDirective.initializeProps = registerProps$1d();
        TableColumnGroupDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTableColumnGroup]',
                        providers: [
                            provideAsWidgetRef(TableColumnGroupDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        TableColumnGroupDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: TableColumnGroupDirective, decorators: [{ type: core$1.SkipSelf }, { type: core$1.Optional }] },
                { type: TableComponent, decorators: [{ type: core$1.Optional }] }
            ];
        };
        return TableColumnGroupDirective;
    }(BaseComponent));

    var WIDGET_CONFIG$11 = { widgetType: 'wm-table-column', hostClass: '' };
    var inlineWidgetProps = ['datafield', 'displayfield', 'placeholder', 'searchkey', 'matchmode', 'displaylabel',
        'checkedvalue', 'uncheckedvalue', 'showdropdownon', 'dataset'];
    var validationProps = ['maxchars', 'regexp', 'minvalue', 'maxvalue', 'required'];
    inlineWidgetProps = __spread(inlineWidgetProps, validationProps);
    var FieldDef = /** @class */ (function () {
        function FieldDef(widget) {
            this.widget = widget;
        }
        FieldDef.prototype.focus = function () {
            this.widget.focus();
        };
        FieldDef.prototype.setProperty = function (prop, newval) {
            // Get the scope of the current editable widget and set the value
            prop = prop === 'value' ? 'datavalue' : prop;
            this.widget[prop] = newval;
        };
        FieldDef.prototype.getProperty = function (prop) {
            prop = prop === 'value' ? 'datavalue' : prop;
            return this.widget[prop];
        };
        return FieldDef;
    }());
    var TableColumnDirective = /** @class */ (function (_super) {
        __extends(TableColumnDirective, _super);
        function TableColumnDirective(inj, appDefaults, table, group, bindfilterdataset, binddataset) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$11) || this;
            _this.appDefaults = appDefaults;
            _this.table = table;
            _this.group = group;
            _this.bindfilterdataset = bindfilterdataset;
            _this.binddataset = binddataset;
            _this._debounceSetUpValidators = core.debounce(_this.setUpValidators.bind(_this, 'inlineInstance'), 250);
            _this._debounceSetUpValidatorsNew = core.debounce(_this.setUpValidators.bind(_this, 'inlineInstanceNew'), 250);
            return _this;
        }
        Object.defineProperty(TableColumnDirective.prototype, "dataoptions", {
            get: function () {
                return this._dataoptions;
            },
            set: function (options) {
                this._dataoptions = options;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableColumnDirective.prototype, "datasource", {
            get: function () {
                return this._datasource;
            },
            set: function (ds) {
                this._datasource = ds;
            },
            enumerable: true,
            configurable: true
        });
        TableColumnDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            // Set the default values and register with table
            this.populateFieldDef();
            // Register column with header config to create group structure
            setHeaderConfigForTable(this.table.headerConfig, {
                field: this.field,
                displayName: this.displayName
            }, this.group && this.group.name);
            this.table.registerColumns(this.widget);
            this._isRowFilter = this.table.filtermode === 'multicolumn' && this.searchable;
            this._isInlineEditable = !this.readonly && (this.table.editmode !== EDIT_MODE.DIALOG && this.table.editmode !== EDIT_MODE.FORM);
            this._isNewEditableRow = this._isInlineEditable && this.table.editmode === EDIT_MODE.QUICK_EDIT && this.table.shownewrow;
            this.setUpControls();
            this._propsInitialized = true;
        };
        TableColumnDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this._isRowFilter) {
                // Listen on the inner row filter widget and setup the widget
                var s1_1 = this._filterInstances.changes.subscribe(function (val) {
                    _this.filterInstance = val.first && val.first.widget;
                    _this.setUpFilterWidget();
                });
                this.registerDestroyListener(function () { return s1_1.unsubscribe(); });
            }
            if (this._isInlineEditable) {
                var s2_1 = this._inlineInstances.changes.subscribe(function (val) {
                    // Listen on the inner inline widget and setup the widget
                    _this.inlineInstance = val.first && val.first.widget;
                    _this.table.registerFormField(_this.binding, new FieldDef(_this.inlineInstance));
                    _this.setUpInlineWidget('inlineInstance');
                });
                this.registerDestroyListener(function () { return s2_1.unsubscribe(); });
                if (this._isNewEditableRow) {
                    var s3_1 = this._inlineInstancesNew.changes.subscribe(function (val) {
                        // Listen on the inner inline widget and setup the widget
                        _this.inlineInstanceNew = val.first && val.first.widget;
                        _this.setUpInlineWidget('inlineInstanceNew');
                    });
                    this.registerDestroyListener(function () { return s3_1.unsubscribe(); });
                }
            }
            _super.prototype.ngAfterContentInit.call(this);
        };
        TableColumnDirective.prototype.ngAfterViewInit = function () {
            // manually listing the table column templateRef as templateRef will not be available prior.
            if (this.filterTemplateRef) {
                this.table.renderDynamicFilterColumn(this.filterTemplateRef);
            }
        };
        TableColumnDirective.prototype.addFormControl = function (suffix) {
            var ctrlName = suffix ? (this.binding + suffix) : this.binding;
            this.table.ngform.addControl(ctrlName, this.table.fb.control(''));
        };
        TableColumnDirective.prototype.getFormControl = function (suffix) {
            var ctrlName = suffix ? (this.binding + suffix) : this.binding;
            return this.table.ngform.controls[ctrlName];
        };
        // Setup the inline edit and filter widget
        TableColumnDirective.prototype.setUpControls = function () {
            if (this._isInlineEditable) {
                if (this.editWidgetType === core.FormWidgetType.UPLOAD) {
                    return;
                }
                this.addFormControl();
                var control = this.getFormControl();
                if (control) {
                    var onValueChangeSubscription_1 = control.valueChanges.subscribe(this.onValueChange.bind(this));
                    this.registerDestroyListener(function () { return onValueChangeSubscription_1.unsubscribe(); });
                }
                if (this._isNewEditableRow) {
                    this.addFormControl('_new');
                    var newControl = this.getFormControl('_new');
                    if (newControl) {
                        var onNewValueChangeSubscription_1 = newControl.valueChanges.subscribe(this.onValueChange.bind(this));
                        this.registerDestroyListener(function () { return onNewValueChangeSubscription_1.unsubscribe(); });
                    }
                }
            }
            if (this._isRowFilter) {
                this.addFormControl('_filter');
                this.filterControl = this.getFormControl('_filter');
                if (this.filterControl) {
                    var onFilterValueSubscription_1 = this.filterControl.valueChanges.subscribe(this.onFilterValueChange.bind(this));
                    this.registerDestroyListener(function () { return onFilterValueSubscription_1.unsubscribe(); });
                }
            }
        };
        // Reset the row filter value
        TableColumnDirective.prototype.resetFilter = function () {
            if (this.filterControl) {
                this.filterControl.setValue('');
            }
            if (this.filterwidget === core.FormWidgetType.AUTOCOMPLETE) {
                this.filterInstance.query = '';
                this.filterInstance.queryModel = '';
            }
        };
        // On field value change, propagate event to parent form
        TableColumnDirective.prototype.onFilterValueChange = function (val) {
            this.table.rowFilter[this.field].value = val;
        };
        // On field value change, apply cascading filter
        TableColumnDirective.prototype.onValueChange = function (val) {
            if (val !== null) {
                applyFilterOnField(this.table.datasource, this.widget, this.table.fieldDefs, val, {
                    widget: 'edit-widget-type'
                });
            }
        };
        TableColumnDirective.prototype.loadFilterData = function () {
            var _this = this;
            // If filterdataset is not bound, get the data implicitly
            if (this._isRowFilter && isDataSetWidget(this.filterwidget) && !this.bindfilterdataset) {
                // For live variable, get the data using distinct API
                if (this.table.datasource.execute(core.DataSource.Operation.SUPPORTS_DISTINCT_API)) {
                    // check for related entity columns
                    if (this.relatedEntityName) {
                        this.widget['is-related'] = true;
                        this.widget['lookup-type'] = this.relatedEntityName;
                        this.widget['lookup-field'] = _.last(_.split(this.field, '.'));
                    }
                    if (this.filterwidget === core.FormWidgetType.AUTOCOMPLETE) {
                        this.filterInstance.dataoptions = getDistinctFieldProperties(this.table.datasource, this);
                        this.filterInstance.datasource = this.table.datasource;
                    }
                    else {
                        getDistinctValues(this.table.datasource, this.widget, 'filterwidget').then(function (res) {
                            _this._filterDataSet = res.data;
                            _this.setFilterWidgetDataSet();
                        });
                    }
                }
                else {
                    // For other datasources, get the data from datasource bound to table
                    this.registerDestroyListener(core.$watch(this.table.binddataset, this.viewParent, {}, function (nv) { return _this.widget.filterdataset = nv; }, getWatchIdentifier(this.widgetId, 'filterdataset')));
                }
            }
        };
        TableColumnDirective.prototype.loadInlineWidgetData = function () {
            // If dataset is not bound, get the data implicitly
            if (isDataSetWidget(this['edit-widget-type']) && !this.binddataset && !this.readonly) {
                var dataSource = this.table.datasource;
                if (this['related-entity-name'] && this['primary-key']) {
                    // Fetch the data for the related fields
                    this.isDataSetBound = true;
                    var bindings = _.split(this.binding, '.');
                    fetchRelatedFieldData(dataSource, this.widget, {
                        relatedField: _.head(bindings),
                        datafield: _.last(bindings),
                        widget: 'edit-widget-type'
                    });
                }
                else if (dataSource.execute(core.DataSource.Operation.SUPPORTS_DISTINCT_API)) {
                    getDistinctValuesForField(dataSource, this.widget, {
                        widget: 'edit-widget-type'
                    });
                }
            }
        };
        // On table datasource change, get the data for row filters
        TableColumnDirective.prototype.onDataSourceChange = function () {
            this.loadFilterData();
            this.loadInlineWidgetData();
        };
        // Set the data on the row filter widget
        TableColumnDirective.prototype.setFilterWidgetDataSet = function () {
            if (this.filterInstance) {
                this.filterInstance.dataset = this._filterDataSet;
            }
        };
        // Set the props on the row filter widget
        TableColumnDirective.prototype.setUpFilterWidget = function () {
            var _this = this;
            this.filterInstance.registerReadyStateListener(function () {
                if (isDataSetWidget(_this.filterwidget)) {
                    // if binding is department.deptId then field will be deptId
                    var field = _.last(_this.binding.split('.'));
                    _this.filterInstance.dataset = _this._filterDataSet;
                    _this.filterInstance.datafield = _this.filterdatafield || field;
                    _this.filterInstance.displayfield = _this.filterdisplayfield || field;
                    if (_this.filterwidget === core.FormWidgetType.AUTOCOMPLETE) {
                        _this.filterInstance.displaylabel = _this.filterdisplaylabel || field;
                        _this.filterInstance.searchkey = _this.filtersearchkey || field;
                    }
                }
                if (_this.filterwidget === core.FormWidgetType.TIME) {
                    _this.filterInstance.timepattern = _this.appDefaults.timeFormat || 'hh:mm:ss a';
                }
                _this.filterInstance.placeholder = _this.filterplaceholder || '';
            });
        };
        // On change of any validation property, set the angular form validators
        TableColumnDirective.prototype.setUpValidators = function (widget) {
            var control = this.getFormControl(widget === 'inlineInstanceNew' ? '_new' : undefined);
            if (!control) {
                return;
            }
            var validators = [];
            if (this.required) {
                // For checkbox/toggle widget, required validation should consider true value only
                if (this.editWidgetType === core.FormWidgetType.CHECKBOX || this.editWidgetType === core.FormWidgetType.TOGGLE) {
                    validators.push(forms.Validators.requiredTrue);
                }
                else {
                    validators.push(forms.Validators.required);
                }
            }
            if (this.maxchars) {
                validators.push(forms.Validators.maxLength(this.maxchars));
            }
            if (this.minvalue) {
                validators.push(forms.Validators.min(this.minvalue));
            }
            if (this.maxvalue) {
                validators.push(forms.Validators.max(this.maxvalue));
            }
            if (this.regexp) {
                validators.push(forms.Validators.pattern(this.regexp));
            }
            if (this[widget] && _.isFunction(this[widget].validate)) {
                validators.push(this[widget].validate.bind(this[widget]));
            }
            control.setValidators(validators);
            control.updateValueAndValidity();
        };
        // Set the props on the inline edit widget
        TableColumnDirective.prototype.setInlineWidgetProp = function (widget, prop, nv) {
            if (prop === 'datepattern' && this.editWidgetType === core.FormWidgetType.TIME) {
                prop = 'timepattern';
            }
            if (this[widget] && core.isDefined(nv)) {
                this[widget][prop] = nv;
            }
            if (validationProps.includes(prop)) {
                this._debounceSetUpValidators();
                this._debounceSetUpValidatorsNew();
            }
        };
        // Initialize the inline edit widget
        TableColumnDirective.prototype.setUpInlineWidget = function (widget) {
            var _this = this;
            this[widget].registerReadyStateListener(function () {
                if (isDataSetWidget(_this['edit-widget-type'])) {
                    _this[widget].dataset = _this.dataset;
                }
                inlineWidgetProps.forEach(function (key) {
                    _this.setInlineWidgetProp(widget, key, _this[key]);
                });
                _this[widget].datasource = _this._datasource;
                _this[widget].dataoptions = _this._dataoptions;
                _this.setInlineWidgetProp(widget, 'datepattern', _this.editdatepattern);
            });
        };
        TableColumnDirective.prototype.getStyleDef = function () {
            return "width: " + (this.width || '') + "; background-color: " + (this.backgroundcolor || '') + "; color: " + (this.textcolor || '') + ";";
        };
        TableColumnDirective.prototype.populateFieldDef = function () {
            this.width = this.width === 'px' ? '' : (this.width || '');
            this.field = this.binding;
            this.displayName = this.caption || '';
            this.pcDisplay = this.pcdisplay;
            this.mobileDisplay = this.mobiledisplay;
            this.textAlignment = this.textalignment;
            this.backgroundColor = this.backgroundcolor;
            this.textColor = this.textcolor;
            this.primaryKey = this['primary-key'];
            this.relatedEntityName = this['related-entity-name'];
            this.style = this.getStyleDef();
            this.class = this['col-class'];
            this.ngclass = this['col-ng-class'];
            this.formatpattern = this.formatpattern === 'toNumber' ? 'numberToString' : this.formatpattern;
            this.searchable = (this.type === 'blob' || this.type === 'clob') ? false : this.searchable;
            this.limit = this.limit ? +this.limit : undefined;
            this.editWidgetType = this['edit-widget-type'] = this['edit-widget-type'] || getEditModeWidget(this);
            this.filterOn = this['filter-on'];
            this.readonly = core.isDefined(this.getAttr('readonly')) ? this.getAttr('readonly') === 'true' : (this['related-entity-name'] ? !this['primary-key'] : _.includes(['identity', 'uniqueid', 'sequence'], this.generator));
            this.filterwidget = this.filterwidget || getDataTableFilterWidget(this.type || 'string');
            this.isFilterDataSetBound = !!this.bindfilterdataset;
            this.defaultvalue = getDefaultValue(this.defaultvalue, this.type, this.editWidgetType);
            // For date time data types, if date pattern is not specified, set the app format or default format
            if (core.isDateTimeType(this.type) && this.formatpattern === 'toDate' && !this.datepattern) {
                var defaultFormat = core.getDisplayDateTimeFormat(this.type);
                if (this.type === core.DataType.DATE) {
                    this.datepattern = this.appDefaults.dateFormat || defaultFormat;
                }
                else if (this.type === core.DataType.TIME) {
                    this.datepattern = this.appDefaults.timeFormat || defaultFormat;
                }
                else if (this.type === core.DataType.TIMESTAMP || this.type === core.DataType.DATETIME) {
                    this.datepattern = this.appDefaults.dateTimeFormat || defaultFormat;
                }
            }
        };
        TableColumnDirective.prototype.onPropertyChange = function (key, nv, ov) {
            if (!this._propsInitialized) {
                return;
            }
            switch (key) {
                case 'caption':
                    this.displayName = nv || '';
                    this.setProperty('displayName', this.displayName);
                    break;
                case 'defaultvalue':
                    this.defaultvalue = getDefaultValue(this.defaultvalue, this.type, this.editWidgetType);
                    break;
                case 'show':
                    this.table.redraw(true);
                    break;
                case 'filterdataset':
                    this._filterDataSet = nv;
                    this.setFilterWidgetDataSet();
                    break;
                case 'editdatepattern':
                    this.setInlineWidgetProp('inlineInstance', 'datepattern', nv);
                    this.setInlineWidgetProp('inlineInstanceNew', 'datepattern', nv);
                    break;
                default:
                    if (inlineWidgetProps.includes(key)) {
                        this.setInlineWidgetProp('inlineInstance', key, nv);
                        this.setInlineWidgetProp('inlineInstanceNew', key, nv);
                    }
                    break;
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        TableColumnDirective.prototype.setProperty = function (property, nv) {
            this[property] = nv;
            switch (property) {
                case 'displayName':
                    this.table.callDataGridMethod('setColumnProp', this.field, property, nv);
                    break;
                default:
                    this.table.redraw(true);
            }
        };
        TableColumnDirective.initializeProps = registerProps$1c();
        TableColumnDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTableColumn]',
                        providers: [
                            provideAsWidgetRef(TableColumnDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        TableColumnDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core.AppDefaults },
                { type: TableComponent, decorators: [{ type: core$1.Optional }] },
                { type: TableColumnGroupDirective, decorators: [{ type: core$1.Optional }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['filterdataset.bind',] }] },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['dataset.bind',] }] }
            ];
        };
        TableColumnDirective.propDecorators = {
            _filterInstances: [{ type: core$1.ContentChildren, args: ['filterWidget',] }],
            _inlineInstances: [{ type: core$1.ContentChildren, args: ['inlineWidget',] }],
            _inlineInstancesNew: [{ type: core$1.ContentChildren, args: ['inlineWidgetNew',] }],
            customExprTmpl: [{ type: core$1.ContentChild, args: ['customExprTmpl',] }],
            filterTemplateRef: [{ type: core$1.ContentChild, args: ['filterTmpl',] }]
        };
        return TableColumnDirective;
    }(BaseComponent));

    var OPERATION = {
        'NEW': 'new',
        'EDIT': 'edit',
        'DELETE': 'delete'
    };
    var TableCUDDirective = /** @class */ (function () {
        function TableCUDDirective(table, dialogService, app) {
            this.table = table;
            this.dialogService = dialogService;
            this.app = app;
            table.initiateSelectItem = this.initiateSelectItem.bind(this);
            table.updateVariable = this.updateVariable.bind(this);
            table.updateRecord = this.updateRecord.bind(this);
            table.deleteRecord = this.deleteRecord.bind(this);
            table.insertRecord = this.insertRecord.bind(this);
            table.editRow = this.editRow.bind(this);
            table.addNewRow = this.addNewRow.bind(this);
            table.addRow = this.addNewRow.bind(this);
            table.deleteRow = this.deleteRow.bind(this);
            table.onRecordDelete = this.onRecordDelete.bind(this);
            table.hideEditRow = this.hideEditRow.bind(this);
            table.saveRow = this.saveRow.bind(this);
            table.cancelRow = this.cancelRow.bind(this);
        }
        TableCUDDirective.prototype.selectItemOnSuccess = function (row, skipSelectItem, callBack) {
            var _this = this;
            /*$timeout is used so that by then $is.dataset has the updated value.
             * Selection of the item is done in the callback of page navigation so that the item that needs to be selected actually exists in the grid.*/
            /*Do not select the item if skip selection item is specified*/
            setTimeout(function () {
                if (!skipSelectItem) {
                    _this.table.selectItem(row, _this.table.dataset);
                }
                core.triggerFn(callBack);
            }, 250);
        };
        TableCUDDirective.prototype.initiateSelectItem = function (index, row, skipSelectItem, isStaticVariable, callBack) {
            var _this = this;
            /*index === "last" indicates that an insert operation has been successfully performed and navigation to the last page is required.
             * Hence increment the "dataSize" by 1.*/
            if (index === 'last') {
                if (!isStaticVariable) {
                    this.table.dataNavigator.dataSize += 1;
                }
                /*Update the data in the current page in the grid after insert/update operations.*/
                if (!this.table.isNavigationEnabled()) {
                    index = 'current';
                }
            }
            /*Re-calculate the paging values like pageCount etc that could change due to change in the dataSize.*/
            this.table.dataNavigator.calculatePagingValues();
            this.table.dataNavigator.navigatePage(index, null, true, function () {
                if (_this.table.isNavigationEnabled() || isStaticVariable) {
                    _this.selectItemOnSuccess(row, skipSelectItem, callBack);
                }
            });
        };
        TableCUDDirective.prototype.updateVariable = function (row, callBack) {
            var _this = this;
            var dataSource = this.table.datasource;
            if (!dataSource) {
                return;
            }
            dataSource.execute(core.DataSource.Operation.FETCH_DISTINCT_VALUES);
            if (!this.table.isNavigationEnabled()) {
                var sortInfo = this.table.sortInfo;
                var sortOptions = sortInfo && sortInfo.direction ? (sortInfo.field + ' ' + sortInfo.direction) : '';
                refreshDataSource(dataSource, {
                    page: 1,
                    filterFields: this.table.getFilterFields(this.table.filterInfo),
                    orderBy: sortOptions,
                    matchMode: 'anywhereignorecase'
                }).then(function () {
                    core.$appDigest();
                    _this.selectItemOnSuccess(row, true, callBack);
                });
            }
        };
        TableCUDDirective.prototype.insertSuccessHandler = function (response, options) {
            /*Display appropriate error message in case of error.*/
            if (response.error) {
                this.table.invokeEventCallback('error', { $event: options.event, $operation: OPERATION.NEW, $data: response.error });
                this.table.toggleMessage(true, 'error', this.table.errormessage || response.error);
                core.triggerFn(options.error, response);
            }
            else {
                if (options.event) {
                    var row = $(options.event.target).closest('tr');
                    this.table.callDataGridMethod('hideRowEditMode', row);
                }
                this.table.toggleMessage(true, 'success', this.table.insertmessage);
                if (this.table.datasource.execute(core.DataSource.Operation.SUPPORTS_CRUD)) {
                    this.table.initiateSelectItem(this.table.getNavigationTargetBySortInfo(), response, undefined, false, options.callBack);
                    this.updateVariable(response, options.callBack);
                }
                else if (!this.table.datasource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                    this.table.initiateSelectItem(this.table.getNavigationTargetBySortInfo(), response, undefined, false, options.callBack);
                }
                core.triggerFn(options.success, response);
                this.table.invokeEventCallback('rowinsert', { $event: options.event, $data: response, row: response });
            }
        };
        TableCUDDirective.prototype.insertRecord = function (options) {
            var _this = this;
            var dataSource = this.table.datasource;
            if (!dataSource) {
                return;
            }
            var dataObject = {
                row: options.row,
                skipNotification: true,
                period: options.period
            };
            if (dataSource.execute(core.DataSource.Operation.SUPPORTS_CRUD) || !dataSource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                if (!dataSource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                    dataSource.execute(core.DataSource.Operation.ADD_ITEM, { item: options.row });
                    this.insertSuccessHandler(options.row, options);
                    return;
                }
                dataSource.execute(core.DataSource.Operation.INSERT_RECORD, dataObject).then(function (response) {
                    _this.insertSuccessHandler(response, options);
                }, function (error) {
                    _this.table.invokeEventCallback('error', { $event: options.event, $operation: OPERATION.NEW, $data: error });
                    _this.table.toggleMessage(true, 'error', _this.table.errormessage || error);
                    core.triggerFn(options.error, error);
                    core.triggerFn(options.callBack, undefined, true);
                });
            }
            else {
                this.table.invokeEventCallback('rowinsert', { $event: options.event, row: options.row });
            }
        };
        TableCUDDirective.prototype.updateSuccessHandler = function (response, options) {
            /*Display appropriate error message in case of error.*/
            if (response.error) {
                this.table.invokeEventCallback('error', { $event: options.event, $operation: OPERATION.EDIT, $data: response.error });
                /*disable readonly and show the appropriate error*/
                this.table.toggleMessage(true, 'error', this.table.errormessage || response.error);
                core.triggerFn(options.error, response);
            }
            else {
                if (options.event) {
                    var row = $(options.event.target).closest('tr');
                    this.table.callDataGridMethod('hideRowEditMode', row);
                }
                this.table.toggleMessage(true, 'success', this.table.updatemessage);
                if (this.table.datasource.execute(core.DataSource.Operation.SUPPORTS_CRUD)) {
                    this.table.initiateSelectItem('current', response, undefined, false, options.callBack);
                    this.updateVariable(response, options.callBack);
                }
                core.triggerFn(options.success, response);
                this.table.invokeEventCallback('rowupdate', { $event: options.event, $data: response, row: response });
            }
        };
        TableCUDDirective.prototype.updateRecord = function (options) {
            var _this = this;
            var dataSource = this.table.datasource;
            if (!dataSource) {
                return;
            }
            var dataObject = {
                row: options.row,
                prevData: options.prevData,
                skipNotification: true,
                period: options.period
            };
            if (dataSource.execute(core.DataSource.Operation.SUPPORTS_CRUD) || !dataSource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                if (!dataSource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                    dataSource.execute(core.DataSource.Operation.SET_ITEM, { prevItem: options.prevData, item: options.row });
                    this.updateSuccessHandler(options.row, options);
                    return;
                }
                dataSource.execute(core.DataSource.Operation.UPDATE_RECORD, dataObject).then(function (response) {
                    _this.updateSuccessHandler(response, options);
                }, function (error) {
                    _this.table.invokeEventCallback('error', { $event: options.event, $operation: OPERATION.EDIT, $data: error });
                    _this.table.toggleMessage(true, 'error', _this.table.errormessage || error);
                    core.triggerFn(options.error, error);
                    core.triggerFn(options.callBack, undefined, true);
                });
            }
            else {
                this.table.invokeEventCallback('rowupdate', { $event: options.event, row: options.row });
            }
        };
        TableCUDDirective.prototype.onRecordDelete = function (callBack) {
            var index;
            /*Check for sanity*/
            if (this.table.dataNavigator) {
                this.table.dataNavigator.dataSize -= 1;
                this.table.dataNavigator.calculatePagingValues();
                /*If the current page does not contain any records due to deletion, then navigate to the previous page.*/
                index = this.table.dataNavigator.pageCount < this.table.dataNavigator.dn.currentPage ? 'prev' : undefined;
                this.table.dataNavigator.navigatePage(index, null, true, function () {
                    setTimeout(function () {
                        core.triggerFn(callBack);
                    }, undefined, false);
                });
            }
        };
        TableCUDDirective.prototype.deleteSuccessHandler = function (row, response, evt, callBack) {
            /* check the response whether the data successfully deleted or not , if any error occurred show the
             * corresponding error , other wise remove the row from grid */
            if (response && response.error) {
                this.table.toggleMessage(true, 'error', this.table.errormessage || response.error);
                return;
            }
            this.onRecordDelete(callBack);
            if (this.table.datasource.execute(core.DataSource.Operation.SUPPORTS_CRUD)) {
                this.updateVariable(row, callBack);
            }
            this.table.toggleMessage(true, 'success', this.table.deletemessage);
            // custom EventHandler for row deleted event
            this.table.invokeEventCallback('rowdelete', { $event: evt, $data: row, row: row });
            this.table.invokeEventCallback('rowdeleted', { $event: evt, $data: row, row: row });
        };
        TableCUDDirective.prototype.deleteFn = function (options) {
            var _this = this;
            var dataSource = this.table.datasource;
            if (!dataSource) {
                return;
            }
            if (dataSource.execute(core.DataSource.Operation.SUPPORTS_CRUD) || !dataSource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                if (!dataSource.execute(core.DataSource.Operation.IS_API_AWARE)) {
                    dataSource.execute(core.DataSource.Operation.REMOVE_ITEM, { item: options.row });
                    this.deleteSuccessHandler(options.row, undefined, options.evt, options.callBack);
                    return;
                }
                dataSource.execute(core.DataSource.Operation.DELETE_RECORD, {
                    row: options.row,
                    skipNotification: true,
                    period: options.period
                }).then(function (response) {
                    _this.deleteSuccessHandler(response, options.row, options.evt, options.callBack);
                }, function (error) {
                    core.triggerFn(options.callBack, undefined, true);
                    _this.table.invokeEventCallback('error', { $event: options.evt, $operation: OPERATION.DELETE, $data: error });
                    _this.table.toggleMessage(true, 'error', _this.table.errormessage || error);
                });
            }
            else {
                this.table.invokeEventCallback('rowdelete', { $event: options.evt, row: options.row });
            }
            core.triggerFn(options.cancelRowDeleteCallback);
        };
        TableCUDDirective.prototype.deleteRecord = function (options) {
            var _this = this;
            if (!this.table.confirmdelete) {
                this.deleteFn(options);
                core.triggerFn(options.cancelRowDeleteCallback);
                return;
            }
            this.dialogService.showAppConfirmDialog({
                title: this.app.appLocale.MESSAGE_DELETE_RECORD || 'Delete Record',
                iconclass: 'wi wi-delete fa-lg',
                message: this.table.confirmdelete,
                oktext: this.table.deleteoktext,
                canceltext: this.table.deletecanceltext,
                onOk: function () {
                    _this.deleteFn(options);
                    _this.dialogService.closeAppConfirmDialog();
                },
                onCancel: function () {
                    core.triggerFn(options.cancelRowDeleteCallback);
                    _this.dialogService.closeAppConfirmDialog();
                },
                onOpen: function () {
                    // Focus the cancel button on open
                    $('.cancel-action').focus();
                }
            });
        };
        TableCUDDirective.prototype.editRow = function (evt) {
            var _this = this;
            var row;
            if (evt && evt.target) {
                this.table.callDataGridMethod('toggleEditRow', evt, { 'selectRow': true, action: 'edit' });
            }
            else {
                // For live form, call the update function with selected item
                if (this.table.editmode === 'form' || this.table.editmode === 'dialog') {
                    row = evt || this.table.selectedItems[0];
                    this.table.gridOptions.beforeRowUpdate(row);
                }
                else {
                    // Wait for the selected item to get updated
                    setTimeout(function () {
                        row = _this.table.datagridElement.find('tr.active');
                        if (row.length) {
                            _this.table.callDataGridMethod('toggleEditRow', undefined, { $row: row, action: 'edit' });
                        }
                    });
                }
            }
        };
        TableCUDDirective.prototype.addNewRow = function () {
            if (!this.table.isGridEditMode) { // If grid is already in edit mode, do not add new row
                this.table.callDataGridMethod('addNewRow');
                if (this.table._liveTableParent) {
                    this.table._liveTableParent.addNewRow();
                }
            }
        };
        TableCUDDirective.prototype.deleteRow = function (evt) {
            var _this = this;
            var row;
            if (evt && evt.target) {
                this.table.callDataGridMethod('deleteRowAndUpdateSelectAll', evt);
            }
            else {
                // Wait for the selected item to get updated
                setTimeout(function () {
                    row = evt || _this.table.selectedItems[0];
                    _this.deleteRecord({ row: row });
                });
            }
        };
        // Function to hide the edited row
        TableCUDDirective.prototype.hideEditRow = function () {
            var $row = this.table.datagridElement.find('tr.row-editing');
            if ($row.length) {
                this.table.callDataGridMethod('hideRowEditMode', $row);
            }
        };
        // Function to save the row
        TableCUDDirective.prototype.saveRow = function () {
            this.table.callDataGridMethod('saveRow');
        };
        // Function to cancel the edit
        TableCUDDirective.prototype.cancelRow = function () {
            var $row = this.table.datagridElement.find('tr.row-editing');
            if ($row.length) {
                this.table.callDataGridMethod('cancelEdit', $row);
            }
        };
        TableCUDDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTableCUD]'
                    },] }
        ];
        /** @nocollapse */
        TableCUDDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [TableComponent,] }] },
                { type: core.AbstractDialogService },
                { type: core.App }
            ];
        };
        return TableCUDDirective;
    }());

    var emptyMatchModes = ['null', 'empty', 'nullorempty', 'isnotnull', 'isnotempty'];
    // Get search value based on the time
    var getSearchValue = function (value, type) {
        if (!core.isDefined(value) || value === '') {
            return undefined;
        }
        if (core.isNumberType(type)) {
            return _.toNumber(value);
        }
        if (type === core.DataType.DATETIME) {
            return moment(value).valueOf();
        }
        return _.toString(value).toLowerCase();
    };
    // Filter the data based on the search value and conditions
    var getFilteredData = function (data, searchObj) {
        var searchVal = getSearchValue(searchObj.value, searchObj.type);
        var currentVal;
        if (!core.isDefined(searchVal) && !_.includes(emptyMatchModes, searchObj.matchMode)) {
            return data;
        }
        data = data.filter(function (obj) {
            var isExists;
            if (searchObj.field) {
                currentVal = getSearchValue(_.get(obj, searchObj.field), searchObj.type);
            }
            else {
                currentVal = _.values(obj).join(' ').toLowerCase(); // If field is not there, search on all the columns
            }
            switch (searchObj.matchMode) {
                case 'start':
                    isExists = _.startsWith(currentVal, searchVal);
                    break;
                case 'end':
                    isExists = _.endsWith(currentVal, searchVal);
                    break;
                case 'exact':
                    isExists = _.isEqual(currentVal, searchVal);
                    break;
                case 'notequals':
                    isExists = !_.isEqual(currentVal, searchVal);
                    break;
                case 'null':
                    isExists = _.isNull(currentVal);
                    break;
                case 'isnotnull':
                    isExists = !_.isNull(currentVal);
                    break;
                case 'empty':
                    isExists = _.isEmpty(currentVal);
                    break;
                case 'isnotempty':
                    isExists = !_.isEmpty(currentVal);
                    break;
                case 'nullorempty':
                    isExists = _.isNull(currentVal) || _.isEmpty(currentVal);
                    break;
                case 'lessthan':
                    isExists = currentVal < searchVal;
                    break;
                case 'lessthanequal':
                    isExists = currentVal <= searchVal;
                    break;
                case 'greaterthan':
                    isExists = currentVal > searchVal;
                    break;
                case 'greaterthanequal':
                    isExists = currentVal >= searchVal;
                    break;
                default:
                    isExists = core.isNumberType(searchObj.type) ? _.isEqual(currentVal, searchVal) : _.includes(currentVal, searchVal);
                    break;
            }
            return isExists;
        });
        return data;
    };
    // Set the filter fields as required by datasource
    var setFilterFields = function (filterFields, searchObj) {
        var field = searchObj && searchObj.field;
        /*Set the filter options only when a field/column has been selected.*/
        if (field) {
            filterFields[field] = {
                'value': searchObj.value,
                'logicalOp': 'AND'
            };
            if (searchObj.matchMode) {
                filterFields[field].matchMode = searchObj.matchMode;
            }
        }
    };
    // Transform filter fields from array to object having field names as keys
    var transformFilterField = function (userFilters, filterField) {
        if (filterField.field) {
            userFilters[filterField.field] = {
                value: filterField.value,
                matchMode: filterField.matchMode,
                type: filterField.type
            };
        }
    };
    var TableFilterSortDirective = /** @class */ (function () {
        function TableFilterSortDirective(table) {
            this.table = table;
            table._searchSortHandler = this.searchSortHandler.bind(this);
            table.getSearchResult = this.getSearchResult.bind(this);
            table.getSortResult = this.getSortResult.bind(this);
            table.checkFiltersApplied = this.checkFiltersApplied.bind(this);
            table.getFilterFields = this.getFilterFields.bind(this);
            table.onRowFilterChange = this.onRowFilterChange.bind(this);
            table.onFilterConditionSelect = this.onFilterConditionSelect.bind(this);
            table.showClearIcon = this.showClearIcon.bind(this);
            table.clearRowFilter = this.clearRowFilter.bind(this);
            table.matchModeTypesMap = getMatchModeTypesMap();
            table.matchModeMsgs = getMatchModeMsgs(table.appLocale);
            table.emptyMatchModes = emptyMatchModes;
            table.getNavigationTargetBySortInfo = this.getNavigationTargetBySortInfo.bind(this);
            table.refreshData = this.refreshData.bind(this);
            table.clearFilter = this.clearFilter.bind(this);
        }
        // Get first or last page based on sort info of primary key
        TableFilterSortDirective.prototype.getNavigationTargetBySortInfo = function () {
            return this.table.sortInfo && this.table.sortInfo.direction === 'desc' &&
                _.includes(this.table.primaryKey, this.table.sortInfo.field) ? 'first' : 'last';
        };
        // Get the filter fields as required by datasource
        TableFilterSortDirective.prototype.getFilterFields = function (searchObj) {
            var filterFields = {};
            if (_.isArray(searchObj)) {
                _.forEach(searchObj, function (obj) {
                    setFilterFields(filterFields, obj);
                });
            }
            else {
                setFilterFields(filterFields, searchObj);
            }
            return filterFields;
        };
        // Reset the sort based on sort returned by the call
        TableFilterSortDirective.prototype.resetSortStatus = function (variableSort) {
            var gridSortString;
            if (!_.isEmpty(this.table.sortInfo) && this.table.datasource) {
                gridSortString = this.table.sortInfo.field + ' ' + this.table.sortInfo.direction;
                variableSort = this.table.datasource.execute(core.DataSource.Operation.GET_OPTIONS).orderBy || variableSort;
                if (variableSort) { // If multiple order by fields are present, compare with the first one
                    variableSort = _.head(_.split(variableSort, ','));
                }
                if (gridSortString !== variableSort) {
                    this.table.callDataGridMethod('resetSortIcons');
                    this.table.sortInfo = {};
                    this.table.setDataGridOption('sortInfo', {});
                }
            }
        };
        // Clear the all the filters applied
        TableFilterSortDirective.prototype.clearFilter = function (skipFilter) {
            var $gridElement;
            this.table.filterInfo = {};
            if (this.table.filtermode === 'multicolumn') {
                this.table.fieldDefs.forEach(function (col) {
                    if (col.resetFilter) {
                        col.resetFilter();
                    }
                });
                if (!skipFilter) {
                    this.table.onRowFilterChange();
                }
            }
            else if (this.table.filtermode === 'search') {
                $gridElement = this.table.datagridElement;
                $gridElement.find('[data-element="dgSearchText"]').val('');
                $gridElement.find('[data-element="dgFilterValue"]').val('');
                if (!skipFilter) {
                    $gridElement.find('.app-search-button').trigger('click');
                }
            }
        };
        // Check the filters applied and remove if dat does not contain any filters
        TableFilterSortDirective.prototype.checkFiltersApplied = function (variableSort) {
            if (!this.table.datasource) {
                return;
            }
            if (this.table.datasource.execute(core.DataSource.Operation.SUPPORTS_SERVER_FILTER)) {
                if (_.isEmpty(this.table.datasource.execute(core.DataSource.Operation.GET_OPTIONS).filterFields) && _.isEmpty(this.table.filterInfo)) {
                    this.clearFilter(true);
                }
                this.resetSortStatus(variableSort);
                return;
            }
            if (this.table.datasource.execute(core.DataSource.Operation.IS_PAGEABLE)) {
                this.resetSortStatus(variableSort);
            }
        };
        // Returns data filtered using searchObj
        TableFilterSortDirective.prototype.getSearchResult = function (data, searchObj) {
            if (!searchObj) {
                return data;
            }
            if (_.isArray(searchObj)) {
                searchObj.forEach(function (obj) {
                    data = getFilteredData(data, obj);
                });
            }
            else {
                data = getFilteredData(data, searchObj);
            }
            return data;
        };
        // Returns data sorted using sortObj
        TableFilterSortDirective.prototype.getSortResult = function (data, sortObj) {
            if (sortObj && sortObj.direction) {
                data = _.orderBy(data, sortObj.field, sortObj.direction);
            }
            return data;
        };
        // This method handles the client side sort and search
        TableFilterSortDirective.prototype.handleClientSideSortSearch = function (searchSortObj, e, type) {
            this.table._isClientSearch = true;
            var data;
            data = this.table.isNavigationEnabled() ? core.getClonedObject(this.table.__fullData) : core.getClonedObject(this.table.dataset);
            if (type === 'search') {
                this.table.filterInfo = searchSortObj;
            }
            else {
                this.table.sortInfo = searchSortObj;
            }
            if (_.isObject(data) && !_.isArray(data)) {
                data = [data];
            }
            /*Both the functions return same 'data' if arguments are undefined*/
            data = this.getSearchResult(data, this.table.filterInfo);
            data = this.getSortResult(data, this.table.sortInfo);
            this.table.serverData = data;
            if (type === 'sort') {
                // Calling 'onSort' event
                this.table.invokeEventCallback('sort', { $event: e, $data: {
                        data: this.table.serverData,
                        sortDirection: this.table.sortInfo.direction,
                        colDef: this.table.columns[this.table.sortInfo.field]
                    } });
            }
            if (this.table.isNavigationEnabled()) {
                // Reset the page number to 1
                this.table.dataNavigator.dn.currentPage = 1;
                this.table.dataNavigator.setPagingValues(data);
            }
            else {
                this.table.setGridData(this.table.serverData);
            }
        };
        // This method handles the search for pageable datasource
        TableFilterSortDirective.prototype.handleSinglePageSearch = function (searchObj) {
            this.table._isPageSearch = true;
            var data = core.getClonedObject(this.table.gridData);
            var $rows = this.table.datagridElement.find('tbody tr.app-datagrid-row');
            this.table.filterInfo = searchObj;
            data = this.getSearchResult(data, searchObj);
            // Compared the filtered data and original data, to show or hide the rows
            _.forEach(this.table.gridData, function (value, index) {
                var $row = $($rows[index]);
                if (_.find(data, function (obj) { return _.isEqual(obj, value); })) {
                    $row.show();
                }
                else {
                    $row.hide();
                }
            });
            if (data && data.length) {
                this.table.callDataGridMethod('setStatus', 'ready');
                // Select the first row after the search for single select
                if (this.table.gridfirstrowselect && !this.table.multiselect) {
                    this.table.callDataGridMethod('selectFirstRow', true, true);
                }
            }
            else {
                this.table.callDataGridMethod('setStatus', 'nodata', this.table.nodatamessage);
                this.table.selecteditem = undefined;
            }
            this.table.callDataGridMethod('updateSelectAllCheckboxState');
        };
        // This method handles the search for server side variables
        TableFilterSortDirective.prototype.handleServerSideSearch = function (searchObj) {
            var _this = this;
            this.table.filterInfo = searchObj;
            if (!this.table.datasource) {
                return;
            }
            var sortInfo = this.table.sortInfo;
            var sortOptions = sortInfo && sortInfo.direction ? (sortInfo.field + ' ' + sortInfo.direction) : '';
            var filterFields = this.getFilterFields(searchObj);
            refreshDataSource(this.table.datasource, {
                page: 1,
                filterFields: filterFields,
                orderBy: sortOptions
            }).then(function () {
                core.$appDigest();
            }, function () {
                _this.table.toggleMessage(true, 'error', _this.table.nodatamessage);
            });
        };
        // This method handles the sort for server side variables
        TableFilterSortDirective.prototype.handleSeverSideSort = function (sortObj, e) {
            var _this = this;
            // Update the sort info for passing to datagrid
            this.table.gridOptions.sortInfo.field = sortObj.field;
            this.table.gridOptions.sortInfo.direction = sortObj.direction;
            this.table.sortInfo = core.getClonedObject(sortObj);
            var sortOptions = sortObj && sortObj.direction ? (sortObj.field + ' ' + sortObj.direction) : '';
            var filterFields = this.getFilterFields(this.table.filterInfo);
            refreshDataSource(this.table.datasource, {
                page: 1,
                filterFields: filterFields,
                orderBy: sortOptions
            }).then(function (response) {
                core.$appDigest();
                var data = (response && response.data) ? response.data : response;
                _this.table.invokeEventCallback('sort', { $event: e, $data: {
                        data: data,
                        sortDirection: sortObj.direction,
                        colDef: _this.table.columns[sortObj.field]
                    } });
            });
        };
        TableFilterSortDirective.prototype.searchHandler = function (searchSortObj, e, type) {
            var filterFields = core.getClonedObject(searchSortObj);
            var dataSource = this.table.datasource;
            if (!dataSource) {
                return;
            }
            var output;
            var userFilters = {};
            // Transform filter fields from array to object having field names as keys
            if (_.isArray(filterFields)) {
                filterFields.forEach(function (filterField) {
                    transformFilterField(userFilters, filterField);
                });
            }
            else {
                transformFilterField(userFilters, filterFields);
            }
            output = this.table.invokeEventCallback('beforefilter', { $event: e, $data: userFilters, columns: userFilters });
            // If callback returns false, don't trigger the filter call
            if (output === false) {
                return;
            }
            // Transform back the filter fields from object to array
            filterFields = [];
            _.forEach(userFilters, function (val, key) {
                filterFields.push({
                    field: key,
                    matchMode: val.matchMode,
                    type: val.type,
                    value: val.value
                });
            });
            if (dataSource.execute(core.DataSource.Operation.SUPPORTS_SERVER_FILTER)) {
                this.handleServerSideSearch(filterFields);
                return;
            }
            if (dataSource.execute(core.DataSource.Operation.IS_API_AWARE) && dataSource.execute(core.DataSource.Operation.IS_PAGEABLE)) {
                this.handleSinglePageSearch(filterFields);
            }
            else {
                this.handleClientSideSortSearch(filterFields, e, type);
            }
        };
        TableFilterSortDirective.prototype.sortHandler = function (searchSortObj, e, type) {
            var dataSource = this.table.datasource;
            if (!dataSource) {
                return;
            }
            if (dataSource.execute(core.DataSource.Operation.IS_PAGEABLE)) {
                this.handleSeverSideSort(searchSortObj, e);
            }
            else {
                this.handleClientSideSortSearch(searchSortObj, e, type);
            }
        };
        // This method is triggered by jquery table
        TableFilterSortDirective.prototype.searchSortHandler = function (searchSortObj, e, type) {
            if (type === 'search') {
                this.searchHandler(searchSortObj, e, type);
            }
            else {
                this.sortHandler(searchSortObj, e, type);
            }
        };
        // Method to show/hide clear icon in multi column filter
        TableFilterSortDirective.prototype.showClearIcon = function (fieldName) {
            var value = this.table.rowFilter[fieldName] && this.table.rowFilter[fieldName].value;
            return core.isDefined(value) && value !== '' && value !== null;
        };
        // Method clear the filter value in multi column filter
        TableFilterSortDirective.prototype.clearRowFilter = function (fieldName) {
            if (this.table.rowFilter && this.table.rowFilter[fieldName]) {
                this.table.columns[fieldName].resetFilter();
                this.onRowFilterChange(fieldName);
            }
        };
        // This method is triggered on select of condition in multi column filter
        TableFilterSortDirective.prototype.onFilterConditionSelect = function (fieldName, condition) {
            var _this = this;
            this.table.rowFilter[fieldName] = this.table.rowFilter[fieldName] || {};
            this.table.rowFilter[fieldName].matchMode = condition;
            // For empty match modes, clear off the value and call filter
            if (_.includes(this.table.emptyMatchModes, condition)) {
                this.table.columns[fieldName].resetFilter();
                this.table.onRowFilterChange();
            }
            else {
                // If value is present, call the filter. Else, focus on the field
                if (core.isDefined(this.table.rowFilter[fieldName].value) && this.table.rowFilter[fieldName].value !== '') {
                    this.table.onRowFilterChange();
                }
                else {
                    setTimeout(function () {
                        _this.table.columns[fieldName].filterInstance.focus();
                    });
                }
            }
        };
        // Method to get the updated values when filter on field is changed for multicolumn filter
        TableFilterSortDirective.prototype.getFilterOnFieldValues = function (filterDef) {
            var _this = this;
            if (!this.table.datasource || !this.table.datasource.execute(core.DataSource.Operation.SUPPORTS_DISTINCT_API)) {
                return;
            }
            var fieldName = filterDef.field;
            var formFields = this.table.fullFieldDefs;
            var filterOnFields = _.filter(formFields, { 'filteronfilter': fieldName });
            var newVal = _.get(this.table.rowFilter, [fieldName, 'value']);
            // Loop over the fields for which the current field is filter on field
            _.forEach(filterOnFields, function (filterField) {
                var filterOn = filterField.filteronfilter;
                var filterKey = filterField.field;
                var filterFields = {};
                var filterWidget = filterField.filterwidget;
                if (!isDataSetWidget(filterWidget) || filterOn === filterKey || filterField.isFilterDataSetBound) {
                    return;
                }
                filterFields[filterOn] = (core.isDefined(newVal) && newVal !== '' && newVal !== null) ? { 'value': newVal } : {};
                if (filterWidget === core.FormWidgetType.AUTOCOMPLETE && filterField.filterInstance.dataoptions) {
                    filterField.filterInstance.dataoptions.filterFields = filterFields;
                }
                else {
                    _this.table.datasource.execute(core.DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS, {
                        'fields': filterKey,
                        'filterFields': filterFields
                    }).then(function (data) {
                        filterField.filterdataset = data.data;
                    });
                }
            });
        };
        // This method is triggered on value change in multi column filter
        TableFilterSortDirective.prototype.onRowFilterChange = function (fieldName) {
            var _this = this;
            var searchObj = [];
            var field = _.find(this.table.fullFieldDefs, { 'field': fieldName });
            // Convert row filters to a search object and call search handler
            _.forEach(this.table.rowFilter, function (value, key) {
                if ((core.isDefined(value.value) && value.value !== '') || _.includes(_this.table.emptyMatchModes, value.matchMode)) {
                    if (field && key === field.field) {
                        value.type = value.type || field.type;
                        value.matchMode = value.matchMode || _.get(_this.table.matchModeTypesMap[value.type], 0);
                    }
                    searchObj.push({
                        field: key,
                        value: value.value,
                        matchMode: value.matchMode,
                        type: value.type
                    });
                }
            });
            this.table.gridOptions.searchHandler(searchObj, undefined, 'search');
            // If field is passed, update any filter on field values if present
            if (field) {
                this.getFilterOnFieldValues(field);
            }
        };
        TableFilterSortDirective.prototype.refreshData = function (isSamePage) {
            if (!this.table.datasource) {
                return;
            }
            var page = isSamePage ? this.table.dataNavigator.dn.currentPage : 1;
            var sortInfo = this.table.sortInfo;
            var sortOptions = sortInfo && sortInfo.direction ? (sortInfo.field + ' ' + sortInfo.direction) : '';
            var filterFields = this.getFilterFields(this.table.filterInfo);
            refreshDataSource(this.table.datasource, {
                page: page,
                filterFields: filterFields,
                orderBy: sortOptions
            });
        };
        TableFilterSortDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTableFilterSort]'
                    },] }
        ];
        /** @nocollapse */
        TableFilterSortDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [TableComponent,] }] }
            ];
        };
        return TableFilterSortDirective;
    }());

    var registerProps$1e = function () {
        register('wm-table-row-action', new Map([
            ['accessroles', PROP_STRING],
            ['action', PROP_STRING],
            ['caption', PROP_STRING],
            ['class ', __assign({ value: 'btn-secondary' }, PROP_STRING)],
            ['disabled', __assign({ value: false }, PROP_BOOLEAN)],
            ['display-name', PROP_STRING],
            ['hyperlink', PROP_STRING],
            ['iconclass', PROP_STRING],
            ['key', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['tabindex', __assign({ value: 0 }, PROP_NUMBER)],
            ['target', PROP_STRING],
            ['title', PROP_STRING],
            ['widget-type', __assign({ value: 'button' }, PROP_STRING)]
        ]));
    };

    var WIDGET_CONFIG$12 = { widgetType: 'wm-table-row-action', hostClass: '' };
    var ɵ0$n = {};
    var TableRowActionDirective = /** @class */ (function (_super) {
        __extends(TableRowActionDirective, _super);
        function TableRowActionDirective(inj, table, contexts) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$12) || this;
            _this.table = table;
            contexts[0].editRow = function (evt) { return _this.table.editRow(evt); };
            contexts[0].deleteRow = function (evt) { return _this.table.deleteRow(evt); };
            contexts[0].addNewRow = function (evt) { return _this.table.addNewRow(evt); };
            return _this;
        }
        TableRowActionDirective.prototype.getTitle = function () {
            return _.isUndefined(this.title) ? (this['display-name'] || '') : this.title;
        };
        TableRowActionDirective.prototype.populateAction = function () {
            this.buttonDef = {
                key: this.key,
                displayName: this['display-name'] || this.caption || '',
                show: this.show,
                class: this.class || '',
                iconclass: this.iconclass || '',
                title: this.getTitle(),
                action: this.action,
                accessroles: this.accessroles,
                disabled: this.disabled,
                tabindex: this.tabindex ? +this.tabindex : undefined,
                widgetType: this['widget-type'] || 'button',
                hyperlink: this.hyperlink,
                target: this.target,
                conditionalclass: this.conditionalclass || '',
                conditionalstyle: this.conditionalstyle || {}
            };
        };
        TableRowActionDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.populateAction();
            this.table.registerRowActions(this.buttonDef);
        };
        TableRowActionDirective.initializeProps = registerProps$1e();
        TableRowActionDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTableRowAction]',
                        providers: [
                            provideAsWidgetRef(TableRowActionDirective),
                            { provide: Context, useValue: ɵ0$n, multi: true }
                        ]
                    },] }
        ];
        /** @nocollapse */
        TableRowActionDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: TableComponent, decorators: [{ type: core$1.Optional }] },
                { type: Array, decorators: [{ type: core$1.Self }, { type: core$1.Inject, args: [Context,] }] }
            ];
        };
        return TableRowActionDirective;
    }(BaseComponent));

    var registerProps$1f = function () {
        register('wm-table-row', new Map([
            ['class', PROP_STRING],
            ['closeothers', __assign({ value: true }, PROP_BOOLEAN)],
            ['content', PROP_STRING],
            ['columnwidth', __assign({ value: '30px' }, PROP_STRING)],
            ['collapseicon', PROP_STRING],
            ['expandicon', PROP_STRING],
            ['height', PROP_STRING],
            ['position', __assign({ value: '0' }, PROP_STRING)]
        ]));
    };

    var WIDGET_CONFIG$13 = { widgetType: 'wm-table-row', hostClass: '' };
    var TableRowDirective = /** @class */ (function (_super) {
        __extends(TableRowDirective, _super);
        function TableRowDirective(inj, table) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$13) || this;
            _this.table = table;
            return _this;
        }
        TableRowDirective.prototype.populateConfig = function () {
            this.config = {
                closeothers: this.closeothers,
                content: this.content,
                columnwidth: this.columnwidth,
                expandicon: this.expandicon,
                collapseicon: this.collapseicon,
                height: this.height,
                position: this.position
            };
        };
        TableRowDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.populateConfig();
            this.table.registerRow(this.config, this);
        };
        TableRowDirective.prototype.onPropertyChange = function (key, nv) {
            if (key === 'content' && this.config) {
                this.config.content = this.content;
            }
        };
        TableRowDirective.initializeProps = registerProps$1f();
        TableRowDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTableRow]',
                        providers: [
                            provideAsWidgetRef(TableRowDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        TableRowDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: TableComponent, decorators: [{ type: core$1.Optional }, { type: core$1.SkipSelf }] }
            ];
        };
        return TableRowDirective;
    }(BaseComponent));

    var WIDGET_CONFIG$14 = {
        widgetType: 'wm-textarea',
        hostClass: 'app-input-wrapper'
    };
    var TextareaComponent = /** @class */ (function (_super) {
        __extends(TextareaComponent, _super);
        function TextareaComponent(inj) {
            return _super.call(this, inj, WIDGET_CONFIG$14) || this;
        }
        TextareaComponent.initializeProps = registerProps$L();
        TextareaComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'wm-textarea',
                        template: "<textarea class=\"form-control app-textarea\"\n          focus-target\n          role=\"input\"\n          [attr.name]=\"name\"\n          [(ngModel)]=\"datavalue\"\n          [ngModelOptions]=\"ngModelOptions\"\n          [readonly]=\"readonly\"\n          [required]=\"required\"\n          [disabled]=\"disabled\"\n          [maxlength]=\"maxchars\"\n          [attr.tabindex]=\"tabindex\"\n          [attr.placeholder]=\"placeholder\"\n          [attr.accesskey]=\"shortcutkey\"\n          [autofocus]=\"autofocus\"\n          (blur)=\"handleBlur($event)\"\n          (ngModelChange)=\"handleChange($event)\"\n          #textarea\n></textarea>",
                        providers: [
                            provideAsNgValueAccessor(TextareaComponent),
                            provideAsWidgetRef(TextareaComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        TextareaComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        TextareaComponent.propDecorators = {
            inputEl: [{ type: core$1.ViewChild, args: ['textarea',] }],
            ngModel: [{ type: core$1.ViewChild, args: [forms.NgModel,] }]
        };
        return TextareaComponent;
    }(BaseInput));

    var TextContentDirective = /** @class */ (function () {
        function TextContentDirective(elRef) {
            this.elRef = elRef;
        }
        Object.defineProperty(TextContentDirective.prototype, "textContent", {
            set: function (nv) {
                var v = nv;
                if (nv === undefined || nv === null) {
                    v = '';
                }
                this.elRef.nativeElement.textContent = v;
            },
            enumerable: true,
            configurable: true
        });
        TextContentDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[textContent]'
                    },] }
        ];
        /** @nocollapse */
        TextContentDirective.ctorParameters = function () {
            return [
                { type: core$1.ElementRef }
            ];
        };
        TextContentDirective.propDecorators = {
            textContent: [{ type: core$1.Input }]
        };
        return TextContentDirective;
    }());

    var registerProps$1g = function () {
        register('wm-tile', new Map([
            ['class', PROP_STRING],
            ['conditionalclass', PROP_ANY],
            ['conditionalstyle', PROP_ANY],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)]
        ]));
    };

    var DEFAULT_CLS$R = 'app-tile';
    var WIDGET_CONFIG$15 = { widgetType: 'wm-tile', hostClass: DEFAULT_CLS$R };
    var TileDirective = /** @class */ (function (_super) {
        __extends(TileDirective, _super);
        function TileDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$15) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.CONTAINER);
            return _this;
        }
        TileDirective.initializeProps = registerProps$1g();
        TileDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTile]',
                        providers: [
                            provideAsWidgetRef(TileDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        TileDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return TileDirective;
    }(StylableComponent));

    var CURRENT_TIME = 'CURRENT_TIME';
    var DEFAULT_CLS$S = 'input-group app-timeinput';
    var WIDGET_CONFIG$16 = { widgetType: 'wm-time', hostClass: DEFAULT_CLS$S };
    var TimeComponent = /** @class */ (function (_super) {
        __extends(TimeComponent, _super);
        function TimeComponent(inj, ngZone, appDefaults, evtMngrPlugins) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$16) || this;
            _this.ngZone = ngZone;
            _this.appDefaults = appDefaults;
            /**
             * This is an internal property used to toggle the timepicker dropdown
             */
            _this.status = { isopen: false };
            // KeyEventsPlugin
            _this.keyEventPlugin = evtMngrPlugins[1];
            styler(_this.nativeElement, _this);
            /**
             * Destroy the timer once the date widget is gone
             */
            _this.registerDestroyListener(function () { return _this.clearTimeInterval(); });
            _this.timepattern = _this.appDefaults.timeFormat || core.getDisplayDateTimeFormat(core.FormWidgetType.TIME);
            _this.updateFormat('timepattern');
            return _this;
        }
        Object.defineProperty(TimeComponent.prototype, "timestamp", {
            get: function () {
                return this.bsTimeValue ? this.bsTimeValue.valueOf() : undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeComponent.prototype, "datavalue", {
            get: function () {
                if (this.isCurrentTime && !this.bsTimeValue) {
                    return CURRENT_TIME;
                }
                return core.getFormattedDate(this.datePipe, this.bsTimeValue, this.outputformat) || '';
            },
            /**Todo[Shubham]: needs to be redefined
             * This property sets the default value for the time selection
             */
            set: function (newVal) {
                if (newVal) {
                    if (newVal === CURRENT_TIME) {
                        this.isCurrentTime = true;
                        this.setTimeInterval();
                    }
                    else {
                        this.clearTimeInterval();
                        this.bsTimeValue = core.getNativeDateObject(newVal);
                        this.isCurrentTime = false;
                    }
                }
                else {
                    this.bsTimeValue = undefined;
                    this.clearTimeInterval();
                    this.isCurrentTime = false;
                }
                this.invokeOnChange(this.datavalue);
                core.$appDigest();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeComponent.prototype, "displayValue", {
            get: function () {
                return core.getFormattedDate(this.datePipe, this.bsTimeValue, this.timepattern) || '';
            },
            enumerable: true,
            configurable: true
        });
        TimeComponent.prototype.onPropertyChange = function (key, nv, ov) {
            if (key === 'tabindex') {
                return;
            }
            if (key === 'timepattern') {
                this.updateFormat('timepattern');
            }
            if (key === 'mintime') {
                this.minTime = core.getNativeDateObject(nv); // TODO it is supposed to be time conversion, not to the day
                this.mintimeMaxtimeValidation();
            }
            else if (key === 'maxtime') {
                this.maxTime = core.getNativeDateObject(nv);
                this.mintimeMaxtimeValidation();
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        /**
         * This is an internal method used to validate mintime and maxtime
         */
        TimeComponent.prototype.mintimeMaxtimeValidation = function () {
            this.timeNotInRange = this.minTime && this.maxTime && (this.bsTimeValue < this.minTime || this.bsTimeValue > this.maxTime);
            this.invokeOnChange(this.datavalue, undefined, false);
        };
        /**
         * This is an internal method used to toggle the dropdown of the time widget
         */
        TimeComponent.prototype.toggleDropdown = function ($event) {
            var _this = this;
            if ($event.type === 'click') {
                this.invokeEventCallback('click', { $event: $event });
            }
            if ($event.target && $($event.target).is('input') && !(this.isDropDownDisplayEnabledOnInput(this.showdropdownon))) {
                return;
            }
            this.ngZone.run(function () {
                _this.status.isopen = !_this.status.isopen;
            });
            this.addBodyClickListener(this.status.isopen);
        };
        /**
         * This is an internal method used to Prevent time picker close while changing time value
         */
        TimeComponent.prototype.preventTpClose = function ($event) {
            $event.stopImmediatePropagation();
        };
        TimeComponent.prototype.addBodyClickListener = function (skipListener) {
            var _this = this;
            if (!skipListener) {
                return;
            }
            var bodyElement = document.querySelector('body');
            setTimeout(function () {
                var dropdownElement = $(bodyElement).find('>bs-dropdown-container .dropdown-menu').get(0);
                _this.deregisterEventListener = core.addEventListenerOnElement(bodyElement, dropdownElement, _this.nativeElement, 'click', _this.isDropDownDisplayEnabledOnInput(_this.showdropdownon), function () {
                    _this.status.isopen = false;
                }, 0 /* ONCE */, true);
            }, 350);
        };
        /**
         * This is an internal method triggered when pressing key on the time input
         */
        TimeComponent.prototype.onDisplayKeydown = function (event) {
            if (this.isDropDownDisplayEnabledOnInput(this.showdropdownon)) {
                event.stopPropagation();
                var action = this.keyEventPlugin.constructor.getEventFullKey(event);
                if (action === 'enter' || action === 'arrowdown') {
                    event.preventDefault();
                    this.toggleDropdown(event);
                }
                else {
                    this.hideTimepickerDropdown();
                }
            }
            else {
                this.hideTimepickerDropdown();
            }
        };
        /**
         * This is an internal method triggered when the time input changes
         */
        TimeComponent.prototype.onDisplayTimeChange = function ($event) {
            var newVal = core.getNativeDateObject($event.target.value);
            // time pattern validation
            // if invalid pattern is entered, device is showing an error.
            if (!this.formatValidation(newVal, $event.target.value)) {
                return;
            }
            this.invalidDateTimeFormat = false;
            this.onTimeChange(newVal);
        };
        TimeComponent.prototype.onInputBlur = function ($event) {
            if (!$($event.relatedTarget).hasClass('bs-timepicker-field')) {
                this.invokeOnTouched();
                this.invokeEventCallback('blur', { $event: $event });
            }
        };
        /**
         * This is an internal method used to execute the on time change functionality
         */
        TimeComponent.prototype.onTimeChange = function (newVal, isNativePicker) {
            var timeValue, timeInputValue, minTimeMeridian, maxTimeMeridian;
            // For nativePicker, newVal is event, get the dateobject from the event.
            if (isNativePicker) {
                newVal = core.getNativeDateObject(newVal.target.value);
            }
            if (newVal) {
                this.bsTimeValue = newVal;
                // if the newVal is valid but not in the given range then highlight the input field
                this.timeNotInRange = this.minTime && this.maxTime && (newVal < this.minTime || newVal > this.maxTime);
            }
            else {
                // sometimes library is not returning the correct value when the min and max time are given, displaying the datavalue based on the value given by the user
                if (this.bsTimePicker && this.bsTimePicker.min && this.bsTimePicker.max) {
                    minTimeMeridian = moment(new Date(this.bsTimePicker.min)).format('A');
                    maxTimeMeridian = moment(new Date(this.bsTimePicker.max)).format('A');
                    timeValue = this.bsTimePicker.hours + ':' + (this.bsTimePicker.minutes || 0) + ':' + (this.bsTimePicker.seconds || 0) + (this.bsTimePicker.showMeridian ? (' ' + minTimeMeridian) : '');
                    timeInputValue = core.getNativeDateObject(timeValue);
                    this.bsTimePicker.meridian = minTimeMeridian;
                    this.timeNotInRange = (this.bsTimePicker.min > timeInputValue || this.bsTimePicker.max < timeInputValue);
                }
                this.bsTimeValue = timeInputValue;
            }
            this.invokeOnTouched();
            this.invokeOnChange(this.datavalue, {}, true);
        };
        /**
         * This is an internal method used to maintain a time interval to update the time model when the data value is set to CURRENT_TIME
         */
        TimeComponent.prototype.setTimeInterval = function () {
            var _this = this;
            if (this.timeinterval) {
                return;
            }
            this.timeinterval = setInterval(function () {
                var now = new Date();
                now.setSeconds(now.getSeconds() + 1);
                _this.datavalue = CURRENT_TIME;
                _this.onTimeChange(now);
            }, 1000);
        };
        /**
         * This is an internal method used to clear the time interval created
         */
        TimeComponent.prototype.clearTimeInterval = function () {
            if (this.timeinterval) {
                clearInterval(this.timeinterval);
                this.timeinterval = null;
            }
        };
        /**
         * This function sets the value isOpen/isTimeOpen (i.e when datepicker popup is closed) based on widget type(i.e  DateTime, Time)
         * @param val - isOpen/isTimeOpen is set based on the timepicker popup is open/closed
         */
        TimeComponent.prototype.setIsTimeOpen = function (val) {
            this.status.isopen = val;
        };
        // Change event is registered from the template, Prevent the framework from registering one more event
        TimeComponent.prototype.handleEvent = function (node, eventName, eventCallback, locals) {
            if (!_.includes(['blur', 'focus', 'change', 'click'], eventName)) {
                _super.prototype.handleEvent.call(this, node, eventName, eventCallback, locals);
            }
        };
        TimeComponent.prototype.hideTimepickerDropdown = function () {
            this.invokeOnTouched();
            this.status.isopen = false;
            if (this.deregisterEventListener) {
                this.deregisterEventListener();
            }
        };
        TimeComponent.prototype.isValid = function (event) {
            if (!event) {
                var enteredDate = $(this.nativeElement).find('input').val();
                var newVal = core.getNativeDateObject(enteredDate);
                if (!this.formatValidation(newVal, enteredDate)) {
                    return;
                }
            }
        };
        /**
         * This is an internal method to add css class for dropdown while opening the time dropdown
         */
        TimeComponent.prototype.onShown = function () {
            var tpElements = document.querySelectorAll('timepicker');
            _.forEach(tpElements, function (element) {
                core.addClass(element.parentElement, 'app-datetime', true);
            });
            this.focusTimePickerPopover(this);
            this.bindTimePickerKeyboardEvents();
            core.adjustContainerPosition($('bs-dropdown-container'), this.nativeElement, this.bsDropdown._dropdown, $('bs-dropdown-container .dropdown-menu'));
        };
        TimeComponent.initializeProps = registerProps$M();
        TimeComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmTime]',
                        template: "<ng-container *ngIf=\"useDatapicker; then timePickerTemplate else nativeTimeTemplate\">\n</ng-container>\n\n<ng-template #timePickerTemplate>\n    <div dropdown [isOpen]=\"status.isopen\" (onShown)=\"onShown()\" (onHidden)=\"hideTimepickerDropdown()\" container=\"body\" style=\"display: inherit\">\n        <input class=\"form-control app-textbox display-input\" aria-label=\"Set the time\"\n               focus-target\n               [tabindex]=\"tabindex\"\n               [name]=\"name\"\n               type=\"text\"\n               [value]=\"displayValue\"\n               [disabled]=\"disabled || readonly || isCurrentTime\"\n               [autofocus]=\"autofocus\"\n               [required]=\"required\"\n               [attr.placeholder]=\"placeholder\"\n               [attr.accesskey]=\"shortcutkey\"\n               [required]=\"required\"\n               (click)=\"toggleDropdown($event)\"\n               (focus)=\"invokeOnFocus($event)\"\n               (blur)=\"onInputBlur($event)\"\n               (change)=\"onDisplayTimeChange($event)\"\n               (keydown)=\"onDisplayKeydown($event)\">\n        <span class=\"input-group-btn dropdown-toggle\">\n          <button type=\"button\" class=\"btn btn-default btn-date\" [tabindex]=\"tabindex\" [disabled]=\"disabled || readonly || isCurrentTime\" aria-label=\"Select time\" aria-haspopup=\"true\" aria-expanded=\"false\" (click)=\"toggleDropdown($event)\"><i aria-hidden=\"true\" class=\"app-icon wi wi-access-time\"></i></button>\n        </span>\n        <div *dropdownMenu class=\"dropdown-menu\" (click)=\"preventTpClose($event)\">\n            <timepicker class=\"model-holder\"\n                        [showMeridian]=\"ismeridian\"\n                        [readonlyInput]=\"isDisabled\"\n                        [(ngModel)]=\"bsTimeValue\"\n                        [disabled]=\"disabled || readonly || isCurrentTime\"\n                        [min]=\"minTime\"\n                        [max]=\"maxTime\"\n                        [hourStep]=\"hourstep\"\n                        [minuteStep]=\"minutestep\"\n                        [secondsStep]=\"secondsstep\"\n                        [mousewheel]=\"true\"\n                        [arrowkeys]=\"true\"\n                        (isValid)=\"isValid($event)\"\n                        [showSeconds]=\"showseconds\" (ngModelChange)=\"onTimeChange($event)\"></timepicker>\n        </div>\n    </div>\n</ng-template>\n<ng-template #nativeTimeTemplate>\n    <input type=\"time\" class=\"form-control app-textbox\"\n           role=\"input\"\n           [value]=\"displayValue\"\n           [required]=\"required\"\n           [disabled]=\"disabled || readonly || isCurrentTime\"\n           (change)=\"onTimeChange($event, true)\"\n           (focus)=\"invokeOnFocus($event)\"\n           (blur)=\"invokeOnTouched($event)\">\n</ng-template>\n",
                        providers: [
                            provideAsNgValueAccessor(TimeComponent),
                            provideAsNgValidators(TimeComponent),
                            provideAsWidgetRef(TimeComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        TimeComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core$1.NgZone },
                { type: core.AppDefaults },
                { type: undefined, decorators: [{ type: core$1.Inject, args: [platformBrowser.EVENT_MANAGER_PLUGINS,] }] }
            ];
        };
        TimeComponent.propDecorators = {
            bsTimePicker: [{ type: core$1.ViewChild, args: [ngxBootstrap.TimepickerComponent,] }]
        };
        return TimeComponent;
    }(BaseDateTimeComponent));

    var registerProps$1h = function () {
        register('wm-top-nav', new Map([
            ['name', PROP_STRING],
            ['content', PROP_STRING]
        ]));
    };

    var DEFAULT_CLS$T = 'app-top-nav';
    var WIDGET_CONFIG$17 = { widgetType: 'wm-top-nav', hostClass: DEFAULT_CLS$T };
    var TopNavDirective = /** @class */ (function (_super) {
        __extends(TopNavDirective, _super);
        function TopNavDirective(inj) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$17) || this;
            styler(_this.nativeElement, _this);
            return _this;
        }
        TopNavDirective.initializeProps = registerProps$1h();
        TopNavDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[wmTopNav]',
                        providers: [
                            provideAsWidgetRef(TopNavDirective)
                        ]
                    },] }
        ];
        /** @nocollapse */
        TopNavDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        return TopNavDirective;
    }(StylableComponent));

    var registerProps$1i = function () {
        register('wm-wizard', new Map([
            ['actionsalignment', __assign({ value: 'right' }, PROP_STRING)],
            ['cancelable', __assign({ value: true }, PROP_BOOLEAN)],
            ['cancelbtnlabel', __assign({ value: 'Cancel' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['defaultstep', __assign({ value: 'none' }, PROP_STRING)],
            ['donebtnlabel', __assign({ value: 'Done' }, PROP_STRING)],
            ['name', PROP_STRING],
            ['nextbtnlabel', __assign({ value: 'Next' }, PROP_STRING)],
            ['previousbtnlabel', __assign({ value: 'Previous' }, PROP_STRING)],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['stepstyle', __assign({ value: 'auto' }, PROP_STRING)]
        ]));
    };

    var registerProps$1j = function () {
        register('wm-wizardstep', new Map([
            ['class', PROP_STRING],
            ['enableskip', __assign({ value: false }, PROP_BOOLEAN)],
            ['iconclass', PROP_STRING],
            ['name', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['title', __assign({ value: 'Step Title' }, PROP_STRING)]
        ]));
    };

    var DEFAULT_CLS$U = 'app-wizard-step-content';
    var WIDGET_CONFIG$18 = {
        widgetType: 'wm-wizardstep',
        hostClass: DEFAULT_CLS$U,
    };
    var WizardStepDirective = /** @class */ (function (_super) {
        __extends(WizardStepDirective, _super);
        function WizardStepDirective(inj, ngForm) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$18) || this;
            _this.ngForm = ngForm;
            _this.status = 2 /* DISABLED */;
            return _this;
        }
        Object.defineProperty(WizardStepDirective.prototype, "isCurrent", {
            get: function () {
                return this.active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepDirective.prototype, "isValid", {
            get: function () {
                return this.ngForm.valid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepDirective.prototype, "enableNext", {
            get: function () {
                return !this.disablenext;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepDirective.prototype, "enableDone", {
            get: function () {
                return !this.disabledone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepDirective.prototype, "enablePrev", {
            get: function () {
                return !this.disableprevious;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepDirective.prototype, "active", {
            get: function () {
                return this.status === 1 /* CURRENT */;
            },
            set: function (nv) {
                var isActive = this.active;
                this.status = 1 /* CURRENT */;
                if (nv && !isActive) {
                    this.invokeEventCallback('load');
                    this.redrawChildren();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepDirective.prototype, "done", {
            get: function () {
                return this.status === 3 /* COMPLETED */;
            },
            set: function (nv) {
                if (nv) {
                    this.status = 3 /* COMPLETED */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepDirective.prototype, "disabled", {
            get: function () {
                return this.status === 2 /* DISABLED */;
            },
            set: function (nv) {
                if (nv) {
                    this.status = 2 /* DISABLED */;
                }
            },
            enumerable: true,
            configurable: true
        });
        WizardStepDirective.prototype.onNext = function (index) {
            return this.invokeEventCallback('next', { currentStep: this, stepIndex: index });
        };
        WizardStepDirective.prototype.onPrev = function (index) {
            return this.invokeEventCallback('prev', { currentStep: this, stepIndex: index });
        };
        WizardStepDirective.prototype.onSkip = function (index) {
            return this.invokeEventCallback('skip', { currentStep: this, stepIndex: index });
        };
        // redraw all the projected components which are projected.
        WizardStepDirective.prototype.redrawChildren = function () {
            var _this = this;
            setTimeout(function () {
                if (_this.reDrawableComponents) {
                    _this.reDrawableComponents.forEach(function (c) { return c.redraw(); });
                }
            }, 100);
        };
        WizardStepDirective.initializeProps = registerProps$1j();
        WizardStepDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'form[wmWizardStep]',
                        providers: [
                            provideAsWidgetRef(WizardStepDirective)
                        ],
                        exportAs: 'wmWizardStep'
                    },] }
        ];
        /** @nocollapse */
        WizardStepDirective.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: forms.NgForm, decorators: [{ type: core$1.Self }] }
            ];
        };
        WizardStepDirective.propDecorators = {
            reDrawableComponents: [{ type: core$1.ContentChildren, args: [RedrawableDirective, { descendants: true },] }],
            isCurrent: [{ type: core$1.HostBinding, args: ['class.current',] }]
        };
        return WizardStepDirective;
    }(BaseComponent));

    var DEFAULT_CLS$V = 'app-wizard panel clearfix';
    var WIDGET_CONFIG$19 = {
        widgetType: 'wm-wizard',
        hostClass: DEFAULT_CLS$V
    };
    var WizardComponent = /** @class */ (function (_super) {
        __extends(WizardComponent, _super);
        function WizardComponent(inj) {
            var _this = this;
            var resolveFn = core.noop;
            _this = _super.call(this, inj, WIDGET_CONFIG$19, new Promise(function (res) { return resolveFn = res; })) || this;
            styler(_this.nativeElement, _this, exports.APPLY_STYLES_TYPE.SHELL);
            _this.promiseResolverFn = resolveFn;
            // initialize the message object with default values
            _this.message = {
                caption: '',
                type: ''
            };
            return _this;
        }
        Object.defineProperty(WizardComponent.prototype, "hasPrevStep", {
            get: function () {
                return !this.isFirstStep(this.currentStep);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardComponent.prototype, "hasNextStep", {
            get: function () {
                return !this.isLastStep(this.currentStep);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardComponent.prototype, "showDoneBtn", {
            get: function () {
                if (!this.currentStep) {
                    return;
                }
                return !this.hasNextStep && this.currentStep.enableDone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardComponent.prototype, "enablePrev", {
            get: function () {
                if (!this.currentStep) {
                    return;
                }
                return this.currentStep.enablePrev;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardComponent.prototype, "enableNext", {
            get: function () {
                if (!this.currentStep) {
                    return;
                }
                return this.currentStep.enableNext && this.currentStep.isValid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardComponent.prototype, "enableDone", {
            get: function () {
                if (!this.currentStep) {
                    return;
                }
                return this.currentStep.enableDone && this.currentStep.isValid;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * returns next valid step. the index passed is also checked if its valid step
         * @param index
         * @returns {WizardStepDirective}
         */
        WizardComponent.prototype.getNextValidStepFormIndex = function (index) {
            for (var i = index; i < this.steps.length; i++) {
                var step = this.getStepRefByIndex(i);
                if (step.show) {
                    return step;
                }
            }
        };
        /**
         * returns previous valid step. the index passed is also checked if its valid step
         * @param index
         * @returns {WizardStepDirective}
         */
        WizardComponent.prototype.getPreviousValidStepFormIndex = function (index) {
            for (var i = index; i >= 0; i--) {
                var step = this.getStepRefByIndex(i);
                if (step.show) {
                    return step;
                }
            }
        };
        /**
         * returns current step index value.
         * @returns {number}
         */
        WizardComponent.prototype.getCurrentStepIndex = function () {
            return this.getStepIndexByRef(this.currentStep);
        };
        /**
         * returns stepRef when index is passed.
         * @param {number} index
         * @returns {WizardStepDirective}
         */
        WizardComponent.prototype.getStepRefByIndex = function (index) {
            return this.steps.toArray()[index];
        };
        /**
         * returns the index value of the step.
         * @param {WizardStepDirective} wizardStep
         * @returns {number}
         */
        WizardComponent.prototype.getStepIndexByRef = function (wizardStep) {
            return this.steps.toArray().indexOf(wizardStep);
        };
        /**
         * gets stepRef by searching on the name property.
         * @param {string} name
         * @returns {WizardStepDirective}
         */
        WizardComponent.prototype.getStepRefByName = function (name) {
            return this.steps.find(function (step) { return step.name === name; });
        };
        /**
         * sets default step as current step if configured
         * or finds first valid step and set it as current step.
         * @param {WizardStepDirective} step
         */
        WizardComponent.prototype.setDefaultStep = function (step) {
            // If the default step has show true then only update the currentStep
            if (step && step.show) {
                this.currentStep = step;
                step.active = true;
                step.isInitialized = true;
                // Mark all previous step status COMPLETED
                var index = this.getStepIndexByRef(step) - 1;
                while (index >= 0) {
                    var prevStep = this.getStepRefByIndex(index);
                    prevStep.done = true;
                    prevStep.isInitialized = true;
                    index--;
                }
            }
            else {
                // set next valid step as current step
                step = this.getNextValidStepFormIndex(0);
                if (step) {
                    this.setDefaultStep(step);
                }
            }
        };
        /**
         * Selects the associated step when the wizard header is clicked.
         * @param $event
         * @param {WizardStepDirective} currentStep
         */
        WizardComponent.prototype.onWizardHeaderClick = function ($event, currentStep) {
            var _this = this;
            // select the step if it's status is done
            if (currentStep.done) {
                // set all the next steps status as disabled and previous steps as done
                this.steps.forEach(function (step, index) {
                    if (index < _this.getStepIndexByRef(currentStep)) {
                        step.done = true;
                    }
                    else {
                        step.disabled = true;
                    }
                });
                // set the selected step as current step and make it active
                this.currentStep = currentStep;
                this.currentStep.active = true;
            }
        };
        // Method to navigate to next step
        WizardComponent.prototype.next = function (eventName) {
            if (eventName === void 0) {
                eventName = 'next';
            }
            var currentStep = this.currentStep;
            var currentStepIndex = this.getCurrentStepIndex();
            var nextStep;
            // abort if onSkip method returns false
            if (eventName === 'skip') {
                if (currentStep.onSkip(currentStepIndex) === false) {
                    return;
                }
            }
            else if (eventName === 'next') {
                if (currentStep.onNext(currentStepIndex) === false) {
                    return;
                }
            }
            nextStep = this.getNextValidStepFormIndex(currentStepIndex + 1);
            nextStep.isInitialized = true;
            // If there are any steps which has show then only change state of current step else remain same
            if (nextStep) {
                currentStep.done = true;
                nextStep.active = true;
                this.currentStep = nextStep;
            }
        };
        // Method to navigate to previous step
        WizardComponent.prototype.prev = function () {
            var currentStep = this.currentStep;
            var currentStepIndex = this.getCurrentStepIndex();
            var prevStep;
            // abort if onPrev method returns false.
            if (currentStep.onPrev(currentStepIndex) === false) {
                return;
            }
            prevStep = this.getPreviousValidStepFormIndex(currentStepIndex - 1);
            // If there are any steps which has show then only change state of current step else remain same
            if (prevStep) {
                currentStep.disabled = true;
                prevStep.active = true;
                this.currentStep = prevStep;
            }
        };
        WizardComponent.prototype.skip = function () {
            this.next('skip');
        };
        // Method to invoke on-Done event on wizard
        WizardComponent.prototype.done = function () {
            this.invokeEventCallback('done', { steps: this.steps.toArray() });
        };
        // Method to invoke on-Cancel event on wizard
        WizardComponent.prototype.cancel = function () {
            this.invokeEventCallback('cancel', { steps: this.steps.toArray() });
        };
        WizardComponent.prototype.isFirstStep = function (stepRef) {
            return this.steps.first === stepRef;
        };
        WizardComponent.prototype.isLastStep = function (stepRef) {
            return this.steps.last === stepRef;
        };
        // Define the property change handler. This Method will be triggered when there is a change in the widget property
        WizardComponent.prototype.onPropertyChange = function (key, nv, ov) {
            // Monitoring changes for properties and accordingly handling respective changes
            if (key === 'stepstyle') {
                this.stepClass = nv === 'justified' ? 'nav-justified' : '';
            }
            else if (key === 'defaultstep') {
                this.setDefaultStep(this.getStepRefByName(nv));
            }
            else {
                _super.prototype.onPropertyChange.call(this, key, nv, ov);
            }
        };
        WizardComponent.prototype.ngAfterContentInit = function () {
            _super.prototype.ngAfterContentInit.call(this);
            this.promiseResolverFn();
        };
        WizardComponent.prototype.ngAfterViewInit = function () {
            _super.prototype.ngAfterViewInit.call(this);
            styler(this.nativeElement.querySelector('.panel-body'), this, exports.APPLY_STYLES_TYPE.INNER_SHELL);
        };
        WizardComponent.initializeProps = registerProps$1i();
        WizardComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'div[wmWizard]',
                        template: "<div class=\"app-wizard-heading\" role=\"tab\">\n    <ul class=\"app-wizard-steps nav nav-pills {{stepClass}}\">\n        <li class=\"app-wizard-step\" *ngFor=\"let step of steps\" [hidden]=\"!step.show\"\n            [ngClass]=\"{active: step.done, current: step.active, disabled: step.disabled}\"\n            (click)=\"onWizardHeaderClick($event, step)\">\n            <a href=\"javascript:void(0)\" [attr.aria-label]=\"step.title\" [attr.title]=\"step.title\">\n                <span class=\"arrow\"></span>\n                <i class=\"app-icon {{step.iconclass}}\" *ngIf=\"step.iconclass\"></i>\n                <span class=\"step-title\" [textContent]=\"step.title\"></span>\n            </a>\n        </li>\n    </ul>\n</div>\n<div class=\"app-wizard-body panel-body\" role=\"tabpanel\">\n    <p wmMessage *ngIf=\"message.caption\" caption.bind=\"message.caption\" type.bind=\"message.type\"></p>\n    <ng-content select=\"form[wmWizardStep]\"></ng-content>\n</div>\n<div class=\"app-wizard-actions panel-footer {{actionsalignment}}\">\n    <a class=\"app-wizard-skip\" name=\"skipStep_{{name}}\" *ngIf=\"currentStep?.enableskip\" title=\"Skip step\" (click)=\"skip()\">Skip &raquo;</a>\n    <div class=\"app-wizard-actions-right\">\n        <button type=\"button\" name=\"cancelBtn_{{name}}\" class=\"btn app-button btn-secondary\" *ngIf=\"cancelable\"\n                (click)=\"cancel()\" [title]=\"cancelbtnlabel\" [textContent]=\"cancelbtnlabel\"></button>\n        <button type=\"button\" name=\"previousBtn_{{name}}\" class=\"btn app-button btn-secondary\"\n                *ngIf=\"hasPrevStep\" (click)=\"prev()\" [disabled]=\"!enablePrev\">\n            <i class=\"app-icon wi wi-chevron-left\"></i>\n            <span class=\"btn-caption\" [textContent]=\"previousbtnlabel\"></span>\n        </button>\n        <button type=\"button\" name=\"nextBtn_{{name}}\" class=\"btn app-button btn-primary\"\n                *ngIf=\"hasNextStep\" (click)=\"next()\" [disabled]=\"!enableNext\">\n            <span class=\"btn-caption\" [textContent]=\"nextbtnlabel\"></span>\n            <i class=\"app-icon wi wi-chevron-right\"></i>\n        </button>\n        <button type=\"button\" name=\"doneBtn_{{name}}\" class=\"btn app-button btn-success\"\n                *ngIf=\"showDoneBtn\" (click)=\"done()\"\n                [disabled]=\"!enableDone\">\n            <i class=\"app-icon wi wi-done\"></i>\n            <span class=\"btn-caption\" [textContent]=\"donebtnlabel\"></span>\n        </button>\n    </div>\n</div>\n",
                        providers: [
                            provideAsWidgetRef(WizardComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        WizardComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector }
            ];
        };
        WizardComponent.propDecorators = {
            steps: [{ type: core$1.ContentChildren, args: [WizardStepDirective,] }]
        };
        return WizardComponent;
    }(StylableComponent));

    var OnFileSelectDirective = /** @class */ (function () {
        function OnFileSelectDirective() {
        }
        OnFileSelectDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[onFileSelect]'
                    },] }
        ];
        return OnFileSelectDirective;
    }());

    var registerProps$1k = function () {
        register('wm-fileupload', new Map([
            ['caption', PROP_STRING],
            ['name', PROP_STRING],
            ['tabindex', PROP_NUMBER],
            ['multiple', PROP_BOOLEAN],
            ['fileuploadmessage', PROP_STRING],
            ['show', __assign({ value: true }, PROP_BOOLEAN)],
            ['disabled', PROP_BOOLEAN],
            ['contenttype', PROP_STRING],
            ['maxfilesize', PROP_NUMBER],
            ['iconclass', __assign({ value: 'wi wi-file-upload' }, PROP_STRING)],
            ['class', PROP_STRING],
            ['uploadpath', __assign({}, PROP_STRING)],
            ['datasource', PROP_STRING],
            ['selectedFiles', PROP_STRING],
            ['destination', PROP_STRING],
            ['filelistheight', PROP_NUMBER],
        ]));
    };

    var DEFAULT_CLS$W = 'app-fileupload';
    var WIDGET_CONFIG$1a = {
        widgetType: 'wm-fileupload',
        hostClass: DEFAULT_CLS$W
    };
    var FileUploadComponent = /** @class */ (function (_super) {
        __extends(FileUploadComponent, _super);
        function FileUploadComponent(inj, app, onSelectEvt) {
            var _this = _super.call(this, inj, WIDGET_CONFIG$1a) || this;
            _this.app = app;
            _this.onSelectEvt = onSelectEvt;
            _this.selectedFiles = [];
            _this.fileTransfers = {};
            _this.caption = 'Upload';
            _this.formName = '';
            _this.DEFAULT_CAPTIONS = {
                MULTIPLE_SELECT: 'Drop your files here.',
                SELECT: 'Select'
            };
            _this.DEVICE_CONTENTTYPES = {
                IMAGE: 'image',
                VIDEO: 'video',
                AUDIO: 'audio',
                FILES: 'files'
            };
            _this.FILESIZE_MB = 1048576;
            // parentPrefabScope = element.closest('.app-prefab').isolateScope(),
            _this.CONSTANT_FILE_SERVICE = 'FileService';
            _this.uploadData = {
                file: undefined,
                uploadPath: undefined
            };
            _this.chooseFilter = '';
            _this.fileUploadMessage = 'You can also browse for files';
            _this.uploadedFiles = {
                fileName: '',
                path: '',
                length: '',
                status: ''
            };
            _this.uploadUrl = 'services';
            return _this;
            // styler(this.nativeElement, this);
        }
        /*_hasOnSuccessEvt = WM.isDefined(attrs.onSuccess);
         _hasOnErrorEvt = WM.isDefined(attrs.onError);*/
        // Checking if the selected file is valid for the choosen filter type
        FileUploadComponent.prototype.isValidFile = function (filename, contenttype, extensionName, isMobileType) {
            var isValid, contentTypes;
            if (!contenttype) {
                return true;
            }
            contentTypes = _.toLower(contenttype).split(',');
            if (_.includes(contentTypes, 'image/*') || (_.includes(contentTypes, 'image') && isMobileType)) {
                isValid = core.isImageFile(filename);
                // If one of the content type chosen is image and user uploads image it is valid file
                if (isValid) {
                    return isValid;
                }
            }
            if (_.includes(contentTypes, 'audio/*') || (_.includes(contentTypes, 'audio') && isMobileType)) {
                isValid = core.isAudioFile(filename);
                // If one of the content type chosen is audio/* and user uploads audio it is valid file
                if (isValid) {
                    return isValid;
                }
            }
            if (_.includes(contentTypes, 'video/*') || (_.includes(contentTypes, 'video') && isMobileType)) {
                isValid = core.isVideoFile(filename);
                // If one of the content type chosen is video/* and user uploads video it is valid file
                if (isValid) {
                    return isValid;
                }
            }
            /*content type and the uploaded file extension should be same*/
            if (_.includes(contentTypes, '.' + _.toLower(extensionName))) {
                isValid = true;
            }
            return isValid;
        };
        /* this return the array of files which are having the file size not more than maxfilesize and filters based on contenttype */
        FileUploadComponent.prototype.getValidFiles = function ($files) {
            var _this = this;
            var validFiles = [];
            var errorFiles = [];
            var MAXFILEUPLOAD_SIZE = parseFloat(this.maxfilesize) * this.FILESIZE_MB || this.FILESIZE_MB;
            var MAX_FILE_UPLOAD_FORMATTED_SIZE = (this.maxfilesize || '1') + 'MB';
            // if contenttype is files for mobile projects.
            if (this.chooseFilter === this.DEVICE_CONTENTTYPES.FILES) {
                this.chooseFilter = '';
            }
            _.forEach($files, function (file) {
                /* check for the file content type before uploading */
                if (!_this.isValidFile(file.name, _this.chooseFilter, _this.getFileExtension(file.name), _this._isMobileType)) {
                    var msg = _this.appLocale.LABEL_FILE_EXTENTION_VALIDATION_MESSAGE + " " + _this.chooseFilter;
                    _this.app.notifyApp(msg, 'Error');
                    var error = {
                        key: 'INVALID_FILE_EXTENSION',
                        message: msg
                    };
                    file.error = error;
                    errorFiles.push(file);
                    return;
                }
                if (file.size > MAXFILEUPLOAD_SIZE) {
                    var msg = _this.appLocale.LABEL_FILE_EXCEED_VALIDATION_MESSAGE + " " + MAX_FILE_UPLOAD_FORMATTED_SIZE;
                    _this.app.notifyApp(msg, 'Error');
                    var error = {
                        key: 'INVALID_FILE_SIZE',
                        message: msg
                    };
                    file.error = error;
                    errorFiles.push(file);
                    return;
                }
                validFiles.push(file);
            });
            return {
                validFiles: validFiles,
                errorFiles: errorFiles
            };
        };
        /*Overwrite the caption only if they are default*/
        FileUploadComponent.prototype.getCaption = function (caption, isMultiple, isMobileType) {
            if (_.includes(this.DEFAULT_CAPTIONS, caption)) {
                return isMultiple && !isMobileType ? this.DEFAULT_CAPTIONS.MULTIPLE_SELECT : this.DEFAULT_CAPTIONS.SELECT;
            }
            return caption;
        };
        /* change server path based on user option */
        FileUploadComponent.prototype.changeServerUploadPath = function (path) {
            this.selectedUploadTypePath = path;
        };
        /* this function returns the fileextension */
        FileUploadComponent.prototype.getFileExtension = function (fileName) {
            if (fileName && _.includes(fileName, '.')) {
                return fileName.substring(fileName.lastIndexOf('.') + 1);
            }
            return 'file';
        };
        /**
         * Calls select Event
         * @param $event
         * @param $files
         */
        FileUploadComponent.prototype.onSelectEventCall = function ($event, $files) {
            var _this = this;
            this.selectedFiles = $files;
            setTimeout(function () {
                _this.invokeEventCallback('select', {
                    $event: $.extend($event.$files || {}, $files),
                    selectedFiles: $files
                });
            });
        };
        FileUploadComponent.prototype.onFileElemClick = function () {
            var fileInputElem = $('.file-input')[0];
            fileInputElem.value = null;
        };
        /*this function to append upload status dom elements to widget */
        FileUploadComponent.prototype.onFileSelect = function ($event, $files) {
            var _this = this;
            var beforeSelectVal;
            var files = this.getValidFiles($files);
            $files = files.validFiles;
            // Trigger error callback event if any invalid file found.
            if (!_.isEmpty(files.errorFiles)) {
                this.invokeEventCallback('error', {
                    $event: $event,
                    files: files.errorFiles
                });
            }
            // Make call if there are valid files else no call is made
            if ($files.length) {
                this.progressObservable = new rxjs.Subject();
                // EVENT: ON_BEFORE_SELECT
                beforeSelectVal = this.invokeEventCallback('beforeselect', {
                    $event: $.extend($event.$files || {}, $files),
                    files: $files
                });
                if (this.datasource) {
                    this.datasource._progressObservable = this.progressObservable;
                    this.datasource._progressObservable.asObservable().subscribe(function (progressObj) {
                        _.forEach(_this.selectedFiles, function (file) {
                            if (file.name === progressObj.fileName) {
                                file.progress = progressObj.progress;
                                if (file.progress === 100) {
                                    file.status = 'success';
                                }
                                else {
                                    file.status = progressObj.status;
                                }
                            }
                        });
                    });
                }
                else {
                    this.selectedFiles = $files;
                }
                if (beforeSelectVal !== false) {
                    // EVENT: ON_SELECT
                    this.onSelectEventCall($event, $files);
                }
            }
        };
        /**
         * Aborts a file upload request
         * @param $file, the file for which the request is to be aborted
         */
        FileUploadComponent.prototype.abortFileUpload = function ($file) {
            this.datasource.execute(core.DataSource.Operation.CANCEL, $file);
        };
        /* Define the property change handler. This function will be triggered when there is a change in the widget property */
        FileUploadComponent.prototype.onPropertyChange = function (key, nv, ov) {
            /*Monitoring changes for styles or properties and accordingly handling respective changes.*/
            switch (key) {
                case 'uploadpath':
                    // TODO Srinivas: why do we need uploadpath
                    this.changeServerUploadPath(nv);
                    break;
                case 'contenttype':
                    this.chooseFilter = nv.split(' ').join(',');
                    break;
                case 'multiple':
                    this.formName = this.name + (this.multiple ? '-multiple-fileupload' : '-single-fileupload');
                    this.caption = this.getCaption(this.caption, this.multiple, this._isMobileType);
                    break;
                case 'fileuploadmessage':
                    this.fileUploadMessage = nv;
            }
            _super.prototype.onPropertyChange.call(this, key, nv, ov);
        };
        FileUploadComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
        };
        FileUploadComponent.prototype.ngAfterViewInit = function () {
            styler(this.nativeElement.querySelector('.app-button, .drop-box'), this);
        };
        FileUploadComponent.initializeProps = registerProps$1k();
        FileUploadComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: '[wmFileUpload]',
                        template: "<div class=\"app-fileupload\" init-widget>\n    <!-- drag and drop files UI in web -->\n    <div class=\"app-multi-file-upload\" *ngIf=\"!_isMobileType && multiple\">\n        <div class=\"drop-box\" drag-files=\"onFileSelect($event,$event.target.files)\">\n            <i class=\"{{iconclass}}\"></i>\n            <div class=\"message\">\n                <label [innerHtml]=\"caption\" class=\"caption\"></label>\n                <form class=\"form-horizontal\" name=\"{{formName}}\">\n                    <input class=\"file-input\" aria-label=\"Select File\" type=\"file\" name=\"files\" *ngIf=\"multiple\" [disabled]=\"disabled\" [accept]=\"chooseFilter\" (click)=\"onFileElemClick()\" (change)=\"onFileSelect($event, $event.target.files)\" multiple >\n                    <a href=\"javascript:void(0);\" class=\"app-anchor\">{{fileUploadMessage}}</a>\n                </form>\n            </div>\n        </div>\n    </div>\n    <!-- single file upload in web and single , multiple file upload UI in mobile runmode -->\n    <div class=\"app-single-file-upload\" *ngIf=\"!_isCordova && (!multiple || _isMobileType)\">\n        <div class=\"app-button-wrapper\">\n            <form class=\"form-horizontal\" name=\"{{formName}}\">\n                <!-- support for file upload in Mobileapp in its runmode (Web) -->\n                <input class=\"file-input\" aria-label=\"Select files\" type=\"file\" name=\"files\" *ngIf=\"multiple\" [disabled]=\"disabled\" [accept]=\"chooseFilter\" (click)=\"onFileElemClick()\" (change)=\"onFileSelect($event, $event.target.files)\" multiple>\n                <input class=\"file-input\" aria-label=\"Select Files\" type=\"file\" name=\"files\" *ngIf=\"!multiple\" [disabled]=\"disabled\" [accept]=\"chooseFilter\" (click)=\"onFileElemClick()\" (change)=\"onFileSelect($event, $event.target.files)\" >\n                <button focus-target class=\"app-button btn btn-default\">\n                    <i class=\"{{iconclass}}\" aria-hidden=\"true\"></i>\n                    <span class=\"caption\">{{caption}}</span>\n                </button>\n            </form>\n        </div>\n        <div class=\"app-files-upload-status single\"></div>\n    </div>\n    <!-- support for file upload in Mobile Application (device) -->\n    <button *ngIf=\"_isCordova\" focus-target class=\"app-button btn btn-default\" (click)=\"openFileSelector()\" [disabled]=\"disabled\">\n        <i class=\"{{iconclass}}\"></i>\n        <span class=\"caption\">{{caption}}</span>\n    </button>\n    <!-- list of selectedfiles UI -->\n    <ul class=\"list-group file-upload\" [ngStyle]=\"{height: filelistheight, overflow: overflow}\" *ngIf=\"selectedFiles.length > 0\" >\n        <div *ngFor=\"let ft of selectedFiles\">\n            <li class=\"list-group-item file-upload-status\" *ngIf=\"ft.status !== 'abort'\">\n                <div class=\"media upload-file-list\">\n                    <div class=\"media-left media-middle file-icon {{getFileExtension(ft.name) | fileIconClass}}\" title=\"{{getFileExtension(ft.name)}}\"></div>\n                    <div class=\"media-body media-middle file-details\">\n                        <p class=\"uploaddetails\">\n                            <label class=\"upload-title\">{{ft.name}}</label><br/>\n                            <span class=\"filesize\" *ngIf=\"ft.fileLength  !== 0\">{{ft.size | filesize:0}}</span>\n                        </p>\n                        <div class=\"progress\" *ngIf=\"ft.status === 'onProgress'\">\n                            <div class=\"progress-bar progress-bar-striped progress-bar-info\" [ngStyle]=\"{width: (ft.progress +'%')}\"></div>\n                        </div>\n                    </div>\n                    <div class=\"media-right media-middle\" *ngIf=\"ft.status === 'onProgress' || ft.status === 'queued'\">\n                        <a class=\"btn btn-transparent file-upload-stop\" type=\"button\" (click)=\"abortFileUpload(ft)\">\n                            <i class=\"wi wi-close\"></i>\n                        </a>\n                    </div>\n                    <div class=\"media-right media-middle\"  *ngIf=\"ft.status === 'success'\">\n                        <span class=\"status-icon {{ft.status | stateClass }}\"></span>\n                    </div>\n                </div>\n            </li>\n        </div>\n    </ul>\n</div>\n",
                        providers: [
                            provideAsWidgetRef(FileUploadComponent)
                        ]
                    }] }
        ];
        /** @nocollapse */
        FileUploadComponent.ctorParameters = function () {
            return [
                { type: core$1.Injector },
                { type: core.App },
                { type: undefined, decorators: [{ type: core$1.Attribute, args: ['select.event',] }] }
            ];
        };
        return FileUploadComponent;
    }(StylableComponent));

    var openedDialogs = [];
    /*We need closedDialogs array because onHidden event is asynchronous,
    and if the user uses script and calls dialog1.close() and then dialog2.close() then
    we cannot be sure if both the dialogs onClose callback will be called or not.*/
    var closeDialogsArray = [];
    var DialogServiceImpl = /** @class */ (function () {
        function DialogServiceImpl() {
            /**
             * map which contains the references to all dialogs by name
             * @type {Map<any, any>}
             * Ex Map[[dialogName, [[dialogScope, dialogRef]]]]
             */
            this.dialogRefsCollection = new Map();
            this.appConfirmDialog = '_app-confirm-dialog';
        }
        /**
         * Register dialog by name and scope
         * @param {string} name
         * @param {BaseDialog} dialogRef
         * @param {scope}
         */
        DialogServiceImpl.prototype.register = function (name, dialogRef, scope) {
            if (!name) {
                return;
            }
            if (this.dialogRefsCollection.get(name)) {
                this.dialogRefsCollection.get(name).set(scope, dialogRef);
            }
            else {
                this.dialogRefsCollection.set(name, new Map([[scope, dialogRef]]));
            }
        };
        DialogServiceImpl.prototype.getDialogRefsCollection = function () {
            return this.dialogRefsCollection;
        };
        /**
         * De Register dialog by name and scope
         * @param name
         * @param dialogRef
         * @param scope
         */
        DialogServiceImpl.prototype.deRegister = function (name, scope) {
            if (!name) {
                return;
            }
            if (this.dialogRefsCollection.get(name)) {
                this.dialogRefsCollection.get(name).delete(scope);
            }
        };
        DialogServiceImpl.prototype.getDialogRef = function (name, scope) {
            var dialogRefMap = this.dialogRefsCollection.get(name);
            var dialogRef;
            if (scope) {
                dialogRef = dialogRefMap.get(scope);
                if (!dialogRef) {
                    // Check if the scope is App level scope
                    // else throw a console error
                    if (!scope.pageName && !scope.partialName && !scope.prefabName) {
                        dialogRefMap.forEach(function (dRef, dialogScope) {
                            // Check if the collection of dialogs have a "common" partial scope
                            // If yes use that else through a console error
                            if (dialogScope && dialogScope.partialName === 'Common') {
                                dialogRef = dRef;
                            }
                            else {
                                console.error('No dialog with the name "' + name + '" found in the App scope.');
                            }
                        });
                    }
                    else {
                        console.error('No dialog with the name "' + name + '" found in the given scope.');
                    }
                }
            }
            else {
                if (dialogRefMap.size === 1) {
                    dialogRef = dialogRefMap.entries().next().value[1];
                }
                else {
                    console.error('There are multiple instances of this dialog name. Please provide the Page/Partial/App instance in which the dialog exists.');
                }
            }
            return dialogRef;
        };
        /**
         * Opens the dialog with the given name
         * @param {string} name
         */
        DialogServiceImpl.prototype.open = function (name, scope, initState) {
            var dialogRef = this.getDialogRef(name, scope);
            if (!dialogRef) {
                return;
            }
            dialogRef.open(initState);
        };
        /**
         * closes the dialog with the given name
         * @param {string} name
         */
        DialogServiceImpl.prototype.close = function (name, scope) {
            var dialogRef = this.getDialogRef(name, scope);
            if (!dialogRef) {
                return;
            }
            dialogRef.close();
        };
        /**
         * closes all the opened dialogs
         */
        DialogServiceImpl.prototype.closeAllDialogs = function () {
            _.forEach(openedDialogs.reverse(), function (dialog) {
                dialog.close();
            });
        };
        DialogServiceImpl.prototype.showAppConfirmDialog = function (initState) {
            this.open(this.getAppConfirmDialog(), undefined, initState);
        };
        DialogServiceImpl.prototype.closeAppConfirmDialog = function () {
            this.close(this.getAppConfirmDialog());
        };
        DialogServiceImpl.prototype.getAppConfirmDialog = function () {
            return this.appConfirmDialog;
        };
        DialogServiceImpl.prototype.setAppConfirmDialog = function (dialogName) {
            this.appConfirmDialog = dialogName;
        };
        DialogServiceImpl.prototype.addToOpenedDialogs = function (ref) {
            openedDialogs.push(ref);
        };
        DialogServiceImpl.prototype.getLastOpenedDialog = function () {
            return openedDialogs[openedDialogs.length - 1];
        };
        DialogServiceImpl.prototype.removeFromOpenedDialogs = function (ref) {
            if (openedDialogs.indexOf(ref) !== -1) {
                openedDialogs.splice(openedDialogs.indexOf(ref), 1);
            }
        };
        DialogServiceImpl.prototype.getOpenedDialogs = function () {
            return openedDialogs;
        };
        DialogServiceImpl.prototype.addToClosedDialogs = function (ref) {
            closeDialogsArray.push(ref);
        };
        DialogServiceImpl.prototype.removeFromClosedDialogs = function (ref) {
            if (closeDialogsArray.indexOf(ref) !== -1) {
                closeDialogsArray.splice(closeDialogsArray.indexOf(ref), 1);
            }
        };
        DialogServiceImpl.prototype.getDialogRefFromClosedDialogs = function () {
            return closeDialogsArray.splice(0, 1)[0];
        };
        DialogServiceImpl.decorators = [
            { type: core$1.Injectable }
        ];
        /** @nocollapse */
        DialogServiceImpl.ctorParameters = function () { return []; };
        return DialogServiceImpl;
    }());

    var wmComponents = [
        // AccordionDirective,
        // AccordionPaneComponent,
        TabsComponent,
        TabPaneComponent,
        AlertDialogComponent,
        AnchorComponent,
        // AudioComponent,
        BreadcrumbComponent,
        ButtonComponent,
        ButtonGroupDirective,
        CalendarComponent,
        CardComponent,
        CardActionsDirective,
        CardContentComponent,
        CardFooterDirective,
        // CarouselDirective,
        // CarouselTemplateDirective,
        ChartComponent,
        CheckboxComponent,
        // ProgressCircleComponent,
        // ColorPickerComponent,
        CompositeDirective,
        ConfirmDialogComponent,
        ContainerDirective,
        ContentComponent,
        CurrencyComponent,
        CheckboxsetComponent,
        ChipsComponent,
        DateComponent,
        DatetimeComponent,
        DependsonDirective,
        DialogComponent,
        DialogBodyDirective,
        DialogFooterDirective,
        DialogHeaderComponent,
        FooterDirective,
        // LoginDialogDirective,
        FormActionDirective,
        FormComponent,
        FormFieldDirective,
        HeaderComponent,
        HtmlDirective,
        IconComponent,
        IframeComponent,
        IframeDialogComponent,
        InputCalendarComponent,
        InputColorComponent,
        InputEmailComponent,
        InputNumberComponent,
        InputTextComponent,
        FileUploadComponent,
        FormWidgetDirective,
        LabelDirective,
        LayoutGridColumnDirective,
        LayoutgridDirective,
        LayoutGridRowDirective,
        LazyLoadDirective,
        LeftPanelDirective,
        ListComponent,
        ListItemDirective,
        LiveActionsDirective,
        LiveFilterDirective,
        LiveFormDirective,
        LiveTableComponent,
        // LoginComponent,
        MarqueeDirective,
        MenuComponent,
        MenuDropdownComponent,
        MenuDropdownItemComponent,
        MessageComponent,
        NavbarComponent,
        NavComponent,
        NavItemDirective,
        NavigationControlDirective,
        NumberComponent,
        OnFileSelectDirective,
        PageContentComponent,
        PageDirective,
        PaginationComponent,
        PanelComponent,
        PartialDialogComponent,
        PartialDirective,
        PartialParamHandlerDirective,
        PartialParamDirective,
        PictureDirective,
        PopoverComponent,
        PrefabDirective,
        PrefabContainerDirective,
        // ProgressBarComponent,
        RadiosetComponent,
        // RatingComponent,
        RedrawableDirective,
        RichTextEditorComponent,
        RightPanelDirective,
        ScrollableDirective,
        SearchComponent,
        SelectComponent,
        ShowInDeviceDirective,
        // SliderComponent,
        SmoothScrollDirective,
        SpinnerComponent,
        SwitchComponent,
        TableActionDirective,
        TableColumnDirective,
        TableColumnGroupDirective,
        TableComponent,
        TableCUDDirective,
        TableFilterSortDirective,
        TableRowDirective,
        TableRowActionDirective,
        TextareaComponent,
        TextContentDirective,
        TileDirective,
        TimeComponent,
        TopNavDirective,
        // TreeDirective,
        // VideoComponent,
        WizardComponent,
        WizardStepDirective
    ];
    var PIPES = [
        ToDatePipe,
        FileIconClassPipe,
        FileExtensionFromMimePipe,
        FilterPipe,
        FileSizePipe,
        ToNumberPipe,
        ToCurrencyPipe,
        PrefixPipe,
        SuffixPipe,
        TimeFromNowPipe,
        NumberToStringPipe,
        StateClassPipe,
        StringToNumberPipe,
        TrustAsPipe,
        ImagePipe
    ];
    var bsDatePickerModule = ngxBootstrap.BsDatepickerModule.forRoot();
    var datepickerModule = ngxBootstrap.DatepickerModule.forRoot();
    var timepickerModule = ngxBootstrap.TimepickerModule.forRoot();
    var bsDropdownModule = ngxBootstrap.BsDropdownModule.forRoot();
    var paginationModule = pagination.PaginationModule.forRoot();
    var typeaheadModule = ngxBootstrap.TypeaheadModule.forRoot();
    var progressbarModule = ngxBootstrap.ProgressbarModule.forRoot();
    var carouselModule = ngxBootstrap.CarouselModule.forRoot();
    var popoverModule = ngxBootstrap.PopoverModule.forRoot();
    var ngCircleProgressModule = ngCircleProgress.NgCircleProgressModule.forRoot({});
    var WmComponentsModule = /** @class */ (function () {
        function WmComponentsModule() {
        }
        WmComponentsModule.forRoot = function () {
            return {
                ngModule: WmComponentsModule,
                providers: [
                    ToDatePipe,
                    FilterPipe,
                    TrustAsPipe,
                    ImagePipe,
                    common.Location,
                    { provide: core.AbstractDialogService, useClass: DialogServiceImpl }
                ]
            };
        };
        WmComponentsModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            ngxColorPicker.ColorPickerModule,
                            common.CommonModule,
                            forms.FormsModule,
                            ngxBootstrap.ModalModule,
                            security.SecurityModule,
                            angular2TextMask.TextMaskModule,
                            bsDatePickerModule,
                            datepickerModule,
                            timepickerModule,
                            bsDropdownModule,
                            paginationModule,
                            typeaheadModule,
                            progressbarModule,
                            carouselModule,
                            popoverModule,
                            ngCircleProgressModule
                        ],
                        declarations: __spread(wmComponents, PIPES),
                        exports: __spread(wmComponents, PIPES),
                        entryComponents: [
                            MenuComponent,
                            MenuDropdownComponent
                        ]
                    },] }
        ];
        return WmComponentsModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ɵdm = ShowInDeviceDirective;
    exports.ɵde = ImagePipe;
    exports.ɵbx = TrustAsPipe;
    exports.ɵf = AnchorComponent;
    exports.ɵbh = BaseDateTimeComponent;
    exports.ɵv = BaseFormCustomComponent;
    exports.ɵw = BaseFormComponent;
    exports.ɵbf = DatasetAwareFormComponent;
    exports.ɵi = DatasetAwareNavComponent;
    exports.ɵn = MenuAdapterComponent;
    exports.ɵdy = TextContentDirective;
    exports.ɵh = BreadcrumbComponent;
    exports.ɵk = ButtonGroupDirective;
    exports.ɵj = ButtonComponent;
    exports.ɵl = CalendarComponent;
    exports.ɵq = CardActionsDirective;
    exports.ɵr = CardContentComponent;
    exports.ɵs = CardFooterDirective;
    exports.ɵm = CardComponent;
    exports.ɵt = ChartComponent;
    exports.ɵu = CheckboxComponent;
    exports.ɵbe = CheckboxsetComponent;
    exports.ɵbg = ChipsComponent;
    exports.ɵx = CompositeDirective;
    exports.ɵz = ContainerDirective;
    exports.ɵba = ContentComponent;
    exports.ɵbb = CurrencyComponent;
    exports.ɵd = AlertDialogComponent;
    exports.ɵe = BaseDialog;
    exports.ɵbp = DialogBodyDirective;
    exports.ɵbq = DialogFooterDirective;
    exports.ɵbr = DialogHeaderComponent;
    exports.ɵy = ConfirmDialogComponent;
    exports.ɵbo = DialogComponent;
    exports.ɵca = IframeDialogComponent;
    exports.ɵcz = PartialDialogComponent;
    exports.ɵcx = OnFileSelectDirective;
    exports.ɵbs = FooterDirective;
    exports.ɵbt = FormActionDirective;
    exports.ɵbu = FormFieldDirective;
    exports.ɵcg = FormWidgetDirective;
    exports.ɵbj = FormComponent;
    exports.ɵbi = DependsonDirective;
    exports.ɵcn = LiveActionsDirective;
    exports.ɵco = LiveFilterDirective;
    exports.ɵcp = LiveFormDirective;
    exports.ɵbv = HeaderComponent;
    exports.ɵbw = HtmlDirective;
    exports.ɵby = IconComponent;
    exports.ɵbz = IframeComponent;
    exports.ɵci = LabelDirective;
    exports.ɵcj = LayoutGridColumnDirective;
    exports.ɵcl = LayoutGridRowDirective;
    exports.ɵck = LayoutgridDirective;
    exports.ɵcm = LazyLoadDirective;
    exports.ɵbn = ListItemDirective;
    exports.ɵbl = ListComponent;
    exports.ɵcq = LiveTableComponent;
    exports.ɵcr = MarqueeDirective;
    exports.ɵct = MenuDropdownItemComponent;
    exports.ɵcs = MenuDropdownComponent;
    exports.ɵo = MenuComponent;
    exports.ɵbk = MessageComponent;
    exports.ɵg = NavItemDirective;
    exports.ɵp = NavComponent;
    exports.ɵcv = NavigationControlDirective;
    exports.ɵcu = NavbarComponent;
    exports.ɵcw = NumberComponent;
    exports.ɵbm = PaginationComponent;
    exports.ɵcy = PanelComponent;
    exports.ɵdc = PartialParamDirective;
    exports.ɵdb = PartialParamHandlerDirective;
    exports.ɵda = PartialDirective;
    exports.ɵdd = PictureDirective;
    exports.ɵdf = PopoverComponent;
    exports.ɵdg = PrefabContainerDirective;
    exports.ɵdh = RadiosetComponent;
    exports.ɵc = RedrawableDirective;
    exports.ɵdi = RichTextEditorComponent;
    exports.ɵdj = RightPanelDirective;
    exports.ɵdk = ScrollableDirective;
    exports.ɵdl = SelectComponent;
    exports.ɵdn = SmoothScrollDirective;
    exports.ɵdo = SpinnerComponent;
    exports.ɵdp = SwitchComponent;
    exports.ɵdq = TableActionDirective;
    exports.ɵds = TableColumnGroupDirective;
    exports.ɵdr = TableColumnDirective;
    exports.ɵdt = TableCUDDirective;
    exports.ɵdu = TableFilterSortDirective;
    exports.ɵdw = TableRowActionDirective;
    exports.ɵdv = TableRowDirective;
    exports.ɵch = TableComponent;
    exports.ɵb = TabPaneComponent;
    exports.ɵa = TabsComponent;
    exports.ɵbd = BaseInput;
    exports.ɵcb = InputCalendarComponent;
    exports.ɵcc = InputColorComponent;
    exports.ɵcd = InputEmailComponent;
    exports.ɵbc = NumberLocale;
    exports.ɵce = InputNumberComponent;
    exports.ɵcf = InputTextComponent;
    exports.ɵdx = TextareaComponent;
    exports.ɵdz = TileDirective;
    exports.ɵea = TopNavDirective;
    exports.ɵec = WizardStepDirective;
    exports.ɵeb = WizardComponent;
    exports.bsDatePickerModule = bsDatePickerModule;
    exports.datepickerModule = datepickerModule;
    exports.timepickerModule = timepickerModule;
    exports.bsDropdownModule = bsDropdownModule;
    exports.paginationModule = paginationModule;
    exports.typeaheadModule = typeaheadModule;
    exports.progressbarModule = progressbarModule;
    exports.carouselModule = carouselModule;
    exports.popoverModule = popoverModule;
    exports.ngCircleProgressModule = ngCircleProgressModule;
    exports.WmComponentsModule = WmComponentsModule;
    exports.getObjValueByKey = getObjValueByKey;
    exports.getEvaluatedData = getEvaluatedData;
    exports.isActiveNavItem = isActiveNavItem;
    exports.getOrderByExpr = getOrderByExpr;
    exports.isDataSetWidget = isDataSetWidget;
    exports.getImageUrl = getImageUrl;
    exports.getBackGroundImageUrl = getBackGroundImageUrl;
    exports.provideAs = provideAs;
    exports.provideAsNgValidators = provideAsNgValidators;
    exports.provideAsNgValueAccessor = provideAsNgValueAccessor;
    exports.provideAsWidgetRef = provideAsWidgetRef;
    exports.provideAsDialogRef = provideAsDialogRef;
    exports.NAVIGATION_TYPE = NAVIGATION_TYPE;
    exports.getWatchIdentifier = getWatchIdentifier;
    exports.getMatchModeTypesMap = getMatchModeTypesMap;
    exports.getMatchModeMsgs = getMatchModeMsgs;
    exports.getConditionalClasses = getConditionalClasses;
    exports.prepareFieldDefs = prepareFieldDefs;
    exports.ɵ0 = ɵ0;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;
    exports.ɵ3 = ɵ3;
    exports.BaseComponent = BaseComponent;
    exports.StylableComponent = StylableComponent;
    exports.DateComponent = DateComponent;
    exports.DatetimeComponent = DatetimeComponent;
    exports.FileUploadComponent = FileUploadComponent;
    exports.LeftPanelDirective = LeftPanelDirective;
    exports.PageDirective = PageDirective;
    exports.PrefabDirective = PrefabDirective;
    exports.PageContentComponent = PageContentComponent;
    exports.SearchComponent = SearchComponent;
    exports.TimeComponent = TimeComponent;
    exports.propNameCSSKeyMap = propNameCSSKeyMap;
    exports.isStyle = isStyle;
    exports.styler = styler;
    exports.WidgetRef = WidgetRef;
    exports.DialogRef = DialogRef;
    exports.Context = Context;
    exports.getWidgetPropsByType = getWidgetPropsByType;
    exports.register = register;
    exports.PROP_STRING = PROP_STRING;
    exports.PROP_NUMBER = PROP_NUMBER;
    exports.PROP_BOOLEAN = PROP_BOOLEAN;
    exports.PROP_ANY = PROP_ANY;
    exports.DialogServiceImpl = DialogServiceImpl;
    exports.ToDatePipe = ToDatePipe;
    exports.ToNumberPipe = ToNumberPipe;
    exports.ToCurrencyPipe = ToCurrencyPipe;
    exports.PrefixPipe = PrefixPipe;
    exports.SuffixPipe = SuffixPipe;
    exports.TimeFromNowPipe = TimeFromNowPipe;
    exports.NumberToStringPipe = NumberToStringPipe;
    exports.StringToNumberPipe = StringToNumberPipe;
    exports.FilterPipe = FilterPipe;
    exports.FileSizePipe = FileSizePipe;
    exports.FileIconClassPipe = FileIconClassPipe;
    exports.StateClassPipe = StateClassPipe;
    exports.FileExtensionFromMimePipe = FileExtensionFromMimePipe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=index.umd.js.map