import { PaginationModule } from 'ngx-bootstrap/pagination';
import { ColorPickerModule } from 'ngx-color-picker';
import { TextMaskModule } from 'angular2-text-mask';
import { NgCircleProgressModule } from 'ng-circle-progress';
import { SecurityService, SecurityModule } from '@wm/security';
import { Router } from '@angular/router';
import { __awaiter } from 'tslib';
import { mergeMap, debounceTime } from 'rxjs/operators';
import { Location, DatePipe, DecimalPipe, getLocaleNumberSymbol, NumberSymbol, CommonModule } from '@angular/common';
import { SwipeAnimation } from '@swipey';
import { EventManager, EVENT_MANAGER_PLUGINS, DomSanitizer, Title } from '@angular/platform-browser';
import { BsModalService, BsDropdownDirective, TypeaheadDirective, BsDatepickerConfig, BsDatepickerDirective, TimepickerComponent, PopoverDirective, BsDatepickerModule, BsDropdownModule, CarouselModule, DatepickerModule, ModalModule, PopoverModule, ProgressbarModule, TimepickerModule, TypeaheadModule } from 'ngx-bootstrap';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormControlName, NgModel, FormBuilder, Validators, NgForm, FormsModule } from '@angular/forms';
import { ReplaySubject, Subject, from, Observable, of } from 'rxjs';
import { $appDigest, addClass, setCSS, setCSSFromObj, encodeUrl, isValidWebURL, stringStartsWith, FormWidgetType, $parseExpr, getClonedObject, prettifyLabel, initCaps, deHyphenate, isMobileApp, isDefined, IDGenerator, $unwatch, isChangeFromWatch, isObject, resetChangeFromWatch, toBoolean, toDimension, $invokeWatchers, $parseEvent, $watch, App, removeAttr, removeClass, setAttr, switchClass, noop, appendNode, AbstractDialogService, getRouteNameFromLink, DataSource, debounce, processFilterExpBindNode, MatchMode, getFormattedDate, isEqualWithFields, findValueOf, validateAccessRoles, getUrlParams, openLink, getSessionStorageItem, isMobile, UserDefinedExecutionContext, isEmptyObject, prettifyLabels, isDataSourceEqual, isNumberType, triggerFn, toggleClass, CURRENCY_INFO, AppDefaults, AppConstants, adjustContainerPosition, isAppleProduct, addForIdAttributes, AbstractI18nService, getDateObj, getNativeDateObject, isString, addEventListenerOnElement, getDisplayDateTimeFormat, DataType, isAndroid, isNumber, getFiles, DynamicComponentRefProvider, extendProto, setProperty, isInsecureContentRequest, closePopover, getValidJSON, EventNotifier, getValidDateObject, isDateTimeType, isIos, isKitkatDevice, validateDataSourceCtx, isAudioFile, isImageFile, isVideoFile } from '@wm/core';
import { InjectionToken, forwardRef, ElementRef, Directive, Inject, Self, Attribute, Component, ContentChildren, HostBinding, Injector, TemplateRef, ViewChild, HostListener, Input, Optional, ViewEncapsulation, ChangeDetectorRef, ViewChildren, Pipe, NgZone, EventEmitter, Output, SkipSelf, ContentChild, ViewContainerRef, SecurityContext, Injectable, NgModule } from '@angular/core';

class TabsAnimator extends SwipeAnimation {
    constructor(tabs) {
        super();
        this.tabs = tabs;
        this._$el = $(this.tabs.getNativeElement()).find('>.tab-content');
        const childEls = this._$el.find('>[wmTabPane]');
        this._noOfTabs = childEls.length;
        const maxWidth = `${this._noOfTabs * 100}%`;
        addClass(this.tabs.getNativeElement(), 'has-transition');
        setCSSFromObj(this._$el[0], { maxWidth: maxWidth, width: maxWidth });
        const width = `${100 / this._noOfTabs}%`;
        for (const child of Array.from(childEls)) {
            setCSS(child, 'width', width);
        }
        this.init(this._$el);
    }
    bounds() {
        const activeTabIndex = this.tabs.getActiveTabIndex(), w = this._$el.find('>.tab-pane:first').width(), noOfTabs = this._$el.find('>.tab-pane:visible').length, centerVal = -1 * activeTabIndex * w;
        return {
            strict: false,
            lower: activeTabIndex === noOfTabs - 1 ? 0 : -w,
            center: centerVal,
            upper: activeTabIndex === 0 ? centerVal : w
        };
    }
    context() {
        return {
            'w': this._$el.width()
        };
    }
    animation() {
        return {
            'transform': 'translate3d(${{ ($D + $d)/w * 100 + \'%\'}}, 0, 0)',
            '-webkit-transform': 'translate3d(${{ ($D + $d)/w * 100 + \'%\'}}, 0, 0)'
        };
    }
    transitionTabIntoView() {
        const activeTabIndex = this.tabs.getActiveTabIndex();
        setCSS(this._$el[0], 'transform', `translate3d(${-1 * activeTabIndex / this._noOfTabs * 100}%, 0, 0)`);
    }
    onUpper() {
        this.tabs.prev();
        $appDigest();
    }
    onLower() {
        this.tabs.next();
        $appDigest();
    }
    threshold() {
        return 5;
    }
}

class WidgetRef {
}
class DialogRef {
}
const Context = new InjectionToken('Context Provider Reference');

const DATASET_WIDGETS = new Set([FormWidgetType.SELECT, FormWidgetType.CHECKBOXSET, FormWidgetType.RADIOSET,
    FormWidgetType.SWITCH, FormWidgetType.AUTOCOMPLETE, FormWidgetType.CHIPS, FormWidgetType.TYPEAHEAD, FormWidgetType.RATING]);
/**
 * Returns the parsed, updated bound expression
 * if the expression is $[data[$i][firstName]] + '--' + $[lastName] + '--' + $['@ID@']
 * returns __1.firstName + '--' + lastName + '--' + __1['@ID@']
 */
const getUpdatedExpr = (expr) => {
    let updated = '', ch, next, i, j, matchCh, matchCount, isQuotedStr, subStr, isQuotedStrEvaluated;
    expr = expr.replace(/\$\[data\[\$i\]/g, '$[__1');
    for (i = 0; i < expr.length; i++) {
        ch = expr[i];
        next = expr[i + 1];
        /**
         * if the expression starts with $[, check the next(ch) character,
         *    if ch is a quote(', ") change the expr to __[
         *    if ch is a whiteSpace, remove it
         *    else remove $[
         */
        if (ch === '$' && next === '[') {
            matchCount = 1;
            isQuotedStrEvaluated = false;
            isQuotedStr = false;
            for (j = i + 2; j < expr.length; j++) {
                matchCh = expr[j];
                if (matchCh === ' ') {
                    continue;
                }
                if (!isQuotedStrEvaluated) {
                    isQuotedStr = expr[j] === '"' || expr[j] === '\'';
                    isQuotedStrEvaluated = true;
                }
                if (matchCh === '[') {
                    matchCount++;
                }
                else if (matchCh === ']') {
                    matchCount--;
                }
                if (!matchCount) {
                    subStr = expr.substring(i + 2, j);
                    if (isQuotedStr) {
                        updated += '__1[' + subStr + ']';
                    }
                    else {
                        updated += subStr;
                    }
                    break;
                }
            }
            i = j;
        }
        else {
            updated += ch;
        }
    }
    return updated;
};
const ɵ0 = getUpdatedExpr;
/**
 * Returns the value for the provided key in the object
 */
const getObjValueByKey = (obj, strKey) => {
    /* check for the key-string */
    if (strKey) {
        let val;
        /* convert indexes to properties, so as to work for even 'key1[0].child1'*/
        strKey.replace(/\[(\w+)\]/g, '.$1').split('.').forEach(key => {
            // If obj is null, then assign val to null.
            val = (val && val[key]) || (_.isNull(obj) ? obj : obj[key]);
        });
        return val;
    }
    return obj;
};
/**
 * returns the display field data for any dataset widgets
 * Based on the bind display expression or display expression or display name,
 * data is extracted and formatted from the passed option object
 * If there is field is specified, field value is obtained from the dataObj.
 * If expression is given, evaluates the expression value.
 * else check for bindExpression, extract the value from the dataObj
 */
const getEvaluatedData = (dataObj, options, context) => {
    let expressionValue;
    const field = options.field, expr = options.expression, bindExpr = options.bindExpression;
    // if key is bound expression
    if (bindExpr) {
        // remove 'bind:' prefix from the boundExpressionName
        expressionValue = bindExpr.replace('bind:', '');
        // parse the expressionValue for replacing all the expressions with values in the object
        expressionValue = getUpdatedExpr(expressionValue);
    }
    else {
        expressionValue = expr ? expr : field;
    }
    // Handling field name with special charecters
    // Ex: field = "f name"
    if (!bindExpr && !expr) {
        return _.get(dataObj, field);
    }
    return $parseExpr(expressionValue)(context, Object.assign({}, dataObj, { __1: dataObj }));
};
const isActiveNavItem = (link, routeName) => {
    if (!link || !routeName) {
        return false;
    }
    routeName = routeName.indexOf('?') === -1 ? routeName : routeName.substring(0, routeName.indexOf('?'));
    link = link.indexOf('?') === -1 ? link : link.substring(0, link.indexOf('?'));
    const routeRegex = new RegExp('^(#\/|#)' + routeName + '$');
    return routeRegex.test(link);
};
/**
 * Returns the orderBy Expression based on the 'sort 'option in pageable object
 * returned by backend
 * @param pageableObj
 * @returns {string}
 */
const getOrderByExpr = pageableObj => {
    pageableObj = pageableObj || [];
    const expressions = [], KEY_VAL_SEPARATOR = ' ', FIELD_SEPARATOR = ',';
    _.forEach(pageableObj, obj => {
        expressions.push(obj.property + KEY_VAL_SEPARATOR + obj.direction.toLowerCase());
    });
    return _.join(expressions, FIELD_SEPARATOR);
};
const isDataSetWidget = widget => {
    return DATASET_WIDGETS.has(widget);
};
/*This function returns the url to the image after checking the validity of url*/
const getImageUrl = (urlString, shouldEncode, defaultUrl) => {
    /*In studio mode before setting picturesource, check if the studioController is loaded and new picturesource is in 'styles/images/' path or not.
     * When page is refreshed, loader.gif will be loaded first and it will be in 'style/images/'.
     * Prepend 'services/projects/' + $rootScope.project.id + '/web/resources/images/imagelists/'  if the image url is just image name in the project root,
     * and if the url pointing to resources/images/ then 'services/projects/' + $rootScope.project.id + '/web/'*/
    if (isValidWebURL(urlString)) {
        return urlString;
    }
    // If no value is provided for picturesource assign pictureplaceholder or default-image
    if (!urlString) {
        urlString = defaultUrl || 'resources/images/imagelists/default-image.png';
    }
    urlString = shouldEncode ? encodeUrl(urlString) : urlString;
    // if the resource to be loaded is inside a prefab
    if (stringStartsWith(urlString, 'services/prefabs')) {
        return urlString;
    }
    return urlString;
};
/*This method returns the url to the backgroundImage*/
const getBackGroundImageUrl = (urlString) => {
    if (urlString === '' || urlString === 'none') {
        return urlString;
    }
    return 'url(' + getImageUrl(urlString) + ')';
};
function provideAs(reference, key, multi) {
    return {
        provide: key,
        useExisting: forwardRef(() => reference),
        multi: multi
    };
}
function provideAsNgValidators(reference) {
    return provideAs(reference, NG_VALIDATORS, true);
}
function provideAsNgValueAccessor(reference) {
    return provideAs(reference, NG_VALUE_ACCESSOR, true);
}
function provideAsWidgetRef(reference) {
    return provideAs(reference, WidgetRef);
}
function provideAsDialogRef(reference) {
    return provideAs(reference, DialogRef);
}
const NAVIGATION_TYPE = {
    ADVANCED: 'Advanced',
    BASIC: 'Basic',
    CLASSIC: 'Classic',
    INLINE: 'Inline',
    NONE: 'None',
    ONDEMAND: 'On-Demand',
    PAGER: 'Pager',
    SCROLL: 'Scroll'
};
const getWatchIdentifier = (...args) => args.join('_');
const typesMap = {
    number: ['number', 'integer', 'big_integer', 'short', 'float', 'big_decimal', 'double', 'long', 'byte'],
    string: ['string', 'text'],
    character: ['character'],
    date: ['date', 'time', 'timestamp', 'datetime']
};
const modes = {
    number: ['exact', 'notequals', 'lessthan', 'lessthanequal', 'greaterthan', 'greaterthanequal', 'null', 'isnotnull'],
    string: ['anywhereignorecase', 'anywhere', 'startignorecase', 'start', 'endignorecase', 'end', 'exactignorecase', 'exact', 'notequalsignorecase', 'notequals', 'null', 'isnotnull', 'empty', 'isnotempty', 'nullorempty'],
    character: ['exactignorecase', 'exact', 'notequalsignorecase', 'notequals', 'null', 'isnotnull', 'empty', 'isnotempty', 'nullorempty'],
    date: ['exact', 'lessthan', 'lessthanequal', 'greaterthan', 'greaterthanequal', 'null', 'notequals', 'isnotnull']
};
const matchModeTypesMap = {
    boolean: ['exact', 'null', 'isnotnull'],
    clob: [],
    blob: []
};
const getMatchModeTypesMap = (multiMode) => {
    if (multiMode) {
        modes.number.push('in', 'notin', 'between');
        modes.date.push('between');
        modes.string.push('in', 'notin');
        modes.character.push('in', 'notin');
    }
    _.forEach(typesMap, (types, primType) => {
        _.forEach(types, type => {
            matchModeTypesMap[type] = modes[primType];
        });
    });
    // this is used in filter criteria when the user types the column name manually and where we dont know the type of the column
    matchModeTypesMap['default'] = _.union(modes['number'], modes['string'], modes['character'], modes['date'], modes['date']);
    return matchModeTypesMap;
};
const getMatchModeMsgs = (appLocale) => {
    return {
        start: appLocale.LABEL_STARTS_WITH,
        startignorecase: appLocale.LABEL_STARTS_WITH_IGNORECASE,
        end: appLocale.LABEL_ENDS_WITH,
        endignorecase: appLocale.LABEL_ENDS_WITH_IGNORECASE,
        anywhere: appLocale.LABEL_CONTAINS,
        anywhereignorecase: appLocale.LABEL_CONTAINS_IGNORECASE,
        exact: appLocale.LABEL_IS_EQUAL_TO,
        exactignorecase: appLocale.LABEL_IS_EQUAL_TO_IGNORECASE,
        notequals: appLocale.LABEL_IS_NOT_EQUAL_TO,
        notequalsignorecase: appLocale.LABEL_IS_NOT_EQUAL_TO_IGNORECASE,
        lessthan: appLocale.LABEL_LESS_THAN,
        lessthanequal: appLocale.LABEL_LESS_THAN_OR_EQUALS_TO,
        greaterthan: appLocale.LABEL_GREATER_THAN,
        greaterthanequal: appLocale.LABEL_GREATER_THAN_OR_EQUALS_TO,
        null: appLocale.LABEL_IS_NULL,
        isnotnull: appLocale.LABEL_IS_NOT_NULL,
        empty: appLocale.LABEL_IS_EMPTY,
        isnotempty: appLocale.LABEL_IS_NOT_EMPTY,
        nullorempty: appLocale.LABEL_IS_NULL_OR_EMPTY,
        in: appLocale.LABEL_IN,
        notin: appLocale.LABEL_NOT_IN,
        between: appLocale.LABEL_BETWEEN
    };
};
// Returns array of classes that are evaluated true for given object or array
const getClassesArray = classVal => {
    let classes = [];
    if (_.isArray(classVal)) {
        classVal.forEach(v => {
            classes = classes.concat(getClassesArray(v));
        });
        return classes;
    }
    if (_.isObject(classVal)) {
        _.forEach(classVal, (val, key) => {
            if (val) {
                classes = classes.concat(key.split(' '));
            }
        });
        return classes;
    }
};
const ɵ1 = getClassesArray;
const getConditionalClasses = (nv, ov) => {
    let toAdd;
    let toRemove;
    // if the conditional class property has already toAdd and toRemove arrays then take that otherwise build those arrays
    const classToAdd = nv.toAdd || nv;
    const classToRemove = nv.toRemove || ov;
    if (_.isObject(nv)) {
        toAdd = _.isArray(classToAdd) ? classToAdd : getClassesArray(classToAdd || []);
        toRemove = classToRemove ? (_.isArray(classToRemove) ? classToRemove : getClassesArray(classToRemove)) : [];
    }
    else {
        toAdd = classToAdd ? [classToAdd] : [];
        toRemove = classToRemove ? [classToRemove] : [];
    }
    return { toAdd, toRemove };
};
/*helper function for prepareFieldDefs*/
const pushFieldDef = (dataObject, columnDefObj, namePrefix, options) => {
    /*loop over the fields in the dataObject to process them*/
    let modifiedTitle, relatedTable, relatedField, relatedInfo, fieldName, isRelated;
    if (!options) {
        options = {};
    }
    _.forEach(dataObject, (value, title) => {
        if (_.includes(title, '.')) {
            relatedInfo = _.split(title, '.');
            relatedTable = relatedInfo[0];
            relatedField = relatedInfo[1];
            isRelated = true;
        }
        if (options.noModifyTitle) {
            modifiedTitle = title;
        }
        else {
            if (_.isString(title)) {
                modifiedTitle = prettifyLabel(title);
                modifiedTitle = deHyphenate(modifiedTitle);
                modifiedTitle = namePrefix ? initCaps(namePrefix) + ' ' + modifiedTitle : modifiedTitle;
            }
            else {
                modifiedTitle = title;
            }
        }
        title = namePrefix ? namePrefix + '.' + title : title;
        if (isRelated) {
            // For related columns, shorten the title to last two words
            fieldName = _.split(modifiedTitle, ' ');
            fieldName = fieldName.length > 1 ? fieldName[fieldName.length - 2] + ' ' + fieldName[fieldName.length - 1] : fieldName[0];
        }
        else {
            fieldName = modifiedTitle;
        }
        const defObj = options.setBindingField ? { 'displayName': fieldName, 'field': title, 'relatedTable': relatedTable, 'relatedField': relatedField || modifiedTitle }
            : { 'displayName': fieldName, 'relatedTable': relatedTable, 'relatedField': relatedField || modifiedTitle };
        /*if field is a leaf node, push it in the columnDefs*/
        if (!_.isObject(value) || (_.isArray(value) && !value[0])) {
            /*if the column counter has reached upperBound return*/
            if (options.upperBound && options.columnCount === options.upperBound) {
                return;
            }
            columnDefObj.terminals.push(defObj);
            /*increment the column counter*/
            options.columnCount += 1;
        }
        else {
            /*else field is an object, process it recursively*/
            /* if parent node to be included, include it */
            if (options.columnCount !== options.upperBound) {
                columnDefObj.objects.push(defObj);
            }
            /* if field is an array node, process its first child */
            if (_.isArray(value) && value[0]) {
                pushFieldDef(value[0], columnDefObj, title + '[0]', options);
            }
            else {
                pushFieldDef(value, columnDefObj, title, options);
            }
        }
    });
};
const ɵ2 = pushFieldDef;
const getMetaDataFromData = (data) => {
    let dataObject;
    if (_.isArray(data)) {
        if (_.isObject(data[0])) {
            dataObject = getClonedObject(data[0]);
            /*Loop over the object to find out any null values. If any null values are present in the first row, check and assign the values from other row.
             * As column generation is dependent on data, for related fields if first row value is null, columns are not generated.
             * To prevent this, check the data in other rows and generate the columns. New keys from others rows are also added*/
            _.forEach(data, (row, index) => {
                if ((index + 1) >= 10) { // Limit the data search to first 10 records
                    return false;
                }
                _.assignWith(dataObject, row, (objValue, srcValue) => {
                    return (objValue === null || objValue === undefined) ? srcValue : objValue;
                });
            });
        }
        else {
            dataObject = data[0];
        }
    }
    else {
        dataObject = data;
    }
    return dataObject;
};
const ɵ3 = getMetaDataFromData;
const prepareFieldDefs = (data, options) => {
    let dataObject;
    const columnDef = {
        'objects': [],
        'terminals': []
    };
    /*if no data provided, initialize default column definitions*/
    if (!data) {
        data = [];
    }
    if (!options) {
        options = {};
    }
    options.setBindingField = true;
    options.columnCount = 0;
    dataObject = getMetaDataFromData(data);
    /*first of the many data objects from grid data*/
    pushFieldDef(dataObject, columnDef, '', options);
    if (!options || (options && !options.filter)) {
        return columnDef.terminals;
    }
    switch (options.filter) {
        case 'all':
            return columnDef;
        case 'objects':
            return columnDef.objects;
        case 'terminals':
            return columnDef.terminals;
    }
    return columnDef;
};

var APPLY_STYLES_TYPE;
(function (APPLY_STYLES_TYPE) {
    APPLY_STYLES_TYPE[APPLY_STYLES_TYPE["CONTAINER"] = 0] = "CONTAINER";
    APPLY_STYLES_TYPE[APPLY_STYLES_TYPE["SCROLLABLE_CONTAINER"] = 1] = "SCROLLABLE_CONTAINER";
    APPLY_STYLES_TYPE[APPLY_STYLES_TYPE["INNER_SHELL"] = 2] = "INNER_SHELL";
    APPLY_STYLES_TYPE[APPLY_STYLES_TYPE["SHELL"] = 3] = "SHELL";
})(APPLY_STYLES_TYPE || (APPLY_STYLES_TYPE = {}));
const propNameCSSKeyMap = {
    'backgroundattachment': 'backgroundAttachment',
    'backgroundcolor': 'backgroundColor',
    'backgroundgradient': 'backgroundGradient',
    'backgroundimage': 'backgroundImage',
    'backgroundposition': 'backgroundPosition',
    'backgroundrepeat': 'backgroundRepeat',
    'backgroundsize': 'backgroundSize',
    'bordercolor': 'borderColor',
    'borderradius': 'borderRadius',
    'borderstyle': 'borderStyle',
    'borderwidth': 'borderWidth',
    'borderbottomwidth': 'borderBottomWidth',
    'borderleftwidth': 'borderLeftWidth',
    'borderrightwidth': 'borderRightWidth',
    'bordertopwidth': 'borderTopWidth',
    'color': 'color',
    'cursor': 'cursor',
    'display': 'display',
    'fontsize': 'fontSize',
    'fontfamily': 'fontFamily',
    'fontstyle': 'fontStyle',
    'fontunit': 'fontunit',
    'fontvariant': 'fontVariant',
    'fontweight': 'fontWeight',
    'height': 'height',
    'horizontalalign': 'textAlign',
    'lineheight': 'lineHeight',
    'margin': 'margin',
    'marginbottom': 'marginBottom',
    'marginleft': 'marginLeft',
    'marginright': 'marginRight',
    'margintop': 'marginTop',
    'opacity': 'opacity',
    'overflow': 'overflow',
    'padding': 'padding',
    'paddingbottom': 'paddingBottom',
    'paddingleft': 'paddingLeft',
    'paddingright': 'paddingRight',
    'paddingtop': 'paddingTop',
    'picturesource': 'backgroundImage',
    'textalign': 'textAlign',
    'textdecoration': 'textDecoration',
    'verticalalign': 'verticalAlign',
    'visibility': 'visibility',
    'whitespace': 'whiteSpace',
    'width': 'width',
    'wordbreak': 'wordbreak',
    'zindex': 'zIndex'
};
const isStyle = key => !!propNameCSSKeyMap[key];
const MAP_SHELL_TYPE_IGNORE_LIST = {
    height: true,
    overflow: true,
    padding: true,
    paddingbottom: true,
    paddingleft: true,
    paddingright: true,
    paddingtop: true
};
const MAP_CONTAINER_TYPE_IGNORE_LIST = {
    textalign: true
};
const MAP_SCROLLABLE_CONTAINER_TYPE_IGNORE_LIST = {
    textalign: true,
    width: true
};
function styler($node, component, type, skipList) {
    // apply init styles;
    const skipListMap = Object.create(null);
    if (skipList) {
        skipList.forEach(k => skipListMap[k] = true);
    }
    component.registerStyleChangeListener((key, nv) => {
        if (skipListMap[key]) {
            return;
        }
        // if the type is `shell` and the key is in the SHELL_TYPE_IGNORE_LIST, return
        if (type === APPLY_STYLES_TYPE.SHELL && MAP_SHELL_TYPE_IGNORE_LIST[key]) {
            return;
        }
        // if the type is `inner-shell` and the key is NOT in the SHELL_TYPE_IGNORE_LIST, return
        if (type === APPLY_STYLES_TYPE.INNER_SHELL) {
            if (!MAP_SHELL_TYPE_IGNORE_LIST[key]) {
                return;
            }
            if (key === 'height') {
                setCSS($node, 'overflow', nv ? 'auto' : '');
            }
        }
        // if the type is `container` and the key is in the CONTAINER_TYPE_IGNORE_LIST, return
        if (type === APPLY_STYLES_TYPE.CONTAINER && MAP_CONTAINER_TYPE_IGNORE_LIST[key]) {
            return;
        }
        if (type === APPLY_STYLES_TYPE.SCROLLABLE_CONTAINER) {
            if (MAP_SCROLLABLE_CONTAINER_TYPE_IGNORE_LIST[key]) {
                return;
            }
            if (key === 'height') {
                setCSS($node, 'overflow', nv ? 'auto' : '');
            }
        }
        if (key === 'fontsize' || key === 'fontunit') {
            setCSS($node, 'fontSize', component.fontsize === '' ? '' : component.fontsize + (component.fontunit || 'px'));
        }
        else if (key === 'backgroundimage') {
            setCSS($node, 'backgroundImage', component.picturesource || getBackGroundImageUrl(nv));
        }
        else if (propNameCSSKeyMap[key]) {
            setCSS($node, propNameCSSKeyMap[key], nv);
        }
    });
}

// map of widgetSubType vs WidgetProps
const widgetProps = new Map();
// returns the widgetPropsMap associated with the given identifier
const getWidgetPropsByType = (identifier) => widgetProps.get(identifier);
// register the widgetProps with the given identifier
const register = (identifier, props) => {
    widgetProps.set(identifier, props);
    window.WM_LOADED_COMPONENTS = [...window.WM_LOADED_COMPONENTS || [], identifier];
};
var PROP_TYPE;
(function (PROP_TYPE) {
    PROP_TYPE[PROP_TYPE["BOOLEAN"] = 1] = "BOOLEAN";
    PROP_TYPE[PROP_TYPE["NUMBER"] = 2] = "NUMBER";
    PROP_TYPE[PROP_TYPE["STRING"] = 3] = "STRING";
})(PROP_TYPE || (PROP_TYPE = {}));
const PROP_STRING = { type: PROP_TYPE.STRING };
const PROP_NUMBER = { type: PROP_TYPE.NUMBER };
const PROP_BOOLEAN = { type: PROP_TYPE.BOOLEAN };
const PROP_ANY = {};

const registerProps = () => {
    const props = new Map([
        ['class', PROP_STRING],
        ['defaultpaneindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['justified', PROP_BOOLEAN],
        ['tabsposition', Object.assign({ value: 'top' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['transition', PROP_STRING]
    ]);
    if (isMobileApp()) {
        props.set('transition', Object.assign({ value: 'slide' }, PROP_STRING));
    }
    register('wm-tabs', props);
};

/**
 * Widget Registry
 */
const registryById = new Map();
/**
 * Registers the Widget with the given id and name
 * Makes the Widget available with the viewParent
 * returns unRegister method
 */
const register$1 = (widget, viewParent, widgetId, name) => {
    let registered = false;
    registryById.set(widgetId, widget);
    if (name) {
        if (isDefined(viewParent.Widgets)) {
            registered = true;
            viewParent.Widgets[name] = widget;
        }
    }
    // Unregister method.
    return () => {
        registryById.delete(widgetId);
        if (registered) {
            viewParent.Widgets[name] = undefined;
        }
    };
};
/**
 * Deregisters the oldname in widgets registry and sets new name
 */
const renameWidget = (viewParent, widget, nv, ov) => {
    if (!isDefined(viewParent.Widgets)) {
        return;
    }
    if (ov) {
        viewParent.Widgets[ov] = undefined;
    }
    if (nv) {
        viewParent.Widgets[nv] = widget;
    }
};

const widgetIdGenerator = new IDGenerator('widget-id');

const EVENTS_MAP = new Map([
    // ['enterkeypress', 'keypress.enter']
    ['tap', 'click']
]);
// TODO: Implement touch events for the mobile
const DISPLAY_TYPE = {
    BLOCK: 'block',
    INLINE_BLOCK: 'inline-block',
    INLINE: 'inline'
};
// set of boolean attrs
const BOOLEAN_ATTRS = new Set([
    'readonly', 'autofocus', 'disabled', 'startchecked', 'multiple',
    'selected', 'required', 'controls', 'autoplay', 'loop', 'muted', 'show'
]);
/**
 * Returns true if the provided key is a boolean attribute
 * @param {string} key
 * @returns {boolean}
 */
const isBooleanAttr = (key) => BOOLEAN_ATTRS.has(key);
const DIMENSION_PROPS = new Set([
    'width',
    'height',
    'iconheight',
    'iconwidth',
    'popoverwidth',
    'popoverheight',
    'imagewidth',
    'imageheight'
]);
const isDimensionProp = (key) => DIMENSION_PROPS.has(key);
const DEBOUNCE_TIMES = {
    PAGINATION_DEBOUNCE_TIME: 250
};

/**
 * Returns the parsed value based on the provided type
 * if the type is PROP_TYPE.NUMBER returns a number/NaN
 * if the type is PROP_BOOLEAN returns true/false
 * else returns the same value without any type conversion
 *
 * @param {string} key
 * @param value
 * @param {PROP_TYPE} type
 * @returns {any}
 */
const parseValue = (key, value, type) => {
    if (type === PROP_TYPE.BOOLEAN) {
        return toBoolean(value, isBooleanAttr(key) && key);
    }
    if (type === PROP_TYPE.NUMBER) {
        return +value;
    }
    return value;
};
/**
 * Whenever a property on a component changes through a proxy this method will be triggered
 * If the new value is not from a watch, the existing watch on that particular property will be removed
 * This method invokes the defaultPropertyChange handler where the common widget properties like name, class are handled
 * Notifies the component about the style/property change
 */
const globalPropertyChangeHandler = (component, key, nv) => {
    const widgetId = component.widgetId;
    const ov = component[key];
    // if the change is not from the bound watch, remove the existing watch
    if (!isChangeFromWatch()) {
        $unwatch(getWatchIdentifier(widgetId, key));
    }
    resetChangeFromWatch();
    const widgetProps = getWidgetPropsByType(component.getWidgetSubType());
    const propInfo = widgetProps.get(key);
    if (propInfo) {
        const type = propInfo.type;
        if (type) {
            nv = parseValue(key, nv, type);
        }
    }
    // Set the value in the component and trigger appDigest when there is a change in the value
    if (nv !== ov || isObject(nv) || isObject(ov)) {
        if (isDimensionProp(key)) {
            nv = toDimension(nv);
        }
        else if (_.startsWith(nv, 'resources/')) {
            const ref = component;
            if (ref._parentPrefab_ === undefined) {
                ref._parentPrefab_ = component.$element.closest('[prefabname][prefabname!="__self__"]').attr('prefabname') || '';
            }
            if (ref._parentPrefab_) {
                nv = `./app/prefabs/${ref._parentPrefab_}/${nv}`;
            }
        }
        component[key] = nv;
        if (isStyle(key)) {
            component.notifyStyleChange(key, nv, ov);
        }
        else {
            if (key === 'conditionalclass') {
                nv = getConditionalClasses(nv, ov);
            }
            if (propInfo) {
                component.notifyPropertyChange(key, nv, ov);
            }
        }
        $appDigest();
    }
};

/**
 * Proxy Provider - Creates a JS proxy for the given object
 */
/**
 *  proxy handler for the components
 */
const proxyHandler = {
    set: (target, key, value) => {
        globalPropertyChangeHandler(target, key, value);
        return true;
    },
    get: (target, key) => {
        const v = target[key];
        if (_.isFunction(v)) { // bind the proper context for the methods
            return v.bind(target);
        }
        return v;
    }
};
const $RAF = window.requestAnimationFrame;
const $RAFQueue = [];
const invokeLater = fn => {
    if (!$RAFQueue.length) {
        $RAF(() => {
            $RAFQueue.forEach(f => f());
            $RAFQueue.length = 0;
        });
    }
    $RAFQueue.push(fn);
};
class WidgetProxyProvider {
    static create(instance, widgetSubType, propsByWidgetSubType) {
        // If the native Proxy is supported
        if (window.Proxy) {
            return new Proxy(instance, proxyHandler);
        }
        else {
            // If the native Proxy is not supported, IE11
            const widget = Object.create(instance);
            // bind proper context for the methods
            invokeLater(() => {
                for (const key in instance) {
                    if (_.isFunction(instance[key]) && key !== 'constructor' && key !== 'super' && !_.startsWith(key, 'ng')) {
                        instance[key] = instance[key].bind(instance);
                    }
                }
            });
            // define setters and getters for styles
            Object.keys(propNameCSSKeyMap)
                .forEach(key => {
                Object.defineProperty(widget, key, {
                    get: () => instance[key],
                    set: nv => globalPropertyChangeHandler(instance, key, nv)
                });
            });
            // define the setters and getters for Props
            if (propsByWidgetSubType) {
                propsByWidgetSubType
                    .forEach((value, key) => {
                    Object.defineProperty(widget, key, {
                        get: () => instance[key],
                        set: nv => globalPropertyChangeHandler(instance, key, nv)
                    });
                });
            }
            return widget;
        }
    }
}

// Gets list of classes to add and remove and applies on the $el
const updateClasses = (toAdd, toRemove, el) => {
    if (toRemove && toRemove.length) {
        removeClass(el, _.join(toRemove, ' '));
    }
    if (toAdd && toAdd.length) {
        addClass(el, _.join(toAdd, ' '));
    }
};
// To add and remove styles on the $el
const updateStyles = (nv, ov, el) => {
    if (ov && _.isObject(ov)) {
        const keys = Object.keys(ov || {});
        keys.forEach(function (key) {
            setCSS(el, key, '');
        });
    }
    if (nv && _.isObject(nv)) {
        setCSSFromObj(el, nv);
    }
};
class BaseComponent {
    constructor(inj, config, initPromise // Promise on which the initialization has to wait
    ) {
        this.inj = inj;
        /**
         * Style change subject and observable
         */
        this.styleChange = new ReplaySubject();
        /**
         * Property change subject and observable
         */
        this.propertyChange = new Subject();
        /**
         * On Ready State change subject and observable
         */
        this.readyState = new Subject();
        /**
         * Component destroy subject and observable
         */
        this.destroy = new Subject();
        /**
         * Map of event handler callbacks
         */
        this.eventHandlers = new Map();
        /**
         * Holds the event registration functions.
         * these functions needs to be executed after onViewInit
         */
        this.toBeSetupEventsQueue = [];
        this.__cloneable__ = false;
        this.$attrs = new Map();
        const elementRef = inj.get(ElementRef);
        this.nativeElement = elementRef.nativeElement;
        this.widgetType = config.widgetType;
        this.widgetSubType = config.widgetSubType || config.widgetType;
        this.viewParent = inj.view.component;
        this.displayType = config.displayType || DISPLAY_TYPE.BLOCK;
        this.context = inj.view.context;
        this.widget = this.createProxy();
        this.eventManager = inj.get(EventManager);
        this.nativeElement.widget = this.widget;
        this.appLocale = inj.get(App).appLocale || {};
        this.initContext();
        if (config.hostClass) {
            addClass(this.nativeElement, config.hostClass);
        }
        this.widgetId = this.generateWidgetId();
        setAttr(this.nativeElement, 'widget-id', this.widgetId, true);
        // register default property change handler and style change handler
        this.registerStyleChangeListener(this.onStyleChange, this);
        this.registerPropertyChangeListener(this.onPropertyChange, this);
        // if the initPromise is provided, wait till the promise is resolved to proceed with the widget initialization
        if (!initPromise) {
            this.initWidget();
        }
        else {
            this.delayedInit = true;
            initPromise.then(() => {
                this.initWidget();
                this.setInitProps();
            });
        }
    }
    /**
     * jQuery nativeElement reference of the component root
     */
    get $element() {
        return $(this.nativeElement);
    }
    getNativeElement() {
        return this.nativeElement;
    }
    getWidgetType() {
        return this.widgetType;
    }
    getWidgetSubType() {
        return this.widgetSubType;
    }
    getWidget() {
        return this.widget;
    }
    getViewParent() {
        return this.viewParent;
    }
    notifyStyleChange(key, nv, ov) {
        this.styleChange.next({ key, nv, ov });
    }
    notifyPropertyChange(key, nv, ov) {
        this.propertyChange.next({ key, nv, ov });
    }
    registerStyleChangeListener(fn, ctx) {
        if (ctx) {
            fn = fn.bind(ctx);
        }
        this.styleChange.subscribe(({ key, nv, ov }) => fn(key, nv, ov));
    }
    registerReadyStateListener(fn, ctx) {
        if (ctx) {
            fn = fn.bind(ctx);
        }
        if (this.readyState.isStopped) {
            fn();
            return;
        }
        this.readyState.subscribe(() => fn());
    }
    registerPropertyChangeListener(fn, ctx) {
        if (ctx) {
            fn = fn.bind(ctx);
        }
        this.propertyChange.subscribe(({ key, nv, ov }) => fn(key, nv, ov));
    }
    registerDestroyListener(fn, ctx) {
        if (ctx) {
            fn = fn.bind(ctx);
        }
        this.destroy.subscribe(() => { }, () => { }, () => fn());
    }
    getDisplayType() {
        return this.displayType;
    }
    createProxy() {
        return WidgetProxyProvider.create(this, this.widgetSubType, getWidgetPropsByType(this.widgetSubType));
    }
    initContext() {
        const context = this.inj.view.context;
        const parentContexts = this.inj.get(Context, {});
        // assign the context property accordingly
        if (this.viewParent !== context) {
            this.context = context;
        }
        else {
            this.context = {};
        }
        if (parentContexts) {
            this.context = Object.assign({}, ...parentContexts, this.context);
        }
    }
    /**
     * set the value on the proxy object ie, widget
     * setting the property on the proxy will invoke the change listeners
     * @param {string} key
     * @param value
     */
    setWidgetProperty(key, value) {
        this.widget[key] = value;
    }
    getAttr(attrName) {
        return this.$attrs.get(attrName);
    }
    /**
     * returns app instance
     * @returns {App}
     */
    getAppInstance() {
        return this.inj.get(App);
    }
    /**
     * Generates a unique id
     * Default pattern is `widget-id-${id}`
     * Components can override this method to generate a different id eg, bar-chart-1
     */
    generateWidgetId() {
        return widgetIdGenerator.nextUid();
    }
    /**
     * Handles the common functionality across the components
     * eg,
     *  1. value of the class property will be applied on the host element
     *  2. based on the value of show property component is shown/hidden
     *
     * @param {string} key
     * @param nv
     * @param ov
     */
    onPropertyChange(key, nv, ov) {
        if (key === 'show') {
            this.nativeElement.hidden = !nv;
        }
        else if (key === 'hint') {
            setAttr(this.nativeElement, 'title', nv);
        }
        else if (key === 'class') {
            switchClass(this.nativeElement, nv, ov);
        }
        else if (key === 'name' || key === 'tabindex') {
            setAttr(this.nativeElement, key, nv);
            if (key === 'name' && nv) {
                renameWidget(this.viewParent, this.widget, nv, ov);
            }
        }
        else if (key === 'conditionalclass') {
            // update classes if old and nv value are different
            updateClasses(nv.toAdd, nv.toRemove, this.nativeElement);
        }
        else if (key === 'autoplay') {
            const tagName = this.widgetType === 'wm-audio' ? 'audio' : 'video';
            // Trigger media(audio/video) element load method after changing autoplay property
            this.nativeElement.querySelector(tagName).load();
        }
        else if (key === 'conditionalstyle') {
            // update styles if old and nv value are different
            updateStyles(nv, ov, this.nativeElement);
        }
    }
    /**
     * Default style change handler
     */
    onStyleChange(k, nv, ov) { }
    /**
     * Register the widget with the widgetRegistry
     */
    registerWidget(widgetName) {
        this.registerDestroyListener(register$1(this.widget, this.viewParent, this.widgetId, widgetName));
    }
    /**
     * override the
     */
    getMappedEventName(eventName) {
        return EVENTS_MAP.get(eventName) || eventName;
    }
    /**
     * invoke the event handler
     * Components can override this method to execute custom logic before invoking the user callback
     */
    handleEvent(node, eventName, eventCallback, locals, meta) {
        this.eventManager.addEventListener(node, eventName, e => {
            locals.$event = e;
            if (meta === 'delayed') {
                setTimeout(() => eventCallback(), 150);
            }
            else {
                return eventCallback();
            }
        });
    }
    /**
     * parse the event expression and save reference to the function inside eventHandlers map
     * If the component provides a override for an event through @Event decorator invoke that
     * else invoke the resolved function
     *
     * @param {string} eventName
     * @param {string} expr
     */
    processEventAttr(eventName, expr, meta) {
        const fn = $parseEvent(expr);
        const locals = this.context;
        locals.widget = this.widget;
        const boundFn = fn.bind(undefined, this.viewParent, locals);
        const eventCallback = () => {
            let boundFnVal;
            $invokeWatchers(true);
            try {
                // If the event is bound directly to the variable then we need to internally handle
                // the promise returned by the variable call.
                boundFnVal = boundFn();
                if (boundFnVal instanceof Promise) {
                    boundFnVal.then(response => response, err => err);
                }
                else {
                    return boundFnVal;
                }
            }
            catch (e) {
                console.error(e);
            }
        };
        this.eventHandlers.set(this.getMappedEventName(eventName), { callback: eventCallback, locals });
        // prepend eventName with on and convert it to camelcase.
        // eg, "click" ---> onClick
        const onEventName = _.camelCase(`on-${eventName}`);
        // save the eventCallback in widgetScope.
        this[onEventName] = eventCallback;
        // events needs to be setup after viewInit
        this.toBeSetupEventsQueue.push(() => {
            this.handleEvent(this.nativeElement, this.getMappedEventName(eventName), eventCallback, locals, meta);
        });
    }
    /**
     * Process the bound property
     * Register a watch on the bound expression
     */
    processBindAttr(propName, expr) {
        this.initState.delete(propName);
        this.registerDestroyListener($watch(expr, this.viewParent, this.context, nv => this.widget[propName] = nv, getWatchIdentifier(this.widgetId, propName), propName === 'datasource'));
    }
    /**
     * Remove watch on the bound property
     */
    removePropertyBinding(propName) {
        $unwatch(getWatchIdentifier(this.widgetId, propName));
    }
    /**
     * invoke the event callback method
     * @param {string} eventName
     * @param extraLocals
     */
    invokeEventCallback(eventName, extraLocals) {
        const callbackInfo = this.eventHandlers.get(eventName);
        if (callbackInfo) {
            const fn = callbackInfo.callback;
            const locals = callbackInfo.locals || {};
            if (fn) {
                return fn(Object.assign(locals, extraLocals));
            }
        }
    }
    /**
     * Process the attribute
     * If the attribute is an event expression, generate a functional representation of the expression
     *      and keep in eventHandlers
     * If the attribute is a bound expression, register a watch on the expression
     */
    processAttr(attrName, attrValue) {
        const { 0: propName, 1: type, 2: meta, length } = attrName.split('.');
        if (type === 'bind') {
            // if the show property is bound, set the initial value to false
            if (propName === 'show') {
                this.nativeElement.hidden = true;
            }
            this.processBindAttr(propName, attrValue);
        }
        else if (type === 'event') {
            this.processEventAttr(propName, attrValue, meta);
        }
        else if (length === 1) {
            // remove class and name attributes. Component will set them on the proper node
            if (attrName === 'class') {
                removeClass(this.nativeElement, attrValue);
            }
            else if (attrName === 'tabindex' || attrName === 'name') {
                removeAttr(this.nativeElement, attrName);
            }
            this.initState.set(propName, attrValue);
        }
    }
    /**
     * Process the attributes
     */
    processAttrs() {
        const elDef = this.inj.elDef;
        for (const [, attrName, attrValue] of elDef.element.attrs) {
            this.$attrs.set(attrName, attrValue);
            this.processAttr(attrName, attrValue);
        }
    }
    /**
     * Update the initState with the default property values and the values provided in the markup
     * Process the attributes
     * Register the widget
     */
    initWidget() {
        this.initState = new Map();
        // get the widget properties
        const widgetProps = getWidgetPropsByType(this.widgetSubType);
        widgetProps.forEach((v, k) => {
            if (isDefined(v.value)) {
                this.initState.set(k, v.value);
            }
        });
        this.widgetProps = widgetProps;
        this.processAttrs();
        this.registerWidget(this.initState.get('name'));
    }
    /**
     * Update the default properties and the properties provided in the markup in component
     * Invoking this method will result in invocation of propertyChange handlers on the component for the first time
     */
    setInitProps() {
        if (this.initState.get('name')) {
            this.widget.name = this.initState.get('name');
        }
        this.initState.forEach((v, k) => {
            // name is already set, ignore name
            // if the key is part of to be ignored attributes list do not set it on the component instance
            if ((this.widgetProps.get(k) || isStyle(k)) && k !== 'name') {
                this.widget[k] = v;
            }
        });
        this.initState.clear();
        this.initState = undefined;
        this.readyState.next();
        this.readyState.complete();
    }
    /**
     * Returns true, if a listener registered for the given event on this widget markup.
     * @param eventName
     * @returns {boolean}
     */
    hasEventCallback(eventName) {
        return this.eventHandlers.has(eventName);
    }
    /**
     * Sets the focus on the widget
     */
    focus() {
        /**
         * Check for the nodes having focus-target attribute inside the element
         * If found, focus the first node (eg, date widget)
         * else, focus the element (eg, text widget)
         */
        let $target = this.$element[0].querySelector('[focus-target]');
        if (!$target) {
            $target = this.$element[0];
        }
        $target.focus();
    }
    // Defining the execute method on BaseComponent. If dataset is binded to widgets ouptut then datasource.execute will be defined
    execute(operation, options) {
    }
    /**
     * nativeElement will be available by this time
     * if the delayInit is false, properties meta will be available by this time
     * Invoke the setInitProps if the delayInit is false
     */
    ngOnInit() {
        if (!this.delayedInit) {
            this.setInitProps();
        }
    }
    /**
     * Register the events
     */
    ngAfterViewInit() {
        if (this.toBeSetupEventsQueue.length) {
            for (const fn of this.toBeSetupEventsQueue) {
                fn();
            }
        }
        this.toBeSetupEventsQueue.length = 0;
    }
    ngAfterContentInit() { }
    ngOnDestroy() {
        this.isDestroyed = true;
        this.widget = Object.create(null);
        this.styleChange.complete();
        this.propertyChange.complete();
        this.destroy.complete();
    }
}

class StylableComponent extends BaseComponent {
}

const registerProps$1 = () => {
    register('wm-tabpane', new Map([
        ['badgevalue', PROP_STRING],
        ['badgetype', Object.assign({ value: 'default' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['content', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['heading', PROP_STRING],
        ['isdefaulttab', PROP_STRING],
        ['name', PROP_STRING],
        ['paneicon', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['smoothscroll', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', Object.assign({ value: 'Tab Title' }, PROP_STRING)]
    ]));
};

class RedrawableDirective {
    constructor(widget) {
        this.redraw = () => widget.redraw();
    }
}
RedrawableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[redrawable]'
            },] }
];
/** @nocollapse */
RedrawableDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Self }, { type: Inject, args: [WidgetRef,] }] }
];

const DEFAULT_CLS = 'tab-pane';
const WIDGET_CONFIG = {
    widgetType: 'wm-tabpane',
    hostClass: DEFAULT_CLS
};
class TabPaneComponent extends StylableComponent {
    constructor(inj, tabsRef, heading, title) {
        super(inj, WIDGET_CONFIG);
        this.tabsRef = tabsRef;
        this.heading = heading;
        this.title = title;
        this.$lazyLoad = noop;
        this.isActive = false;
        this.disabled = false;
        // title property here serves the purpose of heading.
        // TODO: make it common for all the widget.
        removeAttr(this.nativeElement, 'title');
    }
    // parent tabs component will call this method for the order of callbacks to be proper
    // order of callbacks - deselect, select, change
    invokeOnSelectCallback($event) {
        this.invokeEventCallback('select', { $event });
    }
    select($event) {
        // When called programatically $event won't be available
        if (this.isActive || this.disabled) {
            return;
        }
        this.isActive = true;
        this.$lazyLoad();
        this.redrawChildren();
        this.notifyParent($event);
        if ($event) {
            $event.stopPropagation();
            $event.preventDefault();
        }
    }
    deselect() {
        if (this.isActive) {
            this.isActive = false;
            this.invokeEventCallback('deselect');
        }
    }
    redrawChildren() {
        setTimeout(() => {
            if (this.reDrawableComponents) {
                this.reDrawableComponents.forEach(c => c.redraw());
            }
        }, 100);
    }
    notifyParent(evt) {
        this.tabsRef.notifyChange(this, evt);
    }
    // select next valid tab
    handleSwipeLeft() {
        this.tabsRef.next();
    }
    // select prev valid tab
    handleSwipeRight() {
        this.tabsRef.prev();
    }
    // select event is called manually
    handleEvent(node, eventName, callback, locals) {
        if (eventName !== 'select') {
            super.handleEvent(this.nativeElement, eventName, callback, locals);
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'content') {
            if (this.isActive) {
                setTimeout(() => this.$lazyLoad(), 100);
            }
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngOnInit() {
        super.ngOnInit();
        this.title = this.title || this.heading;
    }
    ngAfterViewInit() {
        styler(this.nativeElement.querySelector('.tab-body'), this, APPLY_STYLES_TYPE.CONTAINER);
        super.ngAfterViewInit();
    }
}
TabPaneComponent.initializeProps = registerProps$1();
TabPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmTabPane]',
                template: "<div class=\"tab-body\" partial-container-target [wmSmoothscroll]=\"smoothscroll\">\n    <ng-content></ng-content>\n</div>",
                providers: [
                    provideAsWidgetRef(TabPaneComponent)
                ]
            }] }
];
/** @nocollapse */
TabPaneComponent.ctorParameters = () => [
    { type: Injector },
    { type: TabsComponent },
    { type: undefined, decorators: [{ type: Attribute, args: ['heading',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['title',] }] }
];
TabPaneComponent.propDecorators = {
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    disabled: [{ type: HostBinding, args: ['class.disabled',] }],
    reDrawableComponents: [{ type: ContentChildren, args: [RedrawableDirective, { descendants: true },] }]
};

const DEFAULT_CLS$1 = 'app-tabs clearfix';
const WIDGET_CONFIG$1 = {
    widgetType: 'wm-tabs',
    hostClass: DEFAULT_CLS$1
};
class TabsComponent extends StylableComponent {
    constructor(inj, _transition, _tabsPosition) {
        // handle to the promise resolver
        let resolveFn = noop;
        super(inj, WIDGET_CONFIG$1, new Promise(res => resolveFn = res));
        this.transition = _transition;
        this.tabsposition = _tabsPosition;
        this.promiseResolverFn = resolveFn;
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
    animateIn(element) {
        const tabHeader = $(element);
        // when the animation is not present toggle the active class.
        tabHeader.siblings('.active').removeClass('active');
        tabHeader.addClass('active');
        const ul = this.nativeElement.querySelector('ul.nav.nav-tabs');
        // move the tabheader into the viewport
        const $prevHeaderEle = tabHeader.prev();
        if ($prevHeaderEle.length) {
            ul.scrollLeft = $prevHeaderEle[0].offsetLeft;
        }
        else {
            ul.scrollLeft = 0;
        }
    }
    /**
     * TabPane children components invoke this method to communicate with the parent
     * if the evt argument is defined on-change callback will be invoked.
     */
    notifyChange(paneRef, evt) {
        if (!this.isSelectableTab(paneRef)) {
            return;
        }
        let headerElement;
        // invoke deselect event callback on the preset active tab
        if (this.activeTab) {
            this.activeTab.deselect();
        }
        // invoke select callback on the selected tab
        paneRef.invokeOnSelectCallback(evt);
        this.activeTab = paneRef.getWidget();
        // invoke change callback if the evt is present, select a tab programmatically will not have the event
        if (evt) {
            this.invokeEventCallback('change', {
                $event: evt,
                newPaneIndex: this.getPaneIndexByRef(paneRef),
                oldPaneIndex: this.getActiveTabIndex()
            });
        }
        if (evt) {
            headerElement = $(evt.target).closest('li.tab-header');
        }
        else {
            headerElement = this.nativeElement.querySelector(`li[data-paneid=${paneRef.widgetId}]`);
        }
        this.animateIn(headerElement);
        // this.setTabsLeftPosition(this.getPaneIndexByRef(this.activeTab), this.panes.length);
        if (this.canSlide()) {
            if (!this.tabsAnimator) {
                this.tabsAnimator = new TabsAnimator(this);
                this.tabsAnimator.setGesturesEnabled(this.canSlide());
            }
            this.tabsAnimator.transitionTabIntoView();
        }
    }
    goToTab(tabIndex) {
        if (this.isValidPaneIndex(tabIndex - 1)) {
            const tab = this.getPaneRefByIndex(tabIndex - 1);
            tab.select();
        }
    }
    getPaneIndexByRef(paneRef) {
        return this.panes.toArray().indexOf(paneRef);
    }
    // Returns the active tab index from tabs.
    getActiveTabIndex() {
        return _.findIndex(this.panes.toArray(), { isActive: true });
    }
    isValidPaneIndex(index) {
        return (index >= 0 && index < this.panes.length);
    }
    getPaneRefByIndex(index) {
        return this.panes.toArray()[index];
    }
    // returns false if the pane is hidden or disabled
    isSelectableTab(paneRef) {
        return paneRef.show && !paneRef.disabled;
    }
    canSlide() {
        return this.transition === 'slide' && !this.vertical;
    }
    getSelectableTabAfterIndex(index) {
        for (let i = index + 1; i < this.panes.length; i++) {
            const pane = this.getPaneRefByIndex(i);
            if (this.isSelectableTab(pane)) {
                return pane;
            }
        }
    }
    getSelectableTabBeforeIndex(index) {
        for (let i = index - 1; i >= 0; i--) {
            const pane = this.getPaneRefByIndex(i);
            if (this.isSelectableTab(pane)) {
                return pane;
            }
        }
    }
    // select next tab relative to the current active tab
    next() {
        const pane = this.getSelectableTabAfterIndex(this.getActiveTabIndex());
        if (pane) {
            pane.select();
        }
    }
    // select prev tab relative to the current active tab
    prev() {
        const pane = this.getSelectableTabBeforeIndex(this.getActiveTabIndex());
        if (pane) {
            pane.select();
        }
    }
    /**
     * this method will be invoked during the initialization of the component and on defaultpaneindex property change,
     * if the provided defaultpaneindex is not valid, find the first pane index which can be shown and select it
     */
    selectDefaultPaneByIndex(index) {
        if (!this.isValidPaneIndex(index)) {
            return;
        }
        let paneRef = this.getPaneRefByIndex(index);
        if (!this.isSelectableTab(paneRef)) {
            paneRef = this.getSelectableTabAfterIndex(0);
        }
        if (paneRef) {
            paneRef.select();
        }
    }
    // update the postion of tab header
    setTabsPosition() {
        const ul = this.nativeElement.children[0];
        this.vertical = (this.tabsposition === 'left' || this.tabsposition === 'right');
        removeClass(this.nativeElement, 'inverted');
        if (this.tabsposition === 'bottom' || this.tabsposition === 'right') {
            appendNode(ul, this.nativeElement);
            addClass(this.nativeElement, 'inverted');
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'defaultpaneindex') {
            // If no active tab is set ie.. no isdefaulttab then honor the defaultpaneindex
            setTimeout(() => this.selectDefaultPaneByIndex(nv || 0), 20);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    registerTabsScroll() {
        setTimeout(() => {
            const $ul = this.$element.find('> ul');
            let $liPosition;
            const $li = $ul.children();
            $liPosition = $li.last().position();
            if ($liPosition && ($liPosition.left > $ul.width())) {
                $ul.on('mousewheel', (e) => {
                    const left = $ul[0].scrollLeft, _delta = -1 * e.originalEvent.wheelDelta;
                    e.stopPropagation();
                    e.preventDefault();
                    $ul.animate({ scrollLeft: left + _delta }, { 'duration': 10 });
                });
            }
        });
    }
    ngAfterContentInit() {
        this.promiseResolverFn();
        super.ngAfterContentInit();
        this.setTabsPosition();
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.registerTabsScroll();
    }
}
TabsComponent.initializeProps = registerProps();
TabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmTabs]',
                template: "<ul class=\"nav nav-tabs\" [ngClass]=\"{'nav-stacked': vertical, 'nav-justified': justified}\" role=\"tablist\">\n    <li class=\"tab-header\" *ngFor=\"let pane of panes;\" [attr.data-paneid]=\"pane.widgetId\" [ngClass]=\"{'active': pane.isActive, 'disabled': pane.disabled}\"\n        [hidden]=\"!pane.show\" (click)=\"pane.select($event)\" role=\"tab\">\n        <a href=\"javascript:void(0);\" role=\"button\" [attr.aria-label]=\"pane.title\" [attr.title]=\"pane.title\" [tabindex]=\"pane.tabindex\">\n            <div class=\"tab-heading\">\n                <i [ngClass]=\"['app-icon', pane.paneicon]\" *ngIf=\"pane.paneicon\"></i>\n                <span [textContent]=\"pane.title\"></span>\n                <span *ngIf=\"pane.badgevalue\" class=\"label label-{{pane.badgetype}}\" [textContent]=\"pane.badgevalue\"></span>\n            </div>\n        </a>\n    </li>\n</ul>\n<div class=\"tab-content\" [ngClass]=\"{'tab-stacked': vertical, 'tab-justified': justified}\">\n    <ng-content select=\"div[wmTabPane]\"></ng-content>\n</div>\n",
                providers: [
                    provideAsWidgetRef(TabsComponent)
                ]
            }] }
];
/** @nocollapse */
TabsComponent.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Attribute, args: ['transition',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['tabsposition',] }] }
];
TabsComponent.propDecorators = {
    panes: [{ type: ContentChildren, args: [TabPaneComponent,] }]
};

const registerProps$2 = () => {
    register('wm-alertdialog', new Map([
        ['alerttype', Object.assign({ value: 'error' }, PROP_STRING)],
        ['animation', PROP_STRING],
        ['class', PROP_STRING],
        ['closable', { value: true, PROP_BOOLEAN }],
        ['iconclass', { value: 'wi wi-warning', PROP_STRING }],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['message', Object.assign({ value: 'Am an alert box!' }, PROP_STRING)],
        ['modal', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['name', PROP_STRING],
        ['oktext', Object.assign({ value: 'OK' }, PROP_STRING)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', Object.assign({ value: 'Alert' }, PROP_STRING)]
    ]));
};

let eventsRegistered = false;
const findRootContainer = ($el) => {
    let root = $el.closest('.app-prefab');
    if (!root.length) {
        root = $el.closest('.app-partial');
    }
    if (!root.length) {
        root = $el.closest('.app-page');
    }
    return root.length && root.parent()[0].tagName;
};
const invokeOpenedCallback = (ref) => {
    if (ref) {
        setTimeout(() => {
            const root = findRootContainer(ref.$element);
            // if page styles have to be applied to dialog then dialog has to be child of page element.
            if (root) {
                $('body:first > modal-container > div').wrap('<' + root + '/>');
            }
            ref.invokeEventCallback('opened', { $event: { type: 'opened' } });
        });
    }
};
const invokeClosedCallback = (ref) => {
    if (ref) {
        ref.invokeEventCallback('close');
        ref.dialogRef = undefined;
    }
};
class BaseDialog extends BaseComponent {
    constructor(inj, widgetConfig, modalOptions) {
        super(inj, widgetConfig);
        this.modalOptions = modalOptions;
        this.dialogService = inj.get(AbstractDialogService);
        this.bsModal = inj.get(BsModalService);
        // Subscribe to onShown and onHidden events only once as we will not be
        // unsubscribing to the,m ever and we will handle the logic of calling
        // respective dialog callbacks.
        if (!eventsRegistered) {
            eventsRegistered = true;
            this.bsModal.onShown.subscribe(() => {
                // Always get the reference of last pushed dialog in the array for calling onOpen callback
                invokeOpenedCallback(this.dialogService.getLastOpenedDialog());
            });
            this.bsModal.onHidden.subscribe((closeReason) => {
                const ref = closeReason === 'esc' || closeReason === 'backdrop-click' ? this.dialogService.getLastOpenedDialog() : this.dialogService.getDialogRefFromClosedDialogs();
                // remove the dialog reference from opened dialogs and closed dialogs
                this.dialogService.removeFromOpenedDialogs(ref);
                this.dialogService.removeFromClosedDialogs(ref);
                invokeClosedCallback(ref);
            });
        }
    }
    /**
     * Opens the dialog
     * Subscribe to the onShown event emitter of bsModal and trigger on-opened event callback
     */
    open(initState) {
        // remove the popovers in the page to avoid the overlap with dialog
        // closePopover(this.$element); Commenting this line because it is causing regression(if we have dialog inside popover as partail content, then the dialog close is not working because on closing the popover the partial get destroyed.)
        // do not open the dialog again if it is already opened
        const duplicateDialogCheck = (openedDialog) => {
            return openedDialog === this;
        };
        if (this.dialogService.getOpenedDialogs().some(duplicateDialogCheck)) {
            return;
        }
        this.dialogService.addToOpenedDialogs(this);
        // extend the context with the initState
        Object.assign(this.context, initState);
        this.dialogRef = this.bsModal.show(this.getTemplateRef(), this.modalOptions);
    }
    /**
     * closes the dialog
     * invokes the on-close event callback
     */
    close() {
        // remove the popovers in the page to avoid the overlap with dialog
        // closePopover(this.$element); Commenting this line because it is causing regression(if we have dialog inside popover as partail content, then the dialog close is not working because on closing the popover the partial get destroyed.)
        if (this.dialogRef) {
            this.dialogService.addToClosedDialogs(this);
            this.dialogRef.hide();
        }
    }
    /**
     * Register the dialog with the dialog service for programmatic access
     */
    register(scope) {
        // add scope along with name in the dialogRefsCollection Map while registering dialog
        // So that 2 dialogs having same name on different pages won't be overridden.
        this.dialogService.register(this.name, this, scope);
    }
    /**
     * De Register the dialog with the dialog service after dialog destruction
     */
    deRegister(scope) {
        this.dialogService.deRegister(this.name, scope);
    }
    onPropertyChange(key, nv, ov) {
        // ignore the class attribute.
        // Prevent the framework from setting the class on the host element.
        if (key === 'class' || key === 'name' || key === 'tabindex') {
            return;
        }
        else if (key === 'animation') {
            this.modalOptions.class = this.modalOptions.class.replace('animated ' + ov, '');
            if (nv) {
                this.modalOptions.class = this.modalOptions.class + 'animated ' + nv;
            }
        }
        super.onPropertyChange(key, nv, ov);
    }
    ngOnDestroy() {
        this.close();
        this.deRegister(this.viewParent);
        super.ngOnDestroy();
    }
}

const DIALOG_CLS = 'app-dialog modal-dialog app-alert-dialog';
const WIDGET_INFO = { widgetType: 'wm-alertdialog' };
class AlertDialogComponent extends BaseDialog {
    constructor(inj, dialogClass, modal, closable) {
        if (modal === null || modal === undefined) {
            modal = false;
        }
        if (closable === null || closable === undefined) {
            closable = true;
        }
        // setting the backdrop to 'static' will not close the dialog on backdrop click
        const backdrop = toBoolean(modal) ? 'static' : true;
        super(inj, WIDGET_INFO, {
            class: `${DIALOG_CLS} ${dialogClass || ''}`,
            backdrop,
            keyboard: !toBoolean(modal)
        });
    }
    getTemplateRef() {
        return this.dialogTemplate;
    }
    /**
     * Click event handler for the ok button
     * invokes on-ok event callback
     * @param {Event} $event
     */
    onOk($event) {
        this.invokeEventCallback('ok', { $event });
    }
    ngOnInit() {
        super.ngOnInit();
        this.register(this.viewParent);
    }
}
AlertDialogComponent.initializeProps = registerProps$2();
AlertDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmAlertDialog]',
                template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"></div>\n    <div wmDialogBody>\n        <p class=\"app-dialog-message text-{{alerttype}}\" [attr.aria-describedby]=\"message\" [textContent]=\"message\"></p>\n    </div>\n    <div wmDialogFooter>\n        <button wmButton class=\"btn-primary ok-action\" caption.bind=\"oktext\" aria-label=\"Submit button\" (click)=\"onOk($event)\"></button>\n    </div>\n</ng-template>\n",
                providers: [
                    provideAsWidgetRef(AlertDialogComponent),
                    provideAsDialogRef(AlertDialogComponent)
                ]
            }] }
];
/** @nocollapse */
AlertDialogComponent.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Attribute, args: ['class',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['modal',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['closable',] }] }
];
AlertDialogComponent.propDecorators = {
    dialogTemplate: [{ type: ViewChild, args: ['dialogTemplate',] }]
};

const registerProps$3 = () => {
    register('wm-anchor', new Map([
        ['badgevalue', PROP_STRING],
        ['caption', Object.assign({ value: 'Link' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['encodeurl', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['hyperlink', Object.assign({ value: '' }, PROP_STRING)],
        ['iconclass', PROP_STRING],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconposition', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['name', PROP_STRING],
        ['shortcutkey', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['target', Object.assign({ value: '_self' }, PROP_STRING)]
    ]));
};

const registerProps$4 = () => {
    register('wm-nav-item', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$2 = 'app-nav-item';
const WIDGET_CONFIG$2 = { widgetType: 'wm-nav-item', hostClass: DEFAULT_CLS$2 };
class NavItemDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$2);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
    makeActive() {
        const parentNode = this.nativeElement.parentNode;
        $(parentNode).find('> li.active').removeClass('active');
        addClass(this.nativeElement, 'active');
    }
}
NavItemDirective.initializeProps = registerProps$4();
NavItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmNavItem]',
                providers: [
                    provideAsWidgetRef(NavItemDirective)
                ]
            },] }
];
/** @nocollapse */
NavItemDirective.ctorParameters = () => [
    { type: Injector }
];
NavItemDirective.propDecorators = {
    makeActive: [{ type: HostListener, args: ['click',] }, { type: HostListener, args: ['keydown.enter',] }]
};

const disableContextMenu = ($event) => {
    $event.preventDefault();
};
class NavigationControlDirective {
    constructor(eleRef) {
        this.nativeElement = eleRef.nativeElement;
    }
    set wmNavigationControl(val) {
        this._link = val;
        if (val && !this.disableMenuContext) {
            setAttr(this.nativeElement, 'href', val);
            this.nativeElement.removeEventListener('contextmenu', disableContextMenu);
        }
        else {
            setAttr(this.nativeElement, 'href', 'javascript:void(0)');
            this.nativeElement.addEventListener('contextmenu', disableContextMenu);
        }
    }
}
NavigationControlDirective.decorators = [
    { type: Directive, args: [{ selector: '[wmNavigationControl]' },] }
];
/** @nocollapse */
NavigationControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
NavigationControlDirective.propDecorators = {
    disableMenuContext: [{ type: Input }],
    wmNavigationControl: [{ type: Input }]
};

const DEFAULT_CLS$3 = 'app-anchor';
const WIDGET_CONFIG$3 = {
    widgetType: 'wm-anchor',
    hostClass: DEFAULT_CLS$3,
    displayType: DISPLAY_TYPE.INLINE_BLOCK
};
const regex = /Actions.goToPage_(\w+)\.invoke\(\)/g;
class AnchorComponent extends StylableComponent {
    constructor(inj, navItemRef, app) {
        super(inj, WIDGET_CONFIG$3);
        this.navItemRef = navItemRef;
        this.app = app;
        styler(this.nativeElement, this);
    }
    processEventAttr(eventName, expr, meta) {
        super.processEventAttr(eventName, expr, meta);
        if (!this.hasNavigationToCurrentPageExpr) {
            const app = this.inj.get(App);
            const fns = expr.split(';').map(Function.prototype.call, String.prototype.trim);
            if (fns.some(fn => {
                regex.lastIndex = 0;
                const matches = regex.exec(fn);
                this.hasGoToPageExpr = matches && (matches.length > 0);
                return this.hasGoToPageExpr && matches[1] === app.activePageName;
            })) {
                this.hasNavigationToCurrentPageExpr = true;
            }
        }
    }
    setNavItemActive() {
        if (this.navItemRef) {
            addClass(this.navItemRef.getNativeElement(), 'active');
        }
    }
    handleEvent(node, eventName, eventCallback, locals, meta) {
        super.handleEvent(node, eventName, e => {
            if (this.hasGoToPageExpr && locals.$event) {
                locals.$event.preventDefault();
            }
            eventCallback();
        }, locals, meta);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'hyperlink') {
            if (!nv) {
                setAttr(this.nativeElement, 'href', 'javascript:void(0)');
                this.nativeElement.addEventListener('contextmenu', disableContextMenu);
                return;
            }
            if (this.encodeurl) {
                nv = encodeUrl(nv);
            }
            // if hyperlink starts with 'www.' append '//' in the beginning
            if (nv.startsWith('www.')) {
                nv = `//${nv}`;
            }
            setAttr(this.nativeElement, 'href', nv);
            this.nativeElement.removeEventListener('contextmenu', disableContextMenu);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (this.hasNavigationToCurrentPageExpr) {
            addClass(this.nativeElement, 'active');
        }
        if (this.navItemRef) {
            setTimeout(() => {
                if (this.hyperlink && getRouteNameFromLink(this.hyperlink) === `/${this.app.activePageName}`) {
                    this.setNavItemActive();
                }
                else if (this.hasNavigationToCurrentPageExpr) {
                    this.setNavItemActive();
                }
            });
        }
    }
}
AnchorComponent.initializeProps = registerProps$3();
AnchorComponent.decorators = [
    { type: Component, args: [{
                selector: 'a[wmAnchor]',
                template: "<img data-identifier=\"img\" alt=\"Image\" class=\"anchor-image-icon\" [src]=\"iconurl | image\" *ngIf=\"iconurl\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin}\"/>\n<i class=\"app-icon {{iconclass}}\" aria-hidden=\"true\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin}\" *ngIf=\"iconclass\"></i>\n<span class=\"sr-only\" *ngIf=\"iconclass\">{{caption | trustAs:'html'}} {{appLocale.LABEL_ICON}}</span>\n<span class=\"anchor-caption\" [innerHTML]=\"caption | trustAs:'html'\"></span>\n<ng-content select=\".caret\"></ng-content>\n<span *ngIf=\"badgevalue\" class=\"badge pull-right\" [textContent]=\"badgevalue\"></span>",
                providers: [
                    provideAsWidgetRef(AnchorComponent)
                ]
            }] }
];
/** @nocollapse */
AnchorComponent.ctorParameters = () => [
    { type: Injector },
    { type: NavItemDirective, decorators: [{ type: Optional }] },
    { type: App }
];
AnchorComponent.propDecorators = {
    target: [{ type: HostBinding, args: ['target',] }],
    shortcutkey: [{ type: HostBinding, args: ['attr.accesskey',] }],
    iconposition: [{ type: HostBinding, args: ['attr.icon-position',] }]
};

const registerProps$5 = () => {
    register('wm-breadcrumb', new Map([
        ['class', PROP_STRING],
        ['dataset', PROP_ANY],
        ['itemlabel', PROP_STRING],
        ['itemid', PROP_STRING],
        ['itemlink', PROP_STRING],
        ['itemicon', PROP_STRING],
        ['itemchildren', PROP_STRING],
        ['itemclass', PROP_STRING],
        ['itemtarget', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const noop$1 = () => { };
var Live_Operations;
(function (Live_Operations) {
    Live_Operations["INSERT"] = "insert";
    Live_Operations["UPDATE"] = "update";
    Live_Operations["DELETE"] = "delete";
    Live_Operations["READ"] = "read";
})(Live_Operations || (Live_Operations = {}));
const ALLFIELDS = 'All Fields';
const LIVE_CONSTANTS = {
    'EMPTY_KEY': 'EMPTY_NULL_FILTER',
    'EMPTY_VALUE': 'No Value',
    'LABEL_KEY': 'key',
    'LABEL_VALUE': 'value',
    'NULL_EMPTY': ['null', 'empty'],
    'NULL': 'null',
    'EMPTY': 'empty'
};
// Returns true if widget is autocomplete or chips
function isSearchWidgetType(widget) {
    return _.includes([FormWidgetType.AUTOCOMPLETE, FormWidgetType.TYPEAHEAD, FormWidgetType.CHIPS], widget);
}
function onSuccess(response, res, rej) {
    if (response.error) {
        rej(response);
    }
    else {
        res(response);
    }
}
function performDataOperation(dataSource, requestData, options) {
    return new Promise((res, rej) => {
        if (dataSource.execute(DataSource.Operation.SUPPORTS_CRUD)) {
            let fn;
            const operationType = options.operationType;
            switch (operationType) {
                case Live_Operations.UPDATE:
                    fn = DataSource.Operation.UPDATE_RECORD;
                    break;
                case Live_Operations.INSERT:
                    fn = DataSource.Operation.INSERT_RECORD;
                    break;
                case Live_Operations.DELETE:
                    fn = DataSource.Operation.DELETE_RECORD;
                    break;
            }
            dataSource.execute(fn, requestData).then(response => onSuccess(response, res, rej), rej);
        }
        else if (dataSource.execute(DataSource.Operation.IS_API_AWARE)) {
            dataSource.execute(DataSource.Operation.SET_INPUT, requestData);
            dataSource.execute(DataSource.Operation.INVOKE, {
                'skipNotification': true
            }).then(res, rej);
        }
        else {
            res(requestData);
        }
    });
}
function refreshDataSource(dataSource, options) {
    return new Promise((res, rej) => {
        if (!dataSource) {
            rej();
            return;
        }
        dataSource.execute(DataSource.Operation.LIST_RECORDS, {
            'filterFields': options.filterFields || {},
            'orderBy': options.orderBy,
            'page': options.page || 1
        }).then(res, rej);
    });
}
/**
 * @ngdoc function
 * @name wm.widgets.live.fetchRelatedFieldData
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * This function fetches the data for the related field in live form/ grid
 *
 * @param {object} columnDef field definition
 * @param {string} relatedField related field name
 * @param {string} datafield Datafield to be set on widget
 * @param {string} widget Type of the widget
 * @param {object} elScope element scope
 * @param {object} parentScope live form// grid scope
 */
function fetchRelatedFieldData(dataSource, formField, options) {
    let primaryKeys;
    let displayField;
    const relatedField = options.relatedField;
    const datafield = options.datafield;
    if (!dataSource) {
        return;
    }
    primaryKeys = dataSource.execute(DataSource.Operation.GET_RELATED_PRIMARY_KEYS, relatedField);
    formField.datafield = datafield;
    formField._primaryKey = _.isEmpty(primaryKeys) ? undefined : primaryKeys[0];
    formField.compareby = primaryKeys && primaryKeys.join(',');
    displayField = datafield === ALLFIELDS ? undefined : datafield;
    formField.displayfield = displayField = (formField.displayfield || displayField || formField._primaryKey);
    if (isSearchWidgetType(formField[options.widget])) {
        formField.dataoptions = { 'relatedField': relatedField, 'filterExpr': formField.filterexpressions ? formField.filterexpressions : {} };
        formField.datasource = dataSource;
        formField.searchkey = formField.searchkey || displayField;
        formField.displaylabel = formField.displayfield = (formField.displaylabel || displayField);
    }
    else {
        interpolateBindExpressions(formField.viewParent, formField.filterexpressions, (filterexpressions) => {
            formField.filterexpressions = filterexpressions;
            dataSource.execute(DataSource.Operation.GET_RELATED_TABLE_DATA, {
                relatedField,
                pagesize: formField.limit,
                orderBy: formField.orderby ? _.replace(formField.orderby, /:/g, ' ') : '',
                filterFields: {},
                filterExpr: formField.filterexpressions ? formField.filterexpressions : {}
            }).then(response => {
                formField.dataset = response.data;
                formField.displayfield = formField.displayfield || _.head(_.keys(_.get(response, '[0]')));
            }, noop$1);
        });
    }
}
/**
 * used to interpolate the bind expression for keys in the query builder
 * @param context where we find the variable obj
 * @param filterexpressions - obj containing all the rule objs
 * @param callbackFn - function to be called with the new replaced values if any in the filterexpressions object
 */
const interpolateBindExpressions = (context, filterexpressions, callbackFn) => {
    const debouncedFn = debounce(() => {
        if (_.isFunction(callbackFn)) {
            callbackFn(filterexpressions);
        }
    }, 300);
    /**
     * calling the debounced function first for the case where if there is any filterexpression without the bindedvariables.
     * without this it will never be called. processFilterExpBindNode will be called only for the binded variable expressions.
     */
    debouncedFn();
    const filterExpressions = filterexpressions ? (_.isObject(filterexpressions) ? filterexpressions : JSON.parse(filterexpressions)) : {};
    const destroyFn = context.registerDestroyListener ? context.registerDestroyListener.bind(context) : _.noop;
    const filterSubscription = processFilterExpBindNode(context, filterExpressions).subscribe((response) => {
        filterexpressions = JSON.stringify(response.filterExpressions);
        debouncedFn();
    });
    destroyFn(() => filterSubscription.unsubscribe());
};
/**
 * @ngdoc function
 * @name wm.widgets.live.LiveWidgetUtils#getDistinctFieldProperties
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Returns the properties required for dataset widgets
 *
 * @param {object} dataSource variable source for the widget
 * @param {object} formField definition of the column/ field
 *
 */
const getDistinctFieldProperties = (dataSource, formField) => {
    const props = {};
    let fieldColumn;
    if (formField['is-related']) {
        props.tableName = formField['lookup-type'];
        fieldColumn = formField['lookup-field'];
        props.distinctField = fieldColumn;
        props.aliasColumn = fieldColumn.replace('.', '$'); // For related fields, In response . is replaced by $
        props.filterExpr = formField.filterexpressions ? (_.isObject(formField.filterexpressions) ? formField.filterexpressions : JSON.parse(formField.filterexpressions)) : {};
    }
    else {
        props.tableName = dataSource.execute(DataSource.Operation.GET_ENTITY_NAME);
        fieldColumn = formField.field || formField.key;
        props.distinctField = fieldColumn;
        props.aliasColumn = fieldColumn;
    }
    return props;
};
/**
 * @ngdoc function
 * @name wm.widgets.live.LiveWidgetUtils#getDistinctValues
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Returns the distinct values for a field
 *
 * @param {object} formField definition of the column/ field
 * @param {string} widget widget property on the field
 * @param {object} variable variable for the widget
 * @param {function} callBack Function to be executed after fetching results
 *
 */
function getDistinctValues(dataSource, formField, widget) {
    let props;
    return new Promise((res, rej) => {
        if (isDataSetWidget(formField[widget]) && (!formField.isDataSetBound || widget === 'filterwidget')) {
            props = getDistinctFieldProperties(dataSource, formField);
            dataSource.execute(DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS, {
                fields: props.distinctField,
                entityName: props.tableName,
                pagesize: formField.limit,
                filterExpr: formField.filterexpressions ? JSON.parse(formField.filterexpressions) : {}
            }).then(response => {
                res({ 'field': formField, 'data': response.data, 'aliasColumn': props.aliasColumn });
            }, rej);
        }
    });
}
// Set the data field properties on dataset widgets
function setDataFields(formField, options) {
    // For search widget, set search key and display label
    if (isSearchWidgetType(formField[options.widget])) {
        formField.datafield = options.aliasColumn || LIVE_CONSTANTS.LABEL_KEY;
        formField.searchkey = options.distinctField || LIVE_CONSTANTS.LABEL_KEY;
        formField.displaylabel = formField.displayfield = (options.aliasColumn || LIVE_CONSTANTS.LABEL_VALUE);
        return;
    }
    formField.datafield = LIVE_CONSTANTS.LABEL_KEY;
    formField.displayfield = LIVE_CONSTANTS.LABEL_VALUE;
}
/**
 * @ngdoc function
 * @name wm.widgets.live.LiveWidgetUtils#setFieldDataSet
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Function to set the dataSet on the fields
 *
 * @param {object} formField definition of the column/ field
 * @param {object} data data returned from the server
 * @param {string} aliasColumn column field name
 * @param {string} widget widget property on the field
 * @param {boolean} isEnableEmptyFilter is null or empty values allowed on filter
 *
 */
function setFieldDataSet(formField, data, options) {
    const emptySupportWidgets = [FormWidgetType.SELECT, FormWidgetType.RADIOSET];
    const emptyOption = {};
    const dataSet = [];
    if (options.isEnableEmptyFilter && _.includes(emptySupportWidgets, formField[options.widget]) &&
        !formField['is-range'] && !formField.multiple) {
        // If empty option is selected, push an empty object in to dataSet
        emptyOption[LIVE_CONSTANTS.LABEL_KEY] = LIVE_CONSTANTS.EMPTY_KEY;
        emptyOption[LIVE_CONSTANTS.LABEL_VALUE] = options.EMPTY_VALUE || LIVE_CONSTANTS.EMPTY_VALUE;
        dataSet.push(emptyOption);
    }
    _.each(data, key => {
        const value = key[options.aliasColumn];
        const option = {};
        if (value !== null && value !== '') {
            option[LIVE_CONSTANTS.LABEL_KEY] = value;
            option[LIVE_CONSTANTS.LABEL_VALUE] = value;
            dataSet.push(option);
        }
    });
    setDataFields(formField, options);
    formField.dataset = dataSet;
}
/**
 * @ngdoc function
 * @name wm.widgets.live.LiveWidgetUtils#fetchDistinctValues
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Function to fetch the distinct values for a field
 *
 * @param {object} scope scope of the widget
 * @param {object} formFields definitions of the column/ field
 * @param {string} widget widget property on the field
 * @param {boolean} isEnableEmptyFilter is null or empty values allowed on filter
 *
 */
function fetchDistinctValues(dataSource, formFields, options) {
    if (_.isEmpty(formFields)) {
        return;
    }
    formFields.forEach(formField => {
        getDistinctValuesForField(dataSource, formField, options);
    });
}
/**
 * @ngdoc function
 * @name wm.widgets.live.LiveWidgetUtils#getDistinctValuesForField
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Function to fetch the distinct values for a field
 *
 * @param {object} scope scope of the widget
 * @param {object} formFields definitions of the column/ field
 * @param {string} widget widget property on the field
 * @param {boolean} isEnableEmptyFilter is null or empty values allowed on filter
 *
 */
function getDistinctValuesForField(dataSource, formField, options) {
    if (!dataSource || !formField || formField.isDataSetBound) {
        return;
    }
    if (isSearchWidgetType(formField[options.widget])) {
        const dataoptions = getDistinctFieldProperties(dataSource, formField);
        formField.dataoptions = dataoptions;
        setDataFields(formField, Object.assign(options || {}, dataoptions));
        formField.datasource = dataSource;
    }
    else {
        interpolateBindExpressions(formField.viewParent, formField.filterexpressions, (filterexpressions) => {
            formField.filterexpressions = filterexpressions;
            getDistinctValues(dataSource, formField, options.widget).then((res) => {
                setFieldDataSet(res.field, res.data, {
                    aliasColumn: res.aliasColumn,
                    widget: options.widget,
                    isEnableEmptyFilter: getEnableEmptyFilter(options.enableemptyfilter),
                    EMPTY_VALUE: options.EMPTY_VALUE
                });
            });
        });
    }
}
function isDefinedAndNotEmpty(val) {
    return isDefined(val) && val !== '' && val !== null;
}
/**
 * @ngdoc function
 * @name wm.widgets.live.getRangeFieldValue
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Function to get the field value for range
 *
 * @param {string} minValue min value selected
 * @param {string} maxValue max value selected
 */
function getRangeFieldValue(minValue, maxValue) {
    let fieldValue;
    if (isDefinedAndNotEmpty(minValue) && isDefinedAndNotEmpty(maxValue)) {
        fieldValue = [minValue, maxValue];
    }
    else if (isDefinedAndNotEmpty(minValue)) {
        fieldValue = minValue;
    }
    else if (isDefinedAndNotEmpty(maxValue)) {
        fieldValue = maxValue;
    }
    return fieldValue;
}
/**
 * @ngdoc function
 * @name wm.widgets.live.getRangeMatchMode
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Function to get the match mode for range
 *
 * @param {string} minValue min value selected
 * @param {string} maxValue max value selected
 */
function getRangeMatchMode(minValue, maxValue) {
    let matchMode;
    // If two values exists, then it is between. Otherwise, greater or lesser
    if (isDefinedAndNotEmpty(minValue) && isDefinedAndNotEmpty(maxValue)) {
        matchMode = MatchMode.BETWEEN;
    }
    else if (isDefinedAndNotEmpty(minValue)) {
        matchMode = MatchMode.GREATER;
    }
    else if (isDefinedAndNotEmpty(maxValue)) {
        matchMode = MatchMode.LESSER;
    }
    return matchMode;
}
/**
 * @ngdoc function
 * @name wm.widgets.live.getEnableEmptyFilter
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * This function checks if enable filter options is set on live filter
 *
 * @param {object} enableemptyfilter empty filter options
 */
function getEnableEmptyFilter(enableemptyfilter) {
    return enableemptyfilter && _.intersection(enableemptyfilter.split(','), LIVE_CONSTANTS.NULL_EMPTY).length > 0;
}
/**
 * @ngdoc function
 * @name wm.widgets.live.getEmptyMatchMode
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Function to get the match mode based on the filter selected
 *
 * @param {object} enableemptyfilter empty filter options
 */
function getEmptyMatchMode(enableemptyfilter) {
    let matchMode;
    const emptyFilterOptions = _.split(enableemptyfilter, ',');
    if (_.intersection(emptyFilterOptions, LIVE_CONSTANTS.NULL_EMPTY).length === 2) {
        matchMode = MatchMode.NULLOREMPTY;
    }
    else if (_.includes(emptyFilterOptions, LIVE_CONSTANTS.NULL)) {
        matchMode = MatchMode.NULL;
    }
    else if (_.includes(emptyFilterOptions, LIVE_CONSTANTS.EMPTY)) {
        matchMode = MatchMode.EMPTY;
    }
    return matchMode;
}
/**
 * converts the data passed to array.
 *  -> Array: [1,2,3] - [1,2,3]
 *  -> String: a,b,c - ['a','b','c']
 *  -> object: {a:1} - [{a:1}]
 *  -> null - []
 *  -> undefined - []
 * @param data
 * @returns {Array<any>}
 */
const createArrayFrom = (data) => {
    if (_.isUndefined(data) || _.isNull(data)) {
        return [];
    }
    if (_.isString(data)) {
        data = data.split(',').map(Function.prototype.call, String.prototype.trim);
    }
    if (!_.isArray(data)) {
        data = [data];
    }
    return data;
};
/**
 * @ngdoc function
 * @name wm.widgets.live.applyFilterOnField
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * Function to get the updated values when filter on field is changed
 *
 * @param {object} $scope scope of the filter field/form field
 * @param {object} filterDef filter/form definition of the field
 * @param {boolean} isFirst boolean value to check if this method is called on load
 */
function applyFilterOnField(dataSource, filterDef, formFields, newVal, options = {}) {
    const fieldName = filterDef.field || filterDef.key;
    const filterOnFields = _.filter(formFields, { 'filter-on': fieldName });
    newVal = filterDef['is-range'] ? getRangeFieldValue(filterDef.minValue, filterDef.maxValue) : (isDefined(newVal) ? newVal : filterDef.value);
    if (!dataSource || (options.isFirst && (_.isUndefined(newVal) || newVal === ''))) {
        return;
    }
    // Loop over the fields for which the current field is filter on field
    _.forEach(filterOnFields, filterField => {
        const filterKey = filterField.field || filterField.key;
        const lookUpField = filterDef['lookup-field'] || filterDef._primaryKey;
        const filterWidget = filterField['edit-widget-type'] || filterField.widgettype;
        let filterFields = {};
        let filterOn = filterField['filter-on'];
        let filterVal;
        let fieldColumn;
        let matchMode;
        if (!isDataSetWidget(filterWidget) || filterField.isDataSetBound || filterOn === filterKey) {
            return;
        }
        // For related fields, add lookupfield for query generation
        if (filterDef && filterDef['is-related']) {
            filterOn += '.' + lookUpField;
        }
        if (isDefined(newVal)) {
            if (filterDef['is-range']) {
                matchMode = getRangeMatchMode(filterDef.minValue, filterDef.maxValue);
            }
            else if (getEnableEmptyFilter(options.enableemptyfilter) && newVal === LIVE_CONSTANTS.EMPTY_KEY) {
                matchMode = getEmptyMatchMode(options.enableemptyfilter);
            }
            else {
                matchMode = MatchMode.EQUALS;
            }
            filterVal = (_.isObject(newVal) && !_.isArray(newVal)) ? newVal[lookUpField] : newVal;
            filterFields[filterOn] = {
                'value': filterVal,
                'matchMode': matchMode
            };
        }
        else {
            filterFields = {};
        }
        fieldColumn = filterKey;
        if (isSearchWidgetType(filterWidget) && filterField.dataoptions) {
            filterField.dataoptions.filterFields = filterFields;
        }
        else {
            dataSource.execute(DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS, {
                'fields': fieldColumn,
                'filterFields': filterFields,
                'pagesize': filterField.limit
            }).then(response => {
                setFieldDataSet(filterField, response.data, {
                    aliasColumn: fieldColumn,
                    widget: options.widget || 'widgettype',
                    isEnableEmptyFilter: getEnableEmptyFilter(options.enableemptyfilter),
                    EMPTY_VALUE: options.EMPTY_VALUE
                });
            }, noop$1);
        }
    });
}
// Transform data as required by data table
function transformData(dataObject, variableName) {
    let newObj, tempArr, keys, oldKeys, numKeys, newObject, tempObj;
    // data sanity testing
    dataObject = dataObject || [];
    // if the dataObject is not an array make it an array
    if (!_.isArray(dataObject)) {
        // if the data returned is of type string, make it an object inside an array
        if (_.isString(dataObject)) {
            keys = variableName.substring(variableName.indexOf('.') + 1, variableName.length).split('.');
            oldKeys = [];
            numKeys = keys.length;
            newObject = {};
            tempObj = newObject;
            // loop over the keys to form appropriate data object required for grid
            keys.forEach((key, index) => {
                // loop over old keys to create new object at the iterative level
                oldKeys.forEach(oldKey => {
                    tempObj = newObject[oldKey];
                });
                tempObj[key] = index === numKeys - 1 ? dataObject : {};
                oldKeys.push(key);
            });
            // change the string data to the new dataObject formed
            dataObject = newObject;
        }
        dataObject = [dataObject];
    }
    else {
        /*if the dataObject is an array and each value is a string, then lite-transform the string to an object
         * lite-transform: just checking if the first value is string and then transforming the object, instead of traversing through the whole array
         * */
        if (_.isString(dataObject[0])) {
            tempArr = [];
            _.forEach(dataObject, str => {
                newObj = {};
                newObj[variableName.split('.').join('-')] = str;
                tempArr.push(newObj);
            });
            dataObject = tempArr;
        }
    }
    return dataObject;
}

const momentLocale = moment.localeData();
const momentCalendarOptions = getClonedObject(momentLocale._calendar);
const momentCalendarDayOptions = momentLocale._calendarDay || {
    lastDay: '[Yesterday]',
    lastWeek: '[Last] dddd',
    nextDay: '[Tomorrow]',
    nextWeek: 'dddd',
    sameDay: '[Today]',
    sameElse: 'L'
};
const GROUP_BY_OPTIONS = {
    ALPHABET: 'alphabet',
    WORD: 'word',
    OTHERS: 'Others'
};
const TIME_ROLLUP_OPTIONS = {
    HOUR: 'hour',
    DAY: 'day',
    WEEK: 'week',
    MONTH: 'month',
    YEAR: 'year'
};
const ROLLUP_PATTERNS = {
    DAY: 'yyyy-MM-dd',
    WEEK: 'w \'Week\',  yyyy',
    MONTH: 'MMM, yyyy',
    YEAR: 'YYYY',
    HOUR: 'hh:mm a'
};
/**
 * function to get the ordered dataset based on the given orderby
 */
const getOrderedDataset = (dataSet, orderBy, innerItem) => {
    if (!orderBy) {
        return _.cloneDeep(dataSet);
    }
    // The order by only works when the dataset contains list of objects.
    const items = orderBy.split(','), fields = [], directions = [];
    items.forEach(obj => {
        const item = obj.split(':');
        fields.push(innerItem ? innerItem + '.' + item[0] : item[0]);
        directions.push(item[1]);
    });
    return _.orderBy(dataSet, fields, directions);
};
/**
 * Returns an array of object, each object contain the DataSetItem whose key, value, label are extracted from object keys.
 */
const transformDataWithKeys = (dataSet) => {
    const data = [];
    // if the dataset is instance of object (not an array) or the first item in the dataset array is an object,
    // then we extract the keys from the object and prepare the dataset items.
    if (_.isObject(dataSet[0]) || (_.isObject(dataSet) && !(dataSet instanceof Array))) {
        // getting keys of the object
        const objectKeys = Object.keys(dataSet[0] || dataSet);
        _.forEach(objectKeys, (objKey, index) => {
            data.push({
                key: objKey,
                label: objKey,
                value: objKey,
                index: index + 1
            });
        });
    }
    return data;
};
// Converts any type of data to array.
const extractDataAsArray = data => {
    if (_.isUndefined(data) || _.isNull(data) || _.trim(data) === '') {
        return [];
    }
    if (_.isString(data)) {
        data = _.split(data, ',').map(str => str.trim());
    }
    if (!_.isArray(data)) {
        data = [data];
    }
    return data;
};
// This function return always an object containing dataset details.
const convertDataToObject = dataResult => {
    if (_.isString(dataResult)) {
        dataResult = _.split(dataResult, ',').map(str => str.trim());
    }
    return dataResult;
};
/**
 * The first step in datasetItems creation is data transformation:
 *
 * The dataset can contain one of the following formats and each of them to be converted to the given format;
 *
 * 1) The comma separated string..eg: A,B,C => [{ key: 'A', value: 'A'}, { key: 'B', value: 'B'}, { key: 'C', value: 'C'}]
 * 2) The array of values eg: [1,2,3] => [{ key: 1, value: 1}, { key: 2, value: 2}, { key: 3, value: 3}]
 * 3) an object eg: {name: 'A', age: 20} => [ {key: 'name', value: 'A'}, {key: 'age', value: 20}]
 * 4) an array of objects...eg: [ {name: 'A', age: 20}, {name: 'B', age: 20}] ==> returns [{key: _DATAFIELD_, value: _DISPLAYFIELD, label: _DISPLAYVALUE}]
 */
const transformData$1 = (context, dataSet, myDataField, displayOptions, startIndex) => {
    const data = [];
    if (!dataSet) {
        return;
    }
    dataSet = convertDataToObject(dataSet);
    // startIndex is the index of the next new item.
    if (_.isUndefined(startIndex)) {
        startIndex = 1;
    }
    if (_.isString(dataSet)) {
        dataSet = dataSet.split(',').map(str => str.trim());
        dataSet.forEach((option, index) => {
            data.push({ key: option, value: option, label: (isDefined(option) && option !== null) ? option.toString() : '', index: startIndex + index });
        });
    }
    else if (_.isArray(dataSet) && !_.isObject(dataSet[0])) { // array of primitive values only
        dataSet.forEach((option, index) => {
            data.push({ key: option, value: option, label: (isDefined(option) && option !== null) ? option.toString() : '', index: startIndex + index });
        });
    }
    else if (!(dataSet instanceof Array) && _.isObject(dataSet)) {
        _.forEach(dataSet, (value, key) => {
            data.push({ key: _.trim(key), value: key, label: (isDefined(value) && value !== null) ? value.toString() : '', index: startIndex, dataObject: dataSet });
        });
    }
    else {
        if (!myDataField) { // consider the datafield as 'ALLFIELDS' when datafield is not given.
            myDataField = ALLFIELDS;
        }
        dataSet.forEach((option, index) => {
            const key = myDataField === ALLFIELDS ? startIndex + index : getObjValueByKey(option, myDataField);
            // Omit all the items whose datafield (key) is null or undefined.
            if (!_.isUndefined(key) && !_.isNull(key)) {
                const label = getEvaluatedData(option, {
                    field: displayOptions.displayField,
                    expression: displayOptions.displayExpr,
                    bindExpression: displayOptions.bindDisplayExpr
                }, context);
                const dataSetItem = {
                    key: key,
                    label: (isDefined(label) && label !== null) ? label.toString() : '',
                    value: myDataField === ALLFIELDS ? option : key,
                    dataObject: option,
                    index: startIndex + index
                };
                if (displayOptions.displayImgSrc || displayOptions.bindDisplayImgSrc) {
                    dataSetItem.imgSrc = getEvaluatedData(option, {
                        expression: displayOptions.displayImgSrc,
                        bindExpression: displayOptions.bindDisplayImgSrc
                    }, context);
                }
                data.push(dataSetItem);
            }
        });
    }
    return data;
};
/**
 * Private method to get the unique objects by the data field
 */
const getUniqObjsByDataField = (data, dataField, displayField, allowEmptyFields) => {
    let uniqData;
    const isAllFields = dataField === ALLFIELDS;
    uniqData = isAllFields ? _.uniqWith(data, _.isEqual) : _.uniqBy(data, 'key');
    if (!displayField || allowEmptyFields) {
        return uniqData;
    }
    // return objects having non empty datafield and display field values.
    return _.filter(uniqData, (obj) => {
        if (isAllFields) {
            return _.trim(obj.label);
        }
        return _.trim(obj.key) && _.trim(obj.label);
    });
};
/**
 * This method returns sorted data based to groupkey.
 * Returns a array of objects, each object containing key which is groupKey and data is the sorted data which is sorted by groupby field in the data.
 *
 * @param groupedLiData, grouped data object with key as the groupKey and its value as the array of objects grouped under the groupKey.
 * @param groupBy, string groupby property
 * @returns {any[]}
 */
const getSortedGroupedData = (groupedLiData, groupBy, orderby) => {
    const _groupedData = [];
    _.forEach(_.keys(groupedLiData), (groupkey, index) => {
        const liData = getOrderedDataset(groupedLiData[groupkey], orderby, 'dataObject');
        _groupedData.push({
            key: groupkey,
            data: _.sortBy(liData, data => {
                data._groupIndex = index + 1;
                return _.get(data, groupBy) || _.get(data.dataObject, groupBy);
            })
        });
    });
    return _groupedData;
};
/**
 * This method gets the groupedData using groupby property and match and returns the sorted array of objects.
 *
 * @param compRef represents the component's reference i.e. "this" value.
 * @param data represents the dataset i.e array of objects.
 * @param groupby, string groupby property
 * @param match, string match property
 * @param orderby, string orderby property
 * @param dateformat, string dateFormat property
 * @param innerItem, represents the innerItem on which groupby has to be applied. Incase of datasetItems, 'dataObject' contains the full object. Here innerItem is dataObject.
 * @returns {any[]} groupedData, array of objects, each object having key and data.
 */
const groupData = (compRef, data, groupby, match, orderby, dateformat, datePipe, innerItem, AppDefaults$$1) => {
    let groupedLiData = {};
    if (_.includes(groupby, '(')) {
        const groupDataByUserDefinedFn = $parseEvent(groupby);
        groupedLiData = _.groupBy(data, val => {
            return groupDataByUserDefinedFn(compRef.viewParent, { 'row': val.dataObject || val });
        });
    }
    else {
        groupedLiData = getGroupedData(data, groupby, match, orderby, dateformat, datePipe, innerItem, AppDefaults$$1);
    }
    return getSortedGroupedData(groupedLiData, groupby, orderby);
};
/**
 * This method prepares the grouped data.
 *
 * @param fieldDefs array of objects i.e. dataset
 * @param groupby string groupby
 * @param match string match
 * @param orderby string orderby
 * @param dateFormat string date format
 * @param innerItem, item to look for in the passed data
 */
const getGroupedData = (fieldDefs, groupby, match, orderby, dateFormat, datePipe, innerItem, AppDefaults$$1) => {
    // For day, set the relevant moment calendar options
    if (match === TIME_ROLLUP_OPTIONS.DAY) {
        momentLocale._calendar = momentCalendarDayOptions;
    }
    // handling case-in-sensitive scenario
    // ordering the data based on groupby field. If there is innerItem then apply orderby using the innerItem's containing the groupby field.
    fieldDefs = _.orderBy(fieldDefs, fieldDef => {
        const groupKey = _.get(innerItem ? fieldDef[innerItem] : fieldDef, groupby);
        if (groupKey) {
            return _.toLower(groupKey);
        }
    });
    // extract the grouped data based on the field obtained from 'groupDataByField'.
    const groupedLiData = _.groupBy(fieldDefs, groupDataByField.bind(undefined, groupby, match, innerItem, dateFormat, datePipe, AppDefaults$$1));
    momentLocale._calendar = momentCalendarOptions; // Reset to default moment calendar options
    return groupedLiData;
};
// Format the date with given date format
const filterDate = (value, format, defaultFormat, datePipe) => {
    if (format === 'timestamp') { // For timestamp format, return the epoch value
        return value;
    }
    return getFormattedDate(datePipe, value, format || defaultFormat);
};
/**
 * This method returns the groupkey based on the rollup (match) passed
 *
 * @param concatStr, string containing groupby field value
 * @param rollUp string containing the match property.
 * @param dateformat string containing the date format to display the date.
 */
const getTimeRolledUpString = (concatStr, rollUp, dateformat, datePipe, AppDefaults$$1) => {
    let groupByKey, strMoment = moment(concatStr), dateFormat = dateformat;
    const currMoment = moment(), getSameElseFormat = function () {
        return '[' + filterDate(this.valueOf(), dateFormat, ROLLUP_PATTERNS.DAY, datePipe) + ']';
    };
    switch (rollUp) {
        case TIME_ROLLUP_OPTIONS.HOUR:
            dateFormat = dateFormat || AppDefaults$$1.timeFormat;
            // If date is invalid, check if data is in form of hh:mm a
            if (!strMoment.isValid()) {
                strMoment = moment(new Date().toDateString() + ' ' + concatStr);
                if (strMoment.isValid()) {
                    // As only time is present, roll up at the hour level with given time format
                    momentLocale._calendar.sameDay = function () {
                        return '[' + filterDate(this.valueOf(), dateFormat, ROLLUP_PATTERNS.HOUR, datePipe) + ']';
                    };
                }
            }
            // round off to nearest last hour
            strMoment = strMoment.startOf('hour');
            momentLocale._calendar.sameElse = getSameElseFormat;
            groupByKey = strMoment.calendar(currMoment);
            break;
        case TIME_ROLLUP_OPTIONS.WEEK:
            groupByKey = filterDate(strMoment.valueOf(), dateFormat, ROLLUP_PATTERNS.WEEK, datePipe);
            break;
        case TIME_ROLLUP_OPTIONS.MONTH:
            groupByKey = filterDate(strMoment.valueOf(), dateFormat, ROLLUP_PATTERNS.MONTH, datePipe);
            break;
        case TIME_ROLLUP_OPTIONS.YEAR:
            groupByKey = strMoment.format(ROLLUP_PATTERNS.YEAR);
            break;
        case TIME_ROLLUP_OPTIONS.DAY:
            dateFormat = dateFormat || AppDefaults$$1.dateFormat;
            strMoment = strMoment.startOf('day'); // round off to current day
            momentLocale._calendar.sameElse = getSameElseFormat;
            groupByKey = strMoment.calendar(currMoment);
            break;
    }
    // If invalid date is returned, Categorize it as Others.
    if (groupByKey === 'Invalid date') {
        return GROUP_BY_OPTIONS.OTHERS;
    }
    return groupByKey;
};
// groups the fields based on the groupby value.
const groupDataByField = (groupby, match, innerItem, dateFormat, datePipe, AppDefaults$$1, liData) => {
    // get the groupby field value from the liData or innerItem in the liData.
    let concatStr = _.get(innerItem ? liData[innerItem] : liData, groupby);
    // by default set the undefined groupKey as 'others'
    if (_.isUndefined(concatStr) || _.isNull(concatStr) || concatStr.toString().trim() === '') {
        return GROUP_BY_OPTIONS.OTHERS;
    }
    // if match prop is alphabetic ,get the starting alphabet of the word as key.
    if (match === GROUP_BY_OPTIONS.ALPHABET) {
        concatStr = concatStr.substr(0, 1);
    }
    // if match contains the time options then get the concatStr using 'getTimeRolledUpString'
    if (_.includes(_.values(TIME_ROLLUP_OPTIONS), match)) {
        concatStr = getTimeRolledUpString(concatStr, match, dateFormat, datePipe, AppDefaults$$1);
    }
    return concatStr;
};
/**
 * This method toggles all the list items inside the each list group.
 * @param el, component reference on which groupby is applied.
 */
const toggleAllHeaders = (el) => {
    const groups = $(el.nativeElement).find('.item-group');
    groups.find('.group-list-item').toggle();
    // toggle the collapse icon on list header.
    const groupIcons = groups.find('li.list-group-header .app-icon');
    if (groupIcons) {
        _.forEach(groupIcons, (icon) => {
            icon = $(icon);
            if (icon.hasClass('wi-chevron-down')) {
                icon.removeClass('wi-chevron-down').addClass('wi-chevron-up');
            }
            else {
                icon.removeClass('wi-chevron-up').addClass('wi-chevron-down');
            }
        });
    }
};
/**
 * On list header click, toggle the list items in this group.
 * and also toggle the header icon.
 * @param $event
 */
const handleHeaderClick = ($event) => {
    const selectedGroup = $($event.target).closest('.item-group'), selectedAppIcon = selectedGroup.find('li.list-group-header .app-icon');
    if (selectedAppIcon.hasClass('wi-chevron-down')) {
        selectedAppIcon.removeClass('wi-chevron-down').addClass('wi-chevron-up');
    }
    else {
        selectedAppIcon.removeClass('wi-chevron-up').addClass('wi-chevron-down');
    }
    selectedGroup.find('.group-list-item').toggle();
};
/**
 * configures reordering the items.
 * @param $el element to be sortable
 * @param options object containing the sortable options.
 * @param startCb callback on drag start on the element.
 * @param updateCb callback triggerred when sorting is stopped and the DOM position has changed.
 */
const configureDnD = ($el, options, startCb, updateCb) => {
    const sortOptions = Object.assign({
        containment: $el,
        delay: 100,
        opacity: 0.8,
        helper: 'clone',
        zIndex: 1050,
        tolerance: 'pointer',
        start: startCb,
        update: updateCb
    }, options);
    $el.sortable(sortOptions);
};

const getValidLink = (link) => {
    const routRegex = /^(\/|#\/|#)(?!\W).*/;
    if (link) {
        if (routRegex.test(link)) {
            link = _.first(link.match(/[\w]+.*/g)) || '';
            return `#/${link}`;
        }
        if (_.startsWith(link, 'www.')) {
            return `//${link}`;
        }
        return link;
    }
};
class DatasetAwareNavComponent extends StylableComponent {
    constructor(inj, WIDGET_CONFIG) {
        super(inj, WIDGET_CONFIG);
        this.nodes = [];
        // debounce function for reset nodes functions.
        this._resetNodes = _.debounce(this.resetNodes, 50);
        this.securityService = this.inj.get(SecurityService);
        this.binditemlabel = this.nativeElement.getAttribute('itemlabel.bind');
        this.binditemicon = this.nativeElement.getAttribute('itemicon.bind');
        this.binditemaction = this.nativeElement.getAttribute('itemaction.bind');
        this.binditembadge = this.nativeElement.getAttribute('itembadge.bind');
        this.binditemchildren = this.nativeElement.getAttribute('itemchildren.bind');
        this.binditemid = this.nativeElement.getAttribute('itemid.bind');
        this.binditemlink = this.nativeElement.getAttribute('itemlink.bind');
        this.binditemtarget = this.nativeElement.getAttribute('itemtarget.bind');
        this.binduserrole = this.nativeElement.getAttribute('userrole.bind');
    }
    /**
     * constructs individual node for the widget model.
     * @param fields
     * @param node
     */
    getNode(fields, node) {
        const context = this.viewParent.pageScope || this.viewParent;
        const children = getEvaluatedData(node, { expression: 'itemchildren', bindExpression: this.binditemchildren }, context) || _.get(node, fields.childrenField);
        const navNode = {
            action: getEvaluatedData(node, { expression: 'itemaction', bindExpression: this.binditemaction }, context) || _.get(node, fields.actionField),
            badge: getEvaluatedData(node, { expression: 'itembadge', bindExpression: this.binditembadge }, context) || _.get(node, fields.badgeField),
            children: Array.isArray(children) ? this.getNodes(children) : [],
            class: _.get(node, fields.classField),
            disabled: node.disabled,
            icon: getEvaluatedData(node, { expression: 'itemicon', bindExpression: this.binditemicon }, context) || _.get(node, fields.iconField),
            id: getEvaluatedData(node, { expression: 'itemid', bindExpression: this.binditemid }, context) || _.get(node, fields.idField),
            label: getEvaluatedData(node, { expression: 'itemlabel', bindExpression: this.binditemlabel }, context) || _.get(node, fields.labelField),
            link: getValidLink(getEvaluatedData(node, { expression: 'itemlink', bindExpression: this.binditemlink }, context) || _.get(node, fields.linkField)),
            target: getValidLink(getEvaluatedData(node, { expression: 'itemtarget', bindExpression: this.binditemtarget }, context) || _.get(node, fields.targetField)),
            role: getEvaluatedData(node, { expression: 'userrole', bindExpression: this.binduserrole }, context),
            // older projects have display field & data field property for menu.
            value: this.datafield ? (this.datafield === 'All Fields' ? node : findValueOf(node, this.datafield)) : node
        };
        return _.omitBy(navNode, _.isUndefined);
    }
    resetItemFieldMap() {
        this._itemFieldMap = null;
    }
    getItemFieldsMap() {
        if (!this._itemFieldMap) {
            this._itemFieldMap = {
                idField: this.itemid || 'itemid',
                iconField: this.itemicon || 'icon',
                labelField: this.itemlabel || 'label',
                linkField: this.itemlink || 'link',
                targetField: this.itemtarget || 'target',
                badgeField: this.itembadge || 'badge',
                childrenField: this.itemchildren || 'children',
                classField: this.itemclass || 'class',
                actionField: this.itemaction || 'action'
            };
        }
        return this._itemFieldMap;
    }
    /**
     * returns array for the value passed as nv.
     * nv: 'a,b' => [{label:a, value:a}, {label:b, value:b}]
     * nv: [1,2] => [{label:1, value:1}, {label:2, value:2}]
     * nv: [{obj}, {obj}] => [{obj}, {obj}]
     * @param nv
     */
    prepareNodeDataSet(nv) {
        nv = createArrayFrom(nv);
        return nv.map((val) => {
            if (!isObject(val)) {
                return {
                    label: val,
                    value: val
                };
            }
            return val;
        });
    }
    /**
     * constructs dataset form the nav elements.
     */
    getNodes(nv = this.dataset || {}) {
        let nodes = getOrderedDataset(this.prepareNodeDataSet(nv), this.orderby) || [];
        if (nodes.length) {
            const userRole = this.userrole;
            const nodeFields = this.getItemFieldsMap();
            nodes = nodes.reduce((result, node) => {
                if (validateAccessRoles(node[userRole], this.securityService.loggedInUser)) {
                    result.push(this.getNode(nodeFields, node));
                }
                return result;
            }, []);
        }
        return nodes;
    }
    // enable the inherited class to extend this method.
    resetNodes() {
        this.resetItemFieldMap();
        this.nodes = this.getNodes();
        $appDigest();
    }
    onPropertyChange(key, nv, ov) {
        switch (key) {
            case 'dataset':
            case 'itemicon':
            case 'itemlabel':
            case 'itemlink':
            case 'itemtarget':
            case 'itemclass':
            case 'itemchildren':
            case 'orderby':
                // calls resetnodes method after 50ms. any calls within 50ms will be ignored.
                this._resetNodes();
                break;
        }
        super.onPropertyChange(key, nv, ov);
    }
}

const DEFAULT_CLS$4 = 'breadcrumb app-breadcrumb';
const WIDGET_CONFIG$4 = { widgetType: 'wm-breadcrumb', hostClass: DEFAULT_CLS$4 };
class BreadcrumbComponent extends DatasetAwareNavComponent {
    constructor(inj, route, location, beforeNavigateCB) {
        super(inj, WIDGET_CONFIG$4);
        this.route = route;
        this.location = location;
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
        this.disableMenuContext = !!beforeNavigateCB;
    }
    /**
     * Gets the first path found based on the key provided inside info Object.
     * @param info - Info object which has properties key(Active Page Name) and isPathFound[boolean] is set true if path found.
     * @param children - a child Object form children Array.
     * @param path - final path.
     * @returns {*|Array}: returns array of objects which represents the final path.
     */
    getPath(info, children, path = []) {
        children.forEach((child) => {
            // return if path already found.
            if (info.isPathFound) {
                return path;
            }
            // if key is matched set path found to true and return the path.
            if (child.id === info.key) {
                info.isPathFound = true;
                // only push the child object by omiting the children within it.
                path.push(child);
                return path;
            }
            // if the node has children make a recursive call.
            if (child.children.length) {
                path.push(child);
                this.getPath(info, child.children, path);
                // if path is not found in that node pop the node.
                if (!info.isPathFound) {
                    path.pop();
                }
            }
        });
        // return the path.
        return path;
    }
    getCurrentRoute() {
        return this.location.path().substr(1).split('?')[0];
    }
    // over rides resetNode function, generating path for the breadcrumb.
    resetNodes() {
        super.resetNodes();
        // get path only if the widget have id property.
        if (this.itemid || this.binditemid) {
            this.nodes = this.getPath({ key: this.getCurrentRoute(), isPathFound: false }, this.nodes);
        }
    }
    onItemClick($event, $item) {
        $event.preventDefault();
        const locals = { $item: $item.value, $event };
        const canNavigate = !(this.invokeEventCallback('beforenavigate', locals) === false);
        const linkTarget = $item.target;
        let itemLink = $item.link;
        if (itemLink && canNavigate) {
            if (itemLink.startsWith('#/') && (!linkTarget || linkTarget === '_self')) {
                const queryParams = getUrlParams(itemLink);
                itemLink = getRouteNameFromLink(itemLink);
                this.route.navigate([itemLink], { queryParams });
            }
            else {
                openLink(itemLink, linkTarget);
            }
        }
    }
}
BreadcrumbComponent.initializeProps = registerProps$5();
BreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmBreadcrumb]',
                template: "<li *ngFor=\"let item of nodes; let last = last; let index = index\" [ngClass]=\"{active: last}\" class=\"{{item.class}}\">\n    <i class=\"{{item.icon}}\"></i>\n    <a [title]=\"item.label\" href=\"javascript:void(0)\" [wmNavigationControl]=\"item.link\" [disableMenuContext]=\"disableMenuContext || !!item.action\" (click)=\"onItemClick($event, item)\" *ngIf=\"!last\" [textContent]=\"item.label\"></a>\n    <label *ngIf=\"last\" [textContent]=\"item.label\"></label>\n</li>\n",
                providers: [
                    provideAsWidgetRef(BreadcrumbComponent)
                ]
            }] }
];
/** @nocollapse */
BreadcrumbComponent.ctorParameters = () => [
    { type: Injector },
    { type: Router },
    { type: Location },
    { type: String, decorators: [{ type: Attribute, args: ['beforenavigate.event',] }] }
];

const registerProps$6 = () => {
    register('wm-button', new Map([
        ['badgevalue', PROP_STRING],
        ['caption', PROP_STRING],
        ['class', Object.assign({ value: 'btn-default' }, PROP_STRING)],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['disabled', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconposition', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['name', PROP_STRING],
        ['shortcutkey', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['type', PROP_STRING]
    ]));
};

const DEFAULT_CLS$5 = 'btn app-button';
const WIDGET_CONFIG$5 = {
    widgetType: 'wm-button',
    hostClass: DEFAULT_CLS$5,
    displayType: DISPLAY_TYPE.INLINE_BLOCK
};
class ButtonComponent extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$5);
        styler(this.nativeElement, this);
    }
}
ButtonComponent.initializeProps = registerProps$6();
ButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'button[wmButton]',
                template: "<img data-identifier=\"img\" alt=\"button image\" class=\"button-image-icon\" [src]=\"iconurl | image\" *ngIf=\"iconurl\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin}\"/>\n<i class=\"app-icon {{iconclass}}\" aria-hidden=\"true\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin, fontSize:iconwidth}\" *ngIf=\"iconclass\"></i>\n<span class=\"sr-only\" *ngIf=\"iconclass\">{{caption | trustAs:'html'}} {{appLocale.LABEL_ICON}}</span>\n<span class=\"btn-caption\" [innerHTML]=\"caption | trustAs:'html'\"></span>\n<ng-content select=\".caret\"></ng-content>\n<span *ngIf=\"badgevalue\" class=\"badge pull-right\" [textContent]=\"badgevalue\"></span>",
                providers: [
                    provideAsWidgetRef(ButtonComponent)
                ]
            }] }
];
/** @nocollapse */
ButtonComponent.ctorParameters = () => [
    { type: Injector }
];
ButtonComponent.propDecorators = {
    type: [{ type: HostBinding, args: ['type',] }],
    tabindex: [{ type: HostBinding, args: ['tabIndex',] }],
    disabled: [{ type: HostBinding, args: ['disabled',] }],
    shortcutkey: [{ type: HostBinding, args: ['attr.accesskey',] }],
    iconposition: [{ type: HostBinding, args: ['attr.icon-position',] }]
};

const registerProps$7 = () => {
    register('wm-buttongroup', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['vertical', PROP_BOOLEAN]
    ]));
};

const DEFAULT_CLS$6 = 'btn-group app-button-group';
const WIDGET_CONFIG$6 = {
    widgetType: 'wm-buttongroup',
    hostClass: DEFAULT_CLS$6
};
class ButtonGroupDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$6);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
ButtonGroupDirective.initializeProps = registerProps$7();
ButtonGroupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmButtonGroup]',
                providers: [
                    provideAsWidgetRef(ButtonGroupDirective)
                ]
            },] }
];
/** @nocollapse */
ButtonGroupDirective.ctorParameters = () => [
    { type: Injector }
];
ButtonGroupDirective.propDecorators = {
    vertical: [{ type: HostBinding, args: ['class.btn-group-vertical',] }]
};

const registerProps$8 = () => {
    const props = new Map([
        ['calendartype', Object.assign({ value: 'basic' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['controls', Object.assign({ value: 'navigation, today, year, month, week, day' }, PROP_STRING)],
        ['dataset', PROP_ANY],
        ['datavalue', PROP_STRING],
        ['eventallday', PROP_STRING],
        ['eventclass', PROP_STRING],
        ['eventend', PROP_STRING],
        ['eventstart', PROP_STRING],
        ['eventtitle', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showindevice', Object.assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
        ['view', PROP_STRING],
        ['selectionmode', PROP_STRING]
    ]);
    if (isMobileApp()) {
        props.set('view', Object.assign({ value: 'day' }, PROP_STRING));
    }
    register('wm-calendar', props);
};

const DEFAULT_CLS$7 = 'app-calendar';
const dateFormats = ['yyyy-MM-dd', 'yyyy-M-dd', 'M-dd-yyyy', 'MM-dd-yy', 'yyyy, dd MMMM', 'yyyy, MMM dd', 'MM/dd/yyyy', 'M/d/yyyy', 'EEE, dd MMM yyyy', 'EEE MMM dd yyyy', 'EEEE, MMMM dd, yyyy', 'timestamp'];
const defaultHeaderOptions = {
    left: 'prev next today',
    center: 'title',
    right: 'month basicWeek basicDay'
};
const VIEW_TYPES = {
    BASIC: 'basic',
    AGENDA: 'agenda',
    LIST: 'list'
};
const BUTTON_TEXT = {
    YEAR: 'Year',
    MONTH: 'Month',
    WEEK: 'Week',
    DAY: 'Day',
    TODAY: 'Today'
};
const SELECTION_MODES = {
    NONE: 'none',
    SINGLE: 'single',
    MULTIPLE: 'multiple'
};
const NEXT_DAY_THRESHOLD = {
    START: '00:00',
    END: '24:00'
};
const getEventMomentValue = (value, key) => {
    let isDate = false;
    dateFormats.forEach((format) => {
        // moment supports uppercase formats
        if (moment(value, format.toUpperCase(), true).isValid()) {
            isDate = true;
            return false;
        }
    });
    // if the value is date then for end date the value should be end of the day as the calendar is approximating it to the start.
    if (isDate && key === 'end') {
        return moment(value).endOf('day');
    }
    return moment(value);
};
const getUTCDateTime = (dateObj) => {
    dateObj = _.isObject(dateObj) ? dateObj : moment(dateObj);
    const year = dateObj.format('YYYY'), 
    // javascript starts the month count from '0' where as moment returns the human count
    month = dateObj.format('MM') - 1, day = dateObj.format('DD'), hours = dateObj.format('HH'), minutes = dateObj.format('mm'), seconds = dateObj.format('ss');
    return new Date(year, month, day, hours, minutes, seconds);
};
const WIDGET_CONFIG$7 = { widgetType: 'wm-calendar', hostClass: DEFAULT_CLS$7 };
// mobile calendar class names
const multipleEventClass = 'app-calendar-event';
const doubleEventClass = multipleEventClass + ' two';
const singleEventClass = multipleEventClass + ' one';
const dateFormat = 'YYYY/MM/DD';
class CalendarComponent extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$7);
        this.controls = 'navigation, today, year, month, week, day';
        this.eventSources = [];
        this.dataSetEvents = {
            events: []
        };
        this.changesStack = [];
        this.invokeOnViewRenderback = _.debounce(() => this.invokeEventCallback('viewrender', { $view: this.calendarOptions }), 300);
        // calendarOptions to the calendar
        this.calendarOptions = {
            calendar: {
                height: 600,
                eventSources: this.eventSources,
                editable: true,
                locale: getSessionStorageItem('selectedLocale') || 'en',
                selectable: false,
                header: defaultHeaderOptions,
                nextDayThreshold: NEXT_DAY_THRESHOLD,
                views: {
                    month: {
                        eventLimit: 0
                    }
                },
                unselectAuto: false,
                eventDrop: this.eventDrop.bind(this),
                eventResizeStart: this.onEventChangeStart.bind(this),
                eventDragStart: this.onEventChangeStart.bind(this),
                eventResize: this.eventResize.bind(this),
                eventClick: this.eventClick.bind(this),
                select: this.select.bind(this),
                eventRender: this.eventRender.bind(this),
                viewRender: this.viewRender.bind(this)
            }
        };
        this.dayClass = [];
        this.mobileCalendar = isMobile();
        this.eventSources.push(this.dataSetEvents);
    }
    // this function selects the default date given for the calendar
    selectDate() {
        let start, end;
        if (_.isObject(this.datavalue)) {
            start = this.datavalue.start;
            end = this.datavalue.end;
        }
        else {
            start = moment(this.datavalue);
            end = moment(this.datavalue).add(1, 'day').startOf('day');
        }
        this.$fullCalendar.fullCalendar('gotoDate', start); // after selecting the date go to the date.
        this.$fullCalendar.fullCalendar('select', start, end);
    }
    // changes the calendar view to the default date given for the calendar.
    gotoDate() {
        this.$fullCalendar.fullCalendar('gotoDate', moment(this.datavalue));
    }
    // this function takes the calendar view to the a year ahead
    gotoNextYear() {
        this.$fullCalendar.fullCalendar('nextYear');
    }
    // this function takes the calendar view to the a year before
    gotoPrevYear() {
        this.$fullCalendar.fullCalendar('prevYear');
    }
    /**
     * this function takes the calendar view to the specified month
     * @param monthVal, 1-12 value of month
     */
    gotoMonth(monthVal) {
        const presentDay = this.$fullCalendar.fullCalendar('getDate');
        const presentMonthVal = new Date(presentDay).getMonth();
        if (presentMonthVal < monthVal) {
            this.$fullCalendar.fullCalendar('gotoDate', presentDay.add(monthVal - presentMonthVal - 1, 'M'));
        }
        else {
            this.$fullCalendar.fullCalendar('gotoDate', presentDay.subtract(presentMonthVal - monthVal + 1, 'M'));
        }
    }
    // this function takes the calendar view to the a month ahead
    gotoNextMonth() {
        const presentDay = this.$fullCalendar.fullCalendar('getDate');
        this.$fullCalendar.fullCalendar('gotoDate', presentDay.add(1, 'M'));
    }
    // this function takes the calendar view to the a month before
    gotoPrevMonth() {
        const presentDay = this.$fullCalendar.fullCalendar('getDate');
        this.$fullCalendar.fullCalendar('gotoDate', presentDay.subtract(1, 'M'));
    }
    // this function re-renders the events assigned to the calendar.
    rerenderEvents() {
        this.$fullCalendar.fullCalendar('rerenderEvents');
    }
    setSelectedData(start, end) {
        let dataset = this.dataset;
        if (!dataset) {
            return;
        }
        const filteredDates = [];
        const eventStartKey = this.eventstart || 'start';
        const eventEndKey = this.eventend || 'end';
        const startDate = moment(new Date(start)).format('MM/DD/YYYY');
        const endDate = moment(new Date(end)).subtract(1, 'days').format('MM/DD/YYYY');
        dataset = dataset.data || dataset;
        dataset.forEach((value) => {
            if (!value[eventStartKey]) {
                return;
            }
            const eventStartDate = moment(new Date(value[eventStartKey])).format('MM/DD/YYYY');
            const eventEndDate = moment(new Date(value[eventEndKey] || value[eventStartKey])).format('MM/DD/YYYY');
            const eventExists = moment(eventStartDate).isSameOrAfter(startDate) && moment(eventEndDate).isSameOrBefore(endDate);
            if (eventExists) {
                filteredDates.push(value);
            }
        });
        return filteredDates;
    }
    eventDrop($newData, $delta, $revertFunc, $event, $ui, $view) {
        this.invokeEventCallback('eventdrop', { $event, $newData, $oldData: this.oldData, $delta, $revertFunc, $ui, $view });
    }
    select(start, end, jsEvent, $view) {
        this.selecteddates = { start: getUTCDateTime(start), end: getUTCDateTime(end) };
        this.selecteddata = this.setSelectedData(start, end);
        this.invokeEventCallback('select', { $start: start.valueOf(), $end: end.valueOf(), $view, $data: this.selecteddata });
    }
    eventResize($newData, $delta, $revertFunc, $event, $ui, $view) {
        this.invokeEventCallback('eventresize', { $event, $newData, $oldData: this.oldData, $delta, $revertFunc, $ui, $view });
    }
    onEventChangeStart(event) {
        this.oldData = getClonedObject(event);
    }
    eventClick($data, $event, $view) {
        this.invokeEventCallback('eventclick', { $event, $data, $view });
    }
    eventRender($data, $event, $view) {
        if (this.calendartype === VIEW_TYPES.LIST) {
            this.$fullCalendar.find('.fc-list-table').addClass('table');
        }
        this.invokeEventCallback('eventrender', { $event, $data, $view });
    }
    viewRender($view) {
        this.currentview = { start: $view.start.format(), end: $view.end.subtract(1, 'days').format() };
        if (this.calendartype === VIEW_TYPES.LIST) {
            this.$fullCalendar.find('.fc-list-table').addClass('table');
        }
        this.invokeEventCallback('viewrender', { $view });
    }
    // update the calendar header options once the controls changes
    updateCalendarHeaderOptions() {
        const ctrls = this.controls, viewType = this.calendartype, regEx = new RegExp('\\bday\\b', 'g');
        let left = '', right = '';
        if (ctrls && viewType) {
            if (_.includes(ctrls, 'navigation')) {
                left += ' prev next';
            }
            if (_.includes(ctrls, 'today')) {
                left += ' today';
            }
            if (_.includes(ctrls, 'year')) {
                right += (viewType === VIEW_TYPES.LIST) ? 'listYear' : '';
            }
            if (_.includes(ctrls, 'month')) {
                right += (viewType === VIEW_TYPES.LIST) ? ' listMonth' : ' month';
            }
            if (_.includes(ctrls, 'week')) {
                right += (viewType === VIEW_TYPES.BASIC) ? ' basicWeek' : (viewType === VIEW_TYPES.LIST) ? ' listWeek' : ' agendaWeek';
            }
            if (regEx.test(ctrls)) {
                right += (viewType === VIEW_TYPES.BASIC) ? ' basicDay' : (viewType === VIEW_TYPES.LIST) ? ' listDay' : ' agendaDay';
            }
            _.extend(this.calendarOptions.calendar.header, { 'left': left, 'right': right });
        }
    }
    // to calculate the height for the event limit and parsing the value when it is percentage based.
    calculateHeight(height) {
        const $parent = $(this.nativeElement).parent(), elHeight = height || '650px';
        let parentHeight = $parent.css('height'), computedHeight;
        if (_.includes(elHeight, '%')) {
            if (_.includes(parentHeight, '%')) {
                parentHeight = $parent.height();
            }
            computedHeight = (parseInt(parentHeight, 10) * Number(elHeight.replace(/\%/g, ''))) / 100;
        }
        else {
            computedHeight = parseInt(elHeight, 10);
        }
        this.calendarOptions.calendar.views.month.eventLimit = parseInt('' + computedHeight / 200, 10) + 1;
        return computedHeight;
    }
    triggerMobileCalendarChange() {
        this.prepareCalendarEvents();
        // change the model so that the view is rendered again with the events , after the dataset is changed.
        this.proxyModel = this.proxyModel || moment().valueOf();
        this.selecteddates = {
            start: moment(this.proxyModel).valueOf(),
            end: moment(this.proxyModel).endOf('day').valueOf()
        };
        this.invokeEventCallback('eventrender', { $data: this.eventData });
    }
    // prepares events for the mobie calendar
    prepareCalendarEvents() {
        let eventDay, dataset;
        this.eventData = {};
        if (!this.dataset) {
            return;
        }
        dataset = this.dataset;
        dataset = _.isArray(dataset) ? dataset : (_.isObject(dataset) ? [dataset] : []);
        this.events = dataset || this.constructCalendarDataset(dataset);
        this.events.forEach((event) => {
            const eventStart = event.start || event[this.eventstart];
            if (eventStart) {
                eventDay = moment(eventStart).startOf('day').format(dateFormat);
                if (this.eventData[eventDay]) {
                    this.eventData[eventDay].push(event);
                }
                else {
                    this.eventData[eventDay] = [event];
                }
                if (this.mobileCalendar) {
                    // custom class on the date in the date picker.
                    this.dayClass.push({
                        date: new Date(eventStart).setHours(0, 0, 0, 0),
                        mode: 'day',
                        clazz: this.getDayClass({ eventDay: eventDay })
                    });
                }
            }
        });
        // add the eventData on the calendar by calling refreshView
        if (this.mobileCalendar && this._datepickerInnerComponent) {
            this._datepickerInnerComponent.refreshView();
        }
    }
    // constructs the calendar dataset by mapping the eventstart, eventend, eventtitle etc.,
    constructCalendarDataset(eventSource) {
        const properties = {
            title: this.eventtitle || 'title',
            allDay: this.eventallday || 'allday',
            start: this.eventstart || 'start',
            end: this.eventend || 'end',
            className: this.eventclass || 'className'
        };
        eventSource.forEach((obj) => {
            _.mapKeys(properties, (value, key) => {
                let objVal;
                if (key === 'title') {
                    objVal = getEvaluatedData(obj, { expression: value }, this.viewParent);
                }
                else if (key === 'allDay') {
                    objVal = !!_.get(obj, value);
                }
                else {
                    objVal = _.get(obj, value);
                }
                if (!objVal) {
                    return;
                }
                if (key === 'start' || key === 'end') {
                    objVal = getEventMomentValue(objVal, key);
                }
                obj[key] = objVal;
            });
        });
        return eventSource;
    }
    setLocale() {
        const year = _.get(this.appLocale, 'LABEL_CALENDAR_YEAR') || BUTTON_TEXT.YEAR;
        const month = _.get(this.appLocale, 'LABEL_CALENDAR_MONTH') || BUTTON_TEXT.MONTH;
        const week = _.get(this.appLocale, 'LABEL_CALENDAR_WEEK') || BUTTON_TEXT.WEEK;
        const day = _.get(this.appLocale, 'LABEL_CALENDAR_DAY') || BUTTON_TEXT.DAY;
        const today = _.get(this.appLocale, 'LABEL_CALENDAR_TODAY') || BUTTON_TEXT.TODAY;
        this.calendarOptions.calendar.buttonText = { year, month, week, day, today,
            'listYear': year,
            'listMonth': month,
            'listWeek': week,
            'listDay': day
        };
    }
    ngOnInit() {
        super.ngOnInit();
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER, ['height']);
        if (this.mobileCalendar) {
            if (!this.view || this.view === 'week') {
                this.view = 'day';
            }
            this.triggerMobileCalendarChange();
        }
        else {
            this.setLocale();
        }
    }
    onStyleChange(key, nv, ov) {
        super.onStyleChange(key, nv, ov);
        if (key === 'height') {
            this.calendarOptions.calendar.height = this.calculateHeight(nv);
            this.updateCalendarOptions('option', 'height', this.calendarOptions.calendar.height);
        }
    }
    onPropertyChange(key, nv, ov) {
        super.onPropertyChange(key, nv, ov);
        switch (key) {
            case 'selectionmode':
                if (nv !== SELECTION_MODES.NONE) {
                    this.calendarOptions.calendar.selectable = true;
                    this.updateCalendarOptions('option', 'selectable', true);
                    if (nv === SELECTION_MODES.SINGLE) {
                        this.calendarOptions.calendar.selectConstraint = {
                            start: '00:00',
                            end: '24:00'
                        };
                        this.updateCalendarOptions('option', 'selectConstraint', this.calendarOptions.calendar.selectConstraint);
                    }
                    else {
                        this.updateCalendarOptions('option', 'selectConstraint', {});
                    }
                }
                else {
                    this.calendarOptions.calendar.selectable = false;
                    this.updateCalendarOptions('option', 'selectable', false);
                }
                break;
            case 'view':
                if (nv !== 'month' || this.calendartype === VIEW_TYPES.LIST) {
                    this.calendarOptions.calendar.defaultView = this.calendartype + _.capitalize(nv);
                }
                else {
                    this.calendarOptions.calendar.defaultView = nv;
                }
                this.updateCalendarOptions('changeView', this.calendarOptions.calendar.defaultView);
                break;
            case 'calendartype':
                this.calendartype = nv || 'basic';
            case 'controls':
                this.updateCalendarHeaderOptions();
                break;
            case 'dataset':
                let dataSet;
                this.dataset = nv;
                dataSet = createArrayFrom(getClonedObject(nv));
                dataSet = this.constructCalendarDataset(dataSet);
                this.dataSetEvents.events = dataSet.filter((event) => {
                    event.start = event.start || event.end;
                    if (event.start) {
                        return true;
                    }
                });
                if (this.mobileCalendar) {
                    this.triggerMobileCalendarChange();
                }
                else {
                    this.updateCalendarOptions('removeEvents');
                    this.updateCalendarOptions('addEventSource', this.dataSetEvents.events);
                    this.updateCalendarOptions('rerenderEvents');
                }
                break;
        }
    }
    // Returns the default date when the datavalue is provided
    getDefaultDate() {
        if (this.datavalue) {
            return new Date(this.datavalue);
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (this.mobileCalendar && this._datepicker) {
            let lastActiveDate = this._datepicker.activeDate;
            // renderview when active date changes
            this._datepicker.activeDateChange.subscribe((dt) => {
                const prevYear = lastActiveDate.getYear();
                const prevMonth = lastActiveDate.getMonth();
                const selectedYear = dt.getYear();
                const selectedMonth = dt.getMonth();
                // invoke renderView only when month is changed.
                if (prevMonth !== selectedMonth || prevYear !== selectedYear) {
                    lastActiveDate = dt;
                    this.renderMobileView(dt);
                }
            });
            this._datepickerInnerComponent = this._datepicker._datePicker;
            this.renderMobileView(moment(this.datavalue));
            this.registerDestroyListener($watch('_datepickerInnerComponent.datepickerMode', this, {}, (nv, ov) => {
                if (ov && !_.isEmpty(ov)) {
                    this.invokeOnViewRenderback();
                }
            }));
            return;
        }
        this.$fullCalendar = $(this._calendar.nativeElement);
        this.$fullCalendar.fullCalendar(this.calendarOptions.calendar);
        // if the changes are already stacked before calendar renders then execute them when needed
        if (this.changesStack.length) {
            this.changesStack.forEach((changeObj) => {
                this.$fullCalendar.fullCalendar(changeObj.operationType, changeObj.argumentKey, changeObj.argumentValue);
            });
            this.changesStack.length = 0;
        }
    }
    updateCalendarOptions(operationType, argumentKey, argumentValue) {
        if (!this.$fullCalendar) {
            this.changesStack.push({
                operationType: operationType,
                argumentKey: argumentKey,
                argumentValue: argumentValue
            });
            return;
        }
        this.$fullCalendar.fullCalendar(operationType, argumentKey, argumentValue);
    }
    redraw() {
        this.updateCalendarOptions('render');
    }
    // on date change invoke the select event, and if date has event on it then invoke the event click.
    onValueChange(value) {
        this.proxyModel = value;
        const selectedDate = this.proxyModel && moment(this.proxyModel).startOf('day').format(dateFormat), selectedEventData = this.eventData[selectedDate], start = moment(this.proxyModel), end = moment(this.proxyModel).endOf('day');
        this.selecteddata = selectedEventData;
        this.selecteddates = {
            'start': moment(selectedDate).valueOf(),
            'end': moment(selectedDate).endOf('day').valueOf()
        };
        this.calendarOptions.calendar.select(start.valueOf(), end.valueOf(), {}, this, selectedEventData);
        if (selectedEventData) {
            this.calendarOptions.calendar.eventClick(selectedEventData, {}, this);
        }
    }
    // returns the custom class for the events depending on the length of the events for that day.
    getDayClass(data) {
        const eventDay = data.eventDay;
        if (!_.isEmpty(this.eventData) && this.eventData[eventDay]) {
            const eventsLength = this.eventData[eventDay].length;
            if (eventsLength === 1) {
                return singleEventClass;
            }
            if (eventsLength === 2) {
                return doubleEventClass;
            }
            return multipleEventClass;
        }
        return '';
    }
    // sets the current view and invokes the viewrender method.
    renderMobileView(viewObj) {
        let startDate, endDate;
        if (!viewObj) {
            return;
        }
        startDate = moment(viewObj).startOf('month').valueOf();
        endDate = moment(viewObj).endOf('month').valueOf();
        this.currentview = { start: startDate, end: endDate };
        this.invokeOnViewRenderback();
    }
}
CalendarComponent.initializeProps = registerProps$8();
CalendarComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmCalendar]',
                template: "<div *ngIf=\"!mobileCalendar\" #calendar></div>\n\n<datepicker *ngIf=\"mobileCalendar\" #datepicker [(ngModel)]=\"proxyModel\"\n            [initDate]=\"getDefaultDate()\"\n            [minDate]=\"minDate\"\n            [datepickerMode]=\"view\"\n            [showWeeks]=\"false\"\n            [customClass]=\"dayClass\"\n            (selectionDone)=\"onValueChange($event)\">\n</datepicker>\n\n\n\n",
                providers: [
                    provideAsWidgetRef(CalendarComponent)
                ],
                encapsulation: ViewEncapsulation.None,
                styles: ["/*!\n * FullCalendar v3.10.0\n * Docs & License: https://fullcalendar.io/\n * (c) 2018 Adam Shaw\n */.fc{direction:ltr;text-align:left}.fc-rtl{text-align:right}body .fc{font-size:1em}.fc-highlight{background:#bce8f1;opacity:.3}.fc-bgevent{background:#8fdf82;opacity:.3}.fc-nonbusiness{background:#d7d7d7}.fc button{box-sizing:border-box;margin:0;height:2.1em;padding:0 .6em;font-size:1em;white-space:nowrap;cursor:pointer}.fc button::-moz-focus-inner{margin:0;padding:0}.fc-state-default{border:1px solid;background-color:#f5f5f5;background-image:linear-gradient(to bottom,#fff,#e6e6e6);background-repeat:repeat-x;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);color:#333;text-shadow:0 1px 1px rgba(255,255,255,.75);box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05)}.fc-state-default.fc-corner-left{border-top-left-radius:4px;border-bottom-left-radius:4px}.fc-state-default.fc-corner-right{border-top-right-radius:4px;border-bottom-right-radius:4px}.fc button .fc-icon{position:relative;top:-.05em;margin:0 .2em;vertical-align:middle}.fc-state-active,.fc-state-disabled,.fc-state-down,.fc-state-hover{color:#333;background-color:#e6e6e6}.fc-state-hover{color:#333;text-decoration:none;background-position:0 -15px;transition:background-position .1s linear}.fc-state-active,.fc-state-down{background-color:#ccc;background-image:none;box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05)}.fc-state-disabled{cursor:default;background-image:none;opacity:.65;box-shadow:none}.fc-button-group{display:inline-block}.fc .fc-button-group>*{float:left;margin:0 0 0 -1px}.fc .fc-button-group>:first-child{margin-left:0}.fc-popover{position:absolute;box-shadow:0 2px 6px rgba(0,0,0,.15)}.fc-popover .fc-header{padding:2px 4px}.fc-popover .fc-header .fc-title{margin:0 2px}.fc-popover .fc-header .fc-close{cursor:pointer}.fc-ltr .fc-popover .fc-header .fc-title,.fc-rtl .fc-popover .fc-header .fc-close{float:left}.fc-ltr .fc-popover .fc-header .fc-close,.fc-rtl .fc-popover .fc-header .fc-title{float:right}.fc-divider{border-style:solid;border-width:1px}hr.fc-divider{height:0;margin:0;padding:0 0 2px;border-width:1px 0}.fc-clear{clear:both}.fc-bg,.fc-bgevent-skeleton,.fc-helper-skeleton,.fc-highlight-skeleton{position:absolute;top:0;left:0;right:0}.fc-bg{bottom:0}.fc-bg table{height:100%}.fc table{width:100%;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{border-style:solid;border-width:1px;padding:0;vertical-align:top}.fc td.fc-today{border-style:double}a[data-goto]{cursor:pointer}a[data-goto]:hover{text-decoration:underline}.fc .fc-row{border-style:solid;border-width:0}.fc-row table{border-left:0 hidden transparent;border-right:0 hidden transparent;border-bottom:0 hidden transparent}.fc-row:first-child table{border-top:0 hidden transparent}.fc-row{position:relative}.fc-row .fc-bg{z-index:1}.fc-row .fc-bgevent-skeleton,.fc-row .fc-highlight-skeleton{bottom:0}.fc-row .fc-bgevent-skeleton table,.fc-row .fc-highlight-skeleton table{height:100%}.fc-row .fc-bgevent-skeleton td,.fc-row .fc-highlight-skeleton td{border-color:transparent}.fc-row .fc-bgevent-skeleton{z-index:2}.fc-row .fc-highlight-skeleton{z-index:3}.fc-row .fc-content-skeleton{position:relative;z-index:4;padding-bottom:2px}.fc-row .fc-helper-skeleton{z-index:5}.fc .fc-row .fc-content-skeleton table,.fc .fc-row .fc-content-skeleton td,.fc .fc-row .fc-helper-skeleton td{background:0 0;border-color:transparent}.fc-row .fc-content-skeleton td,.fc-row .fc-helper-skeleton td{border-bottom:0}.fc-row .fc-content-skeleton tbody td,.fc-row .fc-helper-skeleton tbody td{border-top:0}.fc-scroller{-webkit-overflow-scrolling:touch}.fc-scroller>.fc-day-grid,.fc-scroller>.fc-time-grid{position:relative;width:100%}.fc-event{position:relative;display:block;font-size:.85em;line-height:1.3;border-radius:3px;border:1px solid #3a87ad}.fc-event,.fc-event-dot{background-color:#3a87ad}.fc-event,.fc-event:hover{color:#fff;text-decoration:none}.fc-event.fc-draggable,.fc-event[href]{cursor:pointer}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc-event .fc-bg{z-index:1;background:#fff;opacity:.25}.fc-event .fc-content{position:relative;z-index:2}.fc-event .fc-resizer{position:absolute;z-index:4;display:none}.fc-event.fc-allow-mouse-resize .fc-resizer,.fc-event.fc-selected .fc-resizer{display:block}.fc-event.fc-selected .fc-resizer:before{content:\"\";position:absolute;z-index:9999;top:50%;left:50%;width:40px;height:40px;margin-left:-20px;margin-top:-20px}.fc-event.fc-selected{z-index:9999!important;box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event.fc-selected.fc-dragging{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-h-event.fc-selected:before{content:\"\";position:absolute;z-index:3;top:-10px;bottom:-10px;left:0;right:0}.fc-ltr .fc-h-event.fc-not-start,.fc-rtl .fc-h-event.fc-not-end{margin-left:0;border-left-width:0;padding-left:1px;border-top-left-radius:0;border-bottom-left-radius:0}.fc-ltr .fc-h-event.fc-not-end,.fc-rtl .fc-h-event.fc-not-start{margin-right:0;border-right-width:0;padding-right:1px;border-top-right-radius:0;border-bottom-right-radius:0}.fc-ltr .fc-h-event .fc-start-resizer,.fc-rtl .fc-h-event .fc-end-resizer{cursor:w-resize;left:-1px}.fc-ltr .fc-h-event .fc-end-resizer,.fc-rtl .fc-h-event .fc-start-resizer{cursor:e-resize;right:-1px}.fc-h-event.fc-allow-mouse-resize .fc-resizer{width:7px;top:-1px;bottom:-1px}.fc-h-event.fc-selected .fc-resizer{border-radius:4px;width:6px;height:6px;background:#fff;top:50%;margin-top:-4px;border:1px solid;border-color:inherit}.fc-ltr .fc-h-event.fc-selected .fc-start-resizer,.fc-rtl .fc-h-event.fc-selected .fc-end-resizer{margin-left:-4px}.fc-ltr .fc-h-event.fc-selected .fc-end-resizer,.fc-rtl .fc-h-event.fc-selected .fc-start-resizer{margin-right:-4px}.fc-day-grid-event{margin:1px 2px 0;padding:0 1px}tr:first-child>td>.fc-day-grid-event{margin-top:2px}.fc-day-grid-event.fc-selected:after{content:\"\";position:absolute;z-index:1;top:-1px;right:-1px;bottom:-1px;left:-1px;background:#000;opacity:.25}.fc-day-grid-event .fc-content{white-space:nowrap;overflow:hidden}.fc-day-grid-event .fc-time{font-weight:700}.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer,.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer{margin-left:-2px}.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer,.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer{margin-right:-2px}a.fc-more{margin:1px 3px;font-size:.85em;cursor:pointer;text-decoration:none}a.fc-more:hover{text-decoration:underline}.fc-limited{display:none}.fc-day-grid .fc-row{z-index:1}.fc-more-popover{z-index:2;width:220px}.fc-more-popover .fc-event-container{padding:10px}.fc-now-indicator{position:absolute;border:0 solid red}.fc-unselectable{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent}.fc-unthemed .fc-content,.fc-unthemed .fc-divider,.fc-unthemed .fc-list-heading td,.fc-unthemed .fc-list-view,.fc-unthemed .fc-popover,.fc-unthemed .fc-row,.fc-unthemed tbody,.fc-unthemed td,.fc-unthemed th,.fc-unthemed thead{border-color:#ddd}.fc-unthemed .fc-popover{background-color:#fff;border-width:1px;border-style:solid}.fc-unthemed .fc-divider,.fc-unthemed .fc-list-heading td,.fc-unthemed .fc-popover .fc-header{background:#eee}.fc-unthemed .fc-popover .fc-header .fc-close{color:#666;font-size:.9em;margin-top:2px}.fc-unthemed td.fc-today{background:#fcf8e3}.fc-unthemed .fc-disabled-day{background:#d7d7d7;opacity:.3}.fc-icon{display:inline-block;height:1em;line-height:1em;font-size:1em;text-align:center;overflow:hidden;font-family:\"Courier New\",Courier,monospace;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.fc-icon:after{position:relative}.fc-icon-left-single-arrow:after{content:\"\\2039\";font-weight:700;font-size:200%;top:-7%}.fc-icon-right-single-arrow:after{content:\"\\203A\";font-weight:700;font-size:200%;top:-7%}.fc-icon-left-double-arrow:after{content:\"\\AB\";font-size:160%;top:-7%}.fc-icon-right-double-arrow:after{content:\"\\BB\";font-size:160%;top:-7%}.fc-icon-left-triangle:after{content:\"\\25C4\";font-size:125%;top:3%}.fc-icon-right-triangle:after{content:\"\\25BA\";font-size:125%;top:3%}.fc-icon-down-triangle:after{content:\"\\25BC\";font-size:125%;top:2%}.fc-icon-x:after{content:\"\\D7\";font-size:200%;top:6%}.fc-unthemed .fc-list-item:hover td{background-color:#f5f5f5}.ui-widget .fc-disabled-day{background-image:none}.fc-popover>.ui-widget-header+.ui-widget-content{border-top:0}.ui-widget .fc-event{color:#fff;text-decoration:none;font-weight:400}.ui-widget td.fc-axis{font-weight:400}.fc-time-grid .fc-slats .ui-widget-content{background:0 0}.fc.fc-bootstrap3 a{text-decoration:none}.fc.fc-bootstrap3 a[data-goto]:hover{text-decoration:underline}.fc-bootstrap3 hr.fc-divider{border-color:inherit}.fc-bootstrap3 .fc-today.alert{border-radius:0}.fc-bootstrap3 .fc-popover .panel-body{padding:0}.fc-bootstrap3 .fc-time-grid .fc-slats table{background:0 0}.fc.fc-bootstrap4 a{text-decoration:none}.fc.fc-bootstrap4 a[data-goto]:hover{text-decoration:underline}.fc-bootstrap4 hr.fc-divider{border-color:inherit}.fc-bootstrap4 .fc-today.alert{border-radius:0}.fc-bootstrap4 a.fc-event:not([href]):not([tabindex]){color:#fff}.fc-bootstrap4 .fc-popover.card{position:absolute}.fc-bootstrap4 .fc-popover .card-body{padding:0}.fc-bootstrap4 .fc-time-grid .fc-slats table{background:0 0}.fc-toolbar{text-align:center}.fc-toolbar.fc-header-toolbar{margin-bottom:1em}.fc-toolbar.fc-footer-toolbar{margin-top:1em}.fc-toolbar .fc-left{float:left}.fc-toolbar .fc-right{float:right}.fc-toolbar .fc-center{display:inline-block}.fc .fc-toolbar>*>*{float:left;margin-left:.75em}.fc .fc-toolbar>*>:first-child{margin-left:0}.fc-toolbar h2{margin:0}.fc-toolbar button{position:relative}.fc-toolbar .fc-state-hover,.fc-toolbar .ui-state-hover{z-index:2}.fc-toolbar .fc-state-down{z-index:3}.fc-toolbar .fc-state-active,.fc-toolbar .ui-state-active{z-index:4}.fc-toolbar button:focus{z-index:5}.fc-view-container *,.fc-view-container :after,.fc-view-container :before{box-sizing:content-box}.fc-view,.fc-view>table{position:relative;z-index:1}.fc-basicDay-view .fc-content-skeleton,.fc-basicWeek-view .fc-content-skeleton{padding-bottom:1em}.fc-basic-view .fc-body .fc-row{min-height:4em}.fc-row.fc-rigid{overflow:hidden}.fc-row.fc-rigid .fc-content-skeleton{position:absolute;top:0;left:0;right:0}.fc-day-top.fc-other-month{opacity:.3}.fc-basic-view .fc-day-number,.fc-basic-view .fc-week-number{padding:2px}.fc-basic-view th.fc-day-number,.fc-basic-view th.fc-week-number{padding:0 2px}.fc-ltr .fc-basic-view .fc-day-top .fc-day-number{float:right}.fc-rtl .fc-basic-view .fc-day-top .fc-day-number{float:left}.fc-ltr .fc-basic-view .fc-day-top .fc-week-number{float:left;border-radius:0 0 3px}.fc-rtl .fc-basic-view .fc-day-top .fc-week-number{float:right;border-radius:0 0 0 3px}.fc-basic-view .fc-day-top .fc-week-number{min-width:1.5em;text-align:center;background-color:#f2f2f2;color:grey}.fc-basic-view td.fc-week-number{text-align:center}.fc-basic-view td.fc-week-number>*{display:inline-block;min-width:1.25em}.fc-agenda-view .fc-day-grid{position:relative;z-index:2}.fc-agenda-view .fc-day-grid .fc-row{min-height:3em}.fc-agenda-view .fc-day-grid .fc-row .fc-content-skeleton{padding-bottom:1em}.fc .fc-axis{vertical-align:middle;padding:0 4px;white-space:nowrap}.fc-ltr .fc-axis{text-align:right}.fc-rtl .fc-axis{text-align:left}.fc-time-grid,.fc-time-grid-container{position:relative;z-index:1}.fc-time-grid{min-height:100%}.fc-time-grid table{border:0 hidden transparent}.fc-time-grid>.fc-bg{z-index:1}.fc-time-grid .fc-slats,.fc-time-grid>hr{position:relative;z-index:2}.fc-time-grid .fc-content-col{position:relative}.fc-time-grid .fc-content-skeleton{position:absolute;z-index:3;top:0;left:0;right:0}.fc-time-grid .fc-business-container{position:relative;z-index:1}.fc-time-grid .fc-bgevent-container{position:relative;z-index:2}.fc-time-grid .fc-highlight-container{z-index:3;position:relative}.fc-time-grid .fc-event-container{position:relative;z-index:4}.fc-time-grid .fc-now-indicator-line{z-index:5}.fc-time-grid .fc-helper-container{position:relative;z-index:6}.fc-time-grid .fc-slats td{height:1.5em;border-bottom:0}.fc-time-grid .fc-slats .fc-minor td{border-top-style:dotted}.fc-time-grid .fc-highlight{position:absolute;left:0;right:0}.fc-ltr .fc-time-grid .fc-event-container{margin:0 2.5% 0 2px}.fc-rtl .fc-time-grid .fc-event-container{margin:0 2px 0 2.5%}.fc-time-grid .fc-bgevent,.fc-time-grid .fc-event{position:absolute;z-index:1}.fc-time-grid .fc-bgevent{left:0;right:0}.fc-v-event.fc-not-start{border-top-width:0;padding-top:1px;border-top-left-radius:0;border-top-right-radius:0}.fc-v-event.fc-not-end{border-bottom-width:0;padding-bottom:1px;border-bottom-left-radius:0;border-bottom-right-radius:0}.fc-time-grid-event{overflow:hidden}.fc-time-grid-event.fc-selected{overflow:visible}.fc-time-grid-event.fc-selected .fc-bg{display:none}.fc-time-grid-event .fc-content{overflow:hidden}.fc-time-grid-event .fc-time,.fc-time-grid-event .fc-title{padding:0 1px}.fc-time-grid-event .fc-time{font-size:.85em;white-space:nowrap}.fc-time-grid-event.fc-short .fc-content{white-space:nowrap}.fc-time-grid-event.fc-short .fc-time,.fc-time-grid-event.fc-short .fc-title{display:inline-block;vertical-align:top}.fc-time-grid-event.fc-short .fc-time span{display:none}.fc-time-grid-event.fc-short .fc-time:before{content:attr(data-start)}.fc-time-grid-event.fc-short .fc-time:after{content:\"\\A0-\\A0\"}.fc-time-grid-event.fc-short .fc-title{font-size:.85em;padding:0}.fc-time-grid-event.fc-allow-mouse-resize .fc-resizer{left:0;right:0;bottom:0;height:8px;overflow:hidden;line-height:8px;font-size:11px;font-family:monospace;text-align:center;cursor:s-resize}.fc-time-grid-event.fc-allow-mouse-resize .fc-resizer:after{content:\"=\"}.fc-time-grid-event.fc-selected .fc-resizer{border-radius:5px;width:8px;height:8px;background:#fff;left:50%;margin-left:-5px;bottom:-5px;border:1px solid;border-color:inherit}.fc-time-grid .fc-now-indicator-line{border-top-width:1px;left:0;right:0}.fc-time-grid .fc-now-indicator-arrow{margin-top:-5px}.fc-ltr .fc-time-grid .fc-now-indicator-arrow{left:0;border-width:5px 0 5px 6px;border-top-color:transparent;border-bottom-color:transparent}.fc-rtl .fc-time-grid .fc-now-indicator-arrow{right:0;border-width:5px 6px 5px 0;border-top-color:transparent;border-bottom-color:transparent}.fc-event-dot{display:inline-block;width:10px;height:10px;border-radius:5px}.fc-rtl .fc-list-view{direction:rtl}.fc-list-view{border-width:1px;border-style:solid}.fc .fc-list-table{table-layout:auto}.fc-list-table td{border-width:1px 0 0;padding:8px 14px}.fc-list-table tr:first-child td{border-top-width:0}.fc-list-heading{border-bottom-width:1px}.fc-list-heading td{font-weight:700}.fc-ltr .fc-list-heading-main{float:left}.fc-ltr .fc-list-heading-alt,.fc-rtl .fc-list-heading-main{float:right}.fc-rtl .fc-list-heading-alt{float:left}.fc-list-item.fc-has-url{cursor:pointer}.fc-list-item-marker,.fc-list-item-time{white-space:nowrap;width:1px}.fc-ltr .fc-list-item-marker{padding-right:0}.fc-rtl .fc-list-item-marker{padding-left:0}.fc-list-item-title a{text-decoration:none;color:inherit}.fc-list-item-title a[href]:hover{text-decoration:underline}.fc-list-empty-wrap2{position:absolute;top:0;left:0;right:0;bottom:0}.fc-list-empty-wrap1{width:100%;height:100%;display:table}.fc-list-empty{display:table-cell;vertical-align:middle;text-align:center}.fc-unthemed .fc-list-empty{background-color:#eee}"]
            }] }
];
/** @nocollapse */
CalendarComponent.ctorParameters = () => [
    { type: Injector }
];
CalendarComponent.propDecorators = {
    _calendar: [{ type: ViewChild, args: ['calendar',] }],
    _datepicker: [{ type: ViewChild, args: ['datepicker',] }]
};

const registerProps$9 = () => {
    register('wm-card', new Map([
        ['actions', PROP_STRING],
        ['class', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['imageheight', Object.assign({ value: '200px' }, PROP_STRING)],
        ['itemaction', PROP_STRING],
        ['itemchildren', PROP_STRING],
        ['itemicon', PROP_STRING],
        ['itemlabel', PROP_STRING],
        ['itemlink', PROP_STRING],
        ['name', PROP_STRING],
        ['picturesource', PROP_STRING],
        ['picturetitle', Object.assign({ value: '' }, PROP_STRING)],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['subheading', PROP_STRING],
        ['title', PROP_STRING],
        ['userrole', PROP_STRING]
    ]));
};

const registerProps$a = () => {
    register('wm-menu', new Map([
        ['accessroles', Object.assign({ value: 'Everyone' }, PROP_STRING)],
        ['animateitems', PROP_STRING],
        ['autoclose', Object.assign({ value: 'always' }, PROP_STRING)],
        ['autoopen', Object.assign({ value: 'never' }, PROP_STRING)],
        ['caption', PROP_STRING],
        ['class', PROP_STRING],
        ['dataset', Object.assign({ value: 'Menu Item 1, Menu Item 2, Menu Item 3' }, PROP_ANY)],
        ['hint', Object.assign({ value: '' }, PROP_STRING)],
        ['iconclass', PROP_STRING],
        ['iconposition', Object.assign({ value: 'left' }, PROP_STRING)],
        ['itemaction', PROP_STRING],
        ['itemchildren', PROP_STRING],
        ['itemclass', PROP_STRING],
        ['itemicon', PROP_STRING],
        ['itemlabel', PROP_STRING],
        ['itemlink', PROP_STRING],
        ['itemtarget', PROP_STRING],
        ['linktarget', Object.assign({ value: '_self' }, PROP_STRING)],
        ['menuclass', PROP_STRING],
        ['menulayout', PROP_STRING],
        ['menuposition', PROP_STRING],
        ['name', PROP_STRING],
        ['orderby', PROP_STRING],
        ['shortcutkey', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['type', Object.assign({ value: 'menu' }, PROP_STRING)],
        ['userrole', PROP_STRING]
    ]));
};

const registerProps$b = () => {
    register('wm-nav', new Map([
        ['autoclose', Object.assign({ value: 'always' }, PROP_STRING)],
        ['autoopen', Object.assign({ value: 'never' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['dataset', PROP_ANY],
        ['iconposition', Object.assign({ value: 'left' }, PROP_STRING)],
        ['itemlabel', PROP_STRING],
        ['itemlink', PROP_STRING],
        ['itemicon', PROP_STRING],
        ['itemclass', PROP_STRING],
        ['itemchildren', PROP_STRING],
        ['itemaction', PROP_STRING],
        ['itembadge', PROP_STRING],
        ['itemtarget', PROP_STRING],
        ['layout', PROP_STRING],
        ['name', PROP_STRING],
        ['orderby', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['type', PROP_STRING],
        ['userrole', PROP_STRING]
    ]));
};

const DEFAULT_CLS$8 = 'nav app-nav';
const WIDGET_CONFIG$8 = { widgetType: 'wm-nav', hostClass: DEFAULT_CLS$8 };
const NavClassMap = {
    pills: 'nav-pills',
    tabs: 'nav-tabs',
    navbar: 'navbar-nav'
};
class NavComponent extends DatasetAwareNavComponent {
    constructor(inj, cdRef, router, userDefinedExecutionContext, app, selectEventCB) {
        super(inj, WIDGET_CONFIG$8);
        this.cdRef = cdRef;
        this.router = router;
        this.userDefinedExecutionContext = userDefinedExecutionContext;
        this.app = app;
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
        this.disableMenuContext = !!selectEventCB;
        this.pageScope = this.viewParent;
    }
    get activePageName() {
        return this.app.activePageName;
    }
    setNavType(type) {
        addClass(this.nativeElement, NavClassMap[type]);
    }
    setNavLayout(layout) {
        addClass(this.nativeElement, `nav-${layout}`);
    }
    onNavSelect($event, item, liRef) {
        $event.preventDefault();
        if (this.activeNavLINode) {
            removeClass(this.activeNavLINode, 'active');
        }
        this.activeNavLINode = liRef;
        addClass(liRef, 'active');
        this.selecteditem = item;
        this.invokeEventCallback('select', { $event, $item: item.value });
        let itemLink = item.link;
        const itemAction = item.action;
        const linkTarget = item.target;
        if (itemAction) {
            if (!this.itemActionFn) {
                this.itemActionFn = $parseEvent(itemAction);
            }
            this.itemActionFn(this.userDefinedExecutionContext, Object.create(item));
        }
        if (itemLink) {
            if (itemLink.startsWith('#/') && (!linkTarget || linkTarget === '_self')) {
                const queryParams = getUrlParams(itemLink);
                itemLink = getRouteNameFromLink(itemLink);
                this.router.navigate([itemLink], { queryParams });
            }
            else {
                openLink(itemLink, linkTarget);
            }
        }
    }
    ngOnInit() {
        super.ngOnInit();
        this.setNavType(this.type);
        this.setNavLayout(this.layout);
    }
    /**
     * invoked from the menu widget when a menu item is selected.
     * @param $event
     * @param widget
     * @param $item
     */
    onMenuItemSelect($event, widget, $item) {
        this.selecteditem = _.omit($item, ['children', 'value']);
        this.invokeEventCallback('select', { $event, $item: this.selecteditem });
    }
}
NavComponent.initializeProps = registerProps$b();
NavComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmNav]',
                template: "<ng-template #menuRef let-item=\"item\" let-index=\"index\">\n    <div wmMenu dropdown\n         type=\"anchor\"\n         autoclose.bind=\"autoclose\"\n         iconclass.bind=\"item.icon\"\n         autoopen.bind=\"autoopen\"\n         caption.bind=\"item.label\"\n         dataset.bind=\"item.children\"\n         iconposition.bind=\"iconposition\"\n         select.event=\"onMenuItemSelect($event, widget, $item)\"></div>\n</ng-template>\n\n<ng-template #anchorRef let-item=\"item\" let-index=\"index\" let-liRef=\"liRef\">\n    <a wmAnchor\n       [disableMenuContext]=\"disableMenuContext || !!item.action\"\n       [wmNavigationControl]=\"item.link\"\n       caption.bind=\"item.label\"\n       iconclass.bind=\"item.icon\"\n       badgevalue.bind=\"item.badge\"\n       iconposition.bind=\"iconposition\"\n       click.event=\"onNavSelect($event, item, liRef)\"></a>\n</ng-template>\n\n<li class=\"app-nav-item {{item.class}}\" *ngFor=\"let item of nodes; let index = index;\" #liRef [ngClass]=\"{active: item.link === '#/' + activePageName}\">\n    <ng-container [ngTemplateOutlet]=\"anchorRef\" [ngTemplateOutletContext]=\"{item: item, index:index, liRef: liRef}\" *ngIf=\"!item.children.length\"></ng-container>\n    <ng-container [ngTemplateOutlet]=\"menuRef\" [ngTemplateOutletContext]=\"{item: item, index:index}\"  *ngIf=\"item.children.length\"></ng-container>\n</li>\n\n<ng-content *ngIf=\"!nodes.length\" select=\"[wmNavItem]\"></ng-content>",
                providers: [
                    provideAsWidgetRef(NavComponent)
                ]
            }] }
];
/** @nocollapse */
NavComponent.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: Router },
    { type: UserDefinedExecutionContext },
    { type: App },
    { type: undefined, decorators: [{ type: Attribute, args: ['select.event',] }] }
];

const KEYBOARD_MOVEMENTS = {
    MOVE_UP: 'UP-ARROW',
    MOVE_LEFT: 'LEFT-ARROW',
    MOVE_RIGHT: 'RIGHT-ARROW',
    MOVE_DOWN: 'DOWN-ARROW',
    ON_ENTER: 'ENTER',
    ON_TAB: 'TAB',
    ON_ESCAPE: 'ESC'
};
const MENU_POSITION = {
    UP_LEFT: 'up,left',
    UP_RIGHT: 'up,right',
    DOWN_LEFT: 'down,left',
    DOWN_RIGHT: 'down,right',
    INLINE: 'inline'
};
const POSITION = {
    DOWN_RIGHT: 'down,right',
    DOWN_LEFT: 'down,left',
    UP_RIGHT: 'up,right',
    UP_LEFT: 'up,left',
    INLINE: 'inline'
};
const CARET_CLS = {
    UP: 'fa-caret-up',
    DOWN: 'fa-caret-down'
};
const PULL_CLS = {
    LEFT: 'pull-left',
    RIGHT: 'pull-right'
};
const AUTO_OPEN = {
    NEVER: 'never',
    ACTIVE_PAGE: 'activepage',
    ALWAYS: 'always'
};
const WIDGET_CONFIG$9 = { widgetType: 'wm-menu', hostClass: 'dropdown app-menu' };
class MenuComponent extends DatasetAwareNavComponent {
    constructor(inj, route, bsDropdown, parentNav, selectEventCB) {
        super(inj, WIDGET_CONFIG$9);
        this.route = route;
        this.bsDropdown = bsDropdown;
        this.parentNav = parentNav;
        this.selectEventCB = selectEventCB;
        this.menuCaret = 'fa-caret-down';
        this._selectFirstItem = false;
        if (parentNav) {
            this.disableMenuContext = !!parentNav.disableMenuContext;
        }
        else {
            this.disableMenuContext = !!selectEventCB;
        }
    }
    onShow() {
        if (this._selectFirstItem) {
            setTimeout(() => {
                this.$element.find('> ul[wmmenudropdown] li.app-menu-item:first > a').focus();
            });
        }
        $appDigest();
    }
    onHide() {
        this.$element.find('>.dropdown-toggle').focus();
        this.$element.find('li').removeClass('open');
        this._selectFirstItem = false;
        $appDigest();
    }
    onKeyDown($event, eventAction) {
        const KEY_MOVEMENTS = _.clone(KEYBOARD_MOVEMENTS);
        if (this.menuposition === MENU_POSITION.UP_RIGHT) {
            KEY_MOVEMENTS.MOVE_UP = 'DOWN-ARROW';
            KEY_MOVEMENTS.MOVE_DOWN = 'UP-ARROW';
        }
        else if (this.menuposition === MENU_POSITION.UP_LEFT) {
            KEY_MOVEMENTS.MOVE_UP = 'DOWN-ARROW';
            KEY_MOVEMENTS.MOVE_DOWN = 'UP-ARROW';
            KEY_MOVEMENTS.MOVE_LEFT = 'RIGHT-ARROW';
            KEY_MOVEMENTS.MOVE_RIGHT = 'LEFT-ARROW';
        }
        else if (this.menuposition === MENU_POSITION.DOWN_LEFT) {
            KEY_MOVEMENTS.MOVE_LEFT = 'RIGHT-ARROW';
            KEY_MOVEMENTS.MOVE_RIGHT = 'LEFT-ARROW';
        }
        if (_.includes([KEY_MOVEMENTS.MOVE_DOWN, KEY_MOVEMENTS.MOVE_RIGHT], eventAction)) {
            if (!this.bsDropdown.isOpen) {
                this._selectFirstItem = true;
                this.bsDropdown.show();
            }
            else {
                this.$element.find('> ul[wmmenudropdown] li.app-menu-item:first > a').focus();
            }
        }
        else if (eventAction === KEY_MOVEMENTS.ON_ENTER) {
            this.bsDropdown.toggle(true);
        }
        else if (_.includes([KEY_MOVEMENTS.MOVE_UP, KEY_MOVEMENTS.MOVE_LEFT], eventAction)) {
            this.bsDropdown.hide();
        }
        $event.preventDefault();
    }
    /**
     * returns true if the menu has link to the current page.
     * @param nodes
     */
    hasLinkToCurrentPage(nodes) {
        return nodes.some(node => {
            if (isActiveNavItem(node.link, this.route.url)) {
                return true;
            }
            if (node.children) {
                return this.hasLinkToCurrentPage(node.children);
            }
        });
    }
    resetNodes() {
        super.resetNodes();
        // open the menu if any of its menu items has link to current page and if autoopen value is 'active page'
        if ((this.autoopen === AUTO_OPEN.ACTIVE_PAGE && this.hasLinkToCurrentPage(this.nodes)) || this.autoopen === AUTO_OPEN.ALWAYS) {
            this.bsDropdown.show();
        }
    }
    ngOnInit() {
        super.ngOnInit();
        this.setMenuPosition();
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'tabindex') {
            return;
        }
        if (key === 'autoclose') {
            this.bsDropdown.autoClose = nv !== 'disabled';
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    setMenuPosition() {
        switch (this.menuposition) {
            case POSITION.DOWN_RIGHT:
                removeClass(this.nativeElement, 'dropup');
                this.menualign = PULL_CLS.LEFT;
                this.menuCaret = CARET_CLS.DOWN;
                break;
            case POSITION.DOWN_LEFT:
                removeClass(this.nativeElement, 'dropup');
                this.menualign = PULL_CLS.RIGHT;
                this.menuCaret = CARET_CLS.DOWN;
                break;
            case POSITION.UP_LEFT:
                addClass(this.nativeElement, 'dropup');
                this.menualign = PULL_CLS.RIGHT;
                this.menuCaret = CARET_CLS.UP;
                break;
            case POSITION.UP_RIGHT:
                addClass(this.nativeElement, 'dropup');
                this.menualign = PULL_CLS.LEFT;
                this.menuCaret = CARET_CLS.UP;
                break;
            case POSITION.INLINE:
                this.menualign = 'dropinline-menu';
                break;
        }
    }
    onMenuItemSelect(args) {
        const { $event } = args;
        const $item = args.$item.value;
        this.invokeEventCallback('select', { $event, $item });
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.nativeElement.querySelector('.dropdown-toggle'), this);
    }
}
MenuComponent.initializeProps = registerProps$a();
MenuComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmMenu]',
                template: "<ng-template #menuTemplate>\n    <button wmButton\n            dropdownToggle\n            aria-haspopup=\"true\"\n            aria-expanded=\"false\"\n\n            class=\"btn app-button dropdown-toggle {{menuclass}}\"\n            hint.bind=\"hint\"\n            shortcutkey.bind=\"shortcutkey\"\n            tabindex.bind=\"tabindex\"\n            caption.bind=\"caption\"\n            iconclass.bind=\"iconclass\"\n            iconposition.bind=\"iconposition\">\n        <span class=\"pull-right caret fa {{menuCaret}}\"></span>\n    </button>\n</ng-template>\n\n<ng-template #innerTemplate>\n    <i class=\"app-icon {{iconclass}}\"></i>\n    <span class=\"caption\" [textContent]=\"caption\"></span>\n    <span class=\"pull-right caret fa {{menuCaret}}\"></span>\n</ng-template>\n\n<ng-container *ngIf=\"type === 'anchor'; else menuTemplate\">\n    <a wmAnchor\n       dropdownToggle\n\n       href=\"javascript:void(0);\"\n       role=\"button\"\n       aria-haspopup=\"true\"\n       aria-expanded=\"false\"\n\n       hint.bind=\"hint\"\n       class=\"dropdown-toggle {{menuclass}}\"\n       shortcutkey.bind=\"shortcutkey\"\n       tabindex.bind=\"tabindex\"\n       caption.bind=\"caption\"\n       iconclass.bind=\"iconclass\"\n       iconposition.bind=\"iconposition\"\n    >\n        <span class=\"pull-right caret fa {{menuCaret}}\"></span>\n    </a>\n</ng-container>\n\n<ul wmMenuDropdown [items]=\"nodes\" [ngClass]=\"menulayout\" class=\"icon-position-{{iconposition}}\" *dropdownMenu aria-labelledby=\"dropdownmenu\"></ul>\n",
                providers: [
                    provideAsWidgetRef(MenuComponent)
                ]
            }] }
];
/** @nocollapse */
MenuComponent.ctorParameters = () => [
    { type: Injector },
    { type: Router },
    { type: BsDropdownDirective, decorators: [{ type: Self }, { type: Optional }] },
    { type: NavComponent, decorators: [{ type: Optional }] },
    { type: String, decorators: [{ type: Attribute, args: ['select.event',] }] }
];
MenuComponent.propDecorators = {
    onShow: [{ type: HostListener, args: ['onShown',] }],
    onHide: [{ type: HostListener, args: ['onHidden',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown.arrowup', ['$event', '"UP-ARROW"'],] }, { type: HostListener, args: ['keydown.arrowdown', ['$event', '"DOWN-ARROW"'],] }, { type: HostListener, args: ['keydown.arrowright', ['$event', '"RIGHT-ARROW"'],] }, { type: HostListener, args: ['keydown.arrowleft', ['$event', '"LEFT-ARROW"'],] }, { type: HostListener, args: ['keydown.enter', ['$event', '"ENTER"'],] }]
};

const menuProps = ['itemlabel', 'itemicon', 'itemlink', 'itemaction', 'itemchildren', 'userrole'];
class MenuAdapterComponent extends StylableComponent {
    constructor(inj, WIDGET_CONFIG) {
        super(inj, WIDGET_CONFIG);
        this.pageScope = this.viewParent;
        this.binditemlabel = this.nativeElement.getAttribute('itemlabel.bind');
        this.binditemicon = this.nativeElement.getAttribute('itemicon.bind');
        this.binditemaction = this.nativeElement.getAttribute('itemaction.bind');
        this.binditemlink = this.nativeElement.getAttribute('itemlink.bind');
        this.binduserrole = this.nativeElement.getAttribute('userrole.bind');
        this.binditemchildren = this.nativeElement.getAttribute('itemchildren.bind');
    }
    onPropertyChange(key, nv, ov) {
        if (_.includes(menuProps, key) && this.menuRef) {
            this.menuRef.itemlabel = nv;
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        const subscriber = this.menuRefQL.changes.subscribe((menuRefQL) => {
            if (menuRefQL.first) {
                this.menuRef = menuRefQL.first;
                menuProps.forEach((prop) => {
                    const bindProp = `bind${prop}`;
                    if (this[bindProp]) {
                        this.menuRef[bindProp] = this[bindProp];
                    }
                    this.menuRef[prop] = this[prop];
                });
                subscriber.unsubscribe();
            }
        });
    }
}
MenuAdapterComponent.propDecorators = {
    menuRefQL: [{ type: ViewChildren, args: [MenuComponent,] }]
};

const DEFAULT_CLS$9 = 'app-card card app-panel';
const WIDGET_CONFIG$a = {
    widgetType: 'wm-card',
    hostClass: DEFAULT_CLS$9
};
class CardComponent extends MenuAdapterComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$a);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.SHELL);
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.cardContainerElRef.nativeElement, this, APPLY_STYLES_TYPE.INNER_SHELL);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'title' || key === 'subheading' || key === 'iconclass' || key === 'iconurl' || key === 'actions') {
            this.showHeader = !!(this.title || this.subheading || this.iconclass || this.iconurl || this.actions);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
CardComponent.initializeProps = registerProps$9();
CardComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmCard]',
                template: "<div class=\"app-card-header panel-heading\" *ngIf=\"showHeader\">\n    <div class=\"app-card-avatar\" *ngIf=\"iconclass || iconurl\">\n        <i class=\"app-icon\" [ngClass]=\"iconclass\" *ngIf=\"iconclass && !iconurl\"></i>\n        <img class=\"img-circle\" [src]=\"iconurl\" *ngIf=\"iconurl\" />\n    </div>\n    <div class=\"app-card-header-text\">\n        <h4 class=\"card-heading\" [textContent]=\"title\"></h4>\n        <h5 class=\"card-subheading text-muted\" [textContent]=\"subheading\"></h5>\n    </div>\n    <div class=\"panel-actions\" *ngIf=\"actions\">\n        <!-- TODO(punith) need to bind autoclose-->\n        <div wmMenu dropdown\n             [autoClose]=\"autoclose !== 'disabled'\"\n             class=\"panel-action\"\n             type=\"anchor\"\n             iconclass=\"wi wi-more-vert\"\n             menuposition=\"down,left\"\n             hint=\"Actions\"\n             caption=\"\"\n             dataset.bind=\"actions\">\n        </div>\n    </div>\n</div>\n<div class=\"app-card-image\" *ngIf=\"picturesource\"  [ngStyle]=\"{'max-height':imageheight}\">\n   <img wmPicture class=\"card-image\" picturesource.bind=\"picturesource\" hint.bind=\"picturetitle\" />\n</div>\n<div #cardContainerWrapper>\n    <ng-content select=\"[wmCardContent]\"></ng-content>\n</div>\n<div>\n    <ng-content select=\"[wmCardActions]\"></ng-content>\n</div>\n<div>\n    <ng-content select=\"[wmCardFooter]\"></ng-content>\n</div>",
                providers: [
                    provideAsWidgetRef(CardComponent)
                ]
            }] }
];
/** @nocollapse */
CardComponent.ctorParameters = () => [
    { type: Injector }
];
CardComponent.propDecorators = {
    cardContainerElRef: [{ type: ViewChild, args: ['cardContainerWrapper',] }]
};
// Todo(swathi) - menu

const registerProps$c = () => {
    register('wm-card-actions', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ]));
};

const DEFAULT_CLS$a = 'app-card-actions';
const WIDGET_CONFIG$b = {
    widgetType: 'wm-card-actions',
    hostClass: DEFAULT_CLS$a
};
class CardActionsDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$b);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
CardActionsDirective.initializeProps = registerProps$c();
CardActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmCardActions]'
            },] }
];
/** @nocollapse */
CardActionsDirective.ctorParameters = () => [
    { type: Injector }
];

const registerProps$d = () => {
    register('wm-card-content', new Map([
        ['class', PROP_STRING],
        ['content', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$b = 'app-card-content card-body card-block';
const WIDGET_CONFIG$c = {
    widgetType: 'wm-card-content',
    hostClass: DEFAULT_CLS$b
};
class CardContentComponent extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$c);
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.cardContentContainerElRef.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
CardContentComponent.initializeProps = registerProps$d();
CardContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmCardContent]',
                template: "<div partial-container-target #cardContentContainer>\n    <ng-content></ng-content>\n</div>",
                providers: [
                    provideAsWidgetRef(CardContentComponent)
                ]
            }] }
];
/** @nocollapse */
CardContentComponent.ctorParameters = () => [
    { type: Injector }
];
CardContentComponent.propDecorators = {
    cardContentContainerElRef: [{ type: ViewChild, args: ['cardContentContainer',] }]
};

const registerProps$e = () => {
    register('wm-card-footer', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ]));
};

const DEFAULT_CLS$c = 'app-card-footer text-muted card-footer';
const WIDGET_CONFIG$d = {
    widgetType: 'wm-card-footer',
    hostClass: DEFAULT_CLS$c
};
class CardFooterDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$d);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
CardFooterDirective.initializeProps = registerProps$e();
CardFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmCardFooter]'
            },] }
];
/** @nocollapse */
CardFooterDirective.ctorParameters = () => [
    { type: Injector }
];

const registerProps$f = () => {
    register('wm-chart', new Map([
        ['aggregation', Object.assign({ value: 'none' }, PROP_STRING)],
        ['aggregationcolumn', PROP_STRING],
        ['areaviewtype', Object.assign({ value: 'stack' }, PROP_STRING)],
        ['barspacing', Object.assign({ value: 'medium' }, PROP_STRING)],
        ['bubblesize', PROP_STRING],
        ['centerlabel', PROP_STRING],
        ['class', PROP_STRING],
        ['customcolors', PROP_STRING],
        ['dataset', PROP_ANY],
        ['datasource', PROP_STRING],
        ['donutratio', Object.assign({ value: 'medium' }, PROP_STRING)],
        ['formattype', { value: '', PROP_STRING }],
        ['groupby', PROP_STRING],
        ['height', { value: '210px', PROP_STRING }],
        ['highlightpoints', PROP_BOOLEAN],
        ['iconclass', PROP_STRING],
        ['interpolation', Object.assign({ value: 'linear' }, PROP_STRING)],
        ['labelthreshold', Object.assign({ value: 0.01 }, PROP_NUMBER)],
        ['labeltype', Object.assign({ value: 'percent' }, PROP_STRING)],
        ['legendtype', Object.assign({ value: 'furious' }, PROP_STRING)],
        ['linethickness', PROP_STRING],
        ['loadingdatamsg', Object.assign({ value: 'Loading...' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['nodatamessage', Object.assign({ value: 'No Data Available.' }, PROP_STRING)],
        ['offset', PROP_STRING],
        ['offsetbottom', Object.assign({ value: 55 }, PROP_NUMBER)],
        ['offsetleft', Object.assign({ value: 75 }, PROP_NUMBER)],
        ['offsetright', Object.assign({ value: 25 }, PROP_NUMBER)],
        ['offsettop', Object.assign({ value: 25 }, PROP_NUMBER)],
        ['orderby', PROP_STRING],
        ['reducexticks', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['shape', Object.assign({ value: 'circle' }, PROP_STRING)],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showlabels', Object.assign({ value: 'outside' }, PROP_STRING)],
        ['showlabelsoutside', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showlegend', Object.assign({ value: 'top' }, PROP_STRING)],
        ['showvalues', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['showxaxis', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showxdistance', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['showyaxis', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showydistance', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['staggerlabels', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['subheading', PROP_STRING],
        ['theme', PROP_STRING],
        ['title', PROP_STRING],
        ['tooltips', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['type', PROP_STRING],
        ['viewtype', Object.assign({ value: 'Grouped' }, PROP_STRING)],
        ['xaxisdatakey', PROP_STRING],
        ['xaxislabel', PROP_STRING],
        ['xaxislabeldistance', Object.assign({ value: 12 }, PROP_NUMBER)],
        ['xdateformat', PROP_STRING],
        ['xdomain', Object.assign({ value: 'Default' }, PROP_STRING)],
        ['xnumberformat', PROP_STRING],
        ['xunits', PROP_STRING],
        ['yaxisdatakey', PROP_STRING],
        ['yaxislabel', PROP_STRING],
        ['yaxislabeldistance', Object.assign({ value: 12 }, PROP_NUMBER)],
        ['ydomain', Object.assign({ value: 'Default' }, PROP_STRING)],
        ['ynumberformat', PROP_STRING],
        ['yunits', PROP_STRING]
    ]));
};

const chartTypes = ['Column', 'Line', 'Area', 'Cumulative Line', 'Bar', 'Pie', 'Donut', 'Bubble'], allShapes = ['circle', 'square', 'diamond', 'cross', 'triangle-up', 'triangle-down'];
const dateList = ['01/01/2001', '01/01/2002', '01/01/2003'], themes = {
    'Terrestrial': {
        colors: ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'],
        tooltip: {
            'backgroundColor': '#de7d28',
            'textColor': '#FFFFFF'
        }
    },
    'Annabelle': {
        colors: ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'],
        tooltip: {
            'backgroundColor': '#2e306f',
            'textColor': '#FFFFFF'
        }
    },
    'Azure': {
        colors: ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'],
        tooltip: {
            'backgroundColor': '#3182bd',
            'textColor': '#FFFFFF'
        }
    },
    'Retro': {
        colors: ['#0ca7a1', '#ffa615', '#334957', '#acc5c2', '#988f90', '#8accc9', '#515151', '#f27861', '#36c9fd', '#794668', '#0f709d', '#0d2738', '#44be78', '#4a1839', '#6a393f', '#557d8b', '#6c331c', '#1c1c1c', '#861500', '#09562a'],
        tooltip: {
            'backgroundColor': '#80513a',
            'textColor': '#FFFFFF'
        }
    },
    'Mellow': {
        colors: ['#f0dcbf', '#88c877', '#aeb918', '#2e2c23', '#ddddd2', '#dfe956', '#4c963b', '#5d3801', '#e1eec3', '#cd8472', '#fcfab3', '#9a4635', '#9295ad', '#2e3f12', '#565677', '#557d8b', '#4f4d02', '#0c0c1b', '#833324', '#24120e'],
        tooltip: {
            'backgroundColor': '#7c9e73',
            'textColor': '#FFFFFF'
        }
    },
    'Orient': {
        colors: ['#a80000', '#cc6c3c', '#f0e400', '#000084', '#fccc6c', '#009c6c', '#cc309c', '#78cc00', '#fc84e4', '#48e4fc', '#4878d8', '#186c0c', '#606060', '#a8a8a8', '#000000', '#d7d7d7', '#75a06e', '#190d0b', '#888888', '#694b84'],
        tooltip: {
            'backgroundColor': '#c14242',
            'textColor': '#FFFFFF'
        }
    },
    'GrayScale': {
        colors: ['#141414', '#353535', '#5b5b5b', '#848484', '#a8a8a8', '#c3c3c3', '#e0e0e0', '#c8c8c8', '#a5a5a5', '#878787', '#656565', '#4e4e4e', '#303030', '#1c1c1c', '#4f4f4f', '#3b3b3b', '#757575', '#606060', '#868686', '#c1c1c1'],
        tooltip: {
            'backgroundColor': '#575757',
            'textColor': '#FFFFFF'
        }
    },
    'Flyer': {
        colors: ['#3f454c', '#5a646e', '#848778', '#cededf', '#74c4dd', '#0946ed', '#380bb1', '#000ff0', '#f54a23', '#1db262', '#bca3aa', '#ffa500', '#a86b32', '#63a18c', '#56795e', '#934343', '#b75f5f', '#752d2d', '#4e1111', '#920606'],
        tooltip: {
            'backgroundColor': '#47637c',
            'textColor': '#FFFFFF'
        }
    },
    'Luminosity': {
        colors: ['#FFFFFF', '#e4e4e4', '#00bcd4', '#f0dd2f', '#00aabf', '#018376', '#e91e63', '#39e5d4', '#ff6d6d', '#00ff76', '#ff9800', '#969696', '#ff4200', '#e00000', '#95cbe5', '#5331ff', '#fff4a7', '#e7a800', '#0061e4', '#d5e7ff'],
        tooltip: {
            'backgroundColor': '#47637c',
            'textColor': '#FFFFFF'
        }
    }
}, basicProperties = ['xaxislabel', 'yaxislabel', 'xunits', 'yunits', 'xnumberformat', 'xdateformat', 'ynumberformat',
    'showvalues', 'showlabels', 'viewtype', 'areaviewtype', 'staggerlabels', 'reducexticks', 'offsettop', 'offsetbottom', 'offsetright', 'offsetleft',
    'barspacing', 'xaxislabeldistance', 'yaxislabeldistance', 'theme', 'labeltype', 'donutratio', 'showlabelsoutside', 'showxdistance', 'showydistance', 'shape', 'nodatamessage', 'captions', 'showxaxis', 'showyaxis',
    'centerlabel', 'customcolors', 'showlegend', 'legendtype', 'xdomain', 'ydomain', 'tooltips', 'linethickness', 'highlightpoints', 'interpolation', 'labelthreshold'], barSpacingMap = {
    'small': 0.3,
    'medium': 0.5,
    'large': 0.8
}, donutRatioMap = {
    'small': 0.3,
    'medium': 0.6,
    'large': 0.7
}, barSpacingMapInvert = _.invert(barSpacingMap), donutRatioMapInvert = _.invert(donutRatioMap), tickformats = {
    'Thousand': {
        'prefix': 'K',
        'divider': 1000
    },
    'Million': {
        'prefix': 'M',
        'divider': 1000000
    },
    'Billion': {
        'prefix': 'B',
        'divider': 1000000000
    }
}, chartId = '#preview-chart', dataTypeJSON = ['Column', 'Line', 'Pie', 'Bar', 'Donut', 'Bubble'], // Charts that supports the data to be JSON;
lineTypeCharts = ['Line', 'Area', 'Cumulative Line'], // Charts that does not supports the string type of data in the xaxis in the nvd3;
dataTypeArray = ['Cumulative Line', 'Area'], // Charts that supports the data to be Array
SAMPLE_DATA = {
    'group1': 'Europe',
    'group2': 'Asia',
    'group3': 'America',
    'group4': 'Australia'
};
// returns true if chart type is pie
const isPieChart = type => type === 'Pie';
// returns true if chart type is line
const isLineChart = type => type === 'Line';
// returns true if chart type is bar
const isBarChart = type => type === 'Bar';
// returns true if chart type is donut
const isDonutChart = type => type === 'Donut';
// returns true if chart type is bubble
const isBubbleChart = type => type === 'Bubble';
// returns true if chart type is column
const isColumnChart = type => type === 'Column';
// returns true if chart type is area
const isAreaChart = type => type === 'Area';
// returns true if chart type is area
const isPieType = type => isPieChart(type) || isDonutChart(type);
// The format of chart data is array of json objects in case of the following types of chart
const isChartDataJSON = type => _.includes(dataTypeJSON, type) || !_.includes(chartTypes, type);
// The format of chart data is array of objects in case of the following types of chart
const isChartDataArray = type => _.includes(dataTypeArray, type);
// returns true is the chart type is 'line', 'area' or 'cumulative line' else false
const isLineTypeChart = type => _.includes(lineTypeCharts, type);
// X/Y Domain properties are supported only for Column and Area charts
const isAxisDomainSupported = type => isColumnChart(type) || isAreaChart(type);
// Returns bar spacing value
const getBarSpacingValue = (value, prop) => {
    if (prop === 'value') {
        return barSpacingMap[value];
    }
    if (prop === 'key') {
        return barSpacingMapInvert[value];
    }
};
// Returns radius value
const getRadiusValue = (value, prop) => {
    if (prop === 'value') {
        return donutRatioMap[value];
    }
    if (prop === 'key') {
        return donutRatioMapInvert[value];
    }
};
// Returns labels config
const getLabelValues = (showlabels, showlabelsoutside, prop) => {
    const labelsConfig = {};
    switch (showlabels) {
        case 'hide':
            labelsConfig.showlabels = false;
            break;
        case 'inside':
            labelsConfig.showlabels = true;
            labelsConfig.showlabelsoutside = false;
            break;
        case 'outside':
            labelsConfig.showlabels = true;
            labelsConfig.showlabelsoutside = true;
            break;
    }
    return labelsConfig;
};
// Construct the sample data
const constructSampleData = (dataType, yaxisLength, shape) => {
    let first_series = [], second_series = [], third_series = [], first_series_array = [], second_series_array = [], third_series_array = [], first_series_bubble = [], second_series_bubble = [], third_series_bubble = [], data = [];
    switch (dataType) {
        case 'jsonFormat':
            first_series = [
                { 'x': '01/01/2001', 'y': 4000000 },
                { 'x': '01/01/2002', 'y': 1000000 },
                { 'x': '01/01/2003', 'y': 5000000 }
            ];
            second_series = [
                { 'x': '01/01/2001', 'y': 3000000 },
                { 'x': '01/01/2002', 'y': 4000000 },
                { 'x': '01/01/2003', 'y': 7000000 }
            ];
            third_series = [
                { 'x': '01/01/2001', 'y': 2000000 },
                { 'x': '01/01/2002', 'y': 8000000 },
                { 'x': '01/01/2003', 'y': 6000000 }
            ];
            data[0] = {
                values: first_series,
                key: SAMPLE_DATA.group1
            };
            if (yaxisLength >= 2) {
                data[1] = {
                    values: second_series,
                    key: SAMPLE_DATA.group2
                };
            }
            if (yaxisLength >= 3) {
                data[2] = {
                    values: third_series,
                    key: SAMPLE_DATA.group3
                };
            }
            break;
        case 'lineChartFormat':
            first_series = [
                { 'x': 1, 'y': 4000000 },
                { 'x': 2, 'y': 1000000 },
                { 'x': 3, 'y': 5000000 }
            ];
            second_series = [
                { 'x': 1, 'y': 3000000 },
                { 'x': 2, 'y': 4000000 },
                { 'x': 3, 'y': 7000000 }
            ];
            third_series = [
                { 'x': 1, 'y': 2000000 },
                { 'x': 2, 'y': 8000000 },
                { 'x': 3, 'y': 6000000 }
            ];
            data[0] = {
                values: first_series,
                key: SAMPLE_DATA.group1
            };
            if (yaxisLength >= 2) {
                data[1] = {
                    values: second_series,
                    key: SAMPLE_DATA.group2
                };
            }
            if (yaxisLength >= 3) {
                data[2] = {
                    values: third_series,
                    key: SAMPLE_DATA.group3
                };
            }
            break;
        case 'arrayFormat':
            first_series_array = [
                [1, 4000000],
                [2, 1000000],
                [3, 5000000]
            ];
            second_series_array = [
                [1, 3000000],
                [2, 4000000],
                [3, 7000000]
            ];
            third_series_array = [
                [1, 2000000],
                [2, 8000000],
                [3, 6000000]
            ];
            data[0] = {
                values: first_series_array,
                key: SAMPLE_DATA.group1
            };
            if (yaxisLength >= 2) {
                data[1] = {
                    values: second_series_array,
                    key: SAMPLE_DATA.group2
                };
            }
            if (yaxisLength >= 3) {
                data[2] = {
                    values: third_series_array,
                    key: SAMPLE_DATA.group3
                };
            }
            break;
        case 'bubbleFormat':
            shape = shape === 'random' ? allShapes[Math.floor(Math.random() * allShapes.length)] : shape;
            first_series_bubble = [
                { 'x': 80.66, 'y': 33739900, 'size': 78, 'shape': shape },
                { 'x': 79.84, 'y': 81902300, 'size': 90, 'shape': shape },
                { 'x': 78.6, 'y': 5523100, 'size': 45, 'shape': shape }
            ];
            second_series_bubble = [
                { 'x': 72.73, 'y': 79716200, 'size': 98, 'shape': shape },
                { 'x': 80.05, 'y': 61801600, 'size': 20, 'shape': shape },
                { 'x': 72.49, 'y': 73137200, 'size': 34, 'shape': shape }
            ];
            third_series_bubble = [
                { 'x': 68.09, 'y': 33739900, 'size': 45, 'shape': shape },
                { 'x': 81.55, 'y': 7485600, 'size': 78, 'shape': shape },
                { 'x': 68.60, 'y': 141850000, 'size': 56, 'shape': shape }
            ];
            data[0] = {
                values: first_series_bubble,
                key: SAMPLE_DATA.group1
            };
            if (yaxisLength >= 2) {
                data[1] = {
                    values: second_series_bubble,
                    key: SAMPLE_DATA.group2
                };
            }
            if (yaxisLength >= 3) {
                data[2] = {
                    values: third_series_bubble,
                    key: SAMPLE_DATA.group3
                };
            }
            break;
        case 'pieChartFormat':
            data = [
                { 'x': SAMPLE_DATA.group1, 'y': 1000000 },
                { 'x': SAMPLE_DATA.group2, 'y': 2000000 },
                { 'x': SAMPLE_DATA.group3, 'y': 3000000 },
                { 'x': SAMPLE_DATA.group4, 'y': 4000000 }
            ];
            break;
    }
    return data;
};
const getDataType = widgetContext => {
    const type = widgetContext.type;
    if (isLineChart(type)) {
        return 'lineChartFormat';
    }
    if (isPieType(type)) {
        return 'pieChartFormat';
    }
    if (isBubbleChart(type)) {
        return 'bubbleFormat';
    }
    return isChartDataJSON(type) ? 'jsonFormat' : 'arrayFormat';
};
// Sample data to populate when no data is bound
const getSampleData = widgetContext => constructSampleData(getDataType(widgetContext), _.split(widgetContext.yaxisdatakey, ',').length, widgetContext.shape);
// Check whether X/Y Domain was set to Min and is supported for the present chart
const isAxisDomainValid = (widgetContext, axis) => {
    if (widgetContext[axis + 'domain'] === 'Min' && (isAxisDomainSupported(widgetContext.type))) {
        return true;
    }
    return false;
};
// Check whether min and max values are finite or not
const areMinMaxValuesValid = values => {
    if (_.isFinite(values.min) && _.isFinite(values.max)) {
        return true;
    }
    return false;
};
const getYScaleMinValue = value => {
    const _min = Math.floor(value);
    /* If the number has a) decimal part returning floor value - 0.1
     b) no decimal part returning floor value - 1 */
    return Math.abs(value) - _min > 0 ? value - 0.1 : _min - 1;
};
// Chooses the data points of line/cumulative line/area chart and highlights them
const highlightPoints = (id, highlightpoints) => {
    const chartSvg = id ? d3.select('#wmChart' + id + ' svg') : d3.select(chartId + ' svg');
    if (highlightpoints) {
        chartSvg.selectAll('.nv-point').style({ 'stroke-width': '6px', 'fill-opacity': '.95', 'stroke-opacity': '.95' });
    }
    else {
        chartSvg.selectAll('.nv-point').style({ 'stroke-width': '0px', 'fill-opacity': '0' });
    }
};
// Chooses the line of line/cumulative line and increases the thickness of it
const setLineThickness = (id, thickness) => {
    const chartSvg = id ? d3.select('#wmChart' + id + ' svg') : d3.select(chartId + ' svg');
    thickness = thickness || 1.5;
    chartSvg.selectAll('.nv-line').style({ 'stroke-width': thickness });
};
// Constructing a common key value map for preview and canvas mode
const initProperties = (widgetContext, propertyValueMap) => {
    if (!propertyValueMap || isEmptyObject(propertyValueMap)) {
        propertyValueMap = {};
    }
    _.forEach(basicProperties, prop => {
        if (_.isUndefined(propertyValueMap[prop])) {
            propertyValueMap[prop] = widgetContext[prop];
        }
    });
    return propertyValueMap;
};
const getNumberValue = (value, callback) => {
    return isNaN(parseInt(value, 10)) ? callback(value, 'value') : value;
};
// Formats the given value according to date format
const getDateFormatedData = (dateFormat, d) => {
    dateFormat = dateFormat || '%x';
    return d3.time.format(dateFormat)(new Date(d));
};
// Formats the given value according to number format
const getNumberFormatedData = (numberFormat, d) => {
    let formattedData, divider, prefix;
    formattedData = d3.format(numberFormat)(d);
    // formatting the data based on number format selected
    if (numberFormat) {
        // Getting the respective divider[1000,1000000,1000000000] based on the number format choosen
        divider = (tickformats[numberFormat] && tickformats[numberFormat].divider) || 0;
        prefix = tickformats[numberFormat] && tickformats[numberFormat].prefix;
        if (prefix && divider !== 0) {
            formattedData = d3.format('.2f')(d / divider) + prefix;
        }
    }
    else {
        // Auto formatting the data when no formating option is chosen
        formattedData = d >= 1000 ? d3.format('.1s')(d) : d;
    }
    return formattedData;
};
const modifyLegendPosition = (widgetContext, position, id) => {
    const showLegend = isShowLegend(widgetContext.showlegend), chart_Id = id ? '#wmChart' + id : chartId, legendWrap = d3.select(chart_Id + ' .nv-legendWrap'), legendPadding = 5;
    // Return when showlegend is false
    if (!showLegend || !legendWrap[0][0]) {
        return;
    }
    if (position === 'bottom') {
        const legendWrapHeight = legendWrap[0][0].getBoundingClientRect().height, wrap = d3.select(chart_Id + ' .nv-wrap'), wrapTransform = (wrap && wrap.attr('transform')) ? wrap.attr('transform').replace(/, /g, ',') : '', coordinates = /translate\(\s*([^\s,)]+)[ ,]([^\s,)]+)/.exec(wrapTransform), getChartHeight = () => {
            let chartHeight = $(chart_Id + ' svg>.nvd3.nv-wrap')[0].getBoundingClientRect().height;
            if (chartHeight === 0) { // fix for IE
                chartHeight = ($(chart_Id + ' svg')[0].getBoundingClientRect().height - (legendWrapHeight + 15));
            }
            return chartHeight;
        };
        legendWrap.attr('transform', 'translate(0 , ' + (getChartHeight() - legendWrapHeight - legendPadding) + ')');
        if (coordinates) {
            wrap.attr('transform', 'translate(' + coordinates[1] + ',' + legendPadding + ')');
        }
    }
};
// Returns value if legend need to shown or not
const isShowLegend = value => {
    // Old projects will have either true or false
    if (value === 'false' || value === false) {
        return false;
    }
    if (value === 'true' || value === true) {
        return true;
    }
    // New projects will have either 'Hide Legend', 'Show Top', 'Show Bottom'
    return value === 'hide' ? false : true;
};
/**
 * Customise the tooltip for donut & pie charts and also for charts having only one value attached to yaxis
 * @param key
 * @param label
 */
const customiseTooltip = (chart, propertyValueMap, widgetContext, label) => {
    chart.tooltip.contentGenerator(key => {
        let xValue = key.data.x, yValue;
        yValue = getNumberFormatedData(propertyValueMap.ynumberformat, key.data.y);
        if (isPieType(widgetContext.type)) {
            label = key.data.x;
            xValue = '';
        }
        return '<table>' +
            '<tbody>' +
            '<tr class="value"><b>' + xValue +
            '</b></tr>' +
            '<tr>' +
            '<td class="legend-color-guide"><div style="background-color:' + key.color + ';"></div></td>' +
            '<td class="key">' + label + '</td>' +
            '<td class="value">' + yValue + '</td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    });
};
// intializes the chart obejct
const initChart = (widgetContext, xDomainValues, yDomainValues, propertyValueMap, isPreview) => {
    propertyValueMap = initProperties(widgetContext, propertyValueMap);
    let chart, colors = [], xaxislabel, yaxislabel, labelConfig, radius, barSpacing, showLegend, xAxisValue, hasMultipleYValues;
    const xValue = {}, yValue = {};
    switch (widgetContext.type) {
        case 'Column':
            barSpacing = getNumberValue(propertyValueMap.barspacing, getBarSpacingValue) || barSpacingMap.medium;
            chart = nv.models.multiBarChart()
                .x(d => d.x)
                .y(d => d.y)
                .reduceXTicks(propertyValueMap.reducexticks)
                .rotateLabels(0)
                .showControls(false)
                .stacked(propertyValueMap.viewtype === 'Stacked' ? true : false)
                .groupSpacing(barSpacing);
            break;
        case 'Cumulative Line':
            chart = nv.models.cumulativeLineChart()
                .x(d => d[0])
                .y(d => d[1])
                .showControls(false)
                .useInteractiveGuideline(propertyValueMap.tooltips)
                .interpolate(propertyValueMap.interpolation);
            break;
        case 'Line':
            chart = nv.models.lineChart()
                .useInteractiveGuideline(propertyValueMap.tooltips)
                .interpolate(propertyValueMap.interpolation);
            break;
        case 'Area':
            chart = nv.models.stackedAreaChart()
                .x(d => d[0])
                .y(d => d[1])
                .clipEdge(true)
                .showControls(false)
                .style(propertyValueMap.areaviewtype)
                .useInteractiveGuideline(propertyValueMap.tooltips)
                .interpolate(propertyValueMap.interpolation);
            break;
        case 'Bar':
            barSpacing = getNumberValue(propertyValueMap.barspacing, getBarSpacingValue) || barSpacingMap.medium;
            chart = nv.models.multiBarHorizontalChart()
                .x(d => d.x)
                .y(d => d.y)
                .showControls(false)
                .stacked(propertyValueMap.viewtype === 'Stacked' ? true : false)
                .showValues(propertyValueMap.showvalues)
                .groupSpacing(barSpacing);
            break;
        case 'Pie':
        case 'Donut':
            labelConfig = getLabelValues(propertyValueMap.showlabels, propertyValueMap.showlabelsoutside, 'value');
            radius = getNumberValue(propertyValueMap.donutratio, getRadiusValue) || donutRatioMap.medium;
            chart = nv.models.pieChart()
                .x(d => d.x)
                .y(d => d.y)
                .showLabels(labelConfig.showlabels)
                .labelType(propertyValueMap.labeltype)
                .valueFormat(d3.format('%'))
                .title(propertyValueMap.centerlabel)
                .labelThreshold(propertyValueMap.labelthreshold || 0.01)
                .labelsOutside(labelConfig.showlabelsoutside);
            if (isDonutChart(widgetContext.type)) {
                chart.donut(true)
                    .donutRatio(radius);
            }
            if (propertyValueMap.labeltype === 'key-value') {
                chart.labelType(d => d.data.x + ' ' + d.data.y);
            }
            break;
        case 'Bubble':
            chart = nv.models.scatterChart()
                .x(d => d.x)
                .y(d => d.y)
                .showDistX(propertyValueMap.showxdistance)
                .showDistY(propertyValueMap.showydistance);
            break;
    }
    if (xDomainValues) {
        xValue.min = xDomainValues.min.x || xDomainValues.min[0];
        xValue.max = xDomainValues.max.x || xDomainValues.max[0];
        // If the values on the x axis are string then min max values gives Infinity
        if (areMinMaxValuesValid(xValue)) {
            // Reducing the min value to 0.1 so the min value is not missed out
            xValue.min = getYScaleMinValue(xValue.min);
            chart.xDomain([xValue.min, xValue.max]);
        }
    }
    if (yDomainValues) {
        // Reducing the min value to 1 so the min value is not missed out
        yValue.min = yDomainValues.min.y || yDomainValues.min[1];
        yValue.max = yDomainValues.max.y || yDomainValues.max[1];
        // If the values on the y axis are string or invalid then min max values gives Infinity
        if (areMinMaxValuesValid(yValue)) {
            // Reducing the min value to 1 so the min value is not missed out
            yValue.min = getYScaleMinValue(yValue.min);
            chart.yDomain([yValue.min, yValue.max]);
        }
    }
    // Setting the legend type choosen by user or default it will be furious
    chart.legend.vers((propertyValueMap.legendtype && propertyValueMap.legendtype.toLowerCase()) || 'furious');
    if (!_.includes(chartTypes, widgetContext.type)) {
        chart = nv.models.multiBarChart()
            .x(d => d.x)
            .y(d => d.y);
    }
    if (isPieType(widgetContext.type)) {
        // In case of pie/donut chart formatting the values of it
        if (propertyValueMap.labeltype === 'percent') {
            chart.valueFormat(d3.format('%'));
        }
        else {
            chart.valueFormat(d => getNumberFormatedData(propertyValueMap.ynumberformat, d));
        }
        // Customizing the tooltips in case of the pie and donut when labelType is value
        customiseTooltip(chart, propertyValueMap, widgetContext);
    }
    else {
        chart.showXAxis(propertyValueMap.showxaxis)
            .showYAxis(propertyValueMap.showyaxis);
        // Setting the labels if they are specified explicitly or taking the axiskeys chosen
        xaxislabel = propertyValueMap.xaxislabel || prettifyLabels(widgetContext.xaxisdatakey) || 'x caption';
        yaxislabel = propertyValueMap.yaxislabel || prettifyLabels(widgetContext.yaxisdatakey) || 'y caption';
        // Checking if y axis has multiple values
        if (widgetContext.yaxisdatakey && widgetContext.yaxisdatakey.split(',').length > 1) {
            hasMultipleYValues = true;
        }
        // Customizing the tooltip to show yaxislabel, only if the y axis contains one value
        if (!hasMultipleYValues && !isBubbleChart(widgetContext.type)) {
            customiseTooltip(chart, propertyValueMap, widgetContext, yaxislabel);
        }
        // Adding the units to the captions if they are specified
        xaxislabel += propertyValueMap.xunits ? '(' + propertyValueMap.xunits + ')' : '';
        yaxislabel += propertyValueMap.yunits ? '(' + propertyValueMap.yunits + ')' : '';
        chart.xAxis
            .axisLabel(xaxislabel)
            .axisLabelDistance(propertyValueMap.xaxislabeldistance)
            .staggerLabels(propertyValueMap.staggerlabels);
        // If date format set format based date format
        if (propertyValueMap.xdateformat || (isPreview && !isBubbleChart(widgetContext.type))) {
            if (isLineTypeChart(widgetContext.type)) {
                chart.xAxis.tickFormat(d => {
                    // get the actual value
                    xAxisValue = isPreview ? dateList[d - 1] : widgetContext.xDataKeyArr[d];
                    return getDateFormatedData(propertyValueMap.xdateformat, xAxisValue);
                });
            }
            else {
                chart.xAxis.tickFormat(d => getDateFormatedData(propertyValueMap.xdateformat, d));
            }
        }
        else if (propertyValueMap.xnumberformat) {
            chart.xAxis.tickFormat(d => getNumberFormatedData(propertyValueMap.xnumberformat, d));
        }
        else {
            if (isLineTypeChart(widgetContext.type)) {
                // get the actual value
                chart.xAxis.tickFormat(d => widgetContext.xDataKeyArr[d]);
            }
        }
        chart.yAxis
            .axisLabel(yaxislabel)
            .axisLabelDistance(propertyValueMap.yaxislabeldistance)
            .staggerLabels(propertyValueMap.staggerlabels)
            .tickFormat(d => getNumberFormatedData(propertyValueMap.ynumberformat, d));
        if (isBarChart(widgetContext.type)) {
            chart.valueFormat(d => getNumberFormatedData(propertyValueMap.ynumberformat, d));
        }
    }
    // Support for custom colors if user gives direct string of colors in text box
    if (_.isString(propertyValueMap.customcolors) && propertyValueMap.customcolors) {
        colors = _.split(propertyValueMap.customcolors, ',');
    }
    if (_.isArray(propertyValueMap.customcolors)) {
        colors = propertyValueMap.customcolors;
    }
    showLegend = isShowLegend(propertyValueMap.showlegend);
    chart.showLegend(showLegend)
        .margin({ top: propertyValueMap.offsettop, right: propertyValueMap.offsetright, bottom: propertyValueMap.offsetbottom, left: propertyValueMap.offsetleft })
        .color(colors.length ? colors : themes[propertyValueMap.theme].colors);
    chart.tooltip.enabled(propertyValueMap.tooltips);
    widgetContext.message = propertyValueMap.nodatamessage || 'No data found';
    // setting the no data message
    chart.noData(widgetContext.message);
    if (isLineTypeChart(widgetContext.type) && widgetContext.highlightpoints) {
        chart.dispatch.on('stateChange', () => {
            setTimeout(() => postPlotChartProcess(widgetContext), 100);
        });
    }
    return chart;
};
const postPlotChartProcess = (widgetContext, isPreview) => {
    const id = isPreview ? null : widgetContext.$id;
    // If user sets to highlight the data points and increase the thickness of the line
    if (isLineTypeChart(widgetContext.type)) {
        setLineThickness(id, widgetContext.linethickness);
        highlightPoints(id, widgetContext.highlightpoints);
    }
    // Modifying the legend position only when legend is shown
    if (widgetContext.showlegend) {
        modifyLegendPosition(widgetContext, widgetContext.showlegend, id);
    }
};
const getDateList = () => dateList;

const WIDGET_CONFIG$e = { widgetType: 'wm-chart', hostClass: 'app-chart' };
const NONE = 'none', advanceDataProps = ['aggregation', 'aggregationcolumn', 'groupby', 'orderby'], 
// XPaths to get actual data of data points in charts
chartDataPointXpath = {
    'Column': 'rect.nv-bar',
    'Bar': 'g.nv-bar',
    'Area': '.nv-stackedarea .nv-point',
    'Cumulative Line': '.nv-cumulativeLine .nv-scatterWrap path.nv-point',
    'Line': '.nv-lineChart .nv-scatterWrap path.nv-point',
    'Pie': '.nv-pieChart .nv-slice path',
    'Donut': '.nv-pieChart .nv-slice path',
    'Bubble': '.nv-scatterChart .nv-point-paths path'
}, 
styleProps = {
    'fontunit': 'font-size',
    'fontsize': 'font-size',
    'color': 'fill',
    'fontfamily': 'font-family',
    'fontweight': 'font-weight',
    'fontstyle': 'font-style',
    'textdecoration': 'text-decoration'
}, 
// Getting the relevant aggregation function based on the selected option
aggregationFnMap = {
    'average': 'AVG',
    'count': 'COUNT',
    'maximum': 'MAX',
    'minimum': 'MIN',
    'sum': 'SUM'
};
const getBooleanValue = val => {
    if (val === true || val === 'true') {
        return true;
    }
    if (val === false || val === 'false') {
        return false;
    }
    return val;
};
// returns orderby columns and their orders in two separate arrays
const getLodashOrderByFormat = orderby => {
    let columns;
    const orderByColumns = [], orders = [];
    _.forEach(_.split(orderby, ','), function (col) {
        columns = _.split(col, ':');
        orderByColumns.push(columns[0]);
        orders.push(columns[1]);
    });
    return {
        'columns': orderByColumns,
        'orders': orders
    };
};
// Replacing the '.' by the '$' because '.' is not supported in the alias names
const getValidAliasName = aliasName => aliasName ? aliasName.replace(/\./g, '$') : null;
// Applying the font related styles for the chart
const setTextStyle = (properties, id) => {
    const charttext = d3.select('#wmChart' + id + ' svg').selectAll('text');
    charttext.style(properties);
};
const angle = d => {
    const a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
    return a > 90 ? a - 180 : a;
};
class ChartComponent extends StylableComponent {
    constructor(inj, app) {
        super(inj, WIDGET_CONFIG$e);
        this.app = app;
        this.iconclass = '';
        this.nonPrimaryColumns = [];
        this.xDataKeyArr = [];
        this.chartData = [];
        this._processedData = [];
        this._plotChartProxy = _.debounce(this.plotChartProxy.bind(this), 100);
        this.redraw = this._plotChartProxy.bind(this);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER, ['fontsize', 'fontunit', 'color', 'fontfamily', 'fontweight', 'fontstyle', 'textdecoration']);
        // generate unique id for the component
        this.$id = this.widgetId || Math.random();
        // remove title attribute as the element on hover shows you the hint through-out the element
        removeAttr(this.nativeElement, 'title');
        this.chartReady = false;
        this.binddataset = this.nativeElement.getAttribute('dataset.bind');
        // Show loading status based on the variable life cycle
        this.app.subscribe('toggle-variable-state', this.handleLoading.bind(this));
    }
    isGroupByEnabled() {
        return !!(this.groupby && this.groupby !== NONE);
    }
    // Check if x and y axis that are chosen are valid to plot chart
    isValidAxis() {
        // Check if x axis and y axis are chosen and are not equal
        return this.binddataset ? (this.xaxisdatakey && this.yaxisdatakey) : true;
    }
    // Check if aggregation is chosen
    isAggregationEnabled() {
        return !!((this.isGroupByEnabled() && this.aggregation !== NONE && this.aggregationcolumn));
    }
    // Check if either groupby, aggregation or orderby is chosen
    isDataFilteringEnabled() {
        /*Query need to be triggered if any of the following cases satisfy
        * 1. Group By and aggregation both chosen
        * 2. Only Order By is chosen
        * */
        return this.isAggregationEnabled() || (!this.isVisuallyGrouped && this.orderby);
    }
    /*Charts like Line,Area,Cumulative Line does not support any other datatype
        other than integer unlike the column and bar.It is a nvd3 issue. Inorder to
        support that this is a fix*/
    getxAxisVal(dataObj, xKey, index) {
        const value = _.get(dataObj, xKey);
        // If x axis is other than number type then add indexes
        if (isLineTypeChart(this.type) && !isNumberType(this.xAxisDataType)) {
            // Verification to get the unique data keys
            this.xDataKeyArr.push(value);
            return index;
        }
        return value;
    }
    // Getting the min and max values among all the x values
    getXMinMaxValues(datum) {
        if (!datum) {
            return;
        }
        const xValues = {};
        /*
         compute the min x value
         eg: When data has objects
            input: [{x:1, y:2}, {x:2, y:3}, {x:3, y:4}]
            min x: 1
         eg: When data has arrays
            input: [[10, 20], [20, 30], [30, 40]];
            min x: 10
        */
        xValues.min = _.minBy(datum.values, dataObject => dataObject.x || dataObject[0]);
        /*
         compute the max x value
         eg: When data has objects
            input: [{x:1, y:2}, {x:2, y:3}, {x:3, y:4}]
            max x: 3
         eg: When data has arrays
            input: [[10, 20], [20, 30], [30, 40]];
            max x: 30
         */
        xValues.max = _.maxBy(datum.values, dataObject => dataObject.x || dataObject[0]);
        return xValues;
    }
    // Getting the min and max values among all the y values
    getYMinMaxValues(datum) {
        const yValues = {}, minValues = [], maxValues = [];
        if (!datum) {
            return;
        }
        /*
         Getting the min and max y values among all the series of data
         compute the min y value
         eg: When data has objects
            input: [[{x:1, y:2}, {x:2, y:3}, {x:3, y:4}], [{x:2, y:3}, {x:3, y:4}, {x:4, y:5}]]
            min y values : '2'(among first set) & '3'(among second set)
            max y values : '4'(among first set) & '5'(among second set)

         eg: When data has arrays
            input: [[[10, 20], [20, 30], [30, 40]], [[20, 30], [30, 40], [40, 50]]]
            min y values : '20'(among first set) & '30'(among second set)
            max y values : '40'(among first set) & '50'(among second set)
         */
        _.forEach(datum, data => {
            minValues.push(_.minBy(data.values, function (dataObject) { return dataObject.y || dataObject[1]; }));
            maxValues.push(_.maxBy(data.values, function (dataObject) { return dataObject.y || dataObject[1]; }));
        });
        // Gets the least and highest values among all the min and max values of respective series of data
        yValues.min = _.minBy(minValues, dataObject => dataObject.y || dataObject[1]);
        yValues.max = _.maxBy(maxValues, dataObject => dataObject.y || dataObject[1]);
        return yValues;
    }
    // If the x-axis values are undefined, we return empty array else we return the values
    getValidData(values) {
        return (values.length === 1 && values[0] === undefined) ? [] : values;
    }
    // Returns the single data point based on the type of the data chart accepts
    valueFinder(dataObj, xKey, yKey, index, shape) {
        const xVal = this.getxAxisVal(dataObj, xKey, index), value = _.get(dataObj, yKey), yVal = parseFloat(value) || value, size = parseFloat(dataObj[this.bubblesize]) || 2;
        let dataPoint = {};
        if (isChartDataJSON(this.type)) {
            dataPoint.x = xVal;
            dataPoint.y = yVal;
            // only Bubble chart has the third dimension
            if (isBubbleChart(this.type)) {
                dataPoint.size = size;
                dataPoint.shape = shape || 'circle';
            }
        }
        else if (isChartDataArray(this.type)) {
            dataPoint = [xVal, yVal];
        }
        // Adding actual unwrapped data to chart data to use at the time of selected data point of chart event
        dataPoint._dataObj = dataObj;
        return dataPoint;
    }
    // Setting appropriate error messages
    setErrMsg(message) {
        if (this.showNoDataMsg) {
            this.showContentLoadError = true;
            this.invalidConfig = true;
            // TODO: Set the locale from the message
            this.errMsg = ''; // $rootScope.locale[message];
        }
    }
    processChartData() {
        this.sampleData = getSampleData(this);
        // scope variables used to keep the actual key values for x-axis
        this.xDataKeyArr = [];
        // Plotting the chart with sample data when the chart dataset is not bound
        if (!this.binddataset) {
            this.xDataKeyArr = getDateList();
            return this.sampleData;
        }
        if (!this.chartData || !this.chartData.length) {
            return [];
        }
        let datum = [], yAxisKey, shapes = [], values = [];
        const xAxisKey = this.xaxisdatakey, yAxisKeys = this.yaxisdatakey ? this.yaxisdatakey.split(',') : [], dataSet = this.chartData;
        if (_.isArray(dataSet)) {
            if (isPieType(this.type)) {
                yAxisKey = yAxisKeys[0];
                datum = _.map(dataSet, (dataObj, index) => {
                    if (!isEmptyObject(dataSet[index])) {
                        return this.valueFinder(dataSet[index], xAxisKey, yAxisKey);
                    }
                });
                datum = this.getValidData(datum);
            }
            else {
                if (isBubbleChart(this.type)) {
                    shapes = this.shape === 'random' ? allShapes : this.shape;
                }
                yAxisKeys.forEach((yAxisKey, series) => {
                    values = _.map(dataSet, (dataObj, index) => {
                        if (!isEmptyObject(dataSet[index])) {
                            return this.valueFinder(dataSet[index], xAxisKey, yAxisKey, index, (_.isArray(shapes) && shapes[series]) || this.shape);
                        }
                    });
                    values = this.getValidData(values);
                    datum.push({
                        values: values,
                        key: prettifyLabels(yAxisKey)
                    });
                });
            }
        }
        return datum;
    }
    setChartData(data) {
        if (data) {
            this._processedData = data;
        }
    }
    getChartData() {
        return this._processedData;
    }
    // constructing the grouped data based on the selection of orderby, x & y axis
    getVisuallyGroupedData(queryResponse, groupingColumn) {
        let groupData = {}, groupValues = [], orderByDetails, maxLength;
        const chartData = [], _isAreaChart = isAreaChart(this.type), yAxisKey = _.first(_.split(this.yaxisdatakey, ','));
        this.xDataKeyArr = [];
        queryResponse = _.orderBy(queryResponse, _.split(this.groupby, ','));
        if (this.orderby) {
            orderByDetails = getLodashOrderByFormat(this.orderby);
            queryResponse = _.orderBy(queryResponse, orderByDetails.columns, orderByDetails.orders);
        }
        queryResponse = _.groupBy(queryResponse, groupingColumn);
        // In case of area chart all the series data should be of same length
        if (_isAreaChart) {
            maxLength = _.max(_.map(queryResponse, obj => obj.length));
        }
        _.forEach(queryResponse, (values, groupKey) => {
            groupValues = isAreaChart ? _.fill(new Array(maxLength), [0, 0]) : [];
            _.forEachRight(values, (value, index) => {
                groupValues[index] = this.valueFinder(value, this.xaxisdatakey, yAxisKey, index);
            });
            groupData = {
                key: groupKey,
                values: groupValues
            };
            chartData.push(groupData);
        });
        return chartData;
    }
    /*Decides whether the data should be visually grouped or not
            Visually grouped when a different column is choosen in the group by other than x and y axis and aggregation is not chosen*/
    getGroupingDetails() {
        if (this.isGroupByEnabled() && !this.isAggregationEnabled()) {
            let isVisuallyGrouped = false, visualGroupingColumn, groupingExpression, columns = [], groupingColumnIndex;
            const groupbyColumns = this.groupby && this.groupby !== NONE ? this.groupby.split(',') : [], yAxisKeys = this.yaxisdatakey ? this.yaxisdatakey.split(',') : [];
            if (groupbyColumns.length > 1) {
                /*Getting the group by column which is not selected either in x or y axis*/
                groupbyColumns.every((column, index) => {
                    if (this.xaxisdatakey !== column && $.inArray(column, yAxisKeys) === -1) {
                        isVisuallyGrouped = true;
                        visualGroupingColumn = column;
                        groupingColumnIndex = index;
                        groupbyColumns.splice(groupingColumnIndex, 1);
                        return false;
                    }
                    return true;
                });
                // Constructing the groupby expression
                if (visualGroupingColumn) {
                    columns.push(visualGroupingColumn);
                }
                if (groupbyColumns.length) {
                    columns = _.concat(columns, groupbyColumns);
                }
            }
            // If x and y axis are not included in aggregation need to be included in groupby
            if (this.xaxisdatakey !== this.aggregationcolumn) {
                columns.push(this.xaxisdatakey);
            }
            _.forEach(yAxisKeys, key => {
                if (key !== this.aggregationcolumn) {
                    columns.push(key);
                }
            });
            groupingExpression = columns.join(',');
            // set isVisuallyGrouped flag in scope for later use
            this.isVisuallyGrouped = isVisuallyGrouped;
            return {
                expression: groupingExpression,
                isVisuallyGrouped: isVisuallyGrouped,
                visualGroupingColumn: visualGroupingColumn
            };
        }
        return {
            expression: '',
            isVisuallyGrouped: false,
            visualGroupingColumn: ''
        };
    }
    // Function to get the aggregated data after applying the aggregation & group by or order by operations.
    getAggregatedData(callback) {
        const variable = this.datasource, yAxisKeys = this.yaxisdatakey ? this.yaxisdatakey.split(',') : [], data = {};
        let sortExpr, columns = [], colAlias, orderByColumns, groupByFields = [];
        if (!variable) {
            return;
        }
        if (this.isGroupByEnabled()) {
            groupByFields = _.split(this.groupby, ',');
        }
        if (this.orderby) {
            sortExpr = _.replace(this.orderby, /:/g, ' ');
            columns = _.uniq(_.concat(columns, groupByFields, [this.aggregationcolumn]));
            orderByColumns = getLodashOrderByFormat(this.orderby).columns;
            // If the orderby column is chosen either in groupby or orderby then replace . with $ for that column
            _.forEach(_.intersection(columns, orderByColumns), col => {
                colAlias = getValidAliasName(col);
                sortExpr = _.replace(sortExpr, col, colAlias);
            });
        }
        if (this.isAggregationEnabled()) {
            // Send the group by in the aggregations api only if aggregation is also chosen
            data.groupByFields = groupByFields;
            data.aggregations = [
                {
                    'field': this.aggregationcolumn,
                    'type': aggregationFnMap[this.aggregation],
                    'alias': getValidAliasName(this.aggregationcolumn)
                }
            ];
        }
        // Execute the query.
        variable.execute('getAggregatedData', {
            'aggregations': data,
            'sort': sortExpr
        }).then(response => {
            // Transform the result into a format supported by the chart.
            const chartData = [], aggregationAlias = getValidAliasName(this.aggregationcolumn), xAxisAliasKey = getValidAliasName(this.xaxisdatakey), yAxisAliasKeys = [];
            yAxisKeys.forEach(yAxisKey => yAxisAliasKeys.push(getValidAliasName(yAxisKey)));
            _.forEach(response.body.content, (responseContent) => {
                const obj = {};
                // Set the response in the chartData based on 'aggregationColumn', 'xAxisDataKey' & 'yAxisDataKey'.
                if (this.isAggregationEnabled()) {
                    obj[this.aggregationcolumn] = responseContent[aggregationAlias];
                    obj[this.aggregationcolumn] = _.get(responseContent, aggregationAlias) || _.get(responseContent, this.aggregationcolumn);
                }
                obj[this.xaxisdatakey] = _.get(responseContent, xAxisAliasKey) || _.get(responseContent, this.xaxisdatakey);
                yAxisKeys.forEach((yAxisKey, index) => {
                    obj[yAxisKey] = responseContent[yAxisAliasKeys[index]];
                    obj[yAxisKey] = _.get(responseContent, yAxisAliasKeys[index]) || _.get(responseContent, yAxisKey);
                });
                chartData.push(obj);
            });
            this.chartData = chartData;
            triggerFn(callback);
        }, () => {
            this.chartData = [];
            this.setErrMsg('MESSAGE_ERROR_FETCH_DATA');
            triggerFn(callback);
        });
    }
    // This function sets maximum width for the labels that can be displayed.This will helpful when they are overlapping
    setLabelsMaxWidth() {
        let xTicks, tickWidth, maxLength, xDist, yDist, totalHeight, maxNoLabels, nthElement, labelsAvailableWidth, barWrapper, yAxisWrapper, svgWrapper;
        const fontsize = parseInt(this.fontsize, 10) || 12, isBarchart = isBarChart(this.type);
        // getting the x ticks in the chart
        xTicks = $('#wmChart' + this.$id + ' svg').find('g.nv-x').find('g.tick').find('text');
        // getting the distance between the two visible ticks associated with visible text
        xTicks.each(function () {
            const xTick = $(this);
            let xTransform, tickDist;
            if (xTick.text() && xTick.css('opacity') === '1') {
                xTransform = xTick.parent().attr('transform').split(',');
                xDist = parseFloat(xTransform[0].substr(10));
                yDist = parseFloat(xTransform[1] || '0');
                if (!isBarchart && xDist > 0) {
                    tickDist = xDist;
                }
                else if (yDist > 0) {
                    tickDist = yDist;
                }
                if (tickWidth) {
                    tickWidth = tickDist - tickWidth;
                    return false;
                }
                tickWidth = tickDist;
                return true;
            }
        });
        // In case of bar chart getting the available space for the labels to be displayed
        if (isBarchart) {
            barWrapper = $('#wmChart' + this.$id + ' svg>g.nv-wrap>g>g.nv-barsWrap')[0];
            yAxisWrapper = $('#wmChart' + this.$id + ' svg>g.nv-wrap>g>g.nv-y')[0];
            svgWrapper = $('#wmChart' + this.$id + ' svg')[0];
            // getting the total height of the chart
            totalHeight = barWrapper ? barWrapper.getBoundingClientRect().height : 0;
            // getting the labels available space
            labelsAvailableWidth = yAxisWrapper ? svgWrapper.getBoundingClientRect().width - yAxisWrapper.getBoundingClientRect().width : svgWrapper.getBoundingClientRect().width;
            // Setting the max length for the label
            maxLength = Math.round(labelsAvailableWidth / fontsize);
            // if available space for each label is less than the font-size
            // then limiting the labels to be displayed
            if (tickWidth < fontsize) {
                // calculate the maximum no of labels to be fitted
                maxNoLabels = totalHeight / fontsize;
                // showing only the nth element
                nthElement = Math.ceil(this.chartData.length / maxNoLabels);
                // showing up only some labels
                d3.select('#wmChart' + this.$id + ' svg').select('g.nv-x').selectAll('g.tick').select('text').each(function (text, i) {
                    // hiding every non nth element
                    if (i % nthElement !== 0) {
                        d3.select(this).attr('opacity', 0);
                    }
                });
            }
        }
        else {
            // Setting the max length for the label
            maxLength = Math.round(tickWidth / fontsize);
        }
        // maxLength should always be a positive number
        maxLength = Math.abs(maxLength);
        // Validating if every label exceeds the max length and if so limiting the length and adding ellipsis
        xTicks.each(function () {
            if (this.textContent.length > maxLength) {
                this.textContent = this.textContent.substr(0, maxLength) + '...';
            }
        });
    }
    // Returns the columns of that can be choosen in the x and y axis
    getDefaultColumns() {
        let type, stringColumn, i, temp;
        const defaultColumns = [], columns = this.datasource.execute(DataSource.Operation.GET_PROPERTIES_MAP) || [];
        for (i = 0; i < columns.length && defaultColumns.length <= 2; i += 1) {
            type = columns[i].type;
            if (!columns[i].isRelated && (isNumberType(type))) {
                defaultColumns.push(columns[i].fieldName);
            }
            else if (type === 'string' && !stringColumn) {
                stringColumn = columns[i].fieldName;
            }
        }
        // Other than bubble chart x: string type y: number type
        // Bubble chart x: number type y: number type
        if (stringColumn && defaultColumns.length > 0 && !isBubbleChart(this.type)) {
            temp = defaultColumns[0];
            defaultColumns[0] = stringColumn;
            defaultColumns[1] = temp;
        }
        return defaultColumns;
    }
    // Call user defined javascript function when user links it to click event of the widget.
    attachClickEvent() {
        let dataObj;
        d3.select('#wmChart' + this.$id + ' svg').selectAll(chartDataPointXpath[this.type]).style('pointer-events', 'all')
            .on('click', (data, index) => {
            switch (this.type) {
                case 'Column':
                case 'Bar':
                    dataObj = data._dataObj;
                    break;
                case 'Pie':
                case 'Donut':
                    dataObj = data.data._dataObj;
                    break;
                case 'Area':
                case 'Cumulative Line':
                case 'Line':
                    dataObj = data[0]._dataObj;
                    break;
                case 'Bubble':
                    dataObj = data.data.point[4]._dataObj;
                    break;
            }
            this.selecteditem = dataObj;
            this.invokeEventCallback('select', { $event: d3.event, selectedChartItem: data, selectedItem: this.selecteditem });
        });
    }
    /*  Returns Y Scale min value
           Ex: Input   : 8.97
               Output  : 8.87

               Input   : 8
               Output  : 7
       */
    postPlotProcess(chart) {
        let chartSvg, pieLabels, pieGroups, angleArray;
        const styleObj = {};
        const element = this.$element;
        postPlotChartProcess(this);
        if (!isPieType(this.type)) {
            this.setLabelsMaxWidth();
        }
        else if (!this.showlabelsoutside) {
            /** Nvd3 has a issue in rotating text. So we will use this as a temp fix.
             * If the issue is resolved there, we can remove this.*/
            /* If it is a donut chart, then rotate the text and position them*/
            chartSvg = d3.select('#wmChart' + this.$id + ' svg');
            pieLabels = chartSvg.select('.nv-pieLabels').selectAll('.nv-label');
            pieGroups = chartSvg.select('.nv-pie').selectAll('.nv-slice');
            angleArray = [];
            if (pieGroups && pieGroups.length) {
                pieGroups.each(function () {
                    d3.select(this).attr('transform', function (d) {
                        angleArray.push(angle(d));
                    });
                });
                pieLabels.each(function (d, i) {
                    const group = d3.select(this);
                    $(group[0][0]).find('text').attr('transform', 'rotate(' + angleArray[i] + ')');
                });
            }
        }
        // prepare text style props object and set
        _.forEach(styleProps, (value, key) => {
            if (key === 'fontsize' || key === 'fontunit') {
                styleObj[value] = this.fontsize + this.fontunit;
            }
            else {
                styleObj[value] = this[key];
            }
        });
        setTextStyle(styleObj, this.$id);
        /*
         * allow window-resize functionality, for only-run mode as
         * updating chart is being handled by watchers of height & width in studio-mode
         * */
        triggerFn(this._resizeFn && this._resizeFn.clear);
        this._resizeFn = nv.utils.windowResize(() => {
            if (element[0].getBoundingClientRect().height) {
                chart.update();
                postPlotChartProcess(this);
                if (!isPieType(this.type)) {
                    this.setLabelsMaxWidth();
                }
            }
        });
    }
    // prepares and configures the chart properties
    configureChart() {
        // Copy the data only in case of pie chart with default data
        // Reason : when multiple pie charts are bound to same data, first chart theme will be applied to all charts
        let xDomainValues;
        let yDomainValues;
        let chart;
        let beforeRenderVal;
        if (this._processedData.length > 0) {
            if (isAxisDomainValid(this, 'x')) {
                xDomainValues = this.binddataset ? this.getXMinMaxValues(this._processedData[0]) : { 'min': { 'x': 1 }, 'max': { 'x': 5 } };
            }
            if (isAxisDomainValid(this, 'y')) {
                yDomainValues = this.binddataset ? this.getYMinMaxValues(this._processedData) : { 'min': { 'y': 1 }, 'max': { 'y': 5 } };
            }
        }
        if (isPieType(this.type) && (!this.binddataset || !this.scopedataset)) {
            this._processedData = getClonedObject(this.scopedataset || this._processedData);
        }
        // get the chart object
        chart = initChart(this, xDomainValues, yDomainValues, null, !this.binddataset);
        if (_.isArray(this._processedData)) {
            beforeRenderVal = this.invokeEventCallback('beforerender', { 'chartInstance': chart });
            if (beforeRenderVal) {
                chart = beforeRenderVal;
            }
            this.chart = chart;
            // changing the default no data message
            d3.select('#wmChart' + this.$id + ' svg')
                .datum(this._processedData)
                .call(this.chart);
            this.postPlotProcess(chart);
            return chart;
        }
    }
    // Plotting the chart with set of the properties set to it
    plotChart() {
        const element = this.$element;
        // call user-transformed function
        this.chartData = (this.invokeEventCallback('transform')) || this.chartData;
        // Getting the order by data only in run mode. The order by applies for all the charts other than pie and donut charts
        if (this.isVisuallyGrouped && !isPieType(this.type)) {
            this._processedData = this.chartData;
        }
        else {
            this._processedData = this.processChartData();
        }
        // checking the parent container before plotting the chart
        if (!element[0].getBoundingClientRect().height) {
            return;
        }
        if (this.clearCanvas) {
            // empty svg to add-new chart
            element.find('svg').replaceWith('<svg></svg>');
            this.clearCanvas = false;
        }
        // In case of invalid axis show no data available message
        if (!this.isValidAxis()) {
            this._processedData = [];
        }
        nv.addGraph(() => this.configureChart(), () => {
            /*Bubble chart has an time out delay of 300ms in their implementation due to which we
            * won't be getting required data points on attaching events
            * hence delaying it 600ms*/
            setTimeout(() => {
                this.attachClickEvent();
            }, 600);
        });
        this.isLoadInProgress = false;
    }
    // TODO: Need way to figure out if the datasource is a live source
    get isLiveVariable() {
        // setting the flag for the live variable in the scope for the checks
        const variableObj = this.datasource;
        return variableObj && variableObj.category === 'wm.LiveVariable';
    }
    plotChartProxy() {
        this.showContentLoadError = false;
        this.invalidConfig = false;
        // Checking if x and y axis are chosen
        this.isLoadInProgress = true;
        const groupingDetails = this.getGroupingDetails();
        // If aggregation/group by/order by properties have been set, then get the aggregated data and plot the result in the chart.
        // TODO: datasource for live variable detection
        if (this.binddataset && this.isLiveVariable && (this.filterFields || this.isDataFilteringEnabled())) {
            this.getAggregatedData(() => this.plotChart());
        }
        else { // Else, simply plot the chart.
            // In case of live variable resetting the aggregated data to the normal dataset when the aggregation has been removed
            if (this.dataset && this.isLiveVariable) {
                this.chartData = this.dataset;
                if (this.isGroupByEnabled() && groupingDetails.isVisuallyGrouped) {
                    this.chartData = this.getVisuallyGroupedData(this.chartData, groupingDetails.visualGroupingColumn);
                }
            }
            this.plotChart();
        }
    }
    // sets the default x and y axis options
    setDefaultAxisOptions() {
        const defaultColumns = this.getDefaultColumns();
        // If we get the valid default columns then assign them as the x and y axis
        // In case of service variable we may not get the valid columns because we cannot know the datatypes
        this.xaxisdatakey = defaultColumns[0] || null;
        this.yaxisdatakey = defaultColumns[1] || null;
    }
    getCutomizedOptions(prop, fields) {
        const groupByColumns = _.split(this.groupby, ','), aggColumns = _.split(this.aggregationcolumn, ',');
        if (!this.binddataset) {
            return fields;
        }
        if (!this.axisoptions) {
            this.axisoptions = fields;
        }
        let newOptions;
        switch (prop) {
            case 'xaxisdatakey':
                // If group by enabled, columns chosen in groupby will be populated in x axis options
                if (this.isGroupByEnabled()) {
                    newOptions = groupByColumns;
                }
                break;
            case 'yaxisdatakey':
                // If aggregation by enabled, columns chosen in aggregation will be populated in y axis options
                if (this.isAggregationEnabled()) {
                    newOptions = aggColumns;
                }
                else if (this.isLiveVariable) {
                    // In case of live variable populating only numeric columns
                    newOptions = this.numericColumns;
                }
                break;
            case 'groupby':
                // Filtering only non primary key columns
                if (this.isLiveVariable && this.nonPrimaryColumns && this.nonPrimaryColumns.length) {
                    newOptions = this.nonPrimaryColumns;
                }
                break;
            case 'aggregationcolumn':
                // Set the 'aggregationColumn' to show all keys in case of aggregation function is count or to numeric keys in all other cases.
                if (this.isLiveVariable && this.isAggregationEnabled() && this.aggregation !== 'count') {
                    newOptions = this.numericColumns;
                }
                break;
            case 'orderby':
                // Set the 'aggregationColumn' to show all keys in case of aggregation function is count or to numeric keys in all other cases.
                if (this.isLiveVariable && this.isAggregationEnabled()) {
                    newOptions = _.uniq(_.concat(groupByColumns, aggColumns));
                }
                break;
            case 'bubblesize':
                if (this.numericColumns && this.numericColumns.length) {
                    newOptions = this.numericColumns;
                }
                break;
        }
        return newOptions || fields || this.axisoptions;
    }
    // Function that iterates through all the columns and then fetching the numeric and non primary columns among them
    setNumericandNonPrimaryColumns() {
        let columns, type;
        const propertiesMap = this.datasource.execute(DataSource.Operation.GET_PROPERTIES_MAP);
        this.numericColumns = [];
        this.nonPrimaryColumns = [];
        // Fetching all the columns
        if (this.dataset && !_.isEmpty(propertiesMap)) {
            columns = []; // TODO: fetchPropertiesMapColumns(propertiesMap);
        }
        if (columns) {
            // Iterating through all the columns and fetching the numeric and non primary key columns
            _.forEach(Object.keys(columns), (key) => {
                type = columns[key].type;
                if (isNumberType(type)) {
                    this.numericColumns.push(key);
                }
                // Hiding only table's primary key
                if (columns[key].isRelatedPk === 'true' || !columns[key].isPrimaryKey) {
                    this.nonPrimaryColumns.push(key);
                }
            });
            this.numericColumns = this.numericColumns.sort();
            this.nonPrimaryColumns = this.nonPrimaryColumns.sort();
        }
    }
    // plot the chart
    handleDataSet(newVal) {
        this.errMsg = '';
        // Resetting the flag to false when the binding was removed
        if (!newVal && !this.binddataset) {
            this.isVisuallyGrouped = false;
            this.axisoptions = null;
        }
        // liveVariables contain data in 'data' property' of the variable
        this.chartData = this.isLiveVariable ? newVal || '' : (newVal && newVal.dataValue === '' && _.keys(newVal).length === 1) ? '' : newVal;
        // if the data returned is an object make it an array of object
        if (!_.isArray(this.chartData) && _.isObject(this.chartData)) {
            this.chartData = [this.chartData];
        }
        if (newVal && newVal.filterFields) {
            this.filterFields = newVal.filterFields;
        }
        // plotchart for only valid data and only after bound variable returns data
        if (this.chartData) {
            this._plotChartProxy();
        }
    }
    onPropertyChange(key, newVal, oldVal) {
        super.onPropertyChange(key, newVal, oldVal);
        switch (key) {
            case 'dataset':
                this.handleDataSet(newVal);
                break;
            case 'type':
                // Based on the change in type deciding the default margins
                if (isPieType(this.type)) {
                    this.offsettop = 20;
                    this.offsetright = 0;
                    this.offsetbottom = 0;
                    this.offsetleft = 0;
                }
                else if (oldVal === 'Pie' || oldVal === 'Donut') {
                    this.offsettop = 25;
                    this.offsetright = 25;
                    this.offsetbottom = 55;
                    this.offsetleft = 75;
                }
                if (oldVal !== newVal) {
                    this.clearCanvas = true;
                }
                // In studio mode, configure properties dependent on chart type
                this._plotChartProxy();
                break;
            default:
                // In RunMode, the plotchart method will not be called for all property change
                this._plotChartProxy();
                break;
        }
        if (_.includes(advanceDataProps, key)) {
            this._plotChartProxy();
        }
    }
    handleLoading(data) {
        const dataSource = this.datasource;
        if (dataSource && dataSource.execute(DataSource.Operation.IS_API_AWARE) && isDataSourceEqual(data.variable, dataSource)) {
            this.variableInflight = data.active;
            this.isLoadInProgress = data.active;
        }
    }
    onStyleChange(key, newVal, oldVal) {
        const styleObj = {};
        super.onStyleChange(key, newVal, oldVal);
        switch (key) {
            case 'fontsize':
            case 'fontunit':
            case 'color':
            case 'fontfamily':
            case 'fontweight':
            case 'fontstyle':
            case 'textdecoration':
                styleObj[styleProps[key]] = (key === 'fontsize' || key === 'fontunit') ? this.fontsize + this.fontunit : newVal;
                setTextStyle(styleObj, this.$id);
                break;
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        // For old projects
        if (!_.includes(['outside', 'inside', 'hide'], this.showlabels)) {
            this.showlabels = getBooleanValue(this.showlabels);
            this.showlabelsoutside = getBooleanValue(this.showlabelsoutside);
            this.showlabels = this.showlabels ? (this.showlabelsoutside ? 'outside' : 'inside') : 'hide';
        }
        if (!this.theme) {
            // Default theme for pie/donut is Azure and for other it is Terrestrial
            this.theme = isPieType(this.type) ? 'Azure' : 'Terrestrial';
        }
        this.nativeElement.setAttribute('id', 'wmChart' + this.$id);
        // When there is not value binding, then plot the chart with sample data
        if (!this.binddataset && !this.nativeElement.getAttribute('scopedataset')) {
            this._plotChartProxy();
        }
    }
}
ChartComponent.initializeProps = registerProps$f();
ChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmChart]',
                template: "<div class=\"panel-heading\" *ngIf=\"title\">\n    <h3 class=\"panel-title\">\n        <div class=\"pull-left\"><i class=\"app-icon panel-icon {{iconclass}}\" [class.ng-hide]=\"!iconclass\"></i></div>\n        <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\"></div>\n        <div class=\"description\" *ngIf=\"subheading\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n    </h3>\n</div>\n<div class=\"app-chart-inner\" [ngClass]=\"{'loading':isLoadInProgress, 'panel-body': title}\">\n    <svg></svg>\n    <div class=\"wm-content-info readonly-wrapper\" *ngIf=\"showContentLoadError && showNoDataMsg\">\n        <p class=\"wm-message\" [title]=\"hintMsg\" [ngClass]=\"{'error': invalidConfig}\" [innerText]=\"errMsg\"></p>\n    </div>\n    <div wmSpinner show.bind=\"isLoadInProgress\" caption.bind=\"loadingdatamsg\"></div>\n</div>",
                providers: [
                    provideAsWidgetRef(ChartComponent)
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".nvd3 .nv-axis{pointer-events:none;opacity:1}.nvd3 .nv-axis path{fill:none;stroke:#000;stroke-opacity:.75;shape-rendering:crispEdges}.nvd3 .nv-axis path.domain{stroke-opacity:.75}.nvd3 .nv-axis.nv-x path.domain{stroke-opacity:0}.nvd3 .nv-axis line{fill:none;stroke:#e5e5e5;shape-rendering:crispEdges}.nvd3 .nv-axis .zero line,.nvd3 .nv-axis line.zero{stroke-opacity:.75}.nvd3 .nv-axis .nv-axisMaxMin text{font-weight:700}.nvd3 .x .nv-axis .nv-axisMaxMin text,.nvd3 .x2 .nv-axis .nv-axisMaxMin text,.nvd3 .x3 .nv-axis .nv-axisMaxMin text{text-anchor:middle}.nvd3 .nv-axis.nv-disabled{opacity:0}.nvd3 .nv-bars rect{fill-opacity:.75;transition:fill-opacity 250ms linear}.nvd3 .nv-bars rect.hover{fill-opacity:1}.nvd3 .nv-bars .hover rect{fill:#add8e6}.nvd3 .nv-bars text{fill:transparent}.nvd3 .nv-bars .hover text{fill:rgba(0,0,0,1)}.nvd3 .nv-discretebar .nv-groups rect,.nvd3 .nv-multibar .nv-groups rect,.nvd3 .nv-multibarHorizontal .nv-groups rect{stroke-opacity:0;transition:fill-opacity 250ms linear}.nvd3 .nv-candlestickBar .nv-ticks rect:hover,.nvd3 .nv-discretebar .nv-groups rect:hover,.nvd3 .nv-multibar .nv-groups rect:hover,.nvd3 .nv-multibarHorizontal .nv-groups rect:hover{fill-opacity:1}.nvd3 .nv-discretebar .nv-groups text,.nvd3 .nv-multibarHorizontal .nv-groups text{font-weight:700;fill:rgba(0,0,0,1);stroke:transparent}.nvd3 .nv-boxplot circle{fill-opacity:.5}.nvd3 .nv-boxplot circle:hover,.nvd3 .nv-boxplot rect:hover{fill-opacity:1}.nvd3 line.nv-boxplot-median{stroke:#000}.nv-boxplot-tick:hover{stroke-width:2.5px}.nvd3.nv-bullet{font:10px sans-serif}.nvd3.nv-bullet .nv-measure{fill-opacity:.8}.nvd3.nv-bullet .nv-measure:hover{fill-opacity:1}.nvd3.nv-bullet .nv-marker{stroke:#000;stroke-width:2px}.nvd3.nv-bullet .nv-markerTriangle{stroke:#000;fill:#fff;stroke-width:1.5px}.nvd3.nv-bullet .nv-markerLine{stroke:#000;stroke-width:1.5px}.nvd3.nv-bullet .nv-tick line{stroke:#666;stroke-width:.5px}.nvd3.nv-bullet .nv-range.nv-s0{fill:#eee}.nvd3.nv-bullet .nv-range.nv-s1{fill:#ddd}.nvd3.nv-bullet .nv-range.nv-s2{fill:#ccc}.nvd3.nv-bullet .nv-title{font-size:14px;font-weight:700}.nvd3.nv-bullet .nv-subtitle{fill:#999}.nvd3.nv-bullet .nv-range{fill:#bababa;fill-opacity:.4}.nvd3.nv-bullet .nv-range:hover{fill-opacity:.7}.nvd3.nv-candlestickBar .nv-ticks .nv-tick{stroke-width:1px}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.hover{stroke-width:2px}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.positive rect{stroke:#2ca02c;fill:#2ca02c}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.negative rect{stroke:#d62728;fill:#d62728}.with-transitions .nv-candlestickBar .nv-ticks .nv-tick{transition:stroke-width 250ms linear,stroke-opacity 250ms linear}.nvd3.nv-candlestickBar .nv-ticks line{stroke:#333}.nv-force-node{stroke:#fff;stroke-width:1.5px}.nv-force-link{stroke:#999;stroke-opacity:.6}.nv-force-node text{stroke-width:0}.nvd3 .nv-check-box .nv-box{fill-opacity:0;stroke-width:2}.nvd3 .nv-check-box .nv-check{fill-opacity:0;stroke-width:4}.nvd3 .nv-series.nv-disabled .nv-check-box .nv-check{fill-opacity:0;stroke-opacity:0}.nvd3 .nv-controlsWrap .nv-legend .nv-check-box .nv-check{opacity:0}.nvd3.nv-linePlusBar .nv-bar rect{fill-opacity:.75}.nvd3.nv-linePlusBar .nv-bar rect:hover{fill-opacity:1}.nvd3 .nv-groups path.nv-line{fill:none}.nvd3 .nv-groups path.nv-area{stroke:none}.nvd3.nv-line .nvd3.nv-scatter .nv-groups .nv-point{fill-opacity:0;stroke-opacity:0}.nvd3.nv-scatter.nv-single-point .nv-groups .nv-point{fill-opacity:.5!important;stroke-opacity:.5!important}.with-transitions .nvd3 .nv-groups .nv-point{transition:stroke-width 250ms linear,stroke-opacity 250ms linear}.nvd3 .nv-groups .nv-point.hover,.nvd3.nv-scatter .nv-groups .nv-point.hover{stroke-width:7px;fill-opacity:.95!important;stroke-opacity:.95!important}.nvd3 .nv-point-paths path{stroke:#aaa;stroke-opacity:0;fill:#eee;fill-opacity:0}.nvd3 .nv-indexLine{cursor:ew-resize}svg.nvd3-svg{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;width:100%;height:100%}.nvtooltip.with-3d-shadow,.with-3d-shadow .nvtooltip{box-shadow:0 5px 10px rgba(0,0,0,.2);border-radius:5px}.nvd3 text{font:12px Arial,sans-serif}.nvd3 .title{font:bold 14px Arial,sans-serif}.nvd3 .nv-background{fill:#fff;fill-opacity:0}.nvd3.nv-noData{font-size:18px;font-weight:700}.nv-brush .extent{fill-opacity:.125;shape-rendering:crispEdges}.nv-brush .resize path{fill:#eee;stroke:#666}.nvd3 .nv-legend .nv-series{cursor:pointer}.nvd3 .nv-legend .nv-disabled circle{fill-opacity:0}.nvd3 .nv-brush .extent{fill-opacity:0!important}.nvd3 .nv-brushBackground rect{stroke:#000;stroke-width:.4;fill:#fff;fill-opacity:.7}@media print{.nvd3 text{stroke-width:0;fill-opacity:1}}.nvd3.nv-ohlcBar .nv-ticks .nv-tick{stroke-width:1px}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.hover{stroke-width:2px}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.positive{stroke:#2ca02c}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.negative{stroke:#d62728}.nvd3 .background path{fill:none;stroke:#eee;stroke-opacity:.4;shape-rendering:crispEdges}.nvd3 .foreground path{fill:none;stroke-opacity:.7}.nvd3 .nv-parallelCoordinates-brush .extent{fill:#fff;fill-opacity:.6;stroke:gray;shape-rendering:crispEdges}.nvd3 .nv-parallelCoordinates .hover{fill-opacity:1;stroke-width:3px}.nvd3 .missingValuesline line{fill:none;stroke:#000;stroke-width:1;stroke-opacity:1;stroke-dasharray:5,5}.nvd3.nv-pie path{stroke-opacity:0;transition:fill-opacity 250ms linear,stroke-width 250ms linear,stroke-opacity 250ms linear;stroke:#fff;stroke-width:1px;stroke-opacity:1;fill-opacity:.7}.nvd3.nv-pie .nv-pie-title{font-size:24px;fill:rgba(19,196,249,.59)}.nvd3.nv-pie .nv-slice text{stroke:#000;stroke-width:0}.nvd3.nv-pie .hover path{fill-opacity:1}.nvd3.nv-pie .nv-label{pointer-events:none}.nvd3.nv-pie .nv-label rect{fill-opacity:0;stroke-opacity:0}.nvd3 .nv-groups .nv-point.hover{stroke-width:20px;stroke-opacity:.5}.nvd3 .nv-scatter .nv-point.hover{fill-opacity:1}.nv-distx,.nv-disty,.nv-noninteractive{pointer-events:none}.nvd3.nv-sparkline path{fill:none}.nvd3.nv-sparklineplus g.nv-hoverValue{pointer-events:none}.nvd3.nv-sparklineplus .nv-hoverValue line{stroke:#333;stroke-width:1.5px}.nvd3.nv-sparklineplus,.nvd3.nv-sparklineplus g{pointer-events:all}.nvd3 .nv-hoverArea{fill-opacity:0;stroke-opacity:0}.nvd3.nv-sparklineplus .nv-xValue,.nvd3.nv-sparklineplus .nv-yValue{stroke-width:0;font-size:.9em;font-weight:400}.nvd3.nv-sparklineplus .nv-yValue{stroke:#f66}.nvd3.nv-sparklineplus .nv-maxValue{stroke:#2ca02c;fill:#2ca02c}.nvd3.nv-sparklineplus .nv-minValue{stroke:#d62728;fill:#d62728}.nvd3.nv-sparklineplus .nv-currentValue{font-weight:700;font-size:1.1em}.nvd3.nv-stackedarea path.nv-area{fill-opacity:.7;stroke-opacity:0;transition:fill-opacity 250ms linear,stroke-opacity 250ms linear}.nvd3.nv-stackedarea path.nv-area.hover{fill-opacity:.9}.nvd3.nv-stackedarea .nv-groups .nv-point{stroke-opacity:0;fill-opacity:0}.nvtooltip{position:absolute;color:rgba(0,0,0,1);padding:1px;border:1px solid rgba(0,0,0,.5);z-index:10000;display:block;font-family:Arial,sans-serif;font-size:13px;text-align:left;pointer-events:none;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background:rgba(255,255,255,.8);border-radius:4px}.nvtooltip.with-transitions,.with-transitions .nvtooltip{transition:opacity 50ms linear .2s}.nvtooltip.x-nvtooltip,.nvtooltip.y-nvtooltip{padding:8px}.nvtooltip h3{margin:0;padding:4px 14px;line-height:18px;font-weight:400;background-color:rgba(247,247,247,.75);color:rgba(0,0,0,1);text-align:center;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.nvtooltip p{margin:0;padding:5px 14px;text-align:center}.nvtooltip span{display:inline-block;margin:2px 0}.nvtooltip table{margin:6px;border-spacing:0}.nvtooltip table td{padding:2px 9px 2px 0;vertical-align:middle}.nvtooltip table td.key{font-weight:400}.nvtooltip table td.key.total{font-weight:700}.nvtooltip table td.value{text-align:right;font-weight:700}.nvtooltip table td.percent{color:#a9a9a9}.nvtooltip table tr.highlight td{padding:1px 9px 1px 0;border-bottom-style:solid;border-bottom-width:1px;border-top-style:solid;border-top-width:1px}.nvtooltip table td.legend-color-guide div{vertical-align:middle;width:12px;height:12px;border:1px solid #999}.nvtooltip .footer{padding:3px;text-align:center}.nvtooltip-pending-removal{pointer-events:none;display:none}.nvd3 .nv-interactiveGuideLine{pointer-events:none}.nvd3 line.nv-guideline{stroke:#ccc}"]
            }] }
];
/** @nocollapse */
ChartComponent.ctorParameters = () => [
    { type: Injector },
    { type: App }
];
ChartComponent.propDecorators = {
    title: [{ type: HostBinding, args: ['class.panel',] }]
};

const checkboxProps = new Map([
    ['caption', PROP_STRING],
    ['class', PROP_STRING],
    ['conditionalclass', PROP_ANY],
    ['conditionalstyle', PROP_ANY],
    ['checkedvalue', Object.assign({ value: true }, PROP_STRING)],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['name', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['uncheckedvalue', Object.assign({ value: false }, PROP_STRING)]
]);
const registerProps$g = () => {
    register('wm-checkbox', checkboxProps);
};

class BaseFormComponent extends StylableComponent {
    constructor(inj, config, initPromise) {
        super(inj, config, initPromise);
        this.inj = inj;
        this.binddatavalue = this.$element.attr('datavalue.bind');
    }
    /**
     * Responsible for updating the variable bound to the widget's datavalue property.
     * @param value
     */
    updateBoundVariable(value) {
        let binddatavalue = this.binddatavalue;
        // return if the variable bound is not static.
        if (this.datavaluesource && this.datavaluesource.execute(DataSource.Operation.IS_API_AWARE)) {
            return;
        }
        else if (this.datavaluesource && !this.datavaluesource.twoWayBinding) {
            return;
        }
        // return if widget is bound.
        if (!binddatavalue || binddatavalue.startsWith('Widgets.') || binddatavalue.startsWith('itemRef.currentItemWidgets')) {
            return;
        }
        binddatavalue = binddatavalue.replace(/\[\$i\]/g, '[0]');
        // In case of list widget context will be the listItem.
        if (_.has(this.context, binddatavalue.split('.')[0])) {
            _.set(this.context, binddatavalue, value);
        }
        else {
            _.set(this.viewParent, binddatavalue, value);
        }
    }
    invokeOnChange(value, $event) {
        // invoke the event callback
        if ($event) {
            if (this.datavalue !== this.prevDatavalue) {
                this.updateBoundVariable(value);
                this.invokeEventCallback('change', {
                    $event,
                    newVal: value,
                    oldVal: this.prevDatavalue
                });
            }
        }
        // update the previous value
        this.prevDatavalue = value;
    }
    updatePrevDatavalue(val) {
        this.prevDatavalue = val;
    }
}

class BaseFormCustomComponent extends BaseFormComponent {
    constructor() {
        super(...arguments);
        this._onChange = () => { };
        this._onTouched = () => { };
    }
    ngOnInit() {
        super.ngOnInit();
        this._formControl = this.inj.get(FormControlName, null);
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    writeValue(value) {
        if (this.isDestroyed) {
            return;
        }
        if (this._formControl) {
            this.datavalue = value;
            this.onPropertyChange('datavalue', value);
            this.updatePrevDatavalue(value);
        }
    }
    invokeOnChange(value, $event, valid) {
        // let the angular know about the change
        this._onChange(value);
        if (valid) {
            super.invokeOnChange(value, $event);
        }
    }
    invokeOnTouched($event) {
        this._onTouched();
        if ($event) {
            this.invokeEventCallback('blur', { $event });
        }
    }
    invokeOnFocus($event) {
        this.invokeEventCallback('focus', { $event });
    }
}

const DEFAULT_CLS$d = 'app-checkbox checkbox';
const WIDGET_CONFIG$f = {
    widgetType: 'wm-checkbox',
    hostClass: DEFAULT_CLS$d
};
/*
 * try to convert the chekedvalue and unchecked values to boolean/number
 */
const unStringify = (val, defaultVal) => {
    if (val === null) {
        return defaultVal;
    }
    if (val === true || val === 'true') {
        return true;
    }
    if (val === false || val === 'false') {
        return false;
    }
    const number = parseInt(val, 10);
    if (!isNaN(number)) {
        return number;
    }
    return val;
};
class CheckboxComponent extends BaseFormCustomComponent {
    constructor(inj, checkedVal, uncheckedVal, type) {
        super(inj, WIDGET_CONFIG$f);
        this._caption = '&nbsp';
        this._checkedvalue = unStringify(checkedVal, true);
        this._uncheckedvalue = unStringify(uncheckedVal, false);
        // if the type of the checkbox is toggle update the related classes on the host node
        toggleClass(this.nativeElement, 'app-toggle', type === 'toggle');
    }
    // if the checkbox is checked, return checkedvalue else return uncheckedvalue
    get datavalue() {
        return isDefined(this.proxyModel) ? (this.proxyModel ? this._checkedvalue : this._uncheckedvalue) : undefined;
    }
    // when the datavalue is set, update the checked state
    set datavalue(v) {
        this.proxyModel = (isDefined(v) && v !== '') ? v === this._checkedvalue : undefined;
        this.updatePrevDatavalue(this.datavalue);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'tabindex') {
            return;
        }
        if (key === 'caption') {
            if (!isDefined(nv) || nv === '') {
                this._caption = '&nbsp;';
            }
            else {
                this._caption = nv;
            }
        }
        else if (key === 'checkedvalue') {
            this._checkedvalue = unStringify(nv, true);
        }
        else if (key === 'uncheckedvalue') {
            this._uncheckedvalue = unStringify(nv, false);
        }
        else if (key === 'datavalue') {
            this.datavalue = unStringify(nv);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    // change and blur events are handled from template
    handleEvent(node, eventName, callback, locals) {
        if (eventName !== 'change' && eventName !== 'blur') {
            // applying tap (Hammer event) on the label as the event handler is not getting triggered on the input.
            const $el = eventName === 'tap' ? this.nativeElement.querySelector('label') : this.checkboxEl.nativeElement;
            super.handleEvent($el, eventName, callback, locals);
        }
    }
    handleChange(newVal) {
        this.invokeOnChange(this.datavalue, { type: 'change' }, this.ngModel.valid);
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.nativeElement.querySelector('label'), this);
    }
}
CheckboxComponent.initializeProps = registerProps$g();
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmCheckbox]',
                template: "<label [ngClass]=\"{'unchecked': !proxyModel, 'disabled': (disabled || readonly), 'required': (required && _caption)}\" role=\"button\">\n    <input type=\"checkbox\" aria-describedby=\"checkbox\"\n           #checkbox\n           [attr.name]=\"name\"\n           focus-target\n           [(ngModel)]=\"proxyModel\"\n           [readonly]=\"readonly\"\n           [required]=\"required\"\n           [disabled]=\"disabled || readonly\"\n           [attr.accesskey]=\"shortcutkey\"\n           [tabindex]=\"tabindex\"\n           (blur)=\"invokeOnTouched($event)\"\n           (ngModelChange)=\"handleChange($event)\">\n    <span class=\"caption\" [innerHtml]=\"_caption\"></span>\n    <img alt=\"Checkbox Image\" src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" class=\"switch\"/>\n</label>\n<input type=\"hidden\" class=\"ng-hide model-holder\" [disabled]=\"disabled\" [value]=\"proxyModel\">\n",
                providers: [
                    provideAsNgValueAccessor(CheckboxComponent),
                    provideAsWidgetRef(CheckboxComponent)
                ]
            }] }
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Attribute, args: ['checkedvalue',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['uncheckedvalue',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['type',] }] }
];
CheckboxComponent.propDecorators = {
    ngModel: [{ type: ViewChild, args: [NgModel,] }],
    checkboxEl: [{ type: ViewChild, args: ['checkbox', { read: ElementRef },] }]
};

const getEpochValue = data => {
    let epoch;
    // For data in form of string number ('123'), convert to number (123). And don't parse date objects.
    if (!_.isDate(data) && !isNaN(data)) {
        data = parseInt(data, 10);
    }
    // get the timestamp value. If data is time string, append date string to the time value
    epoch = moment(data).valueOf() || moment(new Date().toDateString() + ' ' + data).valueOf();
    return epoch;
};
class ToDatePipe {
    constructor(datePipe) {
        this.datePipe = datePipe;
    }
    transform(data, format) {
        let timestamp;
        // 'null' is to be treated as a special case, If user wants to enter null value, empty string will be passed to the backend
        if (data === 'null' || data === '') {
            return '';
        }
        if (!isDefined(data)) {
            return '';
        }
        timestamp = getEpochValue(data);
        if (timestamp) {
            if (format === 'timestamp') {
                return timestamp;
            }
            return this.datePipe.transform(timestamp, format);
        }
        return '';
    }
}
ToDatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'toDate'
            },] }
];
/** @nocollapse */
ToDatePipe.ctorParameters = () => [
    { type: DatePipe }
];
class ToNumberPipe {
    constructor(decimalPipe) {
        this.decimalPipe = decimalPipe;
    }
    transform(data, fracSize) {
        if (fracSize && !String(fracSize).match(/^(\d+)?\.((\d+)(-(\d+))?)?$/)) {
            fracSize = '1.' + fracSize + '-' + fracSize;
        }
        if (!_.isNaN(+data)) {
            return this.decimalPipe.transform(data, fracSize);
        }
    }
}
ToNumberPipe.decorators = [
    { type: Pipe, args: [{
                name: 'toNumber'
            },] }
];
/** @nocollapse */
ToNumberPipe.ctorParameters = () => [
    { type: DecimalPipe }
];
class ToCurrencyPipe {
    constructor(decimalPipe) {
        this.decimalPipe = decimalPipe;
    }
    transform(data, currencySymbol, fracSize) {
        const _currencySymbol = (CURRENCY_INFO[currencySymbol] || {}).symbol || currencySymbol || '', _val = new ToNumberPipe(this.decimalPipe).transform(data, fracSize);
        return _val ? _currencySymbol + _val : '';
    }
}
ToCurrencyPipe.decorators = [
    { type: Pipe, args: [{
                name: 'toCurrency'
            },] }
];
/** @nocollapse */
ToCurrencyPipe.ctorParameters = () => [
    { type: DecimalPipe }
];
class PrefixPipe {
    transform(data, padding) {
        return (_.isUndefined(data) || data === null || data === '') ? data : ((padding || '') + data);
    }
}
PrefixPipe.decorators = [
    { type: Pipe, args: [{
                name: 'prefix'
            },] }
];
class SuffixPipe {
    transform(data, padding) {
        return (_.isUndefined(data) || data === null || data === '') ? data : (data + (padding || ''));
    }
}
SuffixPipe.decorators = [
    { type: Pipe, args: [{
                name: 'suffix'
            },] }
];
class TimeFromNowPipe {
    transform(data) {
        let timestamp;
        if (!isDefined(data)) {
            return undefined;
        }
        timestamp = getEpochValue(data);
        return timestamp ? moment(timestamp).fromNow() : undefined;
    }
}
TimeFromNowPipe.decorators = [
    { type: Pipe, args: [{
                name: 'timeFromNow'
            },] }
];
class NumberToStringPipe extends ToNumberPipe {
}
NumberToStringPipe.decorators = [
    { type: Pipe, args: [{
                name: 'numberToString'
            },] }
];
class StringToNumberPipe {
    transform(data) {
        return Number(data) || undefined;
    }
}
StringToNumberPipe.decorators = [
    { type: Pipe, args: [{
                name: 'stringToNumber'
            },] }
];
class FilterPipe {
    transform(data, field, value) {
        if (!data) {
            return [];
        }
        // If object is passed as first paramter
        if (_.isObject(field)) {
            return _.filter(data, field);
        }
        // If key value pair is provided
        return _.filter(data, item => {
            return _.includes(item[field], value);
        });
    }
}
FilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'filter'
            },] }
];
class FileSizePipe {
    transform(bytes, precision) {
        const units = [
            'bytes',
            'KB',
            'MB',
            'GB',
            'TB',
            'PB'
        ];
        /*Todo[shubham]
        if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) {
            return isMobile() ? '' : '?';
        }*/
        let unit = 0;
        while (bytes >= 1024) {
            bytes /= 1024;
            unit++;
        }
        return bytes.toFixed(+precision) + ' ' + units[unit];
    }
}
FileSizePipe.decorators = [
    { type: Pipe, args: [{
                name: 'filesize'
            },] }
];
class FileIconClassPipe {
    transform(fileExtension) {
        const fileClassMapping = {
            'zip': 'fa-file-zip-o',
            'pdf': 'fa-file-pdf-o',
            'rar': 'fa-file-archive-o',
            'txt': 'fa-file-text-o',
            'ppt': 'fa-file-powerpoint-o',
            'pot': 'fa-file-powerpoint-o',
            'pps': 'fa-file-powerpoint-o',
            'pptx': 'fa-file-powerpoint-o',
            'potx': 'fa-file-powerpoint-o',
            'ppsx': 'fa-file-powerpoint-o',
            'mpg': 'fa-file-movie-o',
            'mp4': 'fa-file-movie-o',
            'mov': 'fa-file-movie-o',
            'avi': 'fa-file-movie-o',
            'mp3': 'fa-file-audio-o',
            'docx': 'fa-file-word-o',
            'js': 'fa-file-code-o',
            'md': 'fa-file-code-o',
            'html': 'fa-file-code-o',
            'css': 'fa-file-code-o',
            'xlsx': 'fa-file-excel-o',
            'png': 'fa-file-image-o',
            'jpg': 'fa-file-image-o',
            'jpeg': 'fa-file-image-o',
            'file': 'fa-file-o',
            'default': 'fa-file-o'
        };
        return 'fa ' + (fileClassMapping[fileExtension] || 'fa-file-o');
    }
}
FileIconClassPipe.decorators = [
    { type: Pipe, args: [{
                name: 'fileIconClass'
            },] }
];
class StateClassPipe {
    transform(state) {
        const stateClassMap = {
            'success': 'wi wi-done text-success',
            'error': 'wi wi-cancel text-danger'
        };
        return stateClassMap[state.toLowerCase()];
    }
}
StateClassPipe.decorators = [
    { type: Pipe, args: [{
                name: 'stateClass'
            },] }
];
class FileExtensionFromMimePipe {
    transform(mimeType) {
        const typeMapping = {
            'audio/aac': '.aac',
            'application/x-abiword': '.abw',
            'application/vnd.android.package-archive': '.apk',
            'video/x-msvideo': '.avi',
            'application/vnd.amazon.ebook': '.azw',
            'application/octet-stream': '.bin',
            'image/bmp': '.bmp',
            'application/x-bzip': '.bz',
            'application/x-bzip2': '.bz2',
            'application/x-csh': '.csh',
            'text/css': '.css',
            'text/csv': '.csv',
            'application/msword': '.doc',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx',
            'application/vnd.ms-fontobject': '.eot',
            'application/epub+zip': '.epub',
            'application/ecmascript': '.es',
            'image/gif': '.gif',
            'text/html': '.html',
            'image/x-icon': '.ico',
            'text/calendar': '.ics',
            'application/java-archive': '.jar',
            'image/jpeg': ['.jpeg', '.jpg'],
            'application/javascript': '.js',
            'application/json': '.json',
            'audio/midi': '.mid',
            'audio/x-midi': '.midi',
            'video/mpeg': '.mpeg',
            'application/vnd.apple.installer+xml': 'mpkg',
            'application/vnd.oasis.opendocument.presentation': '.odp',
            'application/vnd.oasis.opendocument.spreadsheet': '.ods',
            'application/vnd.oasis.opendocument.text': '.odt',
            'audio/ogg': '.oga',
            'video/ogg': '.ogv',
            'application/ogg': '.ogx',
            'font/otf': '.otf',
            'image/png': '.png',
            'application/pdf': '.pdf',
            'application/vnd.ms-powerpoint': '.ppt',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation': '.pptx',
            'application/x-rar-compressed': '.rar',
            'application/rtf': '.rtf',
            'application/x-sh': '.sh',
            'image/svg+xml': '.svg',
            'application/x-shockwave-flash': '.swf',
            'application/x-tar': '.tar',
            'image/tiff': '.tiff',
            'application/typescript': '.ts',
            'font/ttf': '.ttf',
            'text/plain': '.txt',
            'application/vnd.visio': '.vsd',
            'audio/wav': '.wav',
            'audio/webm': '.weba',
            'video/webm': '.webm',
            'image/webp': '.webp',
            'font/woff': '.woff',
            'font/woff2': '.woff2',
            'application/xhtml+xml': '.xhtml',
            'application/vnd.ms-excel': '.xls',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': '.xlsx',
            'application/xml': '.xml',
            'application/vnd.mozilla.xul+xml': '.xul',
            'application/zip': '.zip',
            'video/3gpp': '.3gp',
            'audio/3gpp': '.3gp',
            'video/3gpp2': '.3g2',
            'audio/3gpp2': '.3g2',
            'application/x-7z-compressed': '.7z'
        };
        return typeMapping[mimeType];
    }
}
FileExtensionFromMimePipe.decorators = [
    { type: Pipe, args: [{
                name: 'fileExtensionFromMime'
            },] }
];

const checkboxsetProps = new Map([
    ['class', PROP_STRING],
    ['collapsible', PROP_BOOLEAN],
    ['compareby', PROP_STRING],
    ['datafield', PROP_STRING],
    ['dataset', Object.assign({ value: 'Option 1, Option 2, Option 3' }, PROP_ANY)],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['dateformat', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['displayexpression', PROP_STRING],
    ['displayfield', PROP_STRING],
    ['displayValue', PROP_STRING],
    ['groupby', PROP_STRING],
    ['itemclass', Object.assign({ value: '' }, PROP_STRING)],
    ['layout', Object.assign({ value: 'stacked' }, PROP_STRING)],
    ['listclass', Object.assign({ value: '' }, PROP_STRING)],
    ['match', PROP_STRING],
    ['name', PROP_STRING],
    ['orderby', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showcount', PROP_BOOLEAN],
    ['showindevice', Object.assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['usekeys', PROP_BOOLEAN]
]);
const registerProps$h = () => {
    register('wm-checkboxset', checkboxsetProps);
};

class DatasetAwareFormComponent extends BaseFormCustomComponent {
    constructor(inj, WIDGET_CONFIG) {
        super(inj, WIDGET_CONFIG);
        this.datasetItems = [];
        this.acceptsArray = false; // set to true if proxyModel on widget accepts array type.
        this.dataset$ = new Subject();
        this.datavalue$ = new Subject();
        this.allowempty = true;
        this._debounceDatavalueUpdation = _.debounce((values) => {
            // if no item is found in datasetItems, wait untill the dataset updates by preserving the datavalue in toBeProcessedDatavalue.
            if (!isDefined(this._modelByKey) || (_.isArray(this._modelByKey) && !this._modelByKey.length)) {
                this.toBeProcessedDatavalue = values;
                this._modelByValue = undefined;
            }
            else if (isDefined(this.toBeProcessedDatavalue)) {
                // obtain the first array value when multiple is set to false.
                // set the modelByValue only when undefined.
                if (!isDefined(this._modelByValue)) {
                    this._modelByValue = (!this.multiple && _.isArray(this.toBeProcessedDatavalue)) ? this.toBeProcessedDatavalue[0] : this.toBeProcessedDatavalue;
                }
                this.toBeProcessedDatavalue = undefined;
            }
            this.initDisplayValues();
        }, 150);
        this.binddisplayexpression = this.nativeElement.getAttribute('displayexpression.bind');
        this.binddisplayimagesrc = this.nativeElement.getAttribute('displayimagesrc.bind');
        this.binddisplaylabel = this.nativeElement.getAttribute('displaylabel.bind');
        this._debouncedInitDatasetItems = debounce(() => {
            this.initDatasetItems();
            $appDigest();
        }, 150);
    }
    get modelByKey() {
        return this._modelByKey;
    }
    // triggers on ngModel change. This function extracts the datavalue value.
    set modelByKey(val) {
        this.selectByKey(val);
        // invoke on datavalue change.
        this.invokeOnChange(this._modelByValue);
    }
    get datavalue() {
        return this._modelByValue;
    }
    // triggers on setting the datavalue. This function extracts the model value.
    set datavalue(val) {
        if (this.multiple) {
            val = extractDataAsArray(val);
        }
        this._modelByValue = val;
        this.selectByValue(val);
        // changes on the datavalue can be subscribed using listenToDatavalue
        this.datavalue$.next(val);
        // invoke on datavalue change.
        this.invokeOnChange(val, undefined, true);
    }
    /**
     * This function sets the _datavalue value from the model and sets the selected flag when item is found.
     * Here model is the value obtained from ngModel.
     * @param keys represent the model.
     */
    selectByKey(keys) {
        this.resetDatasetItems();
        if (!this.datasetItems.length) {
            return;
        }
        if (this.multiple && !_.isArray(keys)) {
            keys = [keys];
        }
        // Set the _modelByKey to the modified keys.
        this._modelByKey = keys;
        if (this.multiple) {
            this._modelByValue = [];
            keys.forEach(key => {
                const itemByKey = _.find(this.datasetItems, item => {
                    // not triple equal, as the instance type can be different.
                    // only value comparison should be done.
                    return _.toString(item.key) === _.toString(key);
                });
                if (itemByKey) {
                    itemByKey.selected = true;
                    this._modelByValue = [...this._modelByValue, itemByKey.value];
                }
            });
        }
        else {
            this._modelByValue = '';
            const itemByKey = _.find(this.datasetItems, item => {
                // not triple equal, as the instance type can be different.
                // only value comparison should be done.
                return _.toString(item.key) === _.toString(keys);
            });
            if (itemByKey) {
                itemByKey.selected = true;
                this._modelByValue = itemByKey.value;
            }
        }
        this.initDisplayValues();
    }
    /**
     * This function sets the _model value from the datavalue (selectedvalues) and sets the selected flag when item is found.
     * datavalue is the default value or a value representing the displayField (for suppose: object in case of ALLFIELDS).
     * If acceptsArray is true, the model always accepts an array.
     * For example, select always accepts model as array whether multiple select is true or false.
     * @param values represent the datavalue.
     */
    selectByValue(values) {
        this.resetDatasetItems();
        // if datavalue is not defined or empty then set the model as undefined.
        if (!isDefined(values) || values === '' || _.isNull(values) || (values instanceof Array && !values.length)) {
            this._modelByKey = undefined;
            // do not return when allowempty is set to true.
            if (!this.allowempty || !isDefined(values)) {
                return;
            }
        }
        if (this.acceptsArray && !_.isArray(values)) {
            values = this.allowempty ? [values] : extractDataAsArray(values);
        }
        // preserve the datavalue if datasetItems are empty.
        if (!this.datasetItems.length && isDefined(values)) {
            this.toBeProcessedDatavalue = values;
            return;
        }
        const filterField = this.datafield === ALLFIELDS ? 'dataObject' : 'key';
        if (_.isArray(values)) {
            this._modelByKey = [];
            values.forEach(val => {
                const itemByValue = _.find(this.datasetItems, item => {
                    if (filterField === 'dataObject') {
                        if (this.compareby && this.compareby.length) {
                            return isEqualWithFields(item[filterField], val, this.compareby);
                        }
                    }
                    return (_.isObject(item.value) ? _.isEqual(item.value, val) : (_.toString(item.value)).toLowerCase() === (_.toString(val)).toLowerCase());
                });
                if (itemByValue) {
                    itemByValue.selected = true;
                    this._modelByKey.push(itemByValue.key);
                }
            });
        }
        else {
            this._modelByKey = undefined;
            const itemByValue = _.find(this.datasetItems, item => {
                if (filterField === 'dataObject') {
                    if (this.compareby && this.compareby.length) {
                        return isEqualWithFields(item[filterField], values, this.compareby);
                    }
                }
                return (_.isObject(item.value) ? _.isEqual(item.value, values) : (_.toString(item.value)).toLowerCase() === (_.toString(values)).toLowerCase());
            });
            if (itemByValue) {
                itemByValue.selected = true;
                this._modelByKey = itemByValue.key;
            }
        }
        // delaying the datavalue update as the widgets in liveform are having datavalue as undefined and not the default provided value
        // because datavalue is updated later when new dataset is available.
        this._debounceDatavalueUpdation(values);
    }
    // Updates the displayValue property.
    initDisplayValues() {
        const displayValues = [];
        this.datasetItems.forEach(item => {
            if (item.selected) {
                displayValues.push(item.label);
            }
        });
        this.displayValue = this.multiple ? displayValues : displayValues[0];
    }
    // This function parses the dataset and extracts the displayOptions from parsed dataset.
    initDatasetItems() {
        if (!this.dataset || _.isEmpty(this.dataset)) {
            this.datasetItems = [];
            return;
        }
        // convert any dataset to the object format.
        const orderedDataset = getOrderedDataset(convertDataToObject(this.dataset), this.orderby);
        if (this.usekeys) {
            this.datasetItems = transformDataWithKeys(orderedDataset);
        }
        else {
            const displayOptions = transformData$1(this.viewParent, orderedDataset, this.datafield, {
                displayField: this.displayfield || this.displaylabel,
                displayExpr: this.displayexpression,
                bindDisplayExpr: this.binddisplayexpression || this.binddisplaylabel,
                bindDisplayImgSrc: this.binddisplayimagesrc,
                displayImgSrc: this.displayimagesrc
            });
            // get the unique objects out of the extracted data. Notify change in datasetItems using [...datasetItems] notation
            this.datasetItems = [...getUniqObjsByDataField(displayOptions, this.datafield, this.displayfield || this.displaylabel, toBoolean(this.allowempty))];
        }
        this.postDatasetItemsInit();
    }
    // Once the datasetItems are ready, set the proxyModel by using datavalue.
    postDatasetItemsInit() {
        if (this.datasetItems.length && !this._defaultQueryInvoked) {
            // use the latest of toBeProcessedDatavalue, datavalue
            const _datavalue = !isDefined(this.toBeProcessedDatavalue) ? this.datavalue : this.toBeProcessedDatavalue;
            this.selectByValue(_datavalue);
        }
        // notify the dataset listeners
        this.dataset$.next(this.datasetItems);
    }
    // Reset the selected flag on datasetItems to false.
    resetDatasetItems() {
        this.datasetItems.forEach(item => item.selected = false);
    }
    onPropertyChange(key, nv, ov) {
        super.onPropertyChange(key, nv, ov);
        switch (key) {
            case 'dataset':
            case 'datafield':
            case 'displayfield':
            case 'displaylabel':
            case 'displayexpression':
            case 'orderby':
            case 'usekeys':
                this._debouncedInitDatasetItems();
                break;
        }
    }
}

const DEFAULT_CLS$e = 'app-checkboxset list-group';
const WIDGET_CONFIG$g = { widgetType: 'wm-checkboxset', hostClass: DEFAULT_CLS$e };
class CheckboxsetComponent extends DatasetAwareFormComponent {
    constructor(inj, groupby, appDefaults, datePipe) {
        super(inj, WIDGET_CONFIG$g);
        this.groupby = groupby;
        this.appDefaults = appDefaults;
        this.datePipe = datePipe;
        this.layout = '';
        styler(this.nativeElement, this);
        this.multiple = true;
        this.handleHeaderClick = noop;
    }
    onCheckboxLabelClick($event, key) {
        if (!$($event.target).is('input')) {
            return;
        }
        // construct the _model from the checked elements.
        const inputElements = this.nativeElement.querySelectorAll('input:checked');
        const keys = [];
        _.forEach(inputElements, ($el) => {
            keys.push($el.value);
        });
        this.modelByKey = keys;
        this.invokeOnTouched();
        // invoke on datavalue change.
        this.invokeOnChange(this.datavalue, $event || {}, true);
    }
    // change and blur events are added from the template
    handleEvent(node, eventName, callback, locals) {
        if (eventName === 'click') {
            this.eventManager.addEventListener(node, eventName, e => {
                if (!$(e.target).is('input')) {
                    return;
                }
                locals.$event = e;
                return callback();
            });
        }
        else if (!_.includes(['change'], eventName)) {
            super.handleEvent(node, eventName, callback, locals);
        }
    }
    getGroupedData() {
        return this.datasetItems.length ? groupData(this, convertDataToObject(this.datasetItems), this.groupby, this.match, this.orderby, this.dateformat, this.datePipe, 'dataObject', this.appDefaults) : [];
    }
    datasetSubscription() {
        const datasetSubscription = this.dataset$.subscribe(() => {
            this.groupedData = this.getGroupedData();
        });
        this.registerDestroyListener(() => datasetSubscription.unsubscribe());
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'tabindex') {
            return;
        }
        if (key === 'layout') {
            switchClass(this.nativeElement, nv, ov);
        }
        else if (key === 'groupby' || key === 'match') {
            this.datasetSubscription();
            // If groupby is set, get the groupedData from the datasetItems.
            this.groupedData = this.getGroupedData();
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.groupby) {
            this.datasetSubscription();
            // If groupby is set, get the groupedData from the datasetItems.
            this.groupedData = this.getGroupedData();
        }
        // adding the handler for header click and toggle headers.
        if (this.groupby && this.collapsible) {
            this.handleHeaderClick = handleHeaderClick;
            this.toggleAllHeaders = toggleAllHeaders.bind(undefined, this);
        }
    }
}
CheckboxsetComponent.initializeProps = registerProps$h();
CheckboxsetComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmCheckboxset]',
                exportAs: 'wmCheckboxset',
                template: "<ng-template [ngIf]=\"!groupby\" [ngIfElse]=\"groupedListTemplate\">\n    <li [ngClass]=\"['checkbox', 'app-checkbox', itemclass]\"\n        [class.active]=\"item.selected\"\n        *ngFor=\"let item of datasetItems; let i = index\"\n        (click)=\"onCheckboxLabelClick($event, item.key)\">\n        <label class=\"app-checkboxset-label\" [ngClass]=\"{'disabled':disabled || readonly}\" [title]=\"item.label\">\n            <input [name]=\"'checkboxset_' + widgetId\" type=\"checkbox\" aria-label=\"checkbox group\"\n                   [tabindex]=\"tabindex\"\n                   [disabled]=\"disabled || readonly\" [attr.data-attr-index]=\"i\"\n                   [value]=\"item.key\" [tabindex]=\"tabindex\" [checked]=\"item.selected\"/>\n            <span class=\"caption\" [textContent]=\"item.label\"></span>\n        </label>\n    </li>\n</ng-template>\n<input [disabled]=\"disabled || readonly\" hidden class=\"model-holder\">\n<div *ngIf=\"readonly || disabled\" class=\"readonly-wrapper\"></div>\n\n<!-- This template will be displayed when groupby is specified. -->\n<ng-template #groupedListTemplate>\n    <li *ngFor=\"let groupObj of groupedData\" class=\"app-list-item-group\">\n        <ul class=\"item-group\">\n            <li class=\"list-group-header\" (click)=\"handleHeaderClick($event)\" [title]=\"groupObj.key\" [ngClass]=\"{'collapsible-content': collapsible}\">\n                <h4 class=\"group-title\">{{groupObj.key}}\n                    <div class=\"header-action\">\n                        <i class=\"app-icon wi action wi-chevron-up\" *ngIf=\"collapsible\" title=\"{{appLocale.LABEL_COLLAPSE}}/{{appLocale.LABEL_EXPAND}}\"></i>\n                        <span *ngIf=\"showcount\" class=\"label label-default\" [textContent]=\"groupObj.data.length\"></span>\n                    </div>\n                </h4>\n            </li>\n            <li *ngFor=\"let item of groupObj.data; let i = index;\"\n                [ngClass]=\"['checkbox', 'app-checkbox', 'group-list-item', itemclass]\"\n                [class.active]=\"item.selected\"\n                (click)=\"onCheckboxLabelClick($event, item)\">\n                <label class=\"app-checkboxset-label\" [ngClass]=\"{'disabled':disabled || readonly}\" [title]=\"item.label\">\n                    <input [name]=\"'checkboxset_' + widgetId\" type=\"checkbox\" aria-label=\"checkbox group\"\n                           [tabindex]=\"tabindex\"\n                           [disabled]=\"disabled || readonly\" [attr.data-attr-index]=\"i\"\n                           [value]=\"item.key\" [tabindex]=\"tabindex\" [checked]=\"item.selected\"/>\n                    <span class=\"caption\" [textContent]=\"item.label\"></span>\n                </label>\n            </li>\n        </ul>\n    </li>\n</ng-template>",
                providers: [
                    provideAsNgValueAccessor(CheckboxsetComponent),
                    provideAsWidgetRef(CheckboxsetComponent)
                ]
            }] }
];
/** @nocollapse */
CheckboxsetComponent.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Attribute, args: ['groupby',] }] },
    { type: AppDefaults },
    { type: ToDatePipe }
];

const chipsProps = new Map([
    ['allowonlyselect', PROP_BOOLEAN],
    ['autofocus', PROP_BOOLEAN],
    ['chipclass', PROP_STRING],
    ['class', PROP_STRING],
    ['compareby', PROP_STRING],
    ['datafield', PROP_STRING],
    ['dataoptions', PROP_ANY],
    ['dataset', Object.assign({ value: 'Option 1, Option 2, Option 3' }, PROP_ANY)],
    ['datasource', PROP_ANY],
    ['datavalue', PROP_ANY],
    ['datavaluesource', PROP_ANY],
    ['disabled', PROP_BOOLEAN],
    ['displayexpression', PROP_STRING],
    ['displayfield', PROP_STRING],
    ['displayimagesrc', PROP_STRING],
    ['enablereorder', PROP_BOOLEAN],
    ['inputposition', Object.assign({ value: 'last' }, PROP_STRING)],
    ['inputwidth', Object.assign({ value: 'default' }, PROP_STRING)],
    ['limit', PROP_NUMBER],
    ['loadingdatamsg', Object.assign({ value: 'Loading items...' }, PROP_STRING)],
    ['matchmode', PROP_STRING],
    ['maxsize', PROP_NUMBER],
    ['minchars', Object.assign({ value: 1 }, PROP_NUMBER)],
    ['name', PROP_STRING],
    ['navsearchbar', Object.assign({ value: false }, PROP_BOOLEAN)],
    ['orderby', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Type here..' }, PROP_STRING)],
    ['query', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['searchkey', PROP_STRING],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showsearchicon', PROP_BOOLEAN],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['type', Object.assign({ value: 'search' }, PROP_STRING)],
    ['debouncetime', Object.assign({ value: 250 }, PROP_NUMBER)],
]);
const registerProps$i = () => {
    register('wm-chips', chipsProps);
};

const searchProps = new Map([
    ['casesensitive', Object.assign({ value: false }, PROP_BOOLEAN)],
    ['class', PROP_STRING],
    ['datacompletemsg', Object.assign({ value: 'No more data to load' }, PROP_STRING)],
    ['datafield', Object.assign({ value: 'All Fields' }, PROP_STRING)],
    ['dataoptions', PROP_ANY],
    ['dataset', PROP_ANY],
    ['datasource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['disabled', PROP_BOOLEAN],
    ['displayimagesrc', PROP_STRING],
    ['displaylabel', PROP_STRING],
    ['dropup', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['imagewidth', Object.assign({ value: '16px' }, PROP_STRING)],
    ['limit', PROP_NUMBER],
    ['loadingdatamsg', Object.assign({ value: 'Loading items...' }, PROP_STRING)],
    ['matchmode', PROP_STRING],
    ['minchars', PROP_NUMBER],
    ['name', PROP_STRING],
    ['navsearchbar', Object.assign({ value: false }, PROP_BOOLEAN)],
    ['orderby', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Search' }, PROP_STRING)],
    ['position', PROP_STRING],
    ['query', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['searchkey', PROP_STRING],
    ['searchon', Object.assign({ value: 'typing' }, PROP_STRING)],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showsearchicon', PROP_BOOLEAN],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['type', Object.assign({ value: 'search' }, PROP_STRING)],
    ['debouncetime', Object.assign({ value: 250 }, PROP_NUMBER)],
    ['width', PROP_STRING]
]);
const registerProps$j = () => {
    register('wm-search', searchProps);
};

class LocalDataProvider {
    // LocalData filtering is done based on the searchkey.
    filter(config) {
        const entries = config.dataset;
        const casesensitive = config.casesensitive;
        let queryText = config.query, filteredData;
        return new Promise((resolve, reject) => {
            /**
             * If searchKey is defined, then check for match string against each item in the dataset with item's field name as the searchKey
             * return the filtered data containing the matching string.
             */
            if (config.searchKey) {
                const keys = _.split(config.searchKey, ',');
                filteredData = _.filter(config.dataset, (item) => {
                    return keys.some(key => {
                        let a = _.get(item, key), b = queryText;
                        if (!casesensitive) {
                            a = _.toLower(_.toString(a));
                            b = _.toLower(_.toString(b));
                        }
                        return _.includes(a, b);
                    });
                });
            }
            else {
                // local search on data with array of objects.
                // Iterate over each item and return the filtered data containing the matching string.
                if (_.isArray(entries) && _.isObject(entries[0])) {
                    filteredData = _.filter(entries, entry => {
                        return (_.includes(_.toLower(_.values(entry).join(' ')), _.toLower(queryText)));
                    });
                }
                else {
                    filteredData = _.filter(entries, entry => {
                        if (!casesensitive) {
                            entry = _.toLower(entry);
                            queryText = _.toLower(queryText);
                        }
                        return _.includes(entry, queryText);
                    });
                }
            }
            resolve({
                data: filteredData,
                hasMoreData: false,
                isLastPage: true
            });
        });
    }
}

class RemoteDataProvider {
    filter(config) {
        return this.filterData(config).then(response => this.onFilterSuccess(config, response), () => this.onFilterFailure());
    }
    filterData(config) {
        if (config.dataoptions) {
            const dataoptions = config.dataoptions;
            const requestParams = config.datasource.execute(DataSource.Operation.GET_REQUEST_PARAMS, config);
            // If options are specified, make specifics calls to fetch the results
            // Fetch the related field data
            if (dataoptions.relatedField) {
                return new Promise((resolve, reject) => {
                    interpolateBindExpressions(config.viewParent, dataoptions.filterExpr, (filterexpressions) => {
                        requestParams.filterExpr = dataoptions.filterExpr = filterexpressions;
                        dataoptions.filterExpr = filterexpressions;
                        config.datasource.execute(DataSource.Operation.GET_RELATED_TABLE_DATA, _.assign({ relatedField: dataoptions.relatedField }, requestParams)).then(resolve, reject);
                    });
                });
            }
            // Fetch the distinct data
            if (dataoptions.distinctField) {
                return config.datasource.execute(DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS, {
                    pagesize: config.limit || config.pagesize,
                    page: config.page,
                    fields: dataoptions.distinctField,
                    entityName: dataoptions.tableName,
                    filterFields: _.assign(dataoptions.filterFields, requestParams.filterFields),
                    filterExpr: getClonedObject(dataoptions.filterExpr || {})
                });
            }
        }
        // search records using the searchkey
        return config.datasource.execute(DataSource.Operation.SEARCH_RECORDS, config);
    }
    // Check if the page retrieved currently is the last page. If last page, don't send any more request
    isLast(page, dataSize, maxResults, currentResults) {
        // if last page info is not returned by backend and current results is less than max results, this is the last page
        if (dataSize === AppConstants.INT_MAX_VALUE) {
            return currentResults !== 0 && currentResults < maxResults;
        }
        const pageCount = ((dataSize > maxResults) ? (Math.ceil(dataSize / maxResults)) : (dataSize < 0 ? 0 : 1));
        return page === pageCount;
    }
    // this function transform the response data in case it is not an array
    getTransformedData(variable, data) {
        const operationResult = variable.operation + 'Result'; // when output is only string it is available as oprationNameResult
        const tempResponse = data[operationResult];
        // in case data received is value as string then add that string value to object and convert object into array
        if (tempResponse) {
            const tempObj = {};
            _.set(tempObj, operationResult, tempResponse);
            data = [tempObj]; // convert data into an array having tempObj
        }
        else {
            // in case data received is already an object then convert it into an array
            data = [data];
        }
        return data;
    }
    onFilterFailure() {
        return [];
    }
    isLastPageForDistinctApi(data, page, totalElements, _isLastPage) {
        return page > 1 && !_isLastPage && _.isEmpty(data) && totalElements === AppConstants.INT_MAX_VALUE;
    }
    // this function processes the response depending on pageOptions, isPageable and prepares the formattedDataset.
    onFilterSuccess(config, response) {
        let data = response.data;
        let formattedData;
        let _isLastPage;
        let page;
        let isPaginatedData;
        const expressionArray = _.split(config.binddataset, '.');
        const dataExpression = _.slice(expressionArray, _.indexOf(expressionArray, 'dataSet') + 1).join('.');
        const $I = '[$i]';
        return new Promise((resolve, reject) => {
            const pageOptions = response.pagination;
            if (config.datasource.execute(DataSource.Operation.IS_PAGEABLE)) {
                page = pageOptions.number + 1;
                _isLastPage = this.isLast(page, (config.limit > 0 && config.limit) || pageOptions.totalElements, pageOptions.size, pageOptions.numberOfElements);
                isPaginatedData = true;
                if (this.isLastPageForDistinctApi(data, page, pageOptions.totalElements, _isLastPage)) {
                    _isLastPage = true;
                    resolve({
                        data: [],
                        isLastPage: _isLastPage,
                        hasMoreData: page > 1,
                        isPaginatedData,
                        page
                    });
                    return;
                }
            }
            // if data expression exists, extract the data from the expression path
            if (dataExpression) {
                const index = dataExpression.lastIndexOf($I);
                const restExpr = dataExpression.substr(index + 5);
                if (_.isArray(data)) {
                    formattedData = data.map(datum => findValueOf(datum, restExpr));
                }
                else if (_.isObject(data)) {
                    formattedData = _.get(data, dataExpression);
                }
                data = formattedData || data;
            }
            if (!_.isArray(data)) {
                data = this.getTransformedData(config.datasource, data);
            }
            // in case of no data received, resolve the promise with empty array
            if (!data.length) {
                resolve({ data: [], isLastPage: _isLastPage, hasMoreData: page > 1, isPaginatedData, page });
            }
            else {
                resolve({ data: data, isLastPage: _isLastPage, hasMoreData: page > 1, isPaginatedData, page });
            }
        });
    }
}

class DataProvider {
    filter(config) {
        let promise;
        /**
         * Make call to remoteDataProvider when searchkey is available and data is not from local / model variable.
         * Otherwise use localDataProvider
         * If datasource is a serviceVariable with no input params, then perform local search.
         * when there is no dataset on the datasource when first time make a remote call to set the dataset for service variable.
         */
        const hasNoVariableDataset = config.datasource && config.datasource.execute(DataSource.Operation.IS_UPDATE_REQUIRED, config.hasData);
        if (!config.isLocalFilter && (config.dataoptions || ((config.datasource && config.datasource.execute(DataSource.Operation.IS_API_AWARE))
            && config.searchKey
            && hasNoVariableDataset))) {
            promise = DataProvider.remoteDataProvider.filter(config);
        }
        else {
            promise = DataProvider.localDataProvider.filter(config);
        }
        return promise.then(response => {
            this.updateDataset = config.datasource && !config.datasource.execute(DataSource.Operation.SUPPORTS_CRUD) && hasNoVariableDataset;
            this.hasMoreData = response.hasMoreData;
            this.isLastPage = response.isLastPage;
            this.page = response.page;
            this.isPaginatedData = response.isPaginatedData;
            return response;
        });
    }
}
DataProvider.remoteDataProvider = new RemoteDataProvider();
DataProvider.localDataProvider = new LocalDataProvider();

const WIDGET_CONFIG$h = { widgetType: 'wm-search', hostClass: 'input-group' };
class SearchComponent extends DatasetAwareFormComponent {
    constructor(inj, binddatavalue, binddataset) {
        super(inj, WIDGET_CONFIG$h);
        this.binddatavalue = binddatavalue;
        this.binddataset = binddataset;
        this.query = '';
        this.page = 1;
        // this flag will not allow the empty datafield values.
        this.allowempty = false;
        addClass(this.nativeElement, 'app-search', true);
        /**
         * Listens for the change in the ngModel on every search and retrieves the data as observable.
         * This observable data is passed to the typeahead.
         * @type {Observable<any>}
         */
        this.typeaheadDataSource = Observable
            .create((observer) => {
            // Runs on every search
            if (this.listenQuery) {
                if (this.isMobileAutoComplete() && !this.$element.hasClass('full-screen')) {
                    this.renderMobileAutoComplete();
                    return;
                }
                this._defaultQueryInvoked = false;
                this._loadingItems = true;
                observer.next(this.query);
            }
            // on keydown, while scrolling the dropdown items, when last item is reached next call is triggered
            // unless the call is resolved, we are able to scroll next to first item and soon
            // This shows flickering from first item to next new items appended.
            // By setting container to undefined, key events changes will be stopped while loading items
            if (this.lastSelectedIndex) {
                this.typeahead._container = undefined;
            }
        }).pipe(mergeMap((token) => this.getDataSourceAsObservable(token)));
        this.dataProvider = new DataProvider();
        /**
         * When default datavalue is not found within the dataset, a filter call is made to get the record using fetchDefaultModel.
         * after getting the response, set the queryModel and query.
         */
        const datavalueSubscription = this.datavalue$.subscribe((val) => {
            const query = (_.isArray(val) ? val[0] : val);
            if (query === null || query === '') {
                this._modelByValue = '';
                // reset the query.
                this.query = this.queryModel = '';
                // on clear or reset filter, empty the lastResults to fetch new records.
                this._lastResult = undefined;
                return;
            }
            if (!this._unsubscribeDv) {
                this._defaultQueryInvoked = false;
                // if prev datavalue is not equal to current datavalue then clear the modelByKey and queryModel
                if (!_.isObject(val) && this.prevDatavalue !== val) {
                    this._modelByKey = undefined;
                    this.query = this.queryModel = '';
                }
                // if the datafield is ALLFILEDS do not fetch the records
                // update the query model with the values we have
                this.updateByDatavalue(val);
            }
        });
        this.registerDestroyListener(() => datavalueSubscription.unsubscribe());
        const datasetSubscription = this.dataset$.subscribe(() => {
            // set the next item index.
            this.startIndex = this.datasetItems.length;
            this.updateByDataset(this.datavalue || this.toBeProcessedDatavalue);
        });
        this.registerDestroyListener(() => datasetSubscription.unsubscribe());
    }
    // getter setter is added to pass the datasource to searchcomponent.
    get datasource() {
        return this._datasource;
    }
    set datasource(nv) {
        this._datasource = nv;
        const data = this.datavalue || this.toBeProcessedDatavalue;
        this.updateByDatavalue(data);
    }
    // on clear, trigger search with page size 1
    clearSearch($event, loadOnClear) {
        this.query = '';
        this.onInputChange($event);
        this.dataProvider.isLastPage = false;
        this.listenQuery = false;
        if (loadOnClear) {
            this.listenQuery = true;
            this._unsubscribeDv = false;
            this.loadMoreData();
        }
        this.invokeEventCallback('clearsearch');
    }
    // Close the full screen mode in mobile view of auto complete
    closeSearch() {
        this._loadingItems = false;
        this.page = 1;
        // after closing the search, insert the element at its previous position (elIndex)
        this.insertAtIndex(this.elIndex);
        this.elIndex = undefined;
        this.parentEl = undefined;
        this.$element.removeClass('full-screen');
        if (this._domUpdated) {
            this._domUpdated = false;
        }
        this.listenQuery = false;
        this._unsubscribeDv = true;
        this.typeahead.hide();
    }
    renderMobileAutoComplete() {
        // Get the parent element of the search element which can be next or prev element, if both are empty then get the parent of element.
        if (!isDefined(this.elIndex)) {
            this.parentEl = this.$element.parent();
            this.elIndex = this.parentEl.children().index(this.$element);
        }
        if (!this.$element.hasClass('full-screen')) {
            // this flag is set to notify that the typeahead-container dom has changed its position
            this._domUpdated = true;
            this.$element.appendTo('div[data-role="pageContainer"]');
            // Add full screen class on focus of the input element.
            this.$element.addClass('full-screen');
            // Add position to set the height to auto
            if (this.position === 'inline') {
                this.$element.addClass(this.position);
            }
        }
        // focus is lost when element is changed to full-screen, keydown to select next items will not work
        // Hence explicitly focusing the input
        if (this.$element.hasClass('full-screen')) {
            this.$element.find('.app-search-input').focus();
        }
    }
    getDataSourceAsObservable(query) {
        // show dropdown only when there is change in query. This should not apply when dataoptions with filterFields are updated.
        // when lastResult is not available i.e. still the first call is pending and second query is invoked then do not return.
        if (this._lastQuery === query && !_.get(this.dataoptions, 'filterFields') && isDefined(this._lastResult)) {
            this._loadingItems = false;
            return of(this._lastResult);
        }
        this._lastQuery = this.query;
        return from(this.getDataSource(query));
    }
    handleEvent(node, eventName, eventCallback, locals) {
        if (!_.includes(['blur', 'focus', 'select', 'submit', 'change'], eventName)) {
            super.handleEvent(node, eventName, eventCallback, locals);
        }
    }
    // highlight the characters in the dropdown matching the query.
    highlight(match, query) {
        if (this.typeaheadContainer) {
            // highlight of chars will work only when label are strings.
            match.value = match.item.label.toString();
            return this.typeaheadContainer.highlight(match, query);
        }
    }
    // inserts the element at the index position
    insertAtIndex(i) {
        if (i === 0) {
            this.parentEl.prepend(this.$element);
        }
        else {
            const $elAtIndex = this.parentEl.children().eq(i);
            if ($elAtIndex.length) {
                this.$element.insertBefore(this.parentEl.children().eq(i));
            }
            else {
                this.$element.insertAfter(this.parentEl.children().eq(i - 1));
            }
        }
    }
    // Check if the widget is of type autocomplete in mobile view/ app
    isMobileAutoComplete() {
        return this.type === 'autocomplete' && isMobile();
    }
    loadMoreData(incrementPage) {
        if (this.dataProvider.isLastPage) {
            return;
        }
        // Increase the page number and trigger force query update
        this.page = incrementPage ? this.page + 1 : this.page;
        this.isScrolled = true;
        this._loadingItems = true;
        // when invoking new set of results, reset the lastQuery.
        if (incrementPage) {
            this._lastQuery = undefined;
        }
        // trigger the typeahead change manually to fetch the next set of results.
        this.typeahead.onInput({
            target: {
                value: _.trim(this.query) || '0' // dummy data to notify the observables
            }
        });
    }
    // on focusout, subscribe to the datavalue changes again
    onFocusOut() {
        this._unsubscribeDv = false;
        this._loadingItems = false;
        // reset the page value on focusout.
        this.page = 1;
        // if domUpdated is true then do not hide the dropdown in the fullscreen
        if (!this._domUpdated && this._isOpen) {
            this.listenQuery = false;
            // hide the typeahead only after the item is selected from dropdown.
            setTimeout(() => {
                if (this.typeahead._typeahead.isShown) {
                    this.typeahead.hide();
                }
            }, 200);
        }
        this._isOpen = false;
        // on outside click, typeahead is hidden. To avoid this, when fullscreen is set, overridding isFocused flag on the typeahead container
        if (this._domUpdated && this.typeahead && this.typeahead._container) {
            this.typeahead._container.isFocused = true;
        }
    }
    onInputChange($event) {
        // reset all the previous page details in order to fetch new set of result.
        this.result = [];
        this.page = 1;
        this.listenQuery = this.isUpdateOnKeyPress();
        this._modelByValue = undefined;
        // when input is cleared, reset the datavalue
        if (this.query === '') {
            this.queryModel = '';
            this._modelByValue = '';
            this.invokeOnChange(this._modelByValue, {}, true);
            // trigger onSubmit only when the search input is cleared off and do not trigger when tab is pressed.
            if ($event && $event.which !== 9) {
                this.invokeEventCallback('submit', { $event });
            }
        }
        else {
            // invoking change event on every input value change.
            this.invokeEventCallback('change', {
                $event: $event,
                newVal: this._modelByValue || this.query,
                oldVal: this.prevDatavalue
            });
        }
        this.showClosebtn = (this.query !== '');
    }
    // Triggered for enter event
    handleEnterEvent($event) {
        // submit event triggered when there is no search results
        if (!this.typeahead._container) {
            this.onSelect($event);
        }
    }
    // Triggerred when typeahead option is selected.
    onSelect($event) {
        // searchOn is set as onBtnClick, then invoke the search api call manually.
        if (!this.isUpdateOnKeyPress()) {
            this.listenQuery = true;
            // trigger the typeahead change manually to fetch the next set of results.
            this.typeahead.onInput({
                target: {
                    value: this.query // dummy data to notify the observables
                }
            });
            return;
        }
        // when matches are available.
        if (this.typeaheadContainer && this.liElements.length) {
            this.typeaheadContainer.selectActiveMatch();
        }
        else {
            this.queryModel = this.query;
            this.invokeEventCallback('submit', { $event });
        }
    }
    onBeforeservicecall(inputData) {
        this.invokeEventCallback('beforeservicecall', { inputData });
    }
    onDropdownOpen() {
        // setting the ulElements, liElement on typeaheadContainer.
        // as we are using customOption template, liElements are not available on typeaheadContainer so append them explicitly.
        const fn = _.debounce(() => {
            this._isOpen = true;
            this.typeaheadContainer = this.typeahead._container || this.typeahead._typeahead.instance;
            this.typeaheadContainer.liElements = this.liElements;
            this.typeaheadContainer.ulElement = this.ulElement;
            adjustContainerPosition($('typeahead-container'), this.nativeElement, this.typeahead._typeahead, $('typeahead-container .dropdown-menu'));
        });
        fn();
        // open full-screen search view
        if (this.isMobileAutoComplete()) {
            const dropdownEl = this.dropdownEl.closest('typeahead-container');
            dropdownEl.insertAfter(this.$element.find('input:first'));
            const screenHeight = this.$element.closest('.app-content').height();
            dropdownEl.css({ position: 'relative', top: 0, height: screenHeight + 'px' });
            this.showClosebtn = this.query && this.query !== '';
            if (!this.dataProvider.isLastPage) {
                this.triggerSearch();
            }
        }
    }
    selectNext() {
        const matches = this.typeaheadContainer.matches;
        if (!matches) {
            return;
        }
        const index = matches.indexOf(this.typeaheadContainer.active);
        // on keydown, if scroll is at the bottom and next page records are available, fetch next page items.
        if (!this._loadingItems && !this.dataProvider.isLastPage && index + 1 > matches.length - 1) {
            // index is saved in order to select the lastSelected item in the dropdown after fetching next page items.
            this.lastSelectedIndex = index;
            this.loadMoreData(true);
        }
    }
    setLastActiveMatchAsSelected() {
        if (this.lastSelectedIndex) {
            this.typeaheadContainer._active = this.typeaheadContainer.matches[this.lastSelectedIndex];
            this.typeaheadContainer.nextActiveMatch();
            this.lastSelectedIndex = undefined;
        }
    }
    triggerSearch() {
        if (this.dataProvider.isLastPage || !this.$element.hasClass('full-screen')) {
            return;
        }
        const typeAheadDropDown = this.dropdownEl;
        const $lastItem = typeAheadDropDown.find('li').last();
        // Check if last item is not below the full screen
        if ($lastItem.length && typeAheadDropDown.length && (typeAheadDropDown.height() + typeAheadDropDown.position().top > $lastItem.height() + $lastItem.position().top)) {
            this.loadMoreData(true);
        }
    }
    isUpdateOnKeyPress() {
        return this.searchon === 'typing';
    }
    debounceDefaultQuery(data) {
        this._defaultQueryInvoked = true;
        this.getDataSource(data, true).then((response) => {
            if (response.length) {
                this.queryModel = response;
                this._lastQuery = this.query = this.queryModel[0].label || '';
                this._modelByValue = this.queryModel[0].value;
                this._modelByKey = this.queryModel[0].key;
            }
            else {
                this._modelByValue = undefined;
                this.queryModel = undefined;
                this.query = '';
            }
        });
    }
    updateByDatavalue(data) {
        this.updateByDataset(data);
        this.updateByDataSource(data);
    }
    updateByDataSource(data) {
        // value is present but the corresponding key is not found then fetch next set
        // modelByKey will be set only when datavalue is available inside the localData otherwise make a N/w call.
        if (isDefined(data) && !_.isObject(data) && this.datasource && !isDefined(this._modelByKey) && this.datafield !== ALLFIELDS) {
            // Avoid making default query if queryModel already exists.
            if (isDefined(this.queryModel) && !_.isEmpty(this.queryModel)) {
                this.updateDatavalueFromQueryModel();
                return;
            }
            // Make default query call only when datasource supports CRUD (live variable).
            if (!this._defaultQueryInvoked && this.datasource.execute(DataSource.Operation.SUPPORTS_CRUD)) {
                this.debounceDefaultQuery(data);
            }
        }
    }
    // updates the model value using queryModel
    updateDatavalueFromQueryModel() {
        this._modelByValue = _.isArray(this.queryModel) ? this.queryModel[0].value : this.queryModel;
        this._modelByKey = _.isArray(this.queryModel) ? this.queryModel[0].key : this.queryModel;
        this.toBeProcessedDatavalue = undefined;
    }
    updateByDataset(data) {
        // default query is already invoked then do not make other default query call.
        // For local search i.e. searchkey is undefined, do not return, verify the datavalue against the datasetItems .
        if (this._defaultQueryInvoked && this.searchkey) {
            return;
        }
        const selectedItem = _.find(this.datasetItems, (item) => {
            return (_.isObject(item.value) ? _.isEqual(item.value, data) : (_.toString(item.value)).toLowerCase() === (_.toString(data)).toLowerCase());
        });
        // set the default only when it is available in dataset.
        if (selectedItem) {
            this.queryModel = [selectedItem];
        }
        else if (this.datafield === ALLFIELDS && _.isObject(data)) {
            this.queryModel = this.getTransformedData(extractDataAsArray(data));
        }
        else {
            this.queryModel = undefined;
            this.query = '';
            return;
        }
        this.updateDatavalueFromQueryModel();
        // Show the label value on input.
        this._lastQuery = this.query = this.queryModel.length ? this.queryModel[0].label : '';
    }
    // This method returns a promise that provides the filtered data from the datasource.
    getDataSource(query, searchOnDataField, nextItemIndex) {
        // For default query, searchOnDataField is set to true, then do not make a n/w call when datafield is ALLFIELDS
        if (searchOnDataField && this.datafield === ALLFIELDS) {
            this._loadingItems = false;
            return Promise.resolve([]);
        }
        // For default datavalue, search key as to be on datafield to get the default data from the filter call.
        const dataConfig = {
            dataset: this.dataset ? convertDataToObject(this.dataset) : undefined,
            binddataset: this.binddataset,
            datasource: this.datasource,
            datafield: this.datafield,
            hasData: this.dataset && this.dataset.length,
            query: query,
            isLocalFilter: !this.searchkey,
            searchKey: searchOnDataField ? this.datafield : this.searchkey,
            // default search call match mode should be startignorecase
            matchMode: searchOnDataField ? 'startignorecase' : this.matchmode,
            casesensitive: this.casesensitive,
            isformfield: this.isformfield,
            orderby: this.orderby,
            limit: this.limit,
            pagesize: this.pagesize,
            page: this.page,
            onBeforeservicecall: this.onBeforeservicecall.bind(this)
        };
        if (this.dataoptions) {
            dataConfig.dataoptions = this.dataoptions;
            dataConfig.viewParent = this.viewParent;
        }
        this._loadingItems = true;
        return this.dataProvider.filter(dataConfig)
            .then((response) => {
            // response from dataProvider returns always data object.
            response = response.data || response;
            // for service variable, updating the dataset only if it is not defined or empty
            if ((!isDefined(this.dataset) || !this.dataset.length) && this.dataProvider.updateDataset) {
                this.dataset = response;
            }
            if (this.dataProvider.hasMoreData) {
                this.formattedDataset = this.formattedDataset.concat(response);
            }
            else {
                this.formattedDataset = response;
            }
            // explicitly setting the optionslimit as the matches more than 20 will be ignored if optionslimit is not specified.
            if (this.formattedDataset.length > 20 && !isDefined(this.limit)) {
                this.typeahead.typeaheadOptionsLimit = this.formattedDataset.length;
            }
            // In mobile, trigger the search by default until the results have height upto page height. Other results can be fetched by scrolling
            if (this._isOpen && this.isMobileAutoComplete() && !this.dataProvider.isLastPage) {
                this.triggerSearch();
            }
            const transformedData = this.getTransformedData(this.formattedDataset, nextItemIndex);
            // result contains the datafield values.
            this.result = _.map(transformedData, 'value');
            return transformedData;
        }, (error) => {
            this._loadingItems = false;
            return [];
        }).then(result => {
            if (this.isScrolled) {
                (_.debounce(() => {
                    this.setLastActiveMatchAsSelected();
                }, 30))();
                this.isScrolled = false;
            }
            // When no result is found, set the datavalue to undefined.
            if (!result.length) {
                this._modelByValue = undefined;
                this.queryModel = query;
            }
            // on focusout i.e. on other widget focus, if n/w is pending loading icon is shown, when data is available then dropdown is shown again.
            // on unsubscribing do not show the results.
            if (this._unsubscribeDv) {
                result = [];
            }
            this._loadingItems = false;
            this._lastResult = result;
            return result;
        });
    }
    getTransformedData(data, itemIndex, iscustom) {
        if (isDefined(itemIndex)) {
            itemIndex++;
        }
        const transformedData = transformData$1(this.viewParent, data, this.datafield, {
            displayField: this.displaylabel || this.displayfield,
            displayExpr: iscustom ? '' : this.displayexpression,
            bindDisplayExpr: iscustom ? '' : this.binddisplaylabel,
            bindDisplayImgSrc: this.binddisplayimagesrc,
            displayImgSrc: this.displayimagesrc
        }, itemIndex);
        return getUniqObjsByDataField(transformedData, this.datafield, this.displayfield || this.displaylabel, toBoolean(this.allowempty));
    }
    // OptionsListTemplate listens to the scroll event and triggers this function.
    onScroll($scrollEl, evt) {
        const totalHeight = $scrollEl.scrollHeight, clientHeight = $scrollEl.clientHeight;
        // If scroll is at the bottom and no request is in progress and next page records are available, fetch next page items.
        if (!this._loadingItems && !this.dataProvider.isLastPage && ($scrollEl.scrollTop + clientHeight >= totalHeight)) {
            this.loadMoreData(true);
        }
    }
    ngOnInit() {
        super.ngOnInit();
        if (!isDefined(this.minchars)) {
            // for autocomplete set the minchars to 0
            if (this.type === 'autocomplete') {
                this.minchars = 0;
            }
            else {
                this.minchars = 1;
            }
        }
        this.listenQuery = this.isUpdateOnKeyPress();
        // by default for autocomplete do not show the search icon
        // by default show the searchicon for type = search
        this.showsearchicon = isDefined(this.showsearchicon) ? this.showsearchicon : (this.type === 'search');
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.nativeElement, this);
    }
    // triggered on select on option from the list. Set the queryModel, query and modelByKey from the matched item.
    typeaheadOnSelect(match, $event) {
        const item = match.item;
        this.queryModel = item;
        item.selected = true;
        this.query = item.label;
        $event = $event || this.$typeaheadEvent;
        // As item.key can vary from key in the datasetItems
        this._modelByKey = item.key;
        this._modelByValue = item.value;
        this.invokeOnTouched();
        this.invokeOnChange(this.datavalue, $event || {});
        if (this.$element.hasClass('full-screen')) {
            this.closeSearch();
        }
        this.invokeEventCallback('select', { $event, selectedValue: this.datavalue });
        this.invokeEventCallback('submit', { $event });
        this.updatePrevDatavalue(this.datavalue);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'tabindex') {
            return;
        }
        // when dataoptions are provided and there is no displaylabel given then displaylabel is set as the relatedfield
        if (key === 'displaylabel' && this.dataoptions && this.binddisplaylabel === null) {
            this.query = _.get(this._modelByValue, nv) || this._modelByValue;
        }
        super.onPropertyChange(key, nv, ov);
    }
}
SearchComponent.initializeProps = registerProps$j();
SearchComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmSearch]',
                template: "<ng-template #customItemTemplate let-model=\"item\" let-index=\"index\" let-query=\"query\" let-match=\"match\">\n    <a>\n        <img *ngIf=\"model.imgSrc\" [src]=\"model.imgSrc\" alt=\"Search\" [style.width]=\"imagewidth\">\n        <span [title]=\"model.label\" [innerHtml]=\"highlight(match, query) || model.label\"></span>\n    </a>\n</ng-template>\n\n<ng-template #customListTemplate let-matches=\"matches\" let-itemTemplate=\"itemTemplate\" let-query=\"query\">\n    <ul #ulElement class=\"app-search dropdown-menu\" scrollable>\n        <li #liElements *ngFor=\"let match of matches\" [ngClass]=\"{active: typeaheadContainer && typeaheadContainer.isActive(match)}\"\n            (mouseenter)=\"typeaheadContainer.selectActive(match);\"\n            (click)=\"typeaheadContainer.selectMatch(match, $event); $typeaheadEvent = $event;\">\n            <!-- itemTemplate comes from the <input> -->\n            <ng-container *ngIf=\"!match.isHeader()\" [ngTemplateOutlet]=\"itemTemplate\"\n                          [ngTemplateOutletContext]=\"{item: match.item, index: i, match: match, query: query}\">\n            </ng-container>\n        </li>\n        <div class=\"status\" [hidden]=\"_loadingItems || !(datacompletemsg && dataProvider.isLastPage)\">\n            <span [textContent]=\"datacompletemsg\"></span>\n        </div>\n        <div class=\"status\" [hidden]=\"!_loadingItems\">\n            <i class=\"fa fa-circle-o-notch fa-spin\"></i>\n            <span [textContent]=\"loadingdatamsg\"></span>\n        </div>\n    </ul>\n</ng-template>\n\n<!--This template is for search inside mobile navbar.-->\n<ng-container *ngIf=\"navsearchbar; else searchTemplate\">\n    <input [title]=\"query || ''\" type=\"text\" class=\"app-textbox form-control list-of-objs app-search-input\" [placeholder]=\"placeholder || ''\"\n           focus-target\n           container=\"body\"\n           [disabled]=\"disabled\"\n           autocomplete=\"off\"\n           [(ngModel)]=\"query\"\n           [readonly]=\"readonly\"\n           [disabled]=\"disabled\"\n           [typeahead]=\"typeaheadDataSource\"\n           [typeaheadWaitMs]=\"debouncetime\"\n           [typeaheadItemTemplate]=\"customItemTemplate\"\n           [optionsListTemplate]=\"customListTemplate\"\n           (input)=\"onInputChange($event)\"\n           (keydown)=\"listenQuery = true\"\n           (keydown.enter)=\"$typeaheadEvent = $event;\"\n           (keydown.arrowdown)=\"selectNext($event)\"\n           (blur)=\"invokeOnTouched($event)\"\n           (focus)=\"_unsubscribeDv = false; listenQuery = true; invokeOnFocus($event);\"\n           (focusout)=\"onFocusOut()\"\n           [typeaheadMinLength]=\"minchars\"\n           [typeaheadOptionsLimit]=\"limit\"\n           (typeaheadLoading)=\"_loadingItems\"\n           (typeaheadOnSelect)=\"typeaheadOnSelect($event)\"\n           typeaheadOptionField=\"label\"\n           [typeaheadAsync]=\"true\"\n           [typeaheadScrollable]=\"true\"\n           [typeaheadOptionsInScrollableView]=\"optionslimitinscrollableview\"\n           [dropup]=\"dropup\"\n           [tabindex]=\"tabindex\"\n           [attr.name]=\"name\"/>\n    <i class=\"btn-close wi wi-cancel\" [hidden]=\"!showClosebtn\" (click)=\"clearSearch($event);\"></i>\n</ng-container>\n<!--This template is for both web and fullscreen mode in mobile.-->\n<ng-template #searchTemplate>\n    <span class=\"wi wi-arrow-left form-control-feedback back-btn\" aria-hidden=\"true\" (click)=\"closeSearch()\"></span>\n    <span class=\"sr-only\">Back button</span>\n    <input [title]=\"query || ''\" type=\"text\" class=\"app-textbox form-control list-of-objs app-search-input\" [placeholder]=\"placeholder || ''\"\n           focus-target\n           container=\"body\"\n           [disabled]=\"disabled\"\n           autocomplete=\"off\"\n           [(ngModel)]=\"query\"\n           [readonly]=\"readonly\"\n           [typeahead]=\"typeaheadDataSource\"\n           [typeaheadWaitMs]=\"debouncetime\"\n           [typeaheadItemTemplate]=\"customItemTemplate\"\n           [optionsListTemplate]=\"customListTemplate\"\n           (input)=\"onInputChange($event)\"\n           (keydown)=\"listenQuery = true\"\n           (keydown.enter)=\"$typeaheadEvent = $event;handleEnterEvent($event)\"\n           (keydown.arrowdown)=\"selectNext($event)\"\n           (blur)=\"invokeOnTouched($event)\"\n           (focus)=\"_unsubscribeDv = false; listenQuery = true; invokeOnFocus($event)\"\n           (focusout)=\"onFocusOut()\"\n           [typeaheadMinLength]=\"minchars\"\n           [typeaheadOptionsLimit]=\"limit\"\n           (typeaheadLoading)=\"_loadingItems\"\n           (typeaheadOnSelect)=\"typeaheadOnSelect($event)\"\n           typeaheadOptionField=\"label\"\n           [typeaheadAsync]=\"true\"\n           [typeaheadScrollable]=\"true\"\n           [typeaheadOptionsInScrollableView]=\"optionslimitinscrollableview\"\n           [tabindex]=\"tabindex\"\n           [dropup]=\"dropup\"\n           [attr.name]=\"name\">\n    <input class=\"model-holder\" ng-model=\"proxyModel\" ng-required=\"required\" tabindex=\"-1\">\n    <span *ngIf=\"_loadingItems\" aria-hidden=\"true\" class=\"fa fa-circle-o-notch fa-spin form-control-feedback\"></span>\n    <span class=\"wi wi-close form-control-feedback clear-btn\" [hidden]=\"!showClosebtn\" (click)=\"clearSearch($event, true)\"></span>\n    <span class=\"sr-only\">Clear button</span>\n    <span *ngIf=\"showsearchicon\" class=\"input-group-addon\" aria-label=\"search icon\" [ngClass]=\"{'disabled': disabled}\">\n        <form>\n            <button title=\"Search\" [disabled]=\"disabled\" class=\"app-search-button wi wi-search\" type=\"submit\"\n                    (click)=\"onSelect($event)\"></button>\n        </form>\n    </span>\n</ng-template>\n",
                providers: [
                    provideAsNgValueAccessor(SearchComponent),
                    provideAsWidgetRef(SearchComponent)
                ]
            }] }
];
/** @nocollapse */
SearchComponent.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Attribute, args: ['datavalue.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['dataset.bind',] }] }
];
SearchComponent.propDecorators = {
    typeahead: [{ type: ViewChild, args: [TypeaheadDirective,] }],
    ulElement: [{ type: ViewChild, args: ['ulElement',] }],
    liElements: [{ type: ViewChildren, args: ['liElements',] }]
};

const WIDGET_CONFIG$i = {
    widgetType: 'wm-chips',
    hostClass: 'app-chips nav nav-pills list-inline'
};
class ChipsComponent extends DatasetAwareFormComponent {
    constructor(inj, bindDisplayField, bindDisplayExpr, bindDisplayImgSrc, bindDataField, bindDataSet, bindChipclass) {
        super(inj, WIDGET_CONFIG$i);
        this.bindDisplayField = bindDisplayField;
        this.bindDisplayExpr = bindDisplayExpr;
        this.bindDisplayImgSrc = bindDisplayImgSrc;
        this.bindDataField = bindDataField;
        this.bindDataSet = bindDataSet;
        this.bindChipclass = bindChipclass;
        this.chipsList = [];
        this.maxSizeReached = 'Max size reached';
        this._unsubscribeDv = false;
        styler(this.nativeElement, this);
        // set the showsearchicon as false by default.
        if (!isDefined(this.showsearchicon)) {
            this.showsearchicon = false;
        }
        this.multiple = true;
        this.nextItemIndex = 0; // default chip index
        this._debounceUpdateQueryModel = debounce((val) => {
            this.updateQueryModel(val).then(() => {
                if (this.bindChipclass) {
                    _.forEach(this.chipsList, (item, index) => {
                        this.registerChipItemClass(item, index);
                    });
                }
            });
        }, 150);
        const datasetSubscription = this.dataset$.subscribe(() => {
            this.searchComponent.dataset = this.dataset;
            this.nextItemIndex = this.datasetItems.length;
            this._debounceUpdateQueryModel(this.datavalue || this.toBeProcessedDatavalue);
        });
        this.registerDestroyListener(() => datasetSubscription.unsubscribe());
        const datavalueSubscription = this.datavalue$.subscribe((val) => {
            // update queryModel only when parentRef is available.
            if (!this._unsubscribeDv) {
                this.chipsList = [];
                // if the datafield is ALLFILEDS do not fetch the records
                // update the query model with the values we have
                this._debounceUpdateQueryModel(val);
            }
        });
        this.registerDestroyListener(() => datavalueSubscription.unsubscribe());
    }
    // getter setter is added to pass the datasource to searchcomponent.
    get datasource() {
        return this._datasource;
    }
    set datasource(nv) {
        this._datasource = nv;
        this.searchComponent.datasource = nv;
        this._debounceUpdateQueryModel(this.datavalue || this.toBeProcessedDatavalue);
    }
    ngOnInit() {
        super.ngOnInit();
        this.searchComponent.multiple = true;
        this.searchComponent.binddisplayimagesrc = this.bindDisplayImgSrc;
        this.searchComponent.displayimagesrc = this.displayimagesrc;
        this.searchComponent.binddisplaylabel = this.bindDisplayExpr;
        this.searchComponent.displaylabel = this.displayfield;
        this.searchComponent.datafield = this.bindDataField || this.datafield;
        this.searchComponent.binddataset = this.bindDataSet;
        this.searchComponent.dataset = this.dataset;
        this.searchComponent.searchkey = this.searchkey;
        this.searchComponent.limit = this.limit;
        this.searchComponent.debouncetime = this.debouncetime;
        this.searchComponent.matchmode = this.matchmode;
        this.getTransformedData = (val, isCustom) => {
            return this.searchComponent.getTransformedData([val], this.nextItemIndex++, isCustom);
        };
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (this.enablereorder) {
            this.configureDnD();
        }
    }
    /**
     * This method returns the evaluated class expression.
     * @param $index index of the chip
     * @param item chip object containing the key, value, label
     * @returns {any} evaluated class expression value
     */
    registerChipItemClass(item, $index) {
        if (this.bindChipclass) {
            const watchName = `${this.widgetId}_chipItemClass_${$index}`;
            $unwatch(watchName);
            this.registerDestroyListener($watch(this.bindChipclass, this.viewParent, { item, $index }, (nv, ov) => {
                this.applyItemClass(getConditionalClasses(nv, ov), $index);
            }, watchName));
        }
    }
    applyItemClass(val, index) {
        const chipItem = this.nativeElement.querySelectorAll('.chip-item').item(index);
        $(chipItem).removeClass(val.toRemove).addClass(val.toAdd);
    }
    removeDuplicates() {
        this.chipsList = getUniqObjsByDataField(this.chipsList, this.datafield, this.displayfield || this.displaylabel);
    }
    // This method updates the queryModel.
    // default call to get the default data can be done only when defaultQuery is true.
    updateQueryModel(data) {
        const promises = [];
        if (!data) {
            this.chipsList = [];
            return Promise.resolve();
        }
        // clone the data as the updations on data will change the datavalue.
        let dataValue = _.clone(data);
        const prevChipsList = this.chipsList;
        this.chipsList = [];
        // update the model when model has items more than maxsize
        if (this.maxsize && dataValue.length > this.maxsize) {
            this._modelByValue = dataValue = _.slice(dataValue, 0, this.maxsize);
            data = dataValue;
        }
        const searchQuery = [];
        /**
         * For each value in datavalue,
         * 1. check whether value is in datasetItems, if item is found, addd to the chipsList.
         * 2. else make a default query to the filter and get the record.
         * 3. In step 2, if datavalue is not ALLFIELDS, then make a query. Extract the chipsList from the query response.
         * 4. If there is no response for the value and allowonlyselect is true, remove the value from the datavalue. So that datavalue just contains the valid values.
         * 5. In step 2, if datavalue is ALLFIELDS and value is object, then just prepare the datasetItem from the value.
         * 6. If value is not object and allowonlyselect is false, then create a customModel and replace this value with customModel and prepare datasetItem from this value
         */
        dataValue.forEach((val, i) => {
            const itemFound = _.find(this.datasetItems, item => {
                return _.isObject(item.value) ? _.isEqual(item.value, val) : _.toString(item.value) === _.toString(val);
            });
            if (itemFound) {
                this.chipsList.push(itemFound);
            }
            else if (this.datafield !== ALLFIELDS) {
                searchQuery.push(val);
            }
            else if (this.datafield === ALLFIELDS) {
                let dataObj, isCustom = false;
                if (!_.isObject(val)) {
                    dataObj = this.createCustomDataModel(val);
                    isCustom = true;
                    if (dataObj) {
                        data.splice(i, 1, dataObj);
                    }
                }
                else {
                    // if custom chips is already generated, val will be object as {'dataField_val': 'entered_val'}
                    // Hence check this val in previous chipList and assign the iscustom flag
                    const prevChipObj = prevChipsList.find(obj => {
                        return _.isEqual(obj.value, val);
                    });
                    if (prevChipObj) {
                        isCustom = prevChipObj.iscustom;
                    }
                }
                dataObj = dataObj || val;
                const transformedData = this.getTransformedData(dataObj, isCustom);
                const chipObj = transformedData[0];
                if (isCustom) {
                    chipObj.iscustom = isCustom;
                }
                this.chipsList.push(chipObj);
            }
        });
        // make default query with all the values and if response for the value is not in datavalue then add a custom chip object.
        if (searchQuery.length) {
            promises.push(this.getDefaultModel(searchQuery, this.nextItemIndex)
                .then(response => {
                this.chipsList = this.chipsList.concat(response || []);
                dataValue.forEach((val, i) => {
                    const isExists = _.find(this.chipsList, (obj) => {
                        return obj.value.toString() === val.toString();
                    });
                    if (!isExists) {
                        if (this.allowonlyselect) {
                            const index = data.indexOf(val);
                            if (index > -1) {
                                data.splice(index, 1);
                            }
                            return;
                        }
                        const transformedData = this.getTransformedData(val, true);
                        const chipObj = transformedData[0];
                        chipObj.iscustom = true;
                        this.chipsList.push(chipObj);
                    }
                });
            }));
        }
        // default chip data is adding focus on to the search input. Hence this flag helps not to focus.
        this.resetSearchModel(true);
        return Promise.all(promises).then(() => {
            this._modelByValue = data;
            this.removeDuplicates();
            this.updateMaxSize();
            $appDigest();
        });
    }
    resetSearchModel(defaultQuery) {
        this._unsubscribeDv = true;
        // clear search will empty the query model and gets the data when minchars is 0 (i.e. autocomplete) on focus
        // defaultQuery flag is set when widget is not active. This will only load the autocomplete dropup with minchars as 0 when widget is focused/active
        this.searchComponent.clearSearch(undefined, !this.minchars && !defaultQuery);
        this._unsubscribeDv = false;
    }
    // Triggerred when typeahead option is selected by enter keypress.
    onSelect($event) {
        if (!this.searchComponent.liElements.length) {
            this.addItem($event);
        }
    }
    // Add the newItem to the list
    addItem($event, widget) {
        const searchComponent = widget;
        let allowAdd;
        let chipObj;
        if (searchComponent && isDefined(searchComponent.datavalue) && searchComponent.queryModel !== '') {
            if (!searchComponent.query || !_.trim(searchComponent.query)) {
                return;
            }
            chipObj = searchComponent.queryModel;
        }
        else {
            if (this.allowonlyselect) {
                return;
            }
            let dataObj;
            if (this.datafield === ALLFIELDS) {
                if (!_.isObject(this.searchComponent.query) && _.trim(this.searchComponent.query)) {
                    dataObj = this.createCustomDataModel(this.searchComponent.query);
                    // return if the custom chip is empty
                    if (!dataObj) {
                        this.resetSearchModel();
                        return;
                    }
                }
            }
            const data = dataObj || _.trim(this.searchComponent.query);
            if (data) {
                const transformedData = this.getTransformedData(data, true);
                chipObj = transformedData[0];
                chipObj.iscustom = true;
            }
        }
        if (!isDefined(chipObj) || chipObj === '') {
            return;
        }
        allowAdd = this.invokeEventCallback('beforeadd', { $event, newItem: chipObj });
        if (isDefined(allowAdd) && !toBoolean(allowAdd)) {
            return;
        }
        if (this.isDuplicate(chipObj)) {
            this.resetSearchModel();
            return;
        }
        this.registerChipItemClass(chipObj, this.chipsList.length);
        this.chipsList.push(chipObj);
        if (!this.datavalue) {
            this._modelByValue = [chipObj.value];
        }
        else {
            this._modelByValue = [...this._modelByValue, chipObj.value];
        }
        this._unsubscribeDv = true;
        this.invokeOnTouched();
        this.invokeOnChange(this._modelByValue, $event || {}, true);
        this.invokeEventCallback('add', { $event, $item: chipObj });
        this.updateMaxSize();
        // reset input box when item is added.
        this.resetSearchModel();
        // stop the event to not to call the submit event on enter press.
        if ($event && ($event.key === 'Enter' || $event.keyCode === 13)) {
            this.stopEvent($event);
        }
    }
    // Prepare datavalue object from a string(junk) value when datafield is allFields.
    createCustomDataModel(val) {
        const key = this.displayfield || (this.datafield !== ALLFIELDS ? this.datafield : undefined);
        if (key) {
            const customObj = {};
            customObj[key] = val;
            return customObj;
        }
    }
    // Check if newItem already exists
    isDuplicate(item) {
        if (this.datafield === ALLFIELDS) {
            return _.findIndex(this.chipsList, { value: item.value }) > -1;
        }
        return _.findIndex(this.chipsList, { key: item.key }) > -1;
    }
    // Check if max size is reached
    updateMaxSize() {
        this.saturate = this.maxsize > 0 && this.chipsList.length === this.maxsize;
    }
    // Makes call to searchComponent to filter the dataSource based on the query.
    getDefaultModel(query, index) {
        this.nextItemIndex++;
        return this.searchComponent.getDataSource(query, true, index)
            .then((response) => {
            return _.filter(query, queryVal => {
                _.find(response, { value: queryVal });
            });
        });
    }
    handleChipClick($event, chip) {
        if (this.readonly) {
            return;
        }
        $event.currentTarget.focus();
        this.invokeEventCallback('chipclick', { $event, $item: chip });
    }
    handleChipFocus($event, chip) {
        if (this.readonly) {
            return;
        }
        chip.active = true;
        this.invokeEventCallback('chipselect', { $event, $item: chip });
    }
    // To avoid form submit on pressing enter key
    stopEvent($event) {
        $event.stopPropagation();
        $event.preventDefault();
    }
    onTextDelete($event) {
        if (isAppleProduct) {
            this.onInputClear($event);
        }
    }
    onInputClear($event) {
        if (!this.chipsList || !this.chipsList.length || this.searchComponent.query) {
            return;
        }
        this.$element.find('li.chip-item > a.app-chip:last').focus();
        this.stopEvent($event);
    }
    onBackspace($event, $item, $index) {
        if (this.readonly) {
            return;
        }
        this.removeItem($event, $item, $index, true);
    }
    onDelete($event, $item, $index) {
        if (this.readonly) {
            return;
        }
        this.removeItem($event, $item, $index);
    }
    onArrowLeft($item, $index) {
        if (this.readonly) {
            return;
        }
        // On left arrow click when search input query is empty.
        if (!this.searchComponent.query && !isDefined($index) && !isDefined($item)) {
            this.$element.find('li.chip-item > a.app-chip:last').focus();
            return;
        }
        if ($index > 0) {
            this.$element.find('li.chip-item > a.app-chip').get($index - 1).focus();
        }
        else {
            this.focusSearchBox();
        }
    }
    onArrowRight($item, $index) {
        if (this.readonly) {
            return;
        }
        // On right arrow click when search input query is empty.
        if (!this.searchComponent.query && !isDefined($index) && !isDefined($item)) {
            this.$element.find('li.chip-item > a.app-chip:first').focus();
            return;
        }
        if ($index < (this.chipsList.length - 1)) {
            this.$element.find('li.chip-item > a.app-chip').get($index + 1).focus();
        }
        else {
            this.focusSearchBox();
        }
    }
    // focus search box.
    focusSearchBox() {
        this.$element.find('.app-chip-input > input.app-textbox').focus();
    }
    // Remove the item from list
    removeItem($event, item, index, canFocus) {
        $event.stopPropagation();
        const indexes = _.isArray(index) ? index : [index];
        const focusIndex = _.max(indexes);
        const items = _.reduce(indexes, (result, i) => {
            result.push(this.chipsList[i]);
            return result;
        }, []);
        // prevent deletion if the before-remove event callback returns false
        const allowRemove = this.invokeEventCallback('beforeremove', { $event, $item: items.length === 1 ? items[0] : items });
        if (isDefined(allowRemove) && !toBoolean(allowRemove)) {
            return;
        }
        const prevDatavalue = _.clone(this.datavalue);
        // focus next chip after deletion.
        // if there are no chips in the list focus search box
        setTimeout(() => {
            const chipsLength = this.chipsList.length;
            const $chipsList = this.$element.find('li.chip-item > a.app-chip');
            if (!chipsLength || !canFocus) {
                this.focusSearchBox();
            }
            else if ((chipsLength - 1) < focusIndex) {
                // if focus index is greater than chips length select last chip
                $chipsList.get(chipsLength - 1).focus();
            }
            else {
                // manually set the succeeding chip as active if there is a chip next to the current chip.
                this.chipsList[focusIndex].active = true;
                $chipsList.get(focusIndex).focus();
            }
        });
        const pulledItems = _.pullAt(this.chipsList, indexes);
        pulledItems.forEach(datasetItem => {
            this._modelByValue = _.filter(this._modelByValue, val => {
                return !(_.isObject(val) ? _.isEqual(val, datasetItem.value) : _.toString(val) === _.toString(datasetItem.value));
            });
        });
        this._unsubscribeDv = false;
        this.invokeOnChange(this._modelByValue, $event, true);
        this.invokeEventCallback('change', { $event, newVal: this.datavalue, oldVal: prevDatavalue });
        this.updateMaxSize();
        this.invokeEventCallback('remove', { $event, $item: items.length === 1 ? items[0] : items });
    }
    /**
     * Swaps items in an array if provided with indexes.
     * @param data :- array to be swapped
     * @param newIndex :- new index for the element to be placed
     * @param currentIndex :- the current index of the element.
     */
    swapElementsInArray(data, newIndex, currentIndex) {
        const draggedItem = _.pullAt(data, currentIndex)[0];
        data.splice(newIndex, 0, draggedItem);
    }
    /**
     * Cancels the reorder by reseting the elements to the original position.
     */
    resetReorder() {
        this.$element.removeData('oldIndex');
    }
    onBeforeservicecall(inputData) {
        this.invokeEventCallback('beforeservicecall', { inputData });
    }
    handleEvent(node, eventName, eventCallback, locals) {
        if (eventName === 'remove' || eventName === 'beforeremove' || eventName === 'chipselect'
            || eventName === 'chipclick' || eventName === 'add' || eventName === 'reorder' || eventName === 'change') {
            return;
        }
        super.handleEvent(node, eventName, eventCallback, locals);
    }
    // Configures the reordable feature in chips widgets.
    configureDnD() {
        const options = {
            items: '> li:not(.app-chip-search)',
            placeholder: 'chip-placeholder'
        };
        configureDnD(this.$element, options, this.onReorderStart.bind(this), this.update.bind(this));
    }
    // Triggered on drag start while reordering.
    onReorderStart(evt, ui) {
        const helper = ui.helper;
        // increasing the width of the dragged item by 1
        helper.width(helper.width() + 1);
        this.$element.data('oldIndex', ui.item.index() - (this.inputposition === 'first' ? 1 : 0));
    }
    // updates the chipsList and datavalue on reorder.
    update($event, ui) {
        let changedItem, newIndex, oldIndex;
        // Get the index of the item at position before drag and after the reorder.
        newIndex = ui.item.index() - (this.inputposition === 'first' ? 1 : 0);
        oldIndex = this.$element.data('oldIndex');
        newIndex = this.chipsList.length === newIndex ? newIndex - 1 : newIndex;
        changedItem = {
            oldIndex: oldIndex,
            newIndex: newIndex,
            item: this.chipsList[oldIndex]
        };
        if (newIndex === oldIndex) {
            this.resetReorder();
            return;
        }
        changedItem.item = this.chipsList[oldIndex];
        const allowReorder = this.invokeEventCallback('beforereorder', { $event, $data: this.chipsList, $changedItem: changedItem });
        if (isDefined(allowReorder) && toBoolean(allowReorder) === false) {
            this.resetReorder();
            return;
        }
        // modify the chipsList and datavalue after the reorder.
        this.swapElementsInArray(this.chipsList, newIndex, oldIndex);
        this.swapElementsInArray(this._modelByValue, newIndex, oldIndex);
        changedItem.item = this.chipsList[newIndex];
        this.chipsList = [...this.chipsList];
        this.resetReorder();
        this.invokeEventCallback('reorder', { $event, $data: this.chipsList, $changedItem: changedItem });
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'tabindex') {
            return;
        }
        if (key === 'dataoptions') {
            this.searchComponent.dataoptions = nv;
        }
        if (key === 'datafield') {
            this.searchComponent.datafield = this.datafield;
        }
        if (key === 'displayfield') {
            this.searchComponent.displaylabel = this.displayfield;
        }
        if (key === 'displayexpression') {
            this.searchComponent.binddisplaylabel = this.binddisplayexpression ? this.binddisplayexpression : this.displayexpression;
        }
        if (key === 'displayimagesrc') {
            this.searchComponent.binddisplayimagesrc = this.binddisplayimagesrc ? this.binddisplayimagesrc : this.displayimagesrc;
        }
        if (key === 'limit') {
            this.searchComponent.limit = this.limit;
        }
        if (key === 'enablereorder') {
            if (this.$element.hasClass('ui-sortable')) {
                this.$element.sortable('option', 'disabled', !nv);
            }
            else if (nv) {
                this.configureDnD();
            }
        }
        if (key === 'readonly') {
            if (nv) {
                this.$element.addClass('readonly');
            }
            else {
                this.$element.removeClass('readonly');
            }
        }
        if (key === 'inputposition') {
            const $inputEl = this.$element.find('li.app-chip-search');
            if (nv === 'first') {
                this.$element.prepend($inputEl);
            }
            else {
                this.$element.append($inputEl);
            }
        }
        if (key === 'autofocus' && nv) {
            // setting the autofocus on the input once after dom is updated
            setTimeout(() => {
                const $chipsList = this.$element.find('.app-chip-input > input.app-textbox');
                if ($chipsList && $chipsList.length) {
                    this.focusSearchBox();
                }
            });
        }
        super.onPropertyChange(key, nv, ov);
    }
}
ChipsComponent.initializeProps = registerProps$i();
ChipsComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmChips]',
                template: "<li class=\"chip-item\" role=\"option\" *ngFor=\"let item of chipsList; let $index = index;\"\n    [ngClass]=\"{'active': item.active, 'disabled': disabled}\">\n    <a class=\"app-chip\" href=\"javascript:void(0);\" tabindex=\"-1\"\n       (click)=\"handleChipClick($event, item)\"\n       (keydown.delete)=\"onDelete($event, item, $index)\"\n       (keydown.backspace)=\"onBackspace($event, item, $index)\"\n       (keydown.arrowleft)=\"onArrowLeft(item, $index)\"\n       (keydown.arrowright)=\"onArrowRight(item, $index)\"\n       (focus)=\"handleChipFocus($event, item)\"\n       (blur)=\"readonly ? 0 : item.active = false\"\n       [ngClass]=\"{'chip-duplicate bg-danger': item.isDuplicate, 'chip-picture': item.imgSrc}\">\n        <img data-identifier=\"img\" alt=\"Chip Image\" class=\"button-image-icon\" [src]=\"item.imgSrc\" *ngIf=\"item.imgSrc\"/>\n        <span class=\"app-chip-title\" [textContent]=\"item.label\" [title]=\"item.label\"></span>\n        <button type=\"button\" tabindex=\"-1\" arial-label=\"Clear Button\" class=\"btn btn-transparent\" (click)=\"removeItem($event, item, $index);\" *ngIf=\"!readonly\">\n            <i class=\"app-icon wi wi-close\"></i>\n        </button>\n    </a>\n</li>\n<li class=\"app-chip-search\" [ngClass]=\"{'full-width': inputwidth === 'full'}\">\n    <div #search wmSearch class=\"app-chip-input\"\n         name=\"app-chip-search\"\n         submit.event=\"addItem($event, widget)\"\n         beforeservicecall.event=\"onBeforeservicecall(inputData)\"\n         disabled.bind=\"disabled || readonly || saturate\"\n         datafield.bind=\"datafield\"\n         allowonlyselect.bind=\"allowonlyselect\"\n         searchkey.bind=\"searchkey\"\n         orderby.bind=\"orderby\"\n         placeholder.bind=\"saturate ? maxSizeReached : placeholder\"\n         showsearchicon.bind=\"showsearchicon\"\n         tabindex.bind=\"tabindex\"\n         minchars.bind=\"minchars\"\n         debouncetime.bind=\"debouncetime\"\n         matchmode.bind=\"matchmode\"\n         (keydown.enter)=\"onSelect($event)\"\n         (keydown.delete)=\"onTextDelete($event)\"\n         (keydown.backspace)=\"onInputClear($event)\"\n         (keydown.arrowleft)=\"onArrowLeft()\"\n         (keydown.arrowright)=\"onArrowRight()\">\n    </div>\n</li>\n",
                providers: [
                    provideAsNgValueAccessor(ChipsComponent),
                    provideAsWidgetRef(ChipsComponent)
                ]
            }] }
];
/** @nocollapse */
ChipsComponent.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Attribute, args: ['displayfield.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['displayexpression.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['displayimagesrc.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['datafield.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['dataset.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['chipclass.bind',] }] }
];
ChipsComponent.propDecorators = {
    searchComponent: [{ type: ViewChild, args: [SearchComponent,] }]
};

const registerProps$k = () => {
    register('wm-form-group', new Map([
        ['captionposition', PROP_STRING],
        ['name', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$f = 'form-group app-composite-widget clearfix';
const WIDGET_CONFIG$j = {
    widgetType: 'wm-form-group',
    hostClass: DEFAULT_CLS$f
};
const CAPTION_POSITION = {
    left: 'caption-left',
    right: 'caption-right',
    top: 'caption-top'
};
class CompositeDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$j);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
    /**
     * this is onPropertyChange handler for the form-group component
     * @param key
     * @param nv
     * @param ov
     */
    onPropertyChange(key, nv, ov) {
        if (key === 'captionposition') {
            switchClass(this.nativeElement, CAPTION_POSITION[nv], CAPTION_POSITION[ov]);
        }
        else if (key === 'required') {
            this.required = nv;
            this.assignRequiredToSubComponents();
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    /**
     * this method assigns the required on the component/directive based on the required attribute of the form-group
     */
    assignRequiredToSubComponents() {
        if (this.required && this.componentRefs) {
            setTimeout(() => {
                this.componentRefs.forEach(componentRef => componentRef.widget.required = true);
            }, 50);
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        addForIdAttributes(this.nativeElement);
        this.assignRequiredToSubComponents();
    }
}
CompositeDirective.initializeProps = registerProps$k();
CompositeDirective.decorators = [
    { type: Directive, args: [{
                selector: 'div[wmComposite]',
                providers: [
                    provideAsWidgetRef(CompositeDirective)
                ]
            },] }
];
/** @nocollapse */
CompositeDirective.ctorParameters = () => [
    { type: Injector }
];
CompositeDirective.propDecorators = {
    componentRefs: [{ type: ContentChildren, args: [WidgetRef, { descendants: true },] }]
};

const registerProps$l = () => {
    register('wm-confirmdialog', new Map([
        ['animation', PROP_STRING],
        ['canceltext', Object.assign({ value: 'CANCEL' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['closable', { value: true, PROP_BOOLEAN }],
        ['iconclass', { value: 'wi wi-done', PROP_STRING }],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['message', Object.assign({ value: 'I am confirm box!' }, PROP_STRING)],
        ['modal', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['name', PROP_STRING],
        ['oktext', Object.assign({ value: 'OK' }, PROP_STRING)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', Object.assign({ value: 'Confirm' }, PROP_STRING)]
    ]));
};

const DIALOG_CLS$1 = 'app-dialog modal-dialog app-confirm-dialog';
const WIDGET_INFO$1 = { widgetType: 'wm-confirmdialog' };
class ConfirmDialogComponent extends BaseDialog {
    constructor(inj, dialogClass, modal, closable) {
        if (modal === null || modal === undefined) {
            modal = false;
        }
        if (closable === null || closable === undefined) {
            closable = true;
        }
        // setting the backdrop to 'static' will not close the dialog on backdrop click
        const backdrop = 'static';
        super(inj, WIDGET_INFO$1, {
            class: `${DIALOG_CLS$1} ${dialogClass || ''}`,
            backdrop,
            keyboard: !toBoolean(modal)
        });
    }
    getTemplateRef() {
        return this.dialogTemplate;
    }
    /**
     * Click event handler for the ok button
     * invokes on-ok event callback
     * @param {Event} $event
     */
    onOk($event) {
        this.invokeEventCallback('ok', { $event });
    }
    /**
     * Click event handler for the cancel button
     * invokes on-cancel event callback
     * @param {Event} $event
     */
    onCancel($event) {
        this.invokeEventCallback('cancel', { $event });
    }
    ngOnInit() {
        super.ngOnInit();
        this.register(this.viewParent);
    }
}
ConfirmDialogComponent.initializeProps = registerProps$l();
ConfirmDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmConfirmDialog]',
                template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"></div>\n    <div wmDialogBody>\n        <p class=\"app-dialog-message {{messageclass}}\" [attr.aria-describedby]=\"message\">{{message}}</p>\n    </div>\n    <div wmDialogFooter>\n        <button wmButton class=\"btn-default btn-secondary cancel-action\" caption.bind=\"canceltext\" aria-label=\"Cancel button\" (click)=\"onCancel($event)\"></button>\n        <button wmButton class=\"btn-primary ok-action\" caption.bind=\"oktext\" aria-label=\"Submit button\" (click)=\"onOk($event)\"></button>\n    </div>\n</ng-template>\n",
                providers: [
                    provideAsWidgetRef(ConfirmDialogComponent),
                    provideAsDialogRef(ConfirmDialogComponent)
                ]
            }] }
];
/** @nocollapse */
ConfirmDialogComponent.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Attribute, args: ['class',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['modal',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['closable',] }] }
];
ConfirmDialogComponent.propDecorators = {
    dialogTemplate: [{ type: ViewChild, args: ['dialogTemplate',] }]
};

const registerProps$m = () => {
    register('wm-container', new Map([
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['content', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$g = 'app-container';
const WIDGET_CONFIG$k = {
    widgetType: 'wm-container',
    hostClass: DEFAULT_CLS$g
};
class ContainerDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$k);
        addClass(this.nativeElement, DEFAULT_CLS$g);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
ContainerDirective.initializeProps = registerProps$m();
ContainerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmContainer]',
                providers: [
                    provideAsWidgetRef(ContainerDirective)
                ]
            },] }
];
/** @nocollapse */
ContainerDirective.ctorParameters = () => [
    { type: Injector }
];

const registerProps$n = () => {
    register('wm-content', new Map([
        ['name', PROP_STRING],
        ['class', PROP_STRING]
    ]));
};

const DEFAULT_CLS$h = 'app-content clearfix';
const WIDGET_CONFIG$l = { widgetType: 'wm-content', hostClass: DEFAULT_CLS$h };
class ContentComponent extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$l);
        styler(this.nativeElement, this);
    }
}
ContentComponent.initializeProps = registerProps$n();
ContentComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmContent]',
                template: "<div class=\"row app-content-row clearfix\">\n    <ng-content></ng-content>\n</div>",
                providers: [
                    provideAsWidgetRef(ContentComponent)
                ]
            }] }
];
/** @nocollapse */
ContentComponent.ctorParameters = () => [
    { type: Injector }
];

const currencyProps = new Map([
    ['class', PROP_STRING],
    ['currency', Object.assign({ value: 'USD' }, PROP_STRING)],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['maxvalue', PROP_NUMBER],
    ['minvalue', PROP_NUMBER],
    ['name', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Enter value' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['step', Object.assign({ value: 1 }, PROP_NUMBER)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)]
]);
const registerProps$o = () => {
    register('wm-currency', currencyProps);
};

class BaseInput extends BaseFormCustomComponent {
    constructor(inj, config) {
        super(inj, config);
        // possible values for ngModelOptions are 'blur' and 'change'
        // default is 'blur'
        this.ngModelOptions = {
            updateOn: ''
        };
        let updateOn = this.nativeElement.getAttribute('updateon') || 'blur';
        updateOn = updateOn === 'default' ? 'change' : updateOn;
        this.ngModelOptions.updateOn = updateOn;
    }
    onPropertyChange(key, nv, ov) {
        // set the class on the input element
        if (key === 'tabindex') {
            return;
        }
        if (key === 'class') {
            if (this.inputEl.nativeElement) {
                switchClass(this.inputEl.nativeElement, nv, ov);
            }
        }
        else if (key === 'datavalue') {
            // update the oldDataValue when the datavalue is modified programmatically
            this.updatePrevDatavalue(nv);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    // invoke the change callback
    handleChange(newValue) {
        this.invokeOnChange(this.datavalue, { type: 'change' }, this.ngModel.valid);
    }
    // Change event is registered from the template, Prevent the framework from registering one more event
    handleEvent(node, eventName, eventCallback, locals) {
        if (eventName !== 'change' && eventName !== 'blur') {
            super.handleEvent(this.inputEl.nativeElement, eventName, eventCallback, locals);
        }
    }
    // invoke the blur callback
    handleBlur($event) {
        this.invokeOnTouched($event);
    }
    // Update the model on enter key press
    flushViewChanges(val) {
        this.ngModel.update.next(val);
        $appDigest();
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        // add the class on the input element
        if (this.class) {
            addClass(this.inputEl.nativeElement, this.class);
        }
        styler(this.inputEl.nativeElement, this);
    }
}

class NumberLocale extends BaseInput {
    constructor(inj, config, i18nService, decimalPipe) {
        super(inj, config);
        this.decimalPipe = decimalPipe;
        this.isDefaultQuery = true;
        this.selectedLocale = i18nService.getSelectedLocale();
        this.DECIMAL = getLocaleNumberSymbol(this.localefilter || this.selectedLocale, NumberSymbol.Decimal);
        this.GROUP = getLocaleNumberSymbol(this.localefilter || this.selectedLocale, NumberSymbol.Group);
        this.numberfilter = '1.0-16';
        this.resetValidations();
    }
    // Setter for the datavalue.
    set datavalue(value) {
        // set text value to null if data value is empty.
        if (_.includes([null, undefined, ''], value)) {
            const input = this.inputEl.nativeElement;
            this.displayValue = input.value = this.proxyModel = null;
            this.resetValidations();
            this._onChange();
            return;
        }
        // if the widget has default value and if we change the locale, the value should be in selected locale format.
        if (this.isDefaultQuery) {
            value = this.transformNumber(value);
        }
        // get a valid number form the text.
        const model = this.parseNumber(value.toString());
        // if the number is valid or if number is not in range update the model value.
        if (this.isValid(model)) {
            this.proxyModel = model;
            // update the display value in the text box.
            this.updateDisplayText();
            this.handleChange(model);
        }
        else {
            this.displayValue = value.toString();
            this.proxyModel = null;
            this.handleChange(null);
        }
    }
    // returns the actual model value of the widget.
    get datavalue() {
        return this.proxyModel;
    }
    // resets all the flags related to the widget's validation.
    resetValidations() {
        this.isInvalidNumber = false;
        this.numberNotInRange = false;
    }
    /**
     * Adds validations for the number before updating the widget model. like validating min and max value for the widget.
     * @param {number} val number to be validated
     * @returns {number}
     */
    isValid(val) {
        // id number is infinite then consider it as invalid value
        if (_.isNaN(val) || !_.isFinite(val)) {
            this.isInvalidNumber = true;
            return false;
        }
        if (val !== this.getValueInRange(val)) {
            this.numberNotInRange = true;
            return true;
        }
        this.resetValidations();
        return true;
    }
    /**
     * returns a valid number by validating the minimum and maximum values.
     * @param {number} value
     * @returns {number}
     */
    getValueInRange(value) {
        if (!_.isNaN(this.minvalue) && value < this.minvalue) {
            return this.minvalue;
        }
        if (!_.isNaN(this.maxvalue) && value > this.maxvalue) {
            return this.maxvalue;
        }
        return value;
    }
    /**
     * convert number to localized number using angular decimal pipe. eg 10,00,000 or 1,000,000
     * @param number
     * @returns {string}
     */
    transformNumber(number) {
        return this.decimalPipe.transform(number, this.numberfilter, this.localefilter || this.selectedLocale);
    }
    /**
     * resets the cursor position in the text box.
     * @param {number} value cursor position index form left to right.
     */
    resetCursorPosition(value) {
        const input = this.inputEl.nativeElement;
        // position of the cursor should be given form right to left.
        let position = input.value.length - value;
        position = position < 0 ? 0 : position;
        // set the cursor position in the text box.
        input.setSelectionRange(position, position);
    }
    /**
     * Method parses the Localized number(string) to a valid number.
     * if the string dose not result to a valid number then returns NaN.
     * @param {string} val Localized number.
     * @returns {number}
     */
    parseNumber(val) {
        // splits string into two parts. decimal and number.
        const parts = val.split(this.DECIMAL);
        if (!parts.length) {
            return null;
        }
        if (parts.length > 2) {
            return NaN;
        }
        // If number have decimal point and not have a decimal value then return.
        if (parts[1] === '') {
            return NaN;
        }
        // replaces all group separators form the number.
        const number = Number(parts[0].split(this.GROUP).join(''));
        const decimal = Number(`0.${parts[1] || 0}`);
        if (Number.isNaN(number) || Number.isNaN(decimal)) {
            return NaN;
        }
        // if the number is negative then calculate the number as number - decimal
        // Ex: number = -123 and decimal = 0.45 then number - decimal = -123-045 = -123.45
        return number >= 0 ? number + decimal : number - decimal;
    }
    // updates the widgets text value.
    updateDisplayText() {
        const input = this.inputEl.nativeElement;
        const position = input.selectionStart;
        const preValue = input.value;
        this.displayValue = input.value = this.transformNumber(this.proxyModel);
        // in safari browser, setSelectionRange will focus the input by default, which may invoke the focus event on widget.
        // Hence preventing the setSelectionRange when default value is set i.e. widget is not focused.
        if (this.updateon === 'default' && !this.isDefaultQuery) {
            this.resetCursorPosition(preValue.length - position);
        }
    }
    /**
     * returns the number of decimal places a number have.
     * @param value: number
     * @returns {number}
     */
    countDecimals(value) {
        if ((value % 1) !== 0) {
            return value.toString().split('.')[1].length;
        }
        return 0;
    }
    /**
     * handles the arrow press event. Increases or decreases the number. triggered fom the template
     * @param $event keyboard event.
     * @param key identifier to increase or decrease the number.
     */
    onArrowPress($event, key) {
        $event.preventDefault();
        if (this.readonly || this.step === 0) {
            return;
        }
        let proxyModel = this.proxyModel;
        let value;
        // if the number is not in range and when arrow buttons are pressed need to get appropriate number value.
        if (this.numberNotInRange) {
            const inputValue = this.parseNumber(this.inputEl.nativeElement.value);
            // take the textbox value as current model if the value is valid.
            if (!_.isNaN(inputValue)) {
                value = this.getValueInRange(inputValue);
                proxyModel = inputValue;
                this.resetValidations();
            }
        }
        else {
            if (_.isUndefined(proxyModel) || _.isNull(proxyModel)) {
                proxyModel = value = this.getValueInRange((this.minvalue || 0));
                this.resetValidations();
            }
            else {
                value = this.getValueInRange(proxyModel + (key === 'UP' ? this.step : -this.step));
            }
        }
        if ((key === 'UP' && proxyModel <= value) || (key === 'DOWN' && proxyModel >= value)) {
            const decimalRoundValue = Math.max(this.countDecimals(proxyModel), this.countDecimals(this.step));
            // update the modelProxy.
            this.proxyModel = _.round(value, decimalRoundValue);
            this.updateDisplayText();
            this.handleChange(this.proxyModel);
        }
    }
    /**
     * method is called from the from widget. to check whether the value entered is valid or not.
     * @returns {object}
     */
    validate(c) {
        if (this.isInvalidNumber) {
            return {
                invalidNumber: {
                    valid: false
                },
            };
        }
        if (this.numberNotInRange) {
            return {
                numberNotInRange: {
                    valid: false
                },
            };
        }
        return null;
    }
    validateInputEntry($event) {
        this.isDefaultQuery = false;
        // allow actions if control key is pressed or if backspace is pressed. (for Mozilla).
        if ($event.ctrlKey || _.includes(['Backspace', 'ArrowRight', 'ArrowLeft', 'Tab', 'Enter'], $event.key)) {
            return;
        }
        const validity = new RegExp(`^[\\d\\s-,.e+${this.GROUP}${this.DECIMAL}]$`, 'i');
        const inputValue = $event.target.value;
        // validates if user entered an invalid character.
        if (!validity.test($event.key)) {
            return false;
        }
        // a decimal value can be entered only once in the input.
        if (_.includes(inputValue, this.DECIMAL) && $event.key === this.DECIMAL) {
            return false;
        }
        // 'e' can be entered only once in the input.
        if (_.intersection(_.toArray(inputValue), ['e', 'E']).length && _.includes('eE', $event.key)) {
            return false;
        }
        if ((_.includes(inputValue, '+') || _.includes(inputValue, '-')) && ($event.key === '+' || $event.key === '-')) {
            return false;
        }
    }
    onEnter($event) {
        this.datavalue = $event.target.value;
    }
}

const DEFAULT_CLS$i = 'input-group app-currency';
const WIDGET_CONFIG$m = {
    widgetType: 'wm-currency',
    hostClass: DEFAULT_CLS$i
};
class CurrencyComponent extends NumberLocale {
    constructor(inj, i18nService, decimalPipe) {
        super(inj, WIDGET_CONFIG$m, i18nService, decimalPipe);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'currency') {
            this.currencySymbol = CURRENCY_INFO[this.currency || 'USD'].symbol;
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
CurrencyComponent.initializeProps = registerProps$o();
CurrencyComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmCurrency]',
                template: "<span class=\"input-group-addon\" [textContent]=\"currencySymbol\"></span>\n<input class=\"form-control app-textbox app-currency-input\"\n       #input\n       role=\"input\"\n       type=\"text\"\n       focus-target\n       [autofocus]=\"autofocus\"\n       [readonly]=\"readonly\"\n       [disabled]=\"disabled\"\n       [required]=\"required\"\n       [pattern]=\"regexp\"\n       [attr.name]=\"name\"\n       [attr.aria-label]=\"name\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [ngModel]=\"displayValue\"\n       [ngModelOptions]=\"ngModelOptions\"\n\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"datavalue=$event\"\n       (keypress)=\"validateInputEntry($event)\"\n       (keydown.enter)=\"onEnter($event)\"\n       (keydown.ArrowUp)=\"onArrowPress($event, 'UP')\"\n       (keydown.ArrowDown)=\"onArrowPress($event, 'DOWN')\">",
                providers: [
                    provideAsNgValueAccessor(CurrencyComponent),
                    provideAsNgValidators(CurrencyComponent),
                    provideAsWidgetRef(CurrencyComponent)
                ]
            }] }
];
/** @nocollapse */
CurrencyComponent.ctorParameters = () => [
    { type: Injector },
    { type: AbstractI18nService },
    { type: DecimalPipe }
];
CurrencyComponent.propDecorators = {
    ngModel: [{ type: ViewChild, args: [NgModel,] }],
    inputEl: [{ type: ViewChild, args: ['input', { read: ElementRef },] }]
};

const dateProps = new Map([
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['datepattern', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['excludedays', PROP_STRING],
    ['excludedates', PROP_STRING],
    ['hint', PROP_STRING],
    ['maxdate', PROP_STRING],
    ['mindate', PROP_STRING],
    ['name', PROP_STRING],
    ['outputformat', Object.assign({ value: 'yyyy-MM-dd' }, PROP_STRING)],
    ['placeholder', Object.assign({ value: 'Select Date' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showdropdownon', Object.assign({ value: 'default' }, PROP_STRING)],
    ['showbuttonbar', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showindevice', Object.assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
    ['showweeks', Object.assign({ value: false }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)]
]);
const registerProps$p = () => {
    if (isMobileApp()) {
        dateProps.set('datepattern', Object.assign({ value: 'yyyy-MM-dd' }, PROP_STRING));
    }
    register('wm-date', dateProps);
};

const CURRENT_DATE = 'CURRENT_DATE';
const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
const DATEPICKER_DROPDOWN_OPTIONS = {
    BUTTON: 'button',
    DEFAULT: 'default'
};
class BaseDateTimeComponent extends BaseFormCustomComponent {
    constructor(inj, WIDGET_CONFIG) {
        super(inj, WIDGET_CONFIG);
        this.useDatapicker = true;
        /**
         * This is an internal property used to map the containerClass, showWeekNumbers etc., to the bsDatepicker
         */
        this._dateOptions = new BsDatepickerConfig();
        this.datePipe = this.inj.get(ToDatePipe);
    }
    /**
     * returns true if the input value is default (i.e open date picker on input click)
     * @param1 dropdownvalue, user selected value (by default datepicker opens on input click)
     * **/
    isDropDownDisplayEnabledOnInput(dropdownvalue) {
        return dropdownvalue === DATEPICKER_DROPDOWN_OPTIONS.DEFAULT;
    }
    /**
     * This method is used to show validation message depending on the isNativePicker flag.
     */
    showValidation($event, displayValue, isNativePicker, msg) {
        if (isNativePicker) {
            alert(msg);
            return $($event.target).val(displayValue);
        }
    }
    resetDisplayInput() {
        $(this.nativeElement).find('.display-input').val('');
    }
    validate() {
        if (this.invalidDateTimeFormat) {
            return {
                invalidDateTimeFormat: {
                    valid: false
                }
            };
        }
        if (!_.isUndefined(this.dateNotInRange) && this.dateNotInRange) {
            return {
                dateNotInRange: {
                    valid: false
                },
            };
        }
        if (!_.isUndefined(this.timeNotInRange) && this.timeNotInRange) {
            return {
                timeNotInRange: {
                    valid: false
                },
            };
        }
        return null;
    }
    /**
     * This method is used to validate date pattern and time pattern
     * If user selects one pattern in design time and if he tries to enter the date in another pattern then the device is throwing an error
     */
    formatValidation(newVal, inputVal, isNativePicker) {
        const pattern = this.datepattern || this.timepattern;
        const formattedDate = getFormattedDate(this.datePipe, newVal, pattern);
        inputVal = inputVal.trim();
        if (inputVal) {
            if (pattern === 'timestamp') {
                if (!_.isNaN(inputVal) && _.parseInt(inputVal) !== formattedDate) {
                    this.invalidDateTimeFormat = true;
                    this.invokeOnChange(this.datavalue, undefined, false);
                    return false;
                }
            }
            else {
                if (isNativePicker) {
                    // format the date value only when inputVal is obtained from $event.target.value, as the format doesnt match.
                    inputVal = getFormattedDate(this.datePipe, inputVal, pattern);
                }
                if (inputVal !== formattedDate) {
                    this.invalidDateTimeFormat = true;
                    this.invokeOnChange(this.datavalue, undefined, false);
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * This method is used to validate min date, max date, exclude dates and exclude days
     * In mobile if invalid dates are entered, device is showing an alert.
     * In web if invalid dates are entered, device is showing validation message.
     */
    minDateMaxDateValidationOnInput(newVal, $event, displayValue, isNativePicker) {
        if (newVal) {
            newVal = moment(newVal).startOf('day').toDate();
            const minDate = moment(getDateObj(this.mindate)).startOf('day').toDate();
            const maxDate = moment(getDateObj(this.maxdate)).startOf('day').toDate();
            if (this.mindate && newVal < minDate) {
                const msg = `${this.appLocale.LABEL_MINDATE_VALIDATION_MESSAGE} ${this.mindate}.`;
                this.dateNotInRange = true;
                this.invokeOnChange(this.datavalue, undefined, false);
                return this.showValidation($event, displayValue, isNativePicker, msg);
            }
            if (this.maxdate && newVal > maxDate) {
                const msg = `${this.appLocale.LABEL_MAXDATE_VALIDATION_MESSAGE} ${this.maxdate}.`;
                this.dateNotInRange = true;
                this.invokeOnChange(this.datavalue, undefined, false);
                return this.showValidation($event, displayValue, isNativePicker, msg);
            }
            if (this.excludedates) {
                let excludeDatesArray;
                if (isString(this.excludedates)) {
                    excludeDatesArray = _.split(this.excludedates, ',');
                }
                else {
                    excludeDatesArray = this.excludedates;
                }
                excludeDatesArray = excludeDatesArray.map(d => getFormattedDate(this.datePipe, d, this.datepattern));
                if (excludeDatesArray.indexOf(getFormattedDate(this.datePipe, newVal, this.datepattern)) > -1) {
                    this.dateNotInRange = true;
                    this.invokeOnChange(this.datavalue, undefined, false);
                    return;
                }
            }
            if (this.excludedays) {
                const excludeDaysArray = _.split(this.excludedays, ',');
                if (excludeDaysArray.indexOf(newVal.getDay().toString()) > -1) {
                    this.dateNotInRange = true;
                    this.invokeOnChange(this.datavalue, undefined, false);
                    return;
                }
            }
        }
        if (!isNativePicker) {
            this.dateNotInRange = false;
            this.invokeOnChange(this.datavalue, undefined, false);
        }
    }
    /**
     * This method is used to highlight the current date
     */
    hightlightToday() {
        const toDay = new Date().getDate().toString();
        _.filter($(`span:contains(${toDay})`).not('.is-other-month'), (obj) => {
            if ($(obj).text() === toDay) {
                $(obj).addClass('current-date text-info');
            }
        });
    }
    /**
     * This method is used to find the new date is from another year or not
     * @param newDate - newly selected date value
     */
    isOtheryear(newDate) {
        return (newDate.getMonth() === 0 && this.activeDate.getMonth() === 11) || (newDate.getMonth() === 11 && this.activeDate.getMonth() === 0);
    }
    /**
     * This method is used to set focus for active day
     * @param newDate - newly selected date value
     * @param isMouseEvent - boolean value represents the event is mouse event/ keyboard event
     */
    setActiveDateFocus(newDate, isMouseEvent) {
        const activeMonth = this.activeDate.getMonth();
        // check for keyboard event
        if (!isMouseEvent) {
            if (newDate.getMonth() < activeMonth) {
                this.isOtheryear(newDate) ? this.goToOtherMonthOryear('next', 'days') : this.goToOtherMonthOryear('previous', 'days');
            }
            else if (newDate.getMonth() > activeMonth) {
                this.isOtheryear(newDate) ? this.goToOtherMonthOryear('previous', 'days') : this.goToOtherMonthOryear('next', 'days');
            }
        }
        setTimeout(() => {
            if (newDate.getMonth() === new Date().getMonth() && newDate.getFullYear() === new Date().getFullYear()) {
                this.hightlightToday();
            }
            const newDay = newDate.getDate().toString();
            _.filter($(`span:contains(${newDay})`).not('.is-other-month'), (obj) => {
                if ($(obj).text() === newDay) {
                    $(obj).focus();
                    this.activeDate = newDate;
                }
            });
        });
    }
    /**
     * This method is used to load other month days or other month or other year
     * @param btnClass - class(previous/next) of the button which we have to click
     * @param timePeriod - String value decides to load other month days or other month or other year
     */
    goToOtherMonthOryear(btnClass, timePeriod) {
        const $node = $(`.bs-datepicker-head .${btnClass}`);
        if ($node.attr('disabled')) {
            return;
        }
        $node.trigger('click');
        if (timePeriod === 'days') {
            this.loadDays();
        }
        else if (timePeriod === 'month') {
            this.loadMonths();
        }
        else if (timePeriod === 'year') {
            this.loadYears();
        }
    }
    /**
    * This method sets the mouse events to Datepicker popup. These events are required when we navigate date picker through mouse.
     */
    addDatepickerMouseEvents() {
        const datePikcerHead = $(`.bs-datepicker-head`);
        datePikcerHead.find(`.previous`).click((event) => {
            // check for original mouse click
            if (event.originalEvent) {
                this.setFocusForDate(-1);
            }
        });
        datePikcerHead.find(`.next`).click((event) => {
            // check for original mouse click
            if (event.originalEvent) {
                this.setFocusForDate(1);
            }
        });
        datePikcerHead.find(`.current`).click((event) => {
            // check for original mouse click
            if (event.originalEvent) {
                this.setFocusForCurrentMonthOryear();
            }
        });
        $('.bs-datepicker-body').click((event) => {
            event.stopPropagation();
            // check for original mouse click
            if (event.originalEvent) {
                this.setFocusForMonthOrDay();
            }
        });
    }
    /**
     * This method sets focus for months/days depending on the loaded datepicker table
     */
    setFocusForMonthOrDay() {
        const activeMonthOrYear = $(`.bs-datepicker-head .current`).first().text();
        const datePickerBody = $('.bs-datepicker-body');
        if (datePickerBody.find('table.months').length > 0) {
            if (_.parseInt(activeMonthOrYear) !== this.activeDate.getFullYear()) {
                this.loadMonths();
            }
            const newDate = new Date(_.parseInt(activeMonthOrYear), this.activeDate.getMonth(), this.activeDate.getDate());
            this.setActiveMonthFocus(newDate, true);
        }
        else if (datePickerBody.find('table.days').length > 0) {
            const newMonth = months.indexOf(activeMonthOrYear);
            if (newMonth !== this.activeDate.getMonth()) {
                this.loadDays();
            }
            const newDate = new Date(this.activeDate.getFullYear(), newMonth, 1);
            this.setActiveDateFocus(newDate, true);
        }
    }
    /**
     * This method sets focus for months/years depending on the loaded datepicker table
     */
    setFocusForCurrentMonthOryear() {
        const datePickerBody = $('.bs-datepicker-body');
        if (datePickerBody.find('table.months').length > 0) {
            this.loadMonths();
            this.setActiveMonthFocus(this.activeDate, true);
        }
        else if (datePickerBody.find('table.years').length > 0) {
            this.loadYears();
            this.setActiveYearFocus(this.activeDate, true);
        }
    }
    /**
     * This method sets focus for months/years/days depending on the loaded datepicker table
     */
    setFocusForDate(count) {
        const datePickerBody = $('.bs-datepicker-body');
        if (datePickerBody.find('table.months').length > 0) {
            this.loadMonths();
            const newDate = new Date(this.activeDate.getFullYear() + count, 0, this.activeDate.getDate());
            this.setActiveMonthFocus(newDate, true);
        }
        else if (datePickerBody.find('table.years').length > 0) {
            this.loadYears();
            const startYear = datePickerBody.find('table.years span').first().text();
            const newDate = new Date(_.parseInt(startYear), this.activeDate.getMonth(), this.activeDate.getDate());
            this.setActiveYearFocus(newDate, true);
        }
        else if (datePickerBody.find('table.days').length > 0) {
            this.loadDays();
            const newDate = new Date(this.activeDate.getFullYear(), this.activeDate.getMonth() + count, 1);
            this.setActiveDateFocus(newDate, true);
        }
    }
    /**
     * This method is used to add keyboard events while opening the date picker
     * @param scope - scope of the date/datetime widget
     * @param isDateTime - boolean value represents the loaded widget is date or datetime
     */
    addDatepickerKeyboardEvents(scope, isDateTime) {
        this.keyEventPluginInstance = scope.keyEventPlugin.constructor;
        this.elementScope = scope;
        const dateContainer = document.querySelector(`.${scope.dateContainerCls}`);
        setAttr(dateContainer, 'tabindex', '0');
        dateContainer.onkeydown = (event) => {
            const action = this.keyEventPluginInstance.getEventFullKey(event);
            // Check for Shift+Tab key or Tab key or escape
            if (action === 'shift.tab' || action === 'escape' || (action === 'tab' && !isDateTime)) {
                this.elementScope.hideDatepickerDropdown();
                const displayInputElem = this.elementScope.nativeElement.querySelector('.display-input');
                setTimeout(() => displayInputElem.focus());
            }
            if (action === 'tab' && isDateTime) {
                this.bsDatePickerDirective.hide();
                this.elementScope.toggleTimePicker(true);
            }
        };
        this.loadDays();
        this.setActiveDateFocus(this.activeDate);
    }
    /**
     * This method is used to add tabindex, keybord and mouse events for days
     */
    loadDays() {
        setTimeout(() => {
            $('.bs-datepicker-body').attr('tabindex', '0');
            $('[bsdatepickerdaydecorator]').not('.is-other-month').attr('tabindex', '0');
            this.addKeyBoardEventsForDays();
            this.addDatepickerMouseEvents();
        });
    }
    /**
     * This method sets keyboard events for days
     */
    addKeyBoardEventsForDays() {
        const datePickerBody = $('.bs-datepicker-body');
        if (datePickerBody.length > 0) {
            datePickerBody[0].addEventListener('mouseenter', (event) => {
                event.stopPropagation();
            }, true);
        }
        datePickerBody.keydown((event) => {
            const action = this.keyEventPluginInstance.getEventFullKey(event);
            let newdate;
            if (action === 'arrowdown') {
                event.preventDefault();
                newdate = moment(this.activeDate).add(+7, 'days').toDate();
                this.setActiveDateFocus(newdate);
            }
            else if (action === 'arrowup') {
                event.preventDefault();
                newdate = moment(this.activeDate).add(-7, 'days').toDate();
                this.setActiveDateFocus(newdate);
            }
            else if (action === 'arrowleft') {
                newdate = moment(this.activeDate).add(-1, 'days').toDate();
                this.setActiveDateFocus(newdate);
            }
            else if (action === 'arrowright') {
                newdate = moment(this.activeDate).add(+1, 'days').toDate();
                this.setActiveDateFocus(newdate);
            }
            else if (action === 'control.arrowup') {
                // clicking on table header month name to load list of months
                $('.bs-datepicker-head .current').first().click();
                this.loadMonths();
                this.setActiveMonthFocus(this.activeDate);
            }
            else if (action === 'enter') {
                if ($(document.activeElement).hasClass('disabled')) {
                    return;
                }
                $(document.activeElement).click();
                this.elementScope.hideDatepickerDropdown();
                const displayInputElem = this.elementScope.nativeElement.querySelector('.display-input');
                setTimeout(() => displayInputElem.focus());
            }
        });
    }
    /**
     * This method is used to add tabindex, keybord and mouse events for months
     */
    loadMonths() {
        setTimeout(() => {
            const datePickerBody = $('.bs-datepicker-body');
            datePickerBody.attr('tabindex', '0');
            datePickerBody.find('table.months span').attr('tabindex', '0');
            this.addKeyBoardEventsForMonths();
            this.addDatepickerMouseEvents();
        });
    }
    /**
     * This method sets keyboard events for months
     */
    addKeyBoardEventsForMonths() {
        $('.bs-datepicker-body').keydown((event) => {
            const action = this.keyEventPluginInstance.getEventFullKey(event);
            let newdate;
            if (action === 'arrowdown') {
                event.preventDefault();
                newdate = moment(this.activeDate).add(+3, 'month').toDate();
                this.setActiveMonthFocus(newdate);
            }
            else if (action === 'arrowup') {
                event.preventDefault();
                newdate = moment(this.activeDate).add(-3, 'month').toDate();
                this.setActiveMonthFocus(newdate);
            }
            else if (action === 'arrowleft') {
                newdate = moment(this.activeDate).add(-1, 'month').toDate();
                this.setActiveMonthFocus(newdate);
            }
            else if (action === 'arrowright') {
                newdate = moment(this.activeDate).add(+1, 'month').toDate();
                this.setActiveMonthFocus(newdate);
            }
            else if (action === 'control.arrowup') {
                // clicking on table header year to load list of years
                $('.bs-datepicker-head .current').first().click();
                this.loadYears();
                this.setActiveYearFocus(this.activeDate);
            }
            else if (action === 'control.arrowdown' || action === 'enter') {
                if ($(document.activeElement).parent().hasClass('disabled')) {
                    return;
                }
                $(document.activeElement).click();
                this.loadDays();
                const newDate = new Date(this.activeDate.getFullYear(), this.activeDate.getMonth(), 1);
                this.setActiveDateFocus(newDate);
            }
        });
    }
    /**
     * This method is used to add tabindex, keybord and mouse events for years
     */
    loadYears() {
        setTimeout(() => {
            const datePickerBody = $('.bs-datepicker-body');
            datePickerBody.attr('tabindex', '0');
            datePickerBody.find('table.years span').attr('tabindex', '0');
            this.addKeyBoardEventsForYears();
            this.addDatepickerMouseEvents();
        });
    }
    /**
     * This method is used to set focus for active month
     */
    setActiveMonthFocus(newDate, isMoouseEvent) {
        const newMonth = months[newDate.getMonth()];
        // check for keyboard event
        if (!isMoouseEvent) {
            if (newDate.getFullYear() < this.activeDate.getFullYear()) {
                this.goToOtherMonthOryear('previous', 'month');
            }
            else if (newDate.getFullYear() > this.activeDate.getFullYear()) {
                this.goToOtherMonthOryear('next', 'month');
            }
        }
        setTimeout(() => {
            $(`.bs-datepicker-body table.months span:contains(${newMonth})`).focus();
            this.activeDate = newDate;
        });
    }
    /**
     * This method sets keyboard events for years
     */
    addKeyBoardEventsForYears() {
        $('.bs-datepicker-body').keydown((event) => {
            const action = this.keyEventPluginInstance.getEventFullKey(event);
            let newdate;
            if (action === 'arrowdown') {
                event.preventDefault();
                newdate = moment(this.activeDate).add(+4, 'year').toDate();
                this.setActiveYearFocus(newdate);
            }
            else if (action === 'arrowup') {
                event.preventDefault();
                newdate = moment(this.activeDate).add(-4, 'year').toDate();
                this.setActiveYearFocus(newdate);
            }
            else if (action === 'arrowleft') {
                newdate = moment(this.activeDate).add(-1, 'year').toDate();
                this.setActiveYearFocus(newdate);
            }
            else if (action === 'arrowright') {
                newdate = moment(this.activeDate).add(+1, 'year').toDate();
                this.setActiveYearFocus(newdate);
            }
            else if (action === 'control.arrowdown' || action === 'enter') {
                if ($(document.activeElement).parent().hasClass('disabled')) {
                    return;
                }
                $(document.activeElement).click();
                this.loadMonths();
                this.setActiveMonthFocus(this.activeDate);
            }
        });
    }
    /**
     * This method is used to set focus for active year
     */
    setActiveYearFocus(newDate, isMouseEvent) {
        const newYear = newDate.getFullYear();
        const datePickerYears = $('.bs-datepicker-body table.years span');
        const startYear = datePickerYears.first().text();
        const endYear = datePickerYears.last().text();
        // check for keyboard event
        if (!isMouseEvent) {
            if (newDate.getFullYear() < _.parseInt(startYear)) {
                this.goToOtherMonthOryear('previous', 'year');
            }
            else if (newDate.getFullYear() > _.parseInt(endYear)) {
                this.goToOtherMonthOryear('next', 'year');
            }
        }
        setTimeout(() => {
            $(`.bs-datepicker-body table.years span:contains(${newYear})`).focus();
            this.activeDate = newDate;
        });
    }
    /**
     * This method sets focus for timepicker first input field(hours field) while opening time picker
     * @param scope - scope of the time picker widget
     */
    focusTimePickerPopover(scope) {
        this.keyEventPluginInstance = scope.keyEventPlugin.constructor;
        this.elementScope = scope;
        // setTimeout is used so that by then time input has the updated value. focus is setting back to the input field
        this.elementScope.ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                $('timepicker .form-group:first > input.form-control').focus();
            });
        });
    }
    /**
     * This function sets the keyboard events to Timepicker popup
     */
    bindTimePickerKeyboardEvents() {
        setTimeout(() => {
            const $timepickerPopup = $('body').find('> bs-dropdown-container timepicker');
            $timepickerPopup.attr('tabindex', 0);
            this.addEventsOnTimePicker($timepickerPopup);
        });
    }
    /**
     * This function checks whether the given date is valid or not
     * @returns boolean value, true if date is valid else returns false
     */
    isValidDate(date) {
        return date && date instanceof Date && !isNaN(date.getTime());
    }
    /**
     * This function checks whether the given time is valid or not
     */
    timeFormatValidation() {
        const enteredDate = $(this.nativeElement).find('input').val();
        const newVal = getNativeDateObject(enteredDate);
        if (!this.formatValidation(newVal, enteredDate)) {
            return;
        }
        this.invalidDateTimeFormat = false;
        this.invokeOnChange(this.datavalue, undefined, false);
    }
    /**
     * This function sets the events to given element
     * @param $el - element on which the event is added
     */
    addEventsOnTimePicker($el) {
        $el.on('keydown', evt => {
            const $target = $(evt.target);
            const $parent = $target.parent();
            const elementScope = this.elementScope;
            const action = this.keyEventPluginInstance.getEventFullKey(evt);
            let stopPropogation, preventDefault;
            if (action === 'escape') {
                elementScope.hideTimepickerDropdown();
            }
            if ($target.hasClass('bs-timepicker-field')) {
                if ($parent.is(':first-child')) {
                    if (action === 'shift.tab' || action === 'enter' || action === 'escape') {
                        elementScope.setIsTimeOpen(false);
                        this.focus();
                        stopPropogation = true;
                        preventDefault = true;
                    }
                }
                else if ($parent.is(':last-child') || ($parent.next().next().find('button.disabled').length)) {
                    if (action === 'tab' || action === 'escape' || action === 'enter') {
                        elementScope.setIsTimeOpen(false);
                        this.focus();
                        stopPropogation = true;
                        preventDefault = true;
                    }
                }
                else {
                    if (action === 'enter' || action === 'escape') {
                        elementScope.setIsTimeOpen(false);
                        this.focus();
                        stopPropogation = true;
                        preventDefault = true;
                    }
                }
                if (stopPropogation) {
                    evt.stopPropagation();
                }
                if (preventDefault) {
                    evt.preventDefault();
                }
                if (elementScope.mintime && elementScope.maxtime && !this.isValidDate(elementScope.bsTimeValue)) {
                    if (action === 'arrowdown') {
                        elementScope.bsTimeValue = elementScope.maxTime;
                    }
                    else if (action === 'arrowup') {
                        elementScope.bsTimeValue = elementScope.minTime;
                    }
                }
                if (action === 'tab') {
                    this.invalidDateTimeFormat = false;
                    this.invokeOnChange(this.datavalue, undefined, false);
                    const pattern = this.datepattern || this.timepattern;
                    if (getFormattedDate(elementScope.datePipe, elementScope.bsTimeValue, pattern) === elementScope.displayValue) {
                        $(this.nativeElement).find('.display-input').val(elementScope.displayValue);
                    }
                }
                if (action === 'arrowdown' || action === 'arrowup') {
                    this.timeFormatValidation();
                }
            }
            else if ($target.hasClass('btn-default')) {
                if (action === 'tab' || action === 'escape') {
                    elementScope.setIsTimeOpen(false);
                    this.focus();
                }
            }
        });
        $el.find('a').on('click', evt => {
            const elementScope = this.elementScope;
            const $target = $(evt.target);
            if (elementScope.mintime && elementScope.maxtime && !this.isValidDate(elementScope.bsTimeValue)) {
                if ($target.find('span').hasClass('bs-chevron-down')) {
                    elementScope.bsTimeValue = elementScope.maxTime;
                }
                else if ($target.find('span').hasClass('bs-chevron-up')) {
                    elementScope.bsTimeValue = elementScope.minTime;
                }
            }
            this.timeFormatValidation();
        });
    }
    updateFormat(pattern) {
        if (pattern === 'datepattern') {
            this._dateOptions.dateInputFormat = this.datepattern;
            this.showseconds = _.includes(this.datepattern, 's');
            this.ismeridian = _.includes(this.datepattern, 'h');
        }
        else if (pattern === 'timepattern') {
            this.showseconds = _.includes(this.timepattern, 's');
            this.ismeridian = _.includes(this.timepattern, 'h');
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'tabindex') {
            return;
        }
        if (this.useDatapicker && key === 'datepattern') {
            this.updateFormat(key);
        }
        else if (key === 'showweeks') {
            this._dateOptions.showWeekNumbers = nv;
        }
        else if (key === 'mindate') {
            this._dateOptions.minDate = (nv === CURRENT_DATE) ? this.mindate = new Date() : getDateObj(nv);
            this.minDateMaxDateValidationOnInput(this.datavalue);
        }
        else if (key === 'maxdate') {
            this._dateOptions.maxDate = (nv === CURRENT_DATE) ? this.maxdate = new Date() : getDateObj(nv);
            this.minDateMaxDateValidationOnInput(this.datavalue);
        }
        else if (key === 'excludedates' || key === 'excludedays') {
            this.minDateMaxDateValidationOnInput(this.datavalue);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (this.bsDatePickerDirective) {
            this.dateOnShowSubscription = this.bsDatePickerDirective
                .onShown
                .subscribe(cal => {
                cal.daysCalendar.subscribe(data => {
                    let excludedDates;
                    if (this.excludedates) {
                        if (isString(this.excludedates)) {
                            excludedDates = _.split(this.excludedates, ',');
                        }
                        else {
                            excludedDates = this.excludedates;
                        }
                        excludedDates = excludedDates.map(d => moment(d));
                    }
                    data[0].weeks.forEach(week => {
                        week.days.forEach(day => {
                            if (!day.isDisabled && this.excludedays) {
                                day.isDisabled = _.includes(this.excludedays, day.dayIndex);
                            }
                            if (!day.isDisabled && excludedDates) {
                                const md = moment(day.date);
                                day.isDisabled = excludedDates.some(ed => md.isSame(ed, 'day'));
                            }
                        });
                    });
                });
            });
        }
    }
    ngOnDestroy() {
        if (this.dateOnShowSubscription) {
            this.dateOnShowSubscription.unsubscribe();
        }
        super.ngOnDestroy();
    }
}
BaseDateTimeComponent.propDecorators = {
    bsDropdown: [{ type: ViewChild, args: [BsDropdownDirective,] }]
};

const CURRENT_DATE$1 = 'CURRENT_DATE';
const DEFAULT_CLS$j = 'app-date input-group';
const WIDGET_CONFIG$n = {
    widgetType: 'wm-date',
    hostClass: DEFAULT_CLS$j
};
class DateComponent extends BaseDateTimeComponent {
    // TODO use BsLocaleService to set the current user's locale to see the localized labels
    constructor(inj, cdRef, appDefaults, evtMngrPlugins) {
        super(inj, WIDGET_CONFIG$n);
        this.cdRef = cdRef;
        this.appDefaults = appDefaults;
        this.isCurrentDate = false;
        this.isEnterPressedOnDateInput = false;
        styler(this.nativeElement, this);
        // KeyEventsPlugin
        this.keyEventPlugin = evtMngrPlugins[1];
        this.dateContainerCls = `app-date-${this.widgetId}`;
        this._dateOptions.containerClass = `app-date ${this.dateContainerCls}`;
        this._dateOptions.showWeekNumbers = false;
        this.datepattern = this.appDefaults.dateFormat || getDisplayDateTimeFormat(FormWidgetType.DATE);
        this.updateFormat('datepattern');
    }
    get timestamp() {
        return this.bsDataValue ? this.bsDataValue.valueOf() : undefined;
    }
    get displayValue() {
        return getFormattedDate(this.datePipe, this.bsDataValue, this._dateOptions.dateInputFormat) || '';
    }
    get datavalue() {
        return getFormattedDate(this.datePipe, this.bsDataValue, this.outputformat) || '';
    }
    // Todo[Shubham]: needs to be redefined
    // sets the dataValue and computes the display model values
    set datavalue(newVal) {
        if (newVal === CURRENT_DATE$1) {
            this.isCurrentDate = true;
            this.setTimeInterval();
            this.bsDataValue = new Date();
        }
        else {
            this.bsDataValue = newVal ? getDateObj(newVal) : undefined;
            this.clearTimeInterval();
        }
        // update the previous datavalue.
        this.invokeOnChange(this.datavalue, undefined, true);
        this.cdRef.detectChanges();
    }
    /**
     * This is an internal method triggered when the date input changes
     */
    onDisplayDateChange($event, isNativePicker) {
        if (this.isEnterPressedOnDateInput) {
            this.isEnterPressedOnDateInput = false;
            return;
        }
        const newVal = getDateObj($event.target.value);
        // date pattern validation
        // if invalid pattern is entered, device is showing an error.
        if (!this.formatValidation(newVal, $event.target.value, isNativePicker)) {
            return;
        }
        // min date and max date validation in mobile view.
        // if invalid dates are entered, device is showing an alert.
        if (isNativePicker && this.minDateMaxDateValidationOnInput(newVal, $event, this.displayValue, isNativePicker)) {
            return;
        }
        this.setDataValue(newVal);
    }
    // sets the dataValue and computes the display model values
    setDataValue(newVal) {
        this.invalidDateTimeFormat = false;
        // min date and max date validation in web.
        // if invalid dates are entered, device is showing validation message.
        this.minDateMaxDateValidationOnInput(newVal);
        if (getFormattedDate(this.datePipe, newVal, this._dateOptions.dateInputFormat) === this.displayValue) {
            $(this.nativeElement).find('.app-dateinput').val(this.displayValue);
        }
        if (newVal) {
            this.bsDataValue = newVal;
        }
        else {
            this.bsDataValue = undefined;
        }
        this.invokeOnChange(this.datavalue, {}, true);
    }
    onDatePickerOpen() {
        this.isOpen = true;
        this.bsDataValue ? this.activeDate = this.bsDataValue : this.activeDate = new Date();
        if (!this.bsDataValue) {
            this.hightlightToday();
        }
        this.addDatepickerKeyboardEvents(this, false);
        adjustContainerPosition($('bs-datepicker-container'), this.nativeElement, this.bsDatePickerDirective._datepicker);
    }
    onInputBlur($event) {
        if (!$($event.relatedTarget).hasClass('current-date')) {
            this.invokeOnTouched();
            this.invokeEventCallback('blur', { $event });
        }
    }
    hideDatepickerDropdown() {
        this.invokeOnTouched();
        this.isOpen = false;
        this.isEnterPressedOnDateInput = false;
        if (this.deregisterEventListener) {
            this.deregisterEventListener();
        }
    }
    // change and blur events are added from the template
    handleEvent(node, eventName, callback, locals) {
        if (!_.includes(['blur', 'focus', 'change', 'click'], eventName)) {
            super.handleEvent(node, eventName, callback, locals);
        }
    }
    /**
     * This is an internal method used to toggle the dropdown of the date widget
     */
    toggleDpDropdown($event) {
        if ($event.type === 'click') {
            this.invokeEventCallback('click', { $event: $event });
        }
        if ($event.target && $($event.target).is('input') && !(this.isDropDownDisplayEnabledOnInput(this.showdropdownon))) {
            $event.stopPropagation();
            return;
        }
        this.bsDatePickerDirective.toggle();
        this.addBodyClickListener(this.bsDatePickerDirective.isOpen);
    }
    addBodyClickListener(skipListener) {
        if (!skipListener) {
            return;
        }
        const bodyElement = document.querySelector('body');
        setTimeout(() => {
            const bsDateContainerElement = bodyElement.querySelector(`.${this.dateContainerCls}`);
            this.deregisterEventListener = addEventListenerOnElement(bodyElement, bsDateContainerElement, this.nativeElement, 'click', this.isDropDownDisplayEnabledOnInput(this.showdropdownon), () => {
                this.isOpen = false;
            }, 0 /* ONCE */, true);
        }, 350);
    }
    /**
     * This is an internal method triggered when pressing key on the date input
     */
    onDisplayKeydown(event) {
        if (this.isDropDownDisplayEnabledOnInput(this.showdropdownon)) {
            event.stopPropagation();
            const newVal = getDateObj(event.target.value);
            const action = this.keyEventPlugin.constructor.getEventFullKey(event);
            if (action === 'enter' || action === 'arrowdown') {
                event.preventDefault();
                const formattedDate = getFormattedDate(this.datePipe, newVal, this._dateOptions.dateInputFormat);
                const inputVal = event.target.value.trim();
                if (inputVal && this.datepattern === 'timestamp') {
                    if (!_.isNaN(inputVal) && _.parseInt(inputVal) !== formattedDate) {
                        this.invalidDateTimeFormat = true;
                        this.invokeOnChange(this.datavalue, event, false);
                    }
                }
                else if (inputVal && inputVal !== formattedDate) {
                    this.invalidDateTimeFormat = true;
                    this.invokeOnChange(this.datavalue, event, false);
                }
                else {
                    this.invalidDateTimeFormat = false;
                    this.isEnterPressedOnDateInput = true;
                    this.bsDatePickerDirective.bsValue = newVal;
                }
                this.toggleDpDropdown(event);
            }
            else {
                this.hideDatepickerDropdown();
            }
        }
        else {
            this.hideDatepickerDropdown();
        }
    }
    /**
     * This is an internal method used to maintain a time interval to update the time model when the data value is set to CURRENT_TIME
     */
    setTimeInterval() {
        if (this.timeinterval) {
            return;
        }
        this.timeinterval = setInterval(() => {
            this.bsDataValue = new Date();
        }, 1000 * 60);
    }
    /**
     * This is an internal method used to clear the time interval created
     */
    clearTimeInterval() {
        if (this.timeinterval) {
            clearInterval(this.timeinterval);
            this.timeinterval = null;
        }
    }
    /**
     * This is an internal method triggered when the date selection changes
     */
    onDateChange(newVal) {
        const displayInputElem = this.nativeElement.querySelector('.display-input');
        if (this.isOpen) {
            setTimeout(() => displayInputElem.focus());
        }
        this.setDataValue(newVal);
    }
}
DateComponent.initializeProps = registerProps$p();
DateComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmDate]',
                template: "<ng-container *ngIf=\"useDatapicker; then dataPickerTemplate else nativeDateTemplate\"></ng-container>\n<ng-template #dataPickerTemplate>\n    <input class=\"form-control app-textbox app-dateinput display-input\" aria-label=\"Select date\"\n           focus-target\n           type=\"text\"\n           [name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [value]=\"displayValue\"\n           (click)=\"toggleDpDropdown($event)\"\n           (focus)=\"invokeOnFocus($event)\"\n           (blur)=\"onInputBlur($event)\"\n           [disabled]=\"disabled || readonly\"\n           [autofocus]=\"autofocus\"\n           [required]=\"required\"\n           [attr.placeholder]=\"placeholder\"\n           [attr.accesskey]=\"shortcutkey\"\n           (change)=\"onDisplayDateChange($event)\"\n           (keydown)=\"onDisplayKeydown($event)\">\n    <div style=\"width: 0;display: inline-block;\" aria-label=\"datepicker dropdownmenu\" aria-controls=\"date\">\n        <input class=\"model-holder\"\n               container=\"body\"\n               [bsConfig]=\"_dateOptions\"\n               [isOpen]=\"isOpen\"\n               #datepicker=\"bsDatepicker\"\n               bsDatepicker\n               [isDisabled]=\"disabled || readonly\"\n               [bsValue]=\"bsDataValue\"\n               (onShown)=\"onDatePickerOpen()\"\n               (onHidden)=\"hideDatepickerDropdown()\"\n               (bsValueChange)=\"onDateChange($event)\">\n    </div>\n    <span class=\"input-group-btn\">\n            <button type=\"button\" class=\"btn btn-default btn-time\" [tabindex]=\"tabindex\" [disabled]=\"disabled || readonly\"\n                    aria-label=\"Select date\" aria-haspopup=\"true\" aria-expanded=\"false\"\n                    (click)=\"toggleDpDropdown($event)\">\n                <i aria-hidden=\"true\" class=\"app-icon wi wi-calendar\"></i>\n            </button>\n    </span>\n</ng-template>\n<ng-template #nativeDateTemplate>\n    <input type=\"date\" class=\"form-control app-textbox app-dateinput\"\n           role=\"input\"\n           step=\"any\"\n           [value]=\"displayValue\"\n           [required]=\"required\"\n           [disabled]=\"disabled || readonly\"\n           (change)=\"onDisplayDateChange($event, true)\"\n           (focus)=\"invokeOnFocus($event)\"\n           (blur)=\"invokeOnTouched($event)\">\n</ng-template>\n",
                providers: [
                    provideAsNgValueAccessor(DateComponent),
                    provideAsNgValidators(DateComponent),
                    provideAsWidgetRef(DateComponent)
                ]
            }] }
];
/** @nocollapse */
DateComponent.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: AppDefaults },
    { type: undefined, decorators: [{ type: Inject, args: [EVENT_MANAGER_PLUGINS,] }] }
];
DateComponent.propDecorators = {
    bsDatePickerDirective: [{ type: ViewChild, args: [BsDatepickerDirective,] }]
};

const dateTimeProps = new Map([
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['datepattern', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['excludedays', PROP_STRING],
    ['excludedates', PROP_STRING],
    ['hint', PROP_STRING],
    ['hourstep', Object.assign({ value: 1 }, PROP_NUMBER)],
    ['maxdate', PROP_STRING],
    ['mindate', PROP_STRING],
    ['minutestep', Object.assign({ value: 15 }, PROP_NUMBER)],
    ['name', PROP_STRING],
    ['outputformat', Object.assign({ value: 'timestamp' }, PROP_STRING)],
    ['placeholder', Object.assign({ value: 'Select date time' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['secondsstep', Object.assign({ value: 1 }, PROP_NUMBER)],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showdropdownon', Object.assign({ value: 'default' }, PROP_STRING)],
    ['showbuttonbar', PROP_BOOLEAN],
    ['showindevice', Object.assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
    ['showweeks', PROP_BOOLEAN],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['timestamp', PROP_STRING]
]);
const registerProps$q = () => {
    if (isMobileApp()) {
        dateTimeProps.set('datepattern', Object.assign({ value: 'yyyy-MM-ddTHH:mm:ss' }, PROP_STRING));
    }
    register('wm-datetime', dateTimeProps);
};

const DEFAULT_CLS$k = 'app-datetime input-group';
const WIDGET_CONFIG$o = { widgetType: 'wm-datetime', hostClass: DEFAULT_CLS$k };
const CURRENT_DATE$2 = 'CURRENT_DATE';
class DatetimeComponent extends BaseDateTimeComponent {
    constructor(inj, ngZone, cdRef, appDefaults, evtMngrPlugins) {
        super(inj, WIDGET_CONFIG$o);
        this.ngZone = ngZone;
        this.cdRef = cdRef;
        this.appDefaults = appDefaults;
        this.isEnterPressedOnDateInput = false;
        /**
         * This property checks if the timePicker is Open
         */
        this.isTimeOpen = false;
        /**
         * This property checks if the datePicker is Open
         */
        this.isDateOpen = false;
        /**
         * This property is set to TRUE if the time component value is set to CURRENT_TIME; In this case the timer keeps changing the time value until the widget is available.
         */
        this.isCurrentDate = false;
        this._debouncedOnChange = _.debounce(this.invokeOnChange, 10);
        this.registerDestroyListener(() => this.clearTimeInterval());
        styler(this.nativeElement, this);
        // KeyEventsPlugin
        this.keyEventPlugin = evtMngrPlugins[1];
        this.dateContainerCls = `app-date-${this.widgetId}`;
        this._dateOptions.containerClass = `app-date ${this.dateContainerCls}`;
        this._dateOptions.showWeekNumbers = false;
        this.datepattern = this.appDefaults.dateTimeFormat || getDisplayDateTimeFormat(FormWidgetType.DATETIME);
        this.updateFormat('datepattern');
    }
    get timestamp() {
        return this.proxyModel ? this.proxyModel.valueOf() : undefined;
    }
    /**
     * The displayValue is the display value of the bsDateTimeValue after applying the datePattern on it.
     * @returns {any|string}
     */
    get displayValue() {
        return getFormattedDate(this.datePipe, this.proxyModel, this._dateOptions.dateInputFormat) || '';
    }
    get datavalue() {
        if (this.isCurrentDate && !this.proxyModel) {
            return CURRENT_DATE$2;
        }
        return getFormattedDate(this.datePipe, this.proxyModel, this.outputformat);
    }
    /**Todo[Shubham]: needs to be redefined
     * This property sets the default value for the date selection
     */
    set datavalue(newVal) {
        if (newVal === CURRENT_DATE$2) {
            this.isCurrentDate = true;
            this.setTimeInterval();
        }
        else {
            this.proxyModel = newVal ? getDateObj(newVal) : undefined;
            this.clearTimeInterval();
            this.isCurrentDate = false;
        }
        this.bsTimeValue = this.bsDateValue = this.proxyModel;
        this.cdRef.detectChanges();
    }
    /**
     * This is an internal method used to maintain a time interval to update the time model when the data value is set to CURRENT_TIME
     */
    setTimeInterval() {
        if (this.timeinterval) {
            return;
        }
        this.timeinterval = setInterval(() => {
            const currentTime = new Date();
            this.onModelUpdate(currentTime);
        }, 1000);
    }
    /**
     * This is an internal method used to clear the time interval created
     */
    clearTimeInterval() {
        if (this.timeinterval) {
            clearInterval(this.timeinterval);
            this.timeinterval = null;
        }
    }
    /**
     * This is an internal method to toggle the time picker
     */
    toggleTimePicker(newVal, $event) {
        this.isTimeOpen = newVal;
        if ($event && $event.type === 'click') {
            this.invokeEventCallback('click', { $event: $event });
        }
        this.addTimepickerClickListener(this.isTimeOpen);
    }
    addTimepickerClickListener(skipListener) {
        if (!skipListener) {
            return;
        }
        const bodyElement = document.querySelector('body');
        setTimeout(() => {
            const dropdownElement = $(bodyElement).find('>bs-dropdown-container .dropdown-menu').get(0);
            this.deregisterTimepickeEventListener = addEventListenerOnElement(bodyElement, dropdownElement, this.nativeElement, 'click', this.isDropDownDisplayEnabledOnInput(this.showdropdownon), () => {
                this.toggleTimePicker(false);
            }, 0 /* ONCE */, true);
        }, 350);
    }
    /**
     * This function sets the value isOpen/isTimeOpen (i.e when datepicker popup is closed) based on widget type(i.e  DateTime, Time)
     * @param val - isOpen/isTimeOpen is set based on the timepicker popup is open/closed
     */
    setIsTimeOpen(val) {
        this.isTimeOpen = val;
    }
    hideTimepickerDropdown() {
        this.invokeOnTouched();
        this.toggleTimePicker(false);
        if (this.deregisterTimepickeEventListener) {
            this.deregisterTimepickeEventListener();
        }
    }
    /**
     * This is an internal method to add a click listener once the time dropdown is open
     */
    onTimepickerOpen() {
        // adding class for time widget dropdown menu
        const tpElements = document.querySelectorAll('timepicker');
        _.forEach(tpElements, (element) => {
            addClass(element.parentElement, 'app-datetime', true);
        });
        this.bsDatePickerDirective.hide();
        this.focusTimePickerPopover(this);
        this.bindTimePickerKeyboardEvents();
        adjustContainerPosition($('bs-dropdown-container'), this.nativeElement, this.bsDropdown._dropdown, $('bs-dropdown-container .dropdown-menu'));
    }
    onDatePickerOpen() {
        this.isDateOpen = !this.isDateOpen;
        this.toggleTimePicker(false);
        this.bsDateValue ? this.activeDate = this.bsDateValue : this.activeDate = new Date();
        if (!this.bsDateValue) {
            this.hightlightToday();
        }
        this.addDatepickerKeyboardEvents(this, true);
        adjustContainerPosition($('bs-datepicker-container'), this.nativeElement, this.bsDatePickerDirective._datepicker);
    }
    /**
     * This is an internal method to update the model
     */
    onModelUpdate(newVal, type) {
        if (type === 'date') {
            this.invalidDateTimeFormat = false;
            if (getFormattedDate(this.datePipe, newVal, this._dateOptions.dateInputFormat) === this.displayValue) {
                $(this.nativeElement).find('.display-input').val(this.displayValue);
            }
        }
        // min date and max date validation in web.
        // if invalid dates are entered, device is showing validation message.
        this.minDateMaxDateValidationOnInput(newVal);
        if (!newVal) {
            // Set timevalue as 00:00:00 if we remove any one from hours/minutes/seconds field in timepicker after selecting date
            if (this.bsDateValue && this.bsTimePicker && (this.bsTimePicker.hours === '' || this.bsTimePicker.minutes === '' || this.bsTimePicker.seconds === '')) {
                this.bsDateValue = this.bsTimeValue = this.proxyModel = moment(this.bsDateValue).startOf('day').toDate();
            }
            else {
                this.bsDateValue = this.bsTimeValue = this.proxyModel = undefined;
            }
            this._debouncedOnChange(this.datavalue, {}, true);
            return;
        }
        if (type === 'date') {
            if (this.isDateOpen) {
                this.toggleTimePicker(true);
            }
        }
        this.proxyModel = newVal;
        if (this.proxyModel) {
            this.bsDateValue = this.bsTimeValue = this.proxyModel;
        }
        this._debouncedOnChange(this.datavalue, {}, true);
        this.cdRef.detectChanges();
    }
    /**
     * This is an internal method used to Prevent time picker close while changing time value
     */
    preventTpClose($event) {
        $event.stopImmediatePropagation();
    }
    /**
     * This is an internal method used to toggle the dropdown of the date widget
     */
    toggleDpDropdown($event) {
        if ($event.type === 'click') {
            this.invokeEventCallback('click', { $event: $event });
        }
        if ($event.target && $($event.target).is('input') && !(this.isDropDownDisplayEnabledOnInput(this.showdropdownon))) {
            $event.stopPropagation();
            return;
        }
        this.bsDatePickerDirective.toggle();
        this.addBodyClickListener(this.bsDatePickerDirective.isOpen);
    }
    addBodyClickListener(skipListener) {
        if (!skipListener) {
            return;
        }
        const bodyElement = document.querySelector('body');
        setTimeout(() => {
            const bsDateContainerElement = bodyElement.querySelector(`.${this.dateContainerCls}`);
            this.deregisterDatepickerEventListener = addEventListenerOnElement(bodyElement, bsDateContainerElement, this.nativeElement, 'click', this.isDropDownDisplayEnabledOnInput(this.showdropdownon), () => {
                this.bsDatePickerDirective.hide();
            }, 0 /* ONCE */, true);
        }, 350);
    }
    hideDatepickerDropdown() {
        this.isDateOpen = false;
        this.invokeOnTouched();
        this.bsDatePickerDirective.hide();
        this.isEnterPressedOnDateInput = false;
        if (this.deregisterDatepickerEventListener) {
            this.deregisterDatepickerEventListener();
        }
    }
    onDateChange($event, isNativePicker) {
        if (this.isEnterPressedOnDateInput) {
            this.isEnterPressedOnDateInput = false;
            return;
        }
        let newVal = $event.target.value.trim();
        newVal = newVal ? getNativeDateObject(newVal) : undefined;
        // datetime pattern validation
        // if invalid pattern is entered, device is showing an error.
        if (!this.formatValidation(newVal, $event.target.value, isNativePicker)) {
            return;
        }
        // min date and max date validation in mobile view.
        // if invalid dates are entered, device is showing an alert.
        if (isNativePicker && this.minDateMaxDateValidationOnInput(newVal, $event, this.displayValue, isNativePicker)) {
            return;
        }
        this.invalidDateTimeFormat = false;
        this.onModelUpdate(newVal);
    }
    /**
     * This is an internal method triggered when pressing key on the datetime input
     */
    onDisplayKeydown(event) {
        if (this.isDropDownDisplayEnabledOnInput(this.showdropdownon)) {
            event.stopPropagation();
            let newVal = event.target.value.trim();
            newVal = newVal ? getNativeDateObject(newVal) : undefined;
            const action = this.keyEventPlugin.constructor.getEventFullKey(event);
            if (action === 'enter' || action === 'arrowdown') {
                event.preventDefault();
                const formattedDate = getFormattedDate(this.datePipe, newVal, this._dateOptions.dateInputFormat);
                const inputVal = event.target.value.trim();
                if (inputVal && this.datepattern === 'timestamp') {
                    if (!_.isNaN(inputVal) && _.parseInt(inputVal) !== formattedDate) {
                        this.invalidDateTimeFormat = true;
                        this.invokeOnChange(this.datavalue, event, false);
                    }
                }
                else if (inputVal && inputVal !== formattedDate) {
                    this.invalidDateTimeFormat = true;
                    this.invokeOnChange(this.datavalue, event, false);
                }
                else {
                    this.invalidDateTimeFormat = false;
                    this.isEnterPressedOnDateInput = true;
                    this.bsDatePickerDirective.bsValue = newVal;
                }
                this.toggleDpDropdown(event);
            }
            else {
                this.hideDatepickerDropdown();
                this.hideTimepickerDropdown();
            }
        }
        else {
            this.hideDatepickerDropdown();
            this.hideTimepickerDropdown();
        }
    }
    isValid(event) {
        if (!event) {
            const enteredDate = $(this.nativeElement).find('input').val();
            const newVal = getNativeDateObject(enteredDate);
            if (!this.formatValidation(newVal, enteredDate)) {
                return;
            }
        }
    }
    // change and blur events are added from the template
    handleEvent(node, eventName, callback, locals) {
        if (!_.includes(['blur', 'focus', 'change', 'click'], eventName)) {
            super.handleEvent(node, eventName, callback, locals);
        }
    }
    onInputBlur($event) {
        if (!$($event.relatedTarget).hasClass('current-date')) {
            this.invokeOnTouched();
            this.invokeEventCallback('blur', { $event });
        }
    }
}
DatetimeComponent.initializeProps = registerProps$q();
DatetimeComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmDateTime]',
                template: "<ng-container *ngIf=\"useDatapicker; then dataPickerTemplate else nativeDateTemplate\"></ng-container>\n\n<ng-template #dataPickerTemplate>\n    <div dropdown [isOpen]=\"isTimeOpen\" autoClose=\"false\" [container]=\"'body'\" (onShown)=\"onTimepickerOpen()\"\n         style=\"display: inherit;\">\n        <input class=\"form-control app-textbox display-input\" aria-label=\"Set the date and time\"\n               focus-target\n               [name]=\"name\"\n               [tabindex]=\"tabindex\"\n               type=\"text\"\n               [value]=\"displayValue\"\n               (click)=\"toggleDpDropdown($event)\"\n               (focus)=\"invokeOnFocus($event)\"\n               (blur)=\"onInputBlur($event)\"\n               (change)=\"onDateChange($event)\"\n               [autofocus]=\"autofocus\"\n               [disabled]=\"disabled || readonly || isCurrentDate\"\n               [required]=\"required\"\n               [attr.placeholder]=\"placeholder\"\n               [attr.accesskey]=\"shortcutkey\"\n               (keydown)=\"onDisplayKeydown($event)\">\n        <div style=\"width: 0;display: inline-block;\" aria-label=\"datepicker dropdownmenu\" aria-controls=\"date\">\n            <input class=\"model-holder\"\n                   focus-target\n                   [container]=\"'body'\"\n                   [bsConfig]=\"_dateOptions\"\n                   [isOpen]=\"isDateOpen\"\n                   (onShown)=\"onDatePickerOpen()\"\n                   (onHidden)=\"hideDatepickerDropdown()\"\n                   #datepicker=bsDatepicker\n                   bsDatepicker\n                   [isDisabled]=\"disabled || readonly || isCurrentDate\"\n                   [bsValue]=\"bsDateValue\"\n                   (bsValueChange)=\"onModelUpdate($event, 'date')\">\n        </div>\n        <span class=\"input-group-btn\">\n            <button type=\"button\" class=\"btn btn-default btn-date\"\n                    [tabindex]=\"tabindex\" [disabled]=\"disabled || readonly || isCurrentDate\" aria-label=\"Select date\" aria-haspopup=\"true\"\n                    aria-expanded=\"false\" (click)=\"toggleDpDropdown($event)\">\n                <i aria-hidden=\"true\" class=\"app-icon wi wi-calendar\"></i>\n            </button>\n            <button type=\"button\" class=\"btn btn-default btn-time\"\n                    [tabindex]=\"tabindex\" [disabled]=\"disabled || readonly || isCurrentDate\" aria-label=\"Select time\" aria-haspopup=\"true\"\n                    aria-expanded=\"false\" (click)=\"toggleTimePicker(!isTimeOpen, $event)\">\n                <i aria-hidden=\"true\" class=\"app-icon wi wi-access-time\"></i>\n            </button>\n        </span>\n        <div *dropdownMenu class=\"dropdown-menu\" aria-label=\"timepicker dropdown\" aria-controls=\"time\"\n             (click)=\"preventTpClose($event)\">\n            <timepicker class=\"model-holder\"\n                        [showMeridian]=\"ismeridian\"\n                        [readonlyInput]=\"disabled || readonly || isCurrentDate\"\n                        [(ngModel)]=\"bsTimeValue\"\n                        [min]=\"minTime\"\n                        [max]=\"maxTime\"\n                        [hourStep]=\"hourstep\"\n                        [minuteStep]=\"minutestep\"\n                        [secondsStep]=\"secondsstep\"\n                        [mousewheel]=\"true\"\n                        [arrowkeys]=\"true\"\n                        (isValid)=\"isValid($event)\"\n                        [showSeconds]=\"showseconds\" (ngModelChange)=\"onModelUpdate($event, 'time')\"></timepicker>\n        </div>\n    </div>\n</ng-template>\n<ng-template #nativeDateTemplate>\n    <input type=\"datetime-local\" class=\"form-control app-textbox\"\n           role=\"input\"\n           step=\"any\"\n           [value]=\"displayValue\"\n           [required]=\"required\"\n           [disabled]=\"disabled || readonly || isCurrentDate\"\n           (change)=\"onDateChange($event, true)\">\n</ng-template>\n",
                providers: [
                    provideAsNgValueAccessor(DatetimeComponent),
                    provideAsNgValidators(DatetimeComponent),
                    provideAsWidgetRef(DatetimeComponent)
                ]
            }] }
];
/** @nocollapse */
DatetimeComponent.ctorParameters = () => [
    { type: Injector },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: AppDefaults },
    { type: undefined, decorators: [{ type: Inject, args: [EVENT_MANAGER_PLUGINS,] }] }
];
DatetimeComponent.propDecorators = {
    bsDatePickerDirective: [{ type: ViewChild, args: [BsDatepickerDirective,] }],
    bsTimePicker: [{ type: ViewChild, args: [TimepickerComponent,] }]
};

const propsMap = new Map([
    ['autocomplete', Object.assign({ value: false }, PROP_BOOLEAN)],
    ['captionalign', Object.assign({ value: 'left' }, PROP_STRING)],
    ['captionposition', Object.assign({ value: 'left' }, PROP_STRING)],
    ['captionsize', PROP_STRING],
    ['captionwidth', Object.assign({ value: 'xs-12 sm-3 md-3 lg-3' }, PROP_STRING)],
    ['class', PROP_STRING],
    ['collapsible', PROP_BOOLEAN],
    ['dataset', PROP_ANY],
    ['datasource', PROP_STRING],
    ['expanded', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['formdatasource', PROP_STRING],
    ['name', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showindevice', Object.assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
    ['subheading', PROP_STRING],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['title', PROP_STRING]
]);
const registerFormProps = () => {
    if (isMobileApp()) {
        propsMap.set('captionwidth', Object.assign({ value: 'xs-4 sm-4 md-4 lg-4' }, PROP_STRING));
    }
    const formMap = new Map(propsMap);
    formMap.set('action', PROP_STRING);
    formMap.set('defaultmode', Object.assign({ value: 'Edit' }, PROP_STRING));
    formMap.set('metadata', PROP_STRING);
    formMap.set('method', PROP_STRING);
    formMap.set('postmessage', Object.assign({ value: 'Data posted successfully' }, PROP_STRING));
    formMap.set('target', PROP_STRING);
    formMap.set('enctype', PROP_STRING);
    formMap.set('errormessage', Object.assign({ value: 'An error occured. Please try again!' }, PROP_STRING));
    formMap.set('messagelayout', Object.assign({ value: 'Inline' }, PROP_STRING));
    formMap.set('formdata', PROP_STRING);
    formMap.set('novalidate', PROP_BOOLEAN);
    formMap.set('validationtype', Object.assign({ value: 'default' }, PROP_STRING));
    formMap.set('iconclass', PROP_STRING);
    register('wm-form', formMap);
};
const registerLiveFormProps = () => {
    if (isMobileApp()) {
        propsMap.set('captionwidth', Object.assign({ value: 'xs-4 sm-4 md-4 lg-4' }, PROP_STRING));
    }
    const liveFormMap = new Map(propsMap);
    liveFormMap.set('defaultmode', Object.assign({ value: 'View' }, PROP_STRING));
    liveFormMap.set('formlayout', Object.assign({ value: 'inline' }, PROP_STRING));
    liveFormMap.set('insertmessage', Object.assign({ value: 'Record added successfully' }, PROP_STRING));
    liveFormMap.set('updatemessage', Object.assign({ value: 'Record updated successfully' }, PROP_STRING));
    liveFormMap.set('deletemessage', Object.assign({ value: 'Record deleted successfully' }, PROP_STRING));
    liveFormMap.set('errormessage', Object.assign({ value: 'An error occured. Please try again!' }, PROP_STRING));
    liveFormMap.set('messagelayout', Object.assign({ value: 'Toaster' }, PROP_STRING));
    liveFormMap.set('formdata', PROP_STRING);
    liveFormMap.set('novalidate', PROP_BOOLEAN);
    liveFormMap.set('validationtype', Object.assign({ value: 'default' }, PROP_STRING));
    liveFormMap.set('iconclass', PROP_STRING);
    register('wm-liveform', liveFormMap);
};
const registerLiveFilterProps = () => {
    if (isMobileApp()) {
        propsMap.set('captionwidth', Object.assign({ value: 'xs-4 sm-4 md-4 lg-4' }, PROP_STRING));
    }
    const liveFilterMap = new Map(propsMap);
    liveFilterMap.set('autoupdate', PROP_BOOLEAN);
    liveFilterMap.set('enableemptyfilter', Object.assign({ value: ' ' }, PROP_STRING));
    liveFilterMap.set('pagesize', Object.assign({ value: 20 }, PROP_NUMBER));
    liveFilterMap.set('iconclass', Object.assign({ value: 'wi wi-filter-list' }, PROP_STRING));
    register('wm-livefilter', liveFilterMap);
};

const VIEW_MODE_OPTIONS = {
    DEFAULT: 'default',
    LABEL: 'label'
};
const EDIT_MODE = {
    QUICK_EDIT: 'quickedit',
    INLINE: 'inline',
    FORM: 'form',
    DIALOG: 'dialog'
};
// Method to set the header config of the data table
const setHeaderConfig = (headerConfig, config, field) => {
    _.forEach(headerConfig, cols => {
        if (cols.isGroup) {
            if (cols.field === field) {
                cols.columns.push(config);
            }
            else {
                setHeaderConfig(cols.columns, config, field);
            }
        }
    });
};
const setHeaderConfigForTable = (headerConfig, config, fieldName) => {
    if (fieldName) {
        setHeaderConfig(headerConfig, config, fieldName);
    }
    else {
        headerConfig.push(config);
    }
};
const getRowOperationsColumn = () => {
    return {
        'field': 'rowOperations',
        'type': 'custom',
        'displayName': 'Actions',
        'width': '120px',
        'readonly': true,
        'sortable': false,
        'searchable': false,
        'resizable': false,
        'selectable': false,
        'show': true,
        'operations': [],
        'opConfig': {},
        'pcDisplay': true,
        'mobileDisplay': true,
        'include': true,
        'isRowOperation': true
    };
};
/**
 * Returns caption and widget bootstrap classes for the field
 */
const getFieldLayoutConfig = (captionWidth, captionPosition, os) => {
    let captionCls = '', widgetCls = '';
    captionPosition = captionPosition || 'top';
    if (captionPosition === 'top') {
        if ((os && os === 'android') || !isMobileApp() || isAndroid()) { // Is android or not a mobile application
            captionCls = widgetCls = 'col-xs-12';
        }
        else if (isMobileApp()) { // Is a mobile application and not android
            captionCls = 'col-xs-4';
            widgetCls = 'col-xs-8';
        }
    }
    else if (captionWidth) {
        // handling itemsperrow containing string of classes
        _.forEach(_.split(captionWidth, ' '), function (cls) {
            const keys = _.split(cls, '-'), tier = keys[0];
            let _captionWidth, widgetWidth;
            _captionWidth = parseInt(keys[1], 10);
            widgetWidth = 12 - _captionWidth;
            widgetWidth = widgetWidth <= 0 ? 12 : widgetWidth;
            captionCls += ' ' + 'col-' + tier + '-' + _captionWidth;
            widgetCls += ' ' + 'col-' + tier + '-' + widgetWidth;
        });
    }
    return {
        'captionCls': captionCls,
        'widgetCls': widgetCls
    };
};
const getDefaultViewModeWidget = widget => {
    if (_.includes(['checkbox', 'toggle', 'rating'], widget)) {
        return VIEW_MODE_OPTIONS.DEFAULT;
    }
    return VIEW_MODE_OPTIONS.LABEL;
};
const parseBooleanValue = value => {
    if (value === 'true') {
        return true;
    }
    if (value === 'false') {
        return false;
    }
    if (/^\d+$/.test(value)) { // Check if the value is a string of number type like '123'
        return +value;
    }
    return value;
};
const parseValueByType = (value, type, widget) => {
    if (widget) {
        if (widget === FormWidgetType.NUMBER || widget === FormWidgetType.SLIDER || widget === FormWidgetType.CURRENCY) {
            return isNaN(Number(value)) ? null : Number(value);
        }
        if (widget === FormWidgetType.CHECKBOX || widget === FormWidgetType.TOGGLE) {
            return parseBooleanValue(value);
        }
        return value;
    }
    if (isNumberType(type)) {
        return isNaN(Number(value)) ? null : Number(value);
    }
    if (type === DataType.BOOLEAN) {
        return parseBooleanValue(value);
    }
    return value;
};
const fieldTypeWidgetTypeMap = {
    'integer': ['number', 'text', 'select', 'checkboxset', 'radioset', 'rating', 'slider', 'currency', 'autocomplete', 'chips'],
    'big_integer': ['number', 'text', 'select', 'checkboxset', 'radioset', 'rating', 'slider', 'currency', 'autocomplete', 'chips'],
    'short': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
    'float': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
    'big_decimal': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
    'number': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
    'double': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
    'long': ['number', 'text', 'select', 'checkboxset', 'radioset', 'rating', 'slider', 'currency', 'autocomplete', 'chips'],
    'byte': ['number', 'text', 'select', 'checkboxset', 'radioset', 'slider', 'currency', 'autocomplete', 'chips'],
    'string': ['text', 'number', 'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp', 'switch', 'currency', 'autocomplete', 'chips', 'colorpicker'],
    'character': ['text', 'number', 'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset', 'switch', 'currency', 'autocomplete', 'chips'],
    'text': ['text', 'number', 'textarea', 'password', 'richtext', 'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp', 'switch', 'currency', 'autocomplete', 'chips', 'colorpicker'],
    'date': ['date', 'text', 'number', 'select', 'checkboxset', 'radioset', 'autocomplete', 'chips'],
    'time': ['time', 'text', 'number', 'select', 'checkboxset', 'radioset', 'autocomplete', 'chips'],
    'timestamp': ['timestamp', 'text', 'number', 'select', 'checkboxset', 'radioset', 'autocomplete', 'chips'],
    'datetime': ['datetime', 'text', 'select', 'checkboxset', 'radioset', 'autocomplete', 'chips'],
    'boolean': ['checkbox', 'radioset', 'toggle', 'select'],
    'list': ['select', 'radioset', 'checkboxset', 'switch', 'autocomplete', 'chips'],
    'clob': ['text', 'textarea', 'richtext'],
    'blob': ['upload'],
    'file': ['upload'],
    'custom': ['text', 'number', 'textarea', 'password', 'checkbox', 'toggle', 'slider', 'richtext', 'currency', 'switch',
        'select', 'checkboxset', 'radioset', 'date', 'time', 'timestamp', 'rating', 'datetime', 'autocomplete', 'chips', 'colorpicker']
};
// Get filter widget applicable to the given type
const getDataTableFilterWidget = type => {
    let widget = fieldTypeWidgetTypeMap[type] && fieldTypeWidgetTypeMap[type][0];
    if (type === DataType.BOOLEAN) {
        widget = FormWidgetType.SELECT;
    }
    if (_.includes([FormWidgetType.TEXT, FormWidgetType.NUMBER, FormWidgetType.SELECT, FormWidgetType.AUTOCOMPLETE,
        FormWidgetType.DATE, FormWidgetType.TIME, FormWidgetType.DATETIME], widget)) {
        return widget;
    }
    return FormWidgetType.TEXT;
};
/**
 * @ngdoc function
 * @name wm.widgets.live.getEditModeWidget
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * This function returns the default widget for grid
 *
 * @param {object} colDef field definition
 */
const getEditModeWidget = colDef => {
    if (colDef['related-entity-name'] && colDef['primary-key']) {
        return FormWidgetType.SELECT;
    }
    return (fieldTypeWidgetTypeMap[colDef.type] && fieldTypeWidgetTypeMap[colDef.type][0]) || FormWidgetType.TEXT;
};
/**
 * @ngdoc function
 * @name wm.widgets.live.LiveWidgetUtils#getDefaultValue
 * @methodOf wm.widgets.live.LiveWidgetUtils
 * @function
 *
 * @description
 * return the formatted default value
 *
 * @param {string} value value to be formatted
 * @param {string} type column type of the value
 */
const getDefaultValue = (value, type, widget) => {
    if (widget) {
        if (widget === FormWidgetType.NUMBER || widget === FormWidgetType.SLIDER || widget === FormWidgetType.CURRENCY) {
            return isNaN(Number(value)) ? null : Number(value);
        }
        if (widget === FormWidgetType.CHECKBOX || widget === FormWidgetType.TOGGLE) {
            return parseBooleanValue(value);
        }
        return value;
    }
    if (isNumberType(type)) {
        return isNaN(Number(value)) ? null : Number(value);
    }
    if (type === DataType.BOOLEAN) {
        return parseBooleanValue(value);
    }
    return value;
};

const registerProps$r = () => {
    register('wm-message', new Map([
        ['caption', Object.assign({ value: 'Message' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['hideclose', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['type', Object.assign({ value: 'success' }, PROP_STRING)],
    ]));
};

const DEFAULT_CLS$l = 'alert app-message';
const WIDGET_CONFIG$p = { widgetType: 'wm-message', hostClass: DEFAULT_CLS$l };
class MessageComponent extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$p);
        this.messageClass = '';
        this.messageIconClass = '';
        this.type = '';
        styler(this.nativeElement, this);
    }
    showMessage(caption, type) {
        if (caption) {
            this.caption = caption;
        }
        if (type) {
            this.setWidgetProperty('type', type);
        }
        this.setWidgetProperty('show', true);
    }
    hideMessage() {
        this.setWidgetProperty('show', false);
    }
    dismiss($event) {
        this.hideMessage();
        this.invokeEventCallback('close', { $event });
    }
    onMessageTypeChange(nv) {
        let msgCls, msgIconCls;
        switch (nv) {
            case 'success':
                msgCls = 'alert-success';
                msgIconCls = 'wi wi-done';
                break;
            case 'error':
                msgCls = 'alert-danger';
                msgIconCls = 'wi wi-cancel';
                break;
            case 'warn': /*To support old projects with type as "warn"*/
            case 'warning':
                msgCls = 'alert-warning';
                msgIconCls = 'wi wi-bell';
                break;
            case 'info':
                msgCls = 'alert-info';
                msgIconCls = 'wi wi-info';
                break;
            case 'loading':
                msgCls = 'alert-info alert-loading';
                msgIconCls = 'fa fa-spinner fa-spin';
                break;
        }
        switchClass(this.nativeElement, msgCls, this.messageClass);
        this.messageClass = msgCls;
        this.messageIconClass = msgIconCls;
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'type') {
            this.onMessageTypeChange(nv);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
MessageComponent.initializeProps = registerProps$r();
MessageComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmMessage]',
                template: "<i [title]=\"type + 'Alert'\" class=\"icon {{type}} {{messageIconClass}}\"></i>\n<span [innerHtml]=\"caption | trustAs: 'html'\"></span>\n<button title=\"Close\" type=\"button\" class=\"btn-transparent close\" [hidden]=\"hideclose\" (click)=\"dismiss($event)\" aria-label=\"Close\">\n    <span aria-hidden=\"true\">&times;</span>\n</button>",
                providers: [
                    provideAsWidgetRef(MessageComponent)
                ]
            }] }
];
/** @nocollapse */
MessageComponent.ctorParameters = () => [
    { type: Injector }
];

const registerProps$s = () => {
    register('wm-list', new Map([
        ['boundarylinks', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['class', PROP_STRING],
        ['collapsible', PROP_BOOLEAN],
        ['dateformat', PROP_STRING],
        ['dataset', PROP_ANY],
        ['datasource', PROP_ANY],
        ['directionlinks', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['disableitem', PROP_BOOLEAN],
        ['enablereorder', PROP_BOOLEAN],
        ['forceellipses', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['groupby', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['itemclass', Object.assign({ value: '' }, PROP_STRING)],
        ['itemsperrow', PROP_STRING],
        ['listclass', Object.assign({ value: 'list-group' }, PROP_STRING)],
        ['multiselect', PROP_BOOLEAN],
        ['loadingdatamsg', Object.assign({ value: 'Loading...' }, PROP_STRING)],
        ['loadingicon', Object.assign({ value: 'fa fa-circle-o-notch' }, PROP_STRING)],
        ['match', PROP_STRING],
        ['maxsize', Object.assign({ value: 5 }, PROP_NUMBER)],
        ['name', PROP_STRING],
        ['navigation', PROP_STRING],
        ['navigationalign', Object.assign({ value: 'left' }, PROP_STRING)],
        ['nodatamessage', Object.assign({ value: 'No data found' }, PROP_STRING)],
        ['ondemandmessage', Object.assign({ value: 'Load More' }, PROP_STRING)],
        ['orderby', PROP_STRING],
        ['paginationclass', PROP_STRING],
        ['pagesize', PROP_NUMBER],
        ['pulltorefresh', Object.assign({ value: isMobileApp() }, PROP_BOOLEAN)],
        ['selectfirstitem', PROP_BOOLEAN],
        ['selectionlimit', PROP_NUMBER],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showcount', PROP_BOOLEAN],
        ['showrecordcount', PROP_BOOLEAN],
        ['subheading', PROP_STRING],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', PROP_STRING]
    ]));
};

const registerProps$t = () => {
    register('wm-pagination', new Map([
        ['boundarylinks', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['class', PROP_STRING],
        ['dataset', PROP_ANY],
        ['directionlinks', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['forceellipses', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['maxResults', PROP_NUMBER],
        ['maxsize', Object.assign({ value: 5 }, PROP_NUMBER)],
        ['name', PROP_STRING],
        ['navigation', Object.assign({ value: 'Basic' }, PROP_STRING)],
        ['navigationalign', Object.assign({ value: 'left' }, PROP_STRING)],
        ['navigationsize', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showrecordcount', PROP_BOOLEAN],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)]
    ]));
};

const DEFAULT_CLS$m = 'app-datanavigator clearfix';
const WIDGET_CONFIG$q = { widgetType: 'wm-pagination', hostClass: DEFAULT_CLS$m };
const sizeClasses = {
    'Pager': {
        'small': 'pager-sm',
        'large': 'pager-lg'
    },
    'Basic': {
        'small': 'pagination-sm',
        'large': 'pagination-lg'
    },
    'Classic': {
        'small': 'pagination-sm',
        'large': 'pagination-lg'
    }
};
class PaginationComponent extends StylableComponent {
    constructor(inj, parent) {
        super(inj, WIDGET_CONFIG$q);
        this.parent = parent;
        this.resultEmitter = new EventEmitter();
        this.maxResultsEmitter = new EventEmitter();
        this.dn = {
            currentPage: 1
        };
        this.pageCount = 0;
        this.isDisableNext = true;
        this.isDisablePrevious = true;
        this.isDisableFirst = true;
        this.isDisableLast = true;
        this._debouncedApplyDataset = debounce(() => this.widget.dataset = this.dataset, DEBOUNCE_TIMES.PAGINATION_DEBOUNCE_TIME);
        this._debouncedPageChanged = debounce(event => {
            const currentPage = event && event.page;
            // Do not call goToPage if page has not changed
            if (currentPage !== this.dn.currentPage) {
                const inst = this.parent || this;
                this.dn.currentPage = currentPage;
                inst.invokeEventCallback('paginationchange', { $event: undefined, $index: this.dn.currentPage });
                this.goToPage();
            }
        }, DEBOUNCE_TIMES.PAGINATION_DEBOUNCE_TIME);
        styler(this.nativeElement, this);
    }
    setResult(result) {
        // TODO: Emit event only if result is changed
        this.result = result;
        this.resultEmitter.emit(this.result);
    }
    // Update navigationClass based on navigation and navigationSize props
    updateNavSize() {
        const sizeCls = sizeClasses[this.navcontrols];
        if (sizeCls && this.navigationsize) {
            this.navigationClass = sizeCls[this.navigationsize];
        }
        else {
            this.navigationClass = '';
        }
    }
    // Function to reset the paging values to default.
    resetPageNavigation() {
        this.pageCount = 0;
        this.dn.currentPage = 1;
        this.dataSize = 0;
    }
    /*Function to calculate the paging values.*/
    calculatePagingValues() {
        this.pageCount = (this.dataSize > this.maxResults) ? (Math.ceil(this.dataSize / this.maxResults)) : (this.dataSize < 0 ? 0 : 1);
        this.dn.currentPage = this.dn.currentPage || 1;
    }
    /*Function to set default values to the paging parameters*/
    setDefaultPagingValues(dataSize, maxResults, currentPage) {
        /*If neither 'dataSize' nor 'maxResults' is set, then set default values to the paging parameters.*/
        if (!dataSize && !maxResults) {
            this.pageCount = 1;
            this.dn.currentPage = 1;
            this.maxResults = dataSize;
            this.dataSize = dataSize;
        }
        else { /*Else, set the specified values and recalculate paging parameters.*/
            this.maxResults = maxResults || this.maxResults;
            this.dataSize = isDefined(dataSize) ? dataSize : this.dataSize;
            this.dn.currentPage = currentPage || this.dn.currentPage;
            this.calculatePagingValues();
        }
        this.maxResultsEmitter.emit(this.maxResults);
    }
    /*Function to check the dataSize and manipulate the navigator accordingly.*/
    checkDataSize(dataSize, numberOfElements, size) {
        /*If the dataSize is -1 or Integer.MAX_VALUE( which is 2147483647), then the total number of records is not known.
         * Hence,
         * 1. Hide the 'Total Record Count'.
         * 2. Disable the 'GoToLastPage' link as the page number of the last page is not known.*/
        if (dataSize === -1 || dataSize === AppConstants.INT_MAX_VALUE) {
            this.prevshowrecordcount = this.showrecordcount;
            this.isDisableLast = true;
            this.isDisableCount = true;
            this.showrecordcount = false;
            // If number of records in current page is less than the max records size, this is the last page. So disable next button.
            if (numberOfElements < size) {
                this.isDisableNext = true;
            }
        }
        else {
            this.isDisableCount = false;
            this.showrecordcount = this.prevshowrecordcount || this.showrecordcount;
        }
    }
    /*Function to disable navigation based on the current and total pages.*/
    disableNavigation() {
        const isCurrentPageFirst = (this.dn.currentPage === 1), isCurrentPageLast = (this.dn.currentPage === this.pageCount);
        this.isDisableFirst = this.isDisablePrevious = isCurrentPageFirst;
        this.isDisableNext = this.isDisableLast = isCurrentPageLast;
        this.isDisableCurrent = isCurrentPageFirst && isCurrentPageLast;
    }
    /*Function to check if the variable bound to the data-navigator has paging.*/
    isDataSourceHasPaging() {
        return this.datasource && this.datasource.execute(DataSource.Operation.IS_PAGEABLE);
    }
    // Set the result for client side pagination
    setNonPageableData(newVal) {
        let dataSize, maxResults, currentPage, startIndex;
        dataSize = _.isArray(newVal) ? newVal.length : (_.isEmpty(newVal) ? 0 : 1);
        maxResults = (this.options && this.options.maxResults) || dataSize;
        // For static variable, keep the current page. For other variables without pagination reset the page to 1
        if (this.datasource && this.datasource.execute(DataSource.Operation.IS_API_AWARE)) {
            currentPage = 1;
        }
        else {
            currentPage = this.dn.currentPage || 1;
        }
        this.setDefaultPagingValues(dataSize, maxResults, currentPage);
        this.disableNavigation();
        startIndex = (this.dn.currentPage - 1) * this.maxResults;
        this.setResult(_.isArray(newVal) ? newVal.slice(startIndex, startIndex + this.maxResults) : newVal);
    }
    /*Function to set the values needed for pagination*/
    setPagingValues(newVal) {
        let dataSize, maxResults, currentPage, dataSource;
        let variableOptions = {};
        // Store the data in __fullData. This is used for client side searching witvah out modifying the actual dataset.
        this.__fullData = newVal;
        /*Check for sanity*/
        if (this.binddataset) {
            dataSource = this.datasource || {};
            variableOptions = dataSource._options || {};
            /*Check for number of elements in the data set*/
            if (newVal) {
                if (this.isDataSourceHasPaging()) {
                    this.pagination = this.datasource.execute(DataSource.Operation.GET_PAGING_OPTIONS) || {};
                    // If "filterFields" and "sortOptions" have been set, then set them so that the filters can be retained while fetching data upon page navigation.
                    this.filterFields = variableOptions.filterFields || {};
                    this.sortOptions = variableOptions.orderBy ||
                        (_.isArray(this.pagination.sort) ? getOrderByExpr(this.pagination.sort) : '');
                    dataSize = this.pagination.totalElements;
                    maxResults = this.pagination.size;
                    if (this.pagination.numberOfElements > 0) {
                        if (isDefined(this.pagination.number)) { // number is page number received from backend
                            this.dn.currentPage = this.pagination.number + 1;
                        }
                        currentPage = this.dn.currentPage || 1;
                    }
                    else {
                        currentPage = 1;
                    }
                    /* Sending pageCount undefined to calculate it again for query.*/
                    this.setDefaultPagingValues(dataSize, maxResults, currentPage);
                    this.disableNavigation();
                    this.checkDataSize(dataSize, this.pagination.numberOfElements, this.pagination.size);
                    this.setResult(newVal);
                }
                else if (!_.isString(newVal)) {
                    this.setNonPageableData(newVal);
                }
            }
            else {
                this.setResult(newVal);
                this.resetPageNavigation();
            }
        }
        else {
            if (newVal && !_.isString(newVal)) {
                this.setNonPageableData(newVal);
            }
        }
    }
    /*Function to check if the current page is the first page*/
    isFirstPage() {
        return (this.dn.currentPage === 1 || !this.dn.currentPage);
    }
    /*Function to check if the current page is the last page*/
    isLastPage() {
        return (this.dn.currentPage === this.pageCount);
    }
    /*Function to navigate to the last page*/
    goToLastPage(isRefresh, event, callback) {
        if (!this.isLastPage()) {
            this.dn.currentPage = this.pageCount;
            this.goToPage(event, callback);
        }
        else if (isRefresh) {
            this.goToPage(event, callback);
        }
    }
    /*Function to navigate to the first page*/
    goToFirstPage(isRefresh, event, callback) {
        if (!this.isFirstPage()) {
            this.dn.currentPage = 1;
            this.goToPage(event, callback);
        }
        else if (isRefresh) {
            this.goToPage(event, callback);
        }
    }
    /*Function to navigate to the current page*/
    goToPage(event, callback) {
        this.firstRow = (this.dn.currentPage - 1) * this.maxResults;
        this.getPageData(event, callback);
    }
    /*Function to be invoked after the data of the page has been fetched.*/
    onPageDataReady(event, data, callback) {
        this.disableNavigation();
        this.invokeSetRecord(event, data);
        triggerFn(callback);
    }
    /*Function to get data for the current page*/
    getPageData(event, callback) {
        let data, startIndex;
        if (this.isDataSourceHasPaging()) {
            this.datasource.execute(DataSource.Operation.LIST_RECORDS, {
                'page': this.dn.currentPage,
                'filterFields': this.filterFields,
                'orderBy': this.sortOptions,
                'matchMode': 'anywhereignorecase'
            }).then(response => {
                this.onPageDataReady(event, response && response.data, callback);
                $appDigest();
            }, error => {
            });
        }
        else {
            startIndex = (this.dn.currentPage - 1) * this.maxResults;
            data = _.isArray(this.__fullData) ? this.__fullData.slice(startIndex, startIndex + this.maxResults) : this.__fullData;
            this.setResult(data);
            this.onPageDataReady(event, data, callback);
        }
    }
    invokeSetRecord(event, data) {
        // Trigger the event handler if exists.
        const pageInfo = {
            currentPage: this.dn.currentPage,
            size: this.maxResults,
            totalElements: this.dataSize,
            totalPages: this.pageCount
        };
        if (this.parent) {
            this.parent.invokeEventCallback('setrecord', { $event: event, $data: data, $index: this.dn.currentPage, pageInfo, data });
        }
        else {
            this.invokeEventCallback('setrecord', { $event: event, $data: data, $index: this.dn.currentPage, pageInfo, data });
        }
    }
    /*Function to validate the page input.
     In case of invalid input, navigate to the appropriate page; also return false.
     In case of valid input, return true.*/
    validateCurrentPage(event, callback) {
        /*If the value entered is greater than the last page number or invalid value, then highlighting the field showing error.*/
        if (event && (isNaN(this.dn.currentPage) || this.dn.currentPage <= 0 || (this.pageCount && (this.dn.currentPage > this.pageCount || _.isNull(this.dn.currentPage))))) {
            $(event.target).closest('a').addClass('ng-invalid');
            return false;
        }
        return true;
    }
    onModelChange(event) {
        if (!this.validateCurrentPage(event)) {
            return;
        }
        this.goToPage(event);
    }
    onKeyDown(event) {
        const targetEle = $(event.target).closest('a');
        if (event.code === 'KeyE') {
            targetEle.addClass('ng-invalid');
            return false;
        }
        targetEle.removeClass('ng-invalid');
        return true;
    }
    pageChanged(event) {
        this._debouncedPageChanged(event);
    }
    /*Function to navigate to the respective pages.*/
    navigatePage(index, event, isRefresh, callback) {
        this.invokeEventCallback('paginationchange', { $event: undefined, $index: this.dn.currentPage });
        // Convert the current page to a valid page number.
        this.dn.currentPage = +this.dn.currentPage;
        switch (index) {
            case 'first':
                this.goToFirstPage(isRefresh, event, callback);
                return;
            case 'prev':
                /*Return if already on the first page.*/
                if (this.isFirstPage() || !this.validateCurrentPage(event, callback)) {
                    return;
                }
                /*Decrement the current page by 1.*/
                this.dn.currentPage -= 1;
                break;
            case 'next':
                /*Return if already on the last page.*/
                if (this.isLastPage() || !this.validateCurrentPage(event, callback)) {
                    return;
                }
                /*Increment the current page by 1.*/
                this.dn.currentPage += 1;
                break;
            case 'last':
                this.goToLastPage(isRefresh, event, callback);
                return;
            default:
                break;
        }
        /*Navigate to the current page.*/
        this.goToPage(event, callback);
    }
    setBindDataSet(binddataset, parent, dataSource, dataset, binddatasource) {
        const parts = binddataset.split('.');
        let bindPagingOptions;
        if (parts[0] === 'Variables' || parts[0] === 'Widgets') {
            bindPagingOptions = `${parts[0]}.${parts[1]}.pagination`;
        }
        if (!binddatasource && dataset) {
            this.dataset = dataset;
            this._debouncedApplyDataset();
            return;
        }
        this.binddataset = binddataset;
        setTimeout(() => {
            this.registerDestroyListener($watch(binddataset, parent, {}, nv => {
                this.dataset = nv;
                this._debouncedApplyDataset();
            }));
            // Register a watch on paging options. Call dataset property change handler even if paging options changes to reflect pagination state
            if (!bindPagingOptions) {
                return;
            }
            this.registerDestroyListener($watch(bindPagingOptions, parent, {}, () => this._debouncedApplyDataset()));
        });
        this.datasource = dataSource;
    }
    // Set the datasource of pagination from the parent widget
    setDataSource(dataSource) {
        this.datasource = dataSource;
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'dataset') {
            let data;
            if (this.parent && this.parent.onDataNavigatorDataSetChange) {
                data = this.parent.onDataNavigatorDataSetChange(nv);
            }
            else {
                data = nv;
            }
            this.setPagingValues(data);
        }
        else if (key === 'navigation') {
            if (nv === 'Advanced') { // Support for older projects where navigation type was advanced instead of clasic
                this.navigation = 'Classic';
            }
            this.updateNavSize();
            this.navcontrols = nv;
        }
        else if (key === 'navigationsize') {
            this.updateNavSize();
        }
        else if (key === 'navigationalign') {
            switchClass(this.nativeElement, `text-${nv}`, `text-${ov}`);
        }
        else if (key === 'maxResults') {
            this.setPagingValues(this.dataset);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngAfterViewInit() {
        const paginationElem = this.nativeElement;
        paginationElem.onclick = (event) => {
            event.stopPropagation();
        };
    }
}
PaginationComponent.initializeProps = registerProps$t();
PaginationComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmPagination]',
                template: "\n<ul class=\"pagination advanced {{navigationClass}}\" *ngIf=\"navcontrols === 'Classic'\">\n    <li [ngClass]=\"{'disabled':isDisableFirst}\">\n        <a [title]=\"appLocale.LABEL_FIRST\" name=\"first\" href=\"javascript:void(0);\" aria-label=\"First\"\n           (click)=\"navigatePage('first', $event)\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-first-page\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_FIRST}}</span>\n        </a>\n    </li>\n    <li [ngClass]=\"{'disabled':isDisablePrevious}\">\n        <a [title]=\"appLocale.LABEL_PREVIOUS\" name=\"prev\" href=\"javascript:void(0);\" aria-label=\"Previous\"\n           (click)=\"navigatePage('prev', $event)\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-chevron-left\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_PREVIOUS}}</span>\n        </a>\n    </li>\n    <li class=\"pagecount disabled\">\n        <a><input type=\"number\" [disabled]=\"isDisableCurrent\" [(ngModel)]=\"dn.currentPage\"\n                  (keydown)=\"onKeyDown($event)\" (change)=\"onModelChange($event)\" class=\"form-control\"/></a>\n    </li>\n    <li class=\"disabled\">\n        <a [hidden]=\"isDisableCount\"> / {{pageCount}}</a>\n    </li>\n    <li [ngClass]=\"{'disabled':isDisableNext}\">\n        <a [title]=\"appLocale.LABEL_NEXT\" name=\"next\" href=\"javascript:void(0);\" aria-label=\"Next\"\n           (click)=\"navigatePage('next', $event)\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-chevron-right\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_NEXT}}</span>\n        </a>\n    </li>\n    <li [ngClass]=\"{'disabled':isDisableLast}\">\n        <a [title]=\"appLocale.LABEL_LAST\" name=\"last\" href=\"javascript:void(0);\" aria-label=\"Last\"\n           (click)=\"navigatePage('last', $event)\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-last-page\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_LAST}}</span>\n        </a>\n    </li>\n    <li *ngIf=\"showrecordcount\" class=\"totalcount disabled\">\n        <a>{{appLocale.LABEL_TOTAL_RECORDS}}: {{dataSize}}</a>\n    </li>\n</ul>\n<ul class=\"pager {{navigationClass}}\" *ngIf=\"navcontrols === 'Pager'\">\n    <li class=\"previous\" [ngClass]=\"{'disabled':isDisablePrevious}\">\n        <a href=\"javascript:void(0);\" (click)=\"navigatePage('prev', $event)\" aria-label=\"Previous\">\n            <span aria-hidden=\"true\"><i class=\"wi wi-chevron-left\"></i></span>\n            {{appLocale.LABEL_PREVIOUS}}\n            <span class=\"sr-only\">{{appLocale.LABEL_PREVIOUS}}</span>\n        </a>\n    </li>\n    <li class=\"next\" [ngClass]=\"{'disabled':isDisableNext}\">\n        <a href=\"javascript:void(0);\" (click)=\"navigatePage('next', $event)\" aria-label=\"Next\">\n            {{appLocale.LABEL_NEXT}}\n            <span aria-hidden=\"true\"><i class=\"wi wi-chevron-right\"></i></span>\n            <span class=\"sr-only\">{{appLocale.LABEL_NEXT}}</span>\n        </a>\n    </li>\n</ul>\n\n<pagination class=\"pagination basic\" [ngClass]=\"navigationClass\" *ngIf=\"navcontrols === 'Basic'\"\n            [itemsPerPage]=\"maxResults\" [totalItems]=\"dataSize\"\n            [ngModel]=\"dn.currentPage\" (pageChanged)=\"pageChanged($event)\"\n            [boundaryLinks]=\"boundarylinks\" [maxSize]=\"maxsize\"\n            [directionLinks]=\"directionlinks\" previousText=\".\" nextText=\".\" firstText=\".\" lastText=\".\"></pagination>\n\n<ul *ngIf=\"navcontrols === 'Basic' && showrecordcount\" class=\"pagination\">\n    <li class=\"totalcount disabled basiccount\"><a>{{appLocale.LABEL_TOTAL_RECORDS}}: {{dataSize}}</a></li>\n</ul>",
                providers: [
                    provideAsWidgetRef(PaginationComponent)
                ]
            }] }
];
/** @nocollapse */
PaginationComponent.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: SkipSelf }, { type: Inject, args: [WidgetRef,] }] }
];
PaginationComponent.propDecorators = {
    resultEmitter: [{ type: Output }],
    maxResultsEmitter: [{ type: Output }]
};

class ListItemDirective {
    constructor(inj, elRef, app) {
        this.inj = inj;
        this.app = app;
        this.destroy = new Subject();
        this.destroy$ = this.destroy.asObservable();
        this.itemClass = '';
        this._currentItemWidgets = {};
        this.isActive = false;
        this.disableItem = false;
        this.nativeElement = elRef.nativeElement;
        this.listComponent = inj.view.component;
        this.context = inj.view.context;
        this.itemClassWatcher(this.listComponent);
        this.disableItemWatcher(this.listComponent);
        $(this.nativeElement).data('listItemContext', this);
    }
    onFocus() {
        // maintains which element is focused/selected most recently.
        this.listComponent.lastSelectedItem = this;
    }
    get $index() {
        return this.context.index;
    }
    get $even() {
        return this.context.even;
    }
    get $odd() {
        return this.context.odd;
    }
    get $first() {
        return this.context.first;
    }
    get $last() {
        return this.context.last;
    }
    get currentItemWidgets() {
        const componentElements = Array.from(this.nativeElement.querySelectorAll('[widget-id]'));
        return Object.assign(this._currentItemWidgets, componentElements.reduce((result, comp) => {
            result[comp.widget.name] = comp.widget;
            return result;
        }, {}));
    }
    set wmListItem(val) {
        this.item = val;
    }
    registerWatch(expression, callback) {
        // Removing ngFor context as the same properties are availble on listitem scope.
        // passing viewparent context for accessing varibales and widgets.
        this.destroy$.subscribe($watch(expression, this.listComponent.viewParent, this, callback));
    }
    itemClassWatcher(listComponent) {
        if (listComponent.binditemclass) {
            this.registerWatch(listComponent.binditemclass, nv => this.itemClass = nv || '');
        }
        else {
            this.itemClass = listComponent.itemclass;
        }
    }
    disableItemWatcher($list) {
        if ($list.binddisableitem) {
            this.registerWatch($list.binddisableitem, nv => this.disableItem = nv || false);
        }
        else {
            this.disableItem = $list.disableitem || false;
        }
    }
    triggerWMEvent(eventName) {
        $invokeWatchers(true);
        // If we have multiselect for the livelist(List with form template), in run mode deleting a record is getting failed. Becuase the selecteditem will be array of objects. So consider the last object.
        const row = this.listComponent.multiselect ? _.last(this.listComponent.selecteditem) : this.listComponent.selecteditem;
        this.app.notify('wm-event', { eventName, widgetName: this.listComponent.name, row: row });
    }
    setUpCUDHandlers() {
        const $editItem = this.nativeElement.querySelector('.edit-list-item');
        const $deleteItem = this.nativeElement.querySelector('.delete-list-item');
        if ($editItem) {
            // Triggered on click of edit action
            $editItem.addEventListener('click', evt => {
                this.triggerWMEvent('update');
            });
        }
        if ($deleteItem) {
            // Triggered on click of delete action
            $deleteItem.addEventListener('click', evt => {
                this.triggerWMEvent('delete');
            });
        }
    }
    ngOnInit() {
        if (this.listComponent.mouseEnterCB) {
            this.nativeElement.addEventListener('mouseenter', ($event) => {
                this.listComponent.invokeEventCallback('mouseenter', { widget: this, $event });
            });
        }
        if (this.listComponent.mouseLeaveCB) {
            this.nativeElement.addEventListener('mouseleave', ($event) => {
                this.listComponent.invokeEventCallback('mouseleave', { widget: this, $event });
            });
        }
    }
    ngAfterViewInit() {
        this.setUpCUDHandlers();
    }
}
ListItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmListItem]',
                exportAs: 'listItemRef'
            },] }
];
/** @nocollapse */
ListItemDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef },
    { type: App }
];
ListItemDirective.propDecorators = {
    isActive: [{ type: HostBinding, args: ['class.active',] }],
    disableItem: [{ type: HostBinding, args: ['class.disable-item',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    wmListItem: [{ type: Input }]
};

class ListAnimator extends SwipeAnimation {
    constructor(list) {
        super();
        this.list = list;
        this.$el = $(this.list.getNativeElement()).find('ul.app-livelist-container:first');
        this.leftChildrenCount = this.$el.find('>.app-list-item-left-action-panel > button:visible').length;
        this.rightChildrenCount = this.$el.find('>.app-list-item-right-action-panel > button:visible').length;
        // when there are no children in both the templates then do not apply swipeAnimation;
        if (!this.leftChildrenCount && !this.rightChildrenCount) {
            return;
        }
        // initialise swipe animation on the list component.
        this.init(this.$el);
        // retrieves all the button components which are placed outside the listTemplate.
        this.$btnSubscription = this.list.btnComponents.changes.subscribe(items => this.actionItems = items);
    }
    // This method sets the css for left or right action panels based on the template. Appends the actionTemplate before li.
    createActionPanel(li, actionPanelTemplate) {
        actionPanelTemplate.css({
            width: li.outerWidth() + 'px',
            height: li.outerHeight() + 'px',
            marginBottom: -1 * li.outerHeight() + 'px',
            float: 'left',
            padding: 0
        });
        return actionPanelTemplate.insertBefore(li);
    }
    // Returns the total width occupied by all the children inside the element
    computeTotalChildrenWidth($ele) {
        return _.reduce($ele.children(), (totalWidth, el) => {
            return totalWidth + $(el).outerWidth();
        }, 0);
    }
    // Returns amount of transition to be applied on element when swiped left or right
    computeTransitionProportions($ele) {
        const totalWidth = this.computeTotalChildrenWidth($ele);
        const reverse = this.position === 'right';
        let d = 0;
        return _.map($ele.children(), e => {
            const f = (totalWidth - d) / totalWidth;
            d += $(e).outerWidth();
            return reverse ? f : (d / totalWidth);
        });
    }
    // Resets the transform applied on the element.
    resetElement(el) {
        if (el) {
            el.css({
                transform: 'none',
                transition: 'none'
            });
        }
    }
    resetState() {
        this.resetElement(this.li);
        this.resetElement(this.actionPanel);
        if (this.actionPanel) {
            this.actionPanel = null;
        }
    }
    // Returns the target button (child element) inside the left and right actionPanels.
    getChildActionElement(actionTemplate) {
        if (actionTemplate.children().length) {
            if (this.position === 'left') {
                return actionTemplate.children().first();
            }
            return actionTemplate.children().last();
        }
    }
    // create the actionPanels and set the background-color for remaining panel as that of first child element
    // calculates the children's width and its transition proportionates.
    initActionPanel(actionTemplate) {
        this.actionPanel = this.createActionPanel(this.li, actionTemplate);
        this.actionPanel.css({
            backgroundColor: this.getChildActionElement(this.actionPanel).css('background-color')
        });
        this.limit = this.computeTotalChildrenWidth(this.actionPanel);
        this.transitionProportions = this.computeTransitionProportions(this.actionPanel);
    }
    bounds(e, $d) {
        const target = $(e.target).closest('li');
        // default bounds when action template markup is not available.
        let bounds = {
            strictUpper: true,
            strictLower: true,
            lower: 0,
            center: 0,
            upper: 0
        };
        // apply swipe animation only on list items having "app-list-item" class.
        if (!target.hasClass('app-list-item')) {
            return bounds;
        }
        if (!this.li || this.li[0] !== target[0]) {
            let selector = $d > 0 ? '.app-list-item-left-action-panel' : '.app-list-item-right-action-panel';
            let actionTemplate = this.$el.find('>' + selector);
            // when groupby is set select the action panel from the list group items.
            if (!actionTemplate.length && this.list.groupby) {
                selector = 'li > ul.list-group >' + selector;
                actionTemplate = this.$el.find('>' + selector);
            }
            // check for children visiblity. If children are visible then initiate the action panel.
            if (!actionTemplate.length || !actionTemplate.find('button:visible').length) {
                return bounds;
            }
            this.resetState();
            this.li = target;
            this.position = actionTemplate.attr('position');
            this.initActionPanel(actionTemplate);
            if ($d > 0) {
                // bounds while swiping from right to left to open left action panel. It can be moved upto limit value (Upper bound).
                bounds = {
                    strictUpper: false,
                    lower: 0,
                    center: 0,
                    upper: this.limit
                };
            }
            else {
                // bounds while swiping from left to right to open right action panel. It can be moved in reverse direction with -limit value (lower bound).
                bounds = {
                    strictLower: false,
                    lower: -this.limit,
                    center: 0,
                    upper: 0
                };
            }
        }
        else if (this.position === 'left') {
            // when left action panel is visible (i.e. center at limit value) then this can be moved by distance (limit) in reverse direction to close the view.
            bounds = {
                strictUpper: false,
                lower: -this.limit,
                center: this.limit
            };
        }
        else if (this.position === 'right') {
            // when right action panel is visible (i.e. center at -limit value) then this can be moved by distance (limit) to close the view.
            bounds = {
                center: -this.limit,
                upper: this.limit,
                strictLower: false
            };
        }
        return bounds;
    }
    context() {
        return {
            computeActionTransition: (index, $d) => {
                const sign = $d > 0 ? 1 : -1;
                if (sign * $d > this.limit) {
                    // once the distance swiped is beyond the limit, then calculate the proportionate distance moved after the limit value.
                    return ($d - sign * this.limit) + (this.transitionProportions[index] * sign * this.limit);
                }
                return this.transitionProportions[index] * $d;
            }
        };
    }
    animation() {
        return [{
                target: () => this.li,
                css: {
                    transform: 'translate3d(${{$D + $d}}px, 0, 0)'
                }
            }, {
                target: () => (this.actionPanel && this.actionPanel.children()),
                css: {
                    transform: 'translate3d(${{computeActionTransition($i, $D + $d)}}px, 0, 0)'
                }
            }];
    }
    // Triggers full swipe event on the target element.
    invokeFullSwipeEvt($event) {
        let target, actions, index;
        // Check if button are visible or not, invoke the tap event of the last button which is visible.
        if (this.position === 'left') {
            actions = this.actionItems.filter(btn => {
                return btn.getAttr('swipe-position') === 'left' && btn.$element.is(':visible');
            });
            index = 0;
        }
        else {
            actions = this.actionItems.filter(btn => {
                return btn.getAttr('swipe-position') === 'right' && btn.$element.is(':visible');
            });
            index = actions.length - 1;
        }
        target = actions[index];
        if (target && target.hasEventCallback('tap')) {
            target.invokeEventCallback('tap', { $event });
        }
        this.resetState();
        this.li = null;
    }
    // Called when swipeEnd is triggered. d contains the total distance covered by the element until touchEnd.
    onAnimation($event, d) {
        // set the selecteditem on the list component on swipe.
        this.list.triggerListItemSelection(this.li, $event);
        if (this.actionPanel && this.actionPanel.attr('enablefullswipe') === 'true') {
            const sign = d > 0 ? 1 : -1;
            const $el = this.getChildActionElement(this.actionPanel);
            if ($el) {
                const index = this.position === 'right' ? this.rightChildrenCount - 1 : 0;
                // proportionate amount of distance covered by the target element.
                const distPercentage = this.transitionProportions[index] * sign * d * 100 / (this.li.outerWidth() - this.limit + $el.width());
                // If distance travelled by the target button element is more than 50% of the list item width then invoke the fullswipe.
                if (distPercentage > 50) {
                    // invoke fullswipe event
                    this.invokeFullSwipeEvt($event);
                }
            }
        }
    }
    onLower() {
        if (this.position === 'left') {
            this.resetState();
            this.li = null;
        }
    }
    onUpper() {
        if (this.position === 'right') {
            this.resetState();
            this.li = null;
        }
    }
    threshold() {
        return 10;
    }
}

const DEFAULT_CLS$n = 'app-livelist app-panel';
const WIDGET_CONFIG$r = { widgetType: 'wm-list', hostClass: DEFAULT_CLS$n };
class ListComponent extends StylableComponent {
    constructor(inj, cdRef, datePipe, app, appDefaults, ngZone, binditemclass, binddisableitem, binddataset, binddatasource, mouseEnterCB, mouseLeaveCB) {
        let resolveFn = noop;
        const propsInitPromise = new Promise(res => resolveFn = res);
        super(inj, WIDGET_CONFIG$r, propsInitPromise);
        this.propsInitPromise = propsInitPromise;
        this.promiseResolverFn = resolveFn;
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.SHELL);
        this.cdRef = cdRef;
        this.ngZone = ngZone;
        this.datePipe = datePipe;
        this.binditemclass = binditemclass;
        this.binddisableitem = binddisableitem;
        this.binddataset = binddataset;
        this.mouseEnterCB = mouseEnterCB;
        this.mouseLeaveCB = mouseLeaveCB;
        this.binddatasource = binddatasource;
        this.app = app;
        this.appDefaults = appDefaults;
        this.variableInflight = false;
        this.noDataFound = !binddataset;
        // Show loading status based on the variable life cycle
        this.app.subscribe('toggle-variable-state', this.handleLoading.bind(this));
    }
    get selecteditem() {
        if (this.multiselect) {
            return getClonedObject(this._items);
        }
        if (_.isEmpty(this._items)) {
            return {};
        }
        return getClonedObject(this._items[0]);
    }
    /**
     * Returns list of widgets present on list item by considering name and index of the widget.
     * If we did'nt pass index, it returns array of all the widgets which are matching to widget name
     * @param widgteName: Name of the widget
     * @param index: Index of the widget
     */
    getWidgets(widgteName, index) {
        let $target;
        const retVal = [];
        if (!widgteName) {
            return;
        }
        if (!isDefined(index)) {
            _.forEach(this.listItems.toArray(), (el) => {
                $target = _.get(el.currentItemWidgets, widgteName);
                if ($target) {
                    retVal.push($target);
                }
            });
            return retVal;
        }
        index = +index || 0;
        $target = _.get(this.listItems.toArray(), index);
        if ($target) {
            return [_.get($target.currentItemWidgets, widgteName)];
        }
    }
    // returns listitem reference by index value. This refers to the same method getListItemByIndex.
    getItem(index) {
        return this.getListItemByIndex(index);
    }
    // return index of listItem(listItemDirective). This refers to the same method getListItemIndex.
    getIndex(item) {
        return this.getListItemIndex(item);
    }
    set selecteditem(items) {
        this._items.length = 0;
        this.deselectListItems();
        if (_.isArray(items)) {
            items.forEach(item => this.selectItem(item));
        }
        else {
            this.selectItem(items);
        }
        $appDigest();
    }
    handleLoading(data) {
        const dataSource = this.datasource;
        if (dataSource && dataSource.execute(DataSource.Operation.IS_API_AWARE) && isDataSourceEqual(data.variable, dataSource)) {
            this.ngZone.run(() => {
                this.variableInflight = data.active;
            });
        }
    }
    resetNavigation() {
        this.showNavigation = false;
        this.navControls = undefined;
        this.infScroll = false;
        this.onDemandLoad = false;
    }
    enableBasicNavigation() {
        this.navControls = NAVIGATION_TYPE.BASIC;
        this.showNavigation = true;
    }
    enableInlineNavigation() {
        this.navControls = NAVIGATION_TYPE.INLINE;
    }
    enableClassicNavigation() {
        this.navControls = NAVIGATION_TYPE.CLASSIC;
        this.showNavigation = true;
    }
    enablePagerNavigation() {
        this.navControls = NAVIGATION_TYPE.PAGER;
        this.showNavigation = true;
    }
    setNavigationTypeNone() {
        this.navControls = NAVIGATION_TYPE.NONE;
        this.showNavigation = false;
    }
    enableInfiniteScroll() {
        this.infScroll = true;
    }
    enableOnDemandLoad() {
        this.onDemandLoad = true;
        this.showNavigation = true;
    }
    /* this function sets the itemclass depending on itemsperrow.
     * if itemsperrow is 2 for large device, then itemclass is 'col-xs-1 col-sm-1 col-lg-2'
     * if itemsperrow is 'lg-3' then itemclass is 'col-lg-3'
     */
    setListClass() {
        let temp = '';
        if (this.itemsperrow) {
            if (isNaN(parseInt(this.itemsperrow, 10))) {
                // handling itemsperrow containing string of classes
                _.split(this.itemsperrow, ' ').forEach((cls) => {
                    const keys = _.split(cls, '-');
                    cls = `${keys[0]}-${(12 / parseInt(keys[1], 10))}`;
                    temp += ` col-${cls}`;
                });
                this.itemsPerRowClass = temp.trim();
            }
            else {
                // handling itemsperrow having integer value.
                this.itemsPerRowClass = `col-xs-${(12 / parseInt(this.itemsperrow, 10))}`;
            }
        }
        else { // If itemsperrow is not specified make it full width
            this.itemsPerRowClass = 'col-xs-12';
        }
    }
    /**
     * Sets Navigation type for the list.
     * @param type
     */
    onNavigationTypeChange(type) {
        this.resetNavigation();
        switch (type) {
            case NAVIGATION_TYPE.BASIC:
                this.enableBasicNavigation();
                break;
            case NAVIGATION_TYPE.INLINE:
                this.enableInlineNavigation();
                break;
            case NAVIGATION_TYPE.ADVANCED:
            case NAVIGATION_TYPE.CLASSIC:
                this.enableClassicNavigation();
                break;
            case NAVIGATION_TYPE.PAGER:
                this.enablePagerNavigation();
                break;
            case NAVIGATION_TYPE.NONE:
                this.setNavigationTypeNone();
                break;
            case NAVIGATION_TYPE.SCROLL:
                this.enableInfiniteScroll();
                break;
            case NAVIGATION_TYPE.ONDEMAND:
                this.enableOnDemandLoad();
                break;
        }
    }
    fetchNextDatasetOnScroll() {
        this.dataNavigator.navigatePage('next');
    }
    setIscrollHandlers(el) {
        let lastScrollTop = 0;
        const wrapper = _.get(el.iscroll, 'wrapper');
        const self = el.iscroll;
        el.iscroll.on('scrollEnd', () => {
            const clientHeight = wrapper.clientHeight, totalHeight = wrapper.scrollHeight, scrollTop = Math.abs(el.iscroll.y);
            if ((lastScrollTop < scrollTop) && (totalHeight * 0.9 < scrollTop + clientHeight)) {
                this.debouncedFetchNextDatasetOnScroll();
                if (self.indicatorRefresh) {
                    self.indicatorRefresh();
                }
            }
            lastScrollTop = scrollTop;
        });
    }
    // Applying iscroll event to invoke the next calls for infinte scroll.
    bindIScrollEvt() {
        const $scrollParent = this.$element.closest('[wmsmoothscroll="true"]');
        const iScroll = _.get($scrollParent[0], 'iscroll');
        // when iscroll is not initialised the notify the smoothscroll and subscribe to the iscroll update
        if (!iScroll) {
            const iScrollSubscription = this.app.subscribe('iscroll-update', (_el) => {
                if (!_.isEmpty(_el) && _el.isSameNode($scrollParent[0])) {
                    this.setIscrollHandlers($scrollParent[0]);
                    iScrollSubscription();
                }
            });
            this.app.notify('no-iscroll', $scrollParent[0]);
            return;
        }
        this.setIscrollHandlers($scrollParent[0]);
    }
    bindScrollEvt() {
        const $el = this.$element;
        const $ul = $el.find('> ul');
        const $firstChild = $ul.children().first();
        const self = this;
        let $scrollParent;
        let scrollNode;
        let lastScrollTop = 0;
        if (!$firstChild.length) {
            return;
        }
        $scrollParent = $firstChild.scrollParent(false);
        if ($scrollParent[0] === document) {
            scrollNode = document.body;
        }
        else {
            scrollNode = $scrollParent[0];
        }
        // has scroll
        if (scrollNode.scrollHeight > scrollNode.clientHeight) {
            $scrollParent
                .each((index, node) => {
                // scrollTop property is 0 or undefined for body in IE, safari.
                lastScrollTop = node === document ? (node.body.scrollTop || $(window).scrollTop()) : node.scrollTop;
            })
                .off('scroll.scroll_evt')
                .on('scroll.scroll_evt', function (evt) {
                let target = evt.target;
                let clientHeight;
                let totalHeight;
                let scrollTop;
                // scrollingElement is undefined for IE, safari. use body as target Element
                target = target === document ? (target.scrollingElement || document.body) : target;
                clientHeight = target.clientHeight;
                totalHeight = target.scrollHeight;
                scrollTop = target === document.body ? $(window).scrollTop() : target.scrollTop;
                if ((lastScrollTop < scrollTop) && (totalHeight * 0.9 < scrollTop + clientHeight)) {
                    $(this).off('scroll.scroll_evt');
                    self.debouncedFetchNextDatasetOnScroll();
                }
                lastScrollTop = scrollTop;
            });
            $ul.off('wheel.scroll_evt');
        }
        else {
            // if there is no scrollable element register wheel event on ul element
            $ul.on('wheel.scroll_evt', e => {
                if (e.originalEvent.deltaY > 0) {
                    $ul.off('wheel.scroll_evt');
                    this.debouncedFetchNextDatasetOnScroll();
                }
            });
        }
    }
    /**
     * Update fieldDefs property, fieldDefs is the model of the List Component.
     * fieldDefs is an Array type.
     * @param newVal
     */
    updateFieldDefs(newVal) {
        if (this.infScroll || this.onDemandLoad) {
            if (!isDefined(this.fieldDefs) || this.dataNavigator.isFirstPage()) {
                this.fieldDefs = [];
            }
            this.fieldDefs = [...this.fieldDefs, ...newVal];
        }
        else {
            this.fieldDefs = newVal;
        }
        if (this.orderby) {
            this.fieldDefs = getOrderedDataset(this.fieldDefs, this.orderby);
        }
        if (this.groupby) {
            this.groupedData = groupData(this, this.fieldDefs, this.groupby, this.match, this.orderby, this.dateformat, this.datePipe, undefined, this.appDefaults);
        }
        if (!this.fieldDefs.length) {
            this.noDataFound = true;
            this.selecteditem = undefined;
        }
        $appDigest();
        this.listItems.setDirty();
    }
    onDataChange(newVal) {
        // Check for newVal is not empty
        if (!_.isEmpty(newVal)) {
            this.noDataFound = false;
            this.isDataChanged = true;
            if (this.datasource && this.datasource.execute(DataSource.Operation.IS_API_AWARE)) {
                // clone the the data in case of live and service variables to prevent the two-way binding for these variables.
                newVal = _.cloneDeep(newVal);
            }
            if (isObject(newVal) && !_.isArray(newVal)) {
                newVal = _.isEmpty(newVal) ? [] : [newVal];
            }
            if (_.isString(newVal)) {
                newVal = newVal.split(',');
            }
            if (_.isArray(newVal)) {
                if (newVal.length) {
                    this.invokeEventCallback('beforedatarender', { $data: newVal });
                }
                this.updateFieldDefs(newVal);
            }
        }
        else {
            this.updateFieldDefs([]);
        }
    }
    // Updates the dataSource when pagination is enabled for the Component.
    setupDataSource() {
        const dataNavigator = this.dataNavigator;
        dataNavigator.options = {
            maxResults: this.pagesize || 5
        };
        this.dataNavigatorWatched = true;
        if (this.navigatorResultWatch) {
            this.navigatorResultWatch.unsubscribe();
        }
        /*Register a watch on the "result" property of the "dataNavigator" so that the paginated data is displayed in the live-list.*/
        this.navigatorResultWatch = dataNavigator.resultEmitter.subscribe((newVal) => {
            this.onDataChange(newVal);
        }, true);
        /*De-register the watch if it is exists */
        if (this.navigatorMaxResultWatch) {
            this.navigatorMaxResultWatch.unsubscribe();
        }
        /*Register a watch on the "maxResults" property of the "dataNavigator" so that the "pageSize" is displayed in the live-list.*/
        this.navigatorMaxResultWatch = dataNavigator.maxResultsEmitter.subscribe((val) => {
            this.pagesize = val;
        });
        dataNavigator.maxResults = this.pagesize || 5;
        this.removePropertyBinding('dataset');
        this.dataNavigator.setBindDataSet(this.binddataset, this.viewParent, this.datasource, this.dataset, this.binddatasource);
    }
    onDataSetChange(newVal) {
        if (!this.dataNavigatorWatched) {
            if (this.navigation && this.navigation !== NAVIGATION_TYPE.NONE) {
                this.setupDataSource();
            }
            else {
                this.onDataChange(newVal);
            }
        }
        else if (this.navigation && this.navigation !== NAVIGATION_TYPE.NONE) {
            // If navigation is already setup and datasource is changed, update the datasource on navigation
            this.dataNavigator.setDataSource(this.datasource);
        }
    }
    // All the ListItem's Active state is set to false.
    deselectListItems() {
        this.listItems.forEach(item => item.isActive = false);
    }
    // Deselect all the ListItems and clear the selecteditem(InOutBound Property model)
    clearSelectedItems() {
        this.deselectListItems();
        this._items.length = 0;
        $appDigest();
    }
    /**
     * return the ListItemDirective instance by checking the equality of the model.
     * @param listModel: model to be searched for
     * @returns ListItem if the model is matched else return null.
     */
    getListItemByModel(listModel) {
        return this.listItems.find((listItem) => {
            let itemObj = listItem.item;
            if (this.groupby && !_.has(listModel, '_groupIndex')) {
                // If groupby is enabled, item contains _groupIndex property which should be excluded while comparing model.
                itemObj = _.clone(itemObj);
                delete itemObj._groupIndex;
            }
            if (_.isEqual(itemObj, listModel)) {
                return true;
            }
        }) || null;
    }
    updateSelectedItemsWidgets() {
        if (this.multiselect) {
            this.selectedItemWidgets.length = 0;
        }
        this.listItems.forEach((item) => {
            if (item.isActive) {
                if (this.multiselect) {
                    this.selectedItemWidgets.push(item.currentItemWidgets);
                }
                else {
                    this.selectedItemWidgets = item.currentItemWidgets;
                }
            }
        });
    }
    /**
     * Selects the listItem and updates selecteditem property.
     * If the listItem is already a selected item then deselects the item.
     * @param {ListItemDirective} $listItem: Item to be selected of deselected.
     */
    toggleListItemSelection($listItem) {
        // item is not allowed to get selected if it is disabled.
        if ($listItem && !$listItem.disableItem) {
            let item = $listItem.item;
            if (this.groupby && _.has(item, '_groupIndex')) {
                // If groupby is enabled, item contains _groupIndex property which should be excluded from selecteditem.
                item = _.clone(item);
                delete item._groupIndex;
            }
            if ($listItem.isActive) {
                this._items = _.pullAllWith(this._items, [item], _.isEqual);
                $listItem.isActive = false;
            }
            else {
                // if multiselect is false, clear the selectItem list before adding an item to the selectItem list.
                if (!this.multiselect) {
                    this.clearSelectedItems();
                }
                this._items.push(item);
                this.invokeEventCallback('select', { widget: $listItem, $data: item });
                $listItem.isActive = true;
            }
            this.updateSelectedItemsWidgets();
        }
    }
    /**
     * Method is Invoked when the model for the List Widget is changed.
     * @param {QueryList<ListItemDirective>} listItems
     */
    onListRender(listItems) {
        // Added render callback event. This method(onListRender) is calling multiple times so checking isDatachanged flag because this falg is changed whenever new data is rendered.
        if (this.isDataChanged) {
            this.invokeEventCallback('render', { $data: this.fieldDefs });
        }
        const selectedItems = _.isArray(this.selecteditem) ? this.selecteditem : [this.selecteditem];
        this.firstSelectedItem = this.lastSelectedItem = null;
        // don't select first item if multi-select is enabled and at least item is already selected in the list.
        if (listItems.length && this.selectfirstitem && !(this._items.length && this.multiselect)) {
            const $firstItem = listItems.first;
            if (!$firstItem.disableItem &&
                this.isDataChanged &&
                // "infinite scroll" or "load on demand" is enabled and at least one item is selected then dont alter the selected list items.
                !((this.infScroll || this.onDemandLoad) &&
                    this._items.length)) {
                this.clearSelectedItems();
                this.firstSelectedItem = this.lastSelectedItem = $firstItem;
                // selecting the first record
                this.selectItem(0);
            }
        }
        else {
            this.deselectListItems();
            selectedItems.forEach(selecteditem => {
                const listItem = this.getListItemByModel(selecteditem);
                if (listItem) {
                    listItem.isActive = true;
                    this.lastSelectedItem = listItem;
                    // focus the active element
                    listItem.nativeElement.focus();
                }
            });
        }
        if (this.fieldDefs.length && this.infScroll) {
            if (isMobileApp()) {
                this.bindIScrollEvt();
            }
            else {
                this.bindScrollEvt();
            }
        }
        this.isDataChanged = false;
    }
    triggerListItemSelection($el, $event) {
        if ($el && $el[0]) {
            const listItemContext = $el.data('listItemContext');
            // Trigger click event only if the list item is from the corresponding list.
            if (listItemContext.listComponent === this) {
                this.onItemClick($event, listItemContext);
            }
        }
    }
    setupHandlers() {
        this.listItems.changes.subscribe(listItems => {
            this.onListRender(listItems);
            this.cdRef.detectChanges();
        });
        // handle click event in capturing phase.
        this.nativeElement.querySelector('ul.app-livelist-container').addEventListener('click', ($event) => {
            let target = $($event.target).closest('.app-list-item');
            // Recursively find the current list item
            while (target.get(0) && (target.closest('ul.app-livelist-container').get(0) !== $event.currentTarget)) {
                target = target.parent().closest('.app-list-item');
            }
            this.triggerListItemSelection(target, $event);
        }, true);
    }
    // Triggers on drag start while reordering.
    onReorderStart(evt, ui) {
        ui.placeholder.height(ui.item.height());
        this.$ulEle.data('oldIndex', ui.item.index());
    }
    // Triggers after the sorting.
    onUpdate(evt, ui) {
        const data = this.fieldDefs;
        const newIndex = ui.item.index();
        const oldIndex = this.$ulEle.data('oldIndex');
        const minIndex = _.min([newIndex, oldIndex]);
        const maxIndex = _.max([newIndex, oldIndex]);
        const draggedItem = _.pullAt(data, oldIndex)[0];
        this.reorderProps.minIndex = _.min([minIndex, this.reorderProps.minIndex]);
        this.reorderProps.maxIndex = _.max([maxIndex, this.reorderProps.maxIndex]);
        data.splice(newIndex, 0, draggedItem);
        this.cdRef.markForCheck();
        this.cdRef.detectChanges();
        const $changedItem = {
            oldIndex: oldIndex,
            newIndex: newIndex,
            item: data[newIndex]
        };
        this.invokeEventCallback('reorder', { $event: evt, $data: data, $changedItem });
        this.$ulEle.removeData('oldIndex');
    }
    // configures reordering the list items.
    configureDnD() {
        const options = {
            appendTo: 'body',
        };
        const $el = $(this.nativeElement);
        this.$ulEle = $el.find('.app-livelist-container');
        configureDnD(this.$ulEle, options, this.onReorderStart.bind(this), this.onUpdate.bind(this));
        this.$ulEle.droppable({ 'accept': '.app-list-item' });
    }
    // returns true if the selection limit is reached.
    checkSelectionLimit(count) {
        return (!this.selectionlimit || count < this.selectionlimit);
    }
    // returns listitem reference by index value.
    getListItemByIndex(index) {
        return this.listItems.toArray()[index];
    }
    /**
     * return index of an (listItemDirective) in the listItem
     * @param {ListItemDirective} item
     * @returns {number}
     */
    getListItemIndex(item) {
        return this.listItems.toArray().indexOf(item);
    }
    // this method is called form other data widgets like table.
    execute(operation, options) {
        if ([DataSource.Operation.IS_API_AWARE, DataSource.Operation.IS_PAGEABLE, DataSource.Operation.SUPPORTS_SERVER_FILTER].includes(operation)) {
            return false;
        }
        return this.datasource.execute(operation, options);
    }
    handleKeyDown($event, action) {
        $event.stopPropagation();
        const listItems = this.listItems;
        let presentIndex = this.getListItemIndex(this.lastSelectedItem);
        if (this.multiselect) {
            const firstIndex = this.getListItemIndex(this.firstSelectedItem);
            const selectCount = _.isArray(this.selecteditem) ? this.selecteditem.length : (_.isObject(this.selecteditem) ? 1 : 0);
            if (action === 'selectPrev') {
                if (presentIndex > 0) {
                    if ((presentIndex <= firstIndex) && this.checkSelectionLimit(selectCount)) {
                        this.lastSelectedItem = this.getListItemByIndex(presentIndex - 1);
                        this.toggleListItemSelection(this.lastSelectedItem);
                    }
                    else if (presentIndex > firstIndex) {
                        this.toggleListItemSelection(this.getListItemByIndex(presentIndex));
                        this.lastSelectedItem = this.getListItemByIndex(presentIndex - 1);
                    }
                    else {
                        this.invokeEventCallback('selectionlimitexceed', { $event });
                    }
                }
            }
            else if (action === 'selectNext') {
                if (presentIndex < listItems.length - 1) {
                    if ((presentIndex >= firstIndex) && this.checkSelectionLimit(selectCount)) {
                        this.lastSelectedItem = this.getListItemByIndex(presentIndex + 1);
                        this.toggleListItemSelection(this.lastSelectedItem);
                    }
                    else if (presentIndex < firstIndex) {
                        this.toggleListItemSelection(this.getListItemByIndex(presentIndex));
                        this.lastSelectedItem = this.getListItemByIndex(presentIndex + 1);
                    }
                    else {
                        this.invokeEventCallback('selectionlimitexceed', { $event });
                    }
                }
            }
        }
        if (action === 'focusPrev') {
            presentIndex = presentIndex <= 0 ? 0 : (presentIndex - 1);
            this.lastSelectedItem = this.getListItemByIndex(presentIndex);
            this.lastSelectedItem.nativeElement.focus();
        }
        else if (action === 'focusNext') {
            presentIndex = presentIndex < (listItems.length - 1) ? (presentIndex + 1) : (listItems.length - 1);
            this.lastSelectedItem = this.getListItemByIndex(presentIndex);
            this.lastSelectedItem.nativeElement.focus();
        }
        else if (action === 'select') {
            // if the enter click is pressed on the item which is not the last selected item, the find the item from which the event is originated.
            if (presentIndex === -1 || !$($event.target).closest(this.lastSelectedItem.nativeElement)) {
                const $li = $($event.target).closest('li.app-list-item');
                const $ul = $li.closest('ul.app-livelist-container');
                presentIndex = $ul.find('li.app-list-item').index($li);
            }
            this.onItemClick($event, this.getListItemByIndex(presentIndex));
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'dataset') {
            if (!nv && this.binddatasource && !this.datasource) {
                return;
            }
            this.onDataSetChange(nv);
        }
        else if (key === 'datasource') {
            if (this.dataset) {
                this.onDataSetChange(this.dataset);
            }
        }
        else if (key === 'navigation') {
            // Support for older projects where navigation type was advanced instead of classic
            if (nv === 'Advanced') {
                this.navigation = 'Classic';
                return;
            }
            switchClass(this.nativeElement, nv, ov);
            this.onNavigationTypeChange(nv);
            if (this.dataNavigator) {
                this.dataNavigator.navigationClass = this.paginationclass;
            }
        }
        else if (key === 'itemsperrow') {
            this.setListClass();
        }
        else if (key === 'tabindex') {
            return;
        }
        else if (key === 'pulltorefresh' && nv) {
            this.app.notify('pullToRefresh:enable');
            this.subscribeToPullToRefresh();
        }
        else if (key === 'paginationclass') {
            if (this.dataNavigator) {
                // Adding setTimeout because in pagination component updateNavSize method is overriding navigationclass
                setTimeout(() => this.dataNavigator.navigationClass = nv);
            }
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    onItemClick(evt, $listItem) {
        let selectCount;
        if (!$listItem.disableItem) {
            this.firstSelectedItem = this.firstSelectedItem || $listItem;
            // Setting selectCount value based number of items selected.
            selectCount = _.isArray(this.selecteditem) ? this.selecteditem.length : (_.isObject(this.selecteditem) ? 1 : 0);
            // Handling multiselect for mobile applications
            if (this.multiselect && isMobileApp()) {
                if (this.checkSelectionLimit(selectCount) || $listItem.isActive) {
                    this.toggleListItemSelection($listItem);
                }
                else {
                    this.invokeEventCallback('selectionlimitexceed', { $event: evt });
                }
            }
            else if ((evt.ctrlKey || evt.metaKey) && this.multiselect) {
                if (this.checkSelectionLimit(selectCount) || $listItem.isActive) {
                    this.firstSelectedItem = this.lastSelectedItem = $listItem;
                    this.toggleListItemSelection($listItem);
                }
                else {
                    this.invokeEventCallback('selectionlimitexceed', { $event: evt });
                }
            }
            else if (evt.shiftKey && this.multiselect) {
                let first = $listItem.context.index;
                let last = this.firstSelectedItem.context.index;
                // if first is greater than last, then swap values
                if (first > last) {
                    last = [first, first = last][0];
                }
                if (this.checkSelectionLimit(last - first)) {
                    this.clearSelectedItems();
                    this.listItems.forEach(($liItem) => {
                        const index = $liItem.context.index;
                        if (index >= first && index <= last) {
                            this.toggleListItemSelection($liItem);
                        }
                    });
                    this.lastSelectedItem = $listItem;
                }
                else {
                    this.invokeEventCallback('selectionlimitexceed', { $event: evt });
                }
            }
            else {
                if (!$listItem.isActive || selectCount > 1) {
                    this.clearSelectedItems();
                    this.toggleListItemSelection($listItem);
                    this.firstSelectedItem = this.lastSelectedItem = $listItem;
                }
            }
            $appDigest();
        }
    }
    // Empty the list content on clear
    clear() {
        this.updateFieldDefs([]);
    }
    /**
     *  Returns ListItem Reference based on the input provided.
     * @param val: index | model of the list item.
     * @returns {ListItemDirective}
     */
    getItemRefByIndexOrModel(val) {
        let listItem;
        if (isNumber(val)) {
            listItem = this.getListItemByIndex(val);
        }
        else {
            listItem = this.getListItemByModel(val);
        }
        return listItem;
    }
    /**
     * deselects item in the list.
     * @param val: index | model of the list item.
     */
    deselectItem(val) {
        const listItem = this.getItemRefByIndexOrModel(val);
        if (listItem && listItem.isActive) {
            this.toggleListItemSelection(listItem);
        }
    }
    /**
     * selects item in the list.
     * @param val: index | model of the list item.
     */
    selectItem(val) {
        const listItem = this.getItemRefByIndexOrModel(val);
        if (!listItem) {
            return;
        }
        if (!listItem.isActive) {
            this.toggleListItemSelection(listItem);
        }
        // focus the element.
        listItem.nativeElement.focus();
    }
    beforePaginationChange($event, $index) {
        this.invokeEventCallback('paginationchange', { $event, $index });
    }
    handleEvent(node, eventName, eventCallback, locals) {
        // tap and doubleTap events are not getting propagated.So, using mouse events instead.
        const touchToMouse = {
            tap: 'click',
            doubletap: 'dblclick'
        };
        if (_.includes(['click', 'tap', 'dblclick', 'doubletap'], eventName)) {
            this.eventManager.addEventListener(this.nativeElement, touchToMouse[eventName] || eventName, (evt) => {
                const target = $(evt.target).closest('.app-list-item');
                if (target.length) {
                    const listItemContext = target.data('listItemContext');
                    if (!listItemContext.disableItem) {
                        this.invokeEventCallback(eventName, { widget: listItemContext, $event: evt, item: listItemContext.item });
                    }
                }
            });
        }
    }
    // Invoke the datasource variable by default when pulltorefresh event is not specified.
    subscribeToPullToRefresh() {
        this.cancelSubscription = this.app.subscribe('pulltorefresh', () => {
            if (this.datasource && this.datasource.listRecords) {
                this.datasource.listRecords();
            }
        });
    }
    ngOnInit() {
        super.ngOnInit();
        this.handleHeaderClick = noop;
        this._items = [];
        this.fieldDefs = [];
        // When pagination is infinite scroll dataset is applying after debounce time(250ms) so making next call after previous data has rendered
        this.debouncedFetchNextDatasetOnScroll = _.debounce(this.fetchNextDatasetOnScroll, DEBOUNCE_TIMES.PAGINATION_DEBOUNCE_TIME);
        this.reorderProps = {
            minIndex: null,
            maxIndex: null
        };
    }
    ngAfterViewInit() {
        this.promiseResolverFn();
        this.propsInitPromise.then(() => {
            super.ngAfterViewInit();
            this.selectedItemWidgets = this.multiselect ? [] : {};
            if (this.enablereorder && !this.groupby) {
                this.configureDnD();
            }
            if (this.groupby && this.collapsible) {
                this.handleHeaderClick = handleHeaderClick;
                this.toggleAllHeaders = toggleAllHeaders.bind(undefined, this);
            }
            this.setListClass();
        });
        this.setupHandlers();
        const $ul = this.nativeElement.querySelector('ul.app-livelist-container');
        styler($ul, this, APPLY_STYLES_TYPE.SCROLLABLE_CONTAINER);
        if (isMobileApp() && $ul.querySelector('.app-list-item-action-panel')) {
            this._listAnimator = new ListAnimator(this);
        }
    }
    ngOnDestroy() {
        if (this._listAnimator && this._listAnimator.$btnSubscription) {
            this._listAnimator.$btnSubscription.unsubscribe();
        }
        if (this.cancelSubscription) {
            this.cancelSubscription();
        }
    }
}
ListComponent.initializeProps = registerProps$s();
ListComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmList]',
                template: "<div class=\"panel-heading\" *ngIf=\"title || subheading || iconclass\">\n    <h3 class=\"panel-title\">\n        <div class=\"pull-left\">\n            <i class=\"app-icon panel-icon {{iconclass}}\" aria-hidden=\"true\" [hidden]=\"!iconclass\"></i>\n        </div>\n        <div class=\"pull-left\">\n            <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\"></div>\n            <div class=\"description\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n        </div>\n    </h3>\n</div>\n\n<nav class=\"app-datanavigator\" aria-label=\"Page navigation\" *ngIf=\"navigation === 'Inline' && !noDataFound\">\n    <ul class=\"pager\">\n        <li class=\"previous\" [ngClass]=\"{'disabled': (dataNavigator ? dataNavigator.isDisablePrevious : true)}\">\n            <a href=\"javascript:void(0);\" (click)=\"dataNavigator.navigatePage('prev', $event)\">\n                <i class=\"wi wi-chevron-left\" aria-hidden=\"true\"></i>\n                <span class=\"sr-only\">Previous</span>\n            </a>\n        </li>\n    </ul>\n</nav>\n\n<ul tabindex=\"0\" class=\"app-livelist-container clearfix {{listclass}}\"\n    (keydown.enter)=\"handleKeyDown($event, 'select')\"\n\n    (keydown.arrowup)=\"handleKeyDown($event, 'focusPrev')\"\n    (keydown.arrowdown)=\"handleKeyDown($event, 'focusNext')\"\n    (keydown.arrowleft)=\"handleKeyDown($event, 'focusPrev')\"\n    (keydown.arrowright)=\"handleKeyDown($event, 'focusNext')\"\n\n    (keydown.shift.arrowup)=\"handleKeyDown($event, 'selectPrev')\"\n    (keydown.shift.arrowdown)=\"handleKeyDown($event, 'selectNext')\"\n    (keydown.shift.arrowleft)=\"handleKeyDown($event, 'selectPrev')\"\n    (keydown.shift.arrowright)=\"handleKeyDown($event, 'selectNext')\"\n>\n    <ng-template [ngIf]=\"!groupby\" [ngIfElse]=\"groupedListTemplate\">\n        <li *ngFor=\"let item of fieldDefs; index as $index; first as $first; last as $last;\" class=\"app-list-item {{itemsPerRowClass}}\" [ngClass]=\"listItemRef.itemClass\"\n            [wmListItem]=\"item\"\n            #listItemRef=\"listItemRef\"\n            tabindex=\"0\">\n            <ng-container [ngTemplateOutlet]=\"listTemplate\" [ngTemplateOutletContext]=\"{item: item, $index: $index, itemRef: listItemRef, $first: $first, $last: $last, currentItemWidgets: listItemRef.currentItemWidgets}\"></ng-container>\n        </li>\n    </ng-template>\n    <ng-container [ngTemplateOutlet]=\"listLeftActionTemplate\"></ng-container>\n    <ng-container [ngTemplateOutlet]=\"listRightActionTemplate\"></ng-container>\n</ul>\n\n<div class=\"no-data-msg\" *ngIf=\"noDataFound && !variableInflight\" [textContent]=\"nodatamessage\"></div>\n\n<div class=\"loading-data-msg\" *ngIf=\"variableInflight && !pulltorefresh\">\n    <span>\n        <i class=\"app-icon panel-icon fa-spin\" aria-hidden=\"true\" [ngClass]=\"loadingicon\"></i>\n        <span class=\"sr-only\">Loading</span>\n        <span class=\"loading-text\" [textContent]=\"loadingdatamsg\"></span>\n    </span>\n</div>\n\n<nav class=\"app-datanavigator\" *ngIf=\"navigation === 'Inline' && !noDataFound\">\n    <ul class=\"pager\">\n        <li class=\"next\" [ngClass]=\"{'disabled': (dataNavigator ? dataNavigator.isDisableNext  : true)}\">\n            <a href=\"javascript:void(0);\" (click)=\"dataNavigator.navigatePage('next', $event)\">\n                <i class=\"wi wi-chevron-right\" aria-hidden=\"true\"></i>\n                <span class=\"sr-only\">Next</span>\n            </a>\n        </li>\n    </ul>\n</nav>\n\n<div class=\"panel-footer\" *ngIf=\"navigation !== 'None'\" [hidden]=\"!showNavigation || (onDemandLoad && dataNavigator.isDisableNext) || (dataNavigator.dataSize <= pagesize) || !dataNavigator.dataSize\">\n    <nav wmPagination\n         navigationalign.bind=\"navigationalign\"\n         navigation.bind=\"navControls\"\n         showrecordcount.bind=\"showrecordcount\"\n         maxsize.bind=\"maxsize\"\n         boundarylinks.bind=\"boundarylinks\"\n         forceellipses.bind=\"forceellipses\"\n         directionlinks.bind=\"directionlinks\"\n         show.bind=\"!onDemandLoad\"\n         paginationchange.event=\"beforePaginationChange($event, $index)\"\n    ></nav>\n    <a *ngIf=\"onDemandLoad\" href=\"javascript:void(0);\"\n       (click)=\"dataNavigator.navigatePage('next', $event)\"\n       class=\"app-button btn btn-block\"\n       [ngClass]=\"paginationclass\"\n       [textContent]=\"ondemandmessage\"\n    ></a>\n</div>\n\n<!--This template will be displayed when groupby is specified-->\n<ng-template #groupedListTemplate>\n    <li *ngFor=\"let groupObj of groupedData\" class=\"app-list-item-group clearfix\">\n        <ul class=\"list-group item-group\" [ngClass]=\"listclass\">\n            <li class=\"app-list-item-header list-item list-group-header\" (click)=\"handleHeaderClick($event)\" [ngClass]=\"{'collapsible-content': collapsible}\">\n            <h4>{{groupObj.key}}\n                <div class=\"header-action\">\n                    <i class=\"app-icon wi action wi-chevron-up\" *ngIf=\"collapsible\"></i>\n                    <span *ngIf=\"showcount\" class=\"label label-default\">{{groupObj.data.length}}</span>\n                    </div>\n                </h4>\n            </li>\n            <li *ngFor=\"let item of groupObj.data; index as $index; first as $first; last as $last;\" tabindex=\"0\"\n                class=\"app-list-item group-list-item {{itemsPerRowClass}}\"\n                [ngClass]=\"listItemRef.itemClass\"\n                [wmListItem]=\"item\" #listItemRef=\"listItemRef\">\n                <ng-container [ngTemplateOutlet]=\"listTemplate\" [ngTemplateOutletContext]=\"{item: item, $index: $index, itemRef: listItemRef, $first: $first, $last: $last, currentItemWidgets: listItemRef.currentItemWidgets}\"></ng-container>\n            </li>\n        </ul>\n    </li>\n</ng-template>\n",
                providers: [
                    provideAsWidgetRef(ListComponent)
                ]
            }] }
];
/** @nocollapse */
ListComponent.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: ToDatePipe },
    { type: App },
    { type: AppDefaults },
    { type: NgZone },
    { type: String, decorators: [{ type: Attribute, args: ['itemclass.bind',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['disableitem.bind',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['dataset.bind',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['datasource.bind',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['mouseenter.event',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['mouseleave.event',] }] }
];
ListComponent.propDecorators = {
    listTemplate: [{ type: ContentChild, args: ['listTemplate',] }],
    listLeftActionTemplate: [{ type: ContentChild, args: ['listLeftActionTemplate',] }],
    listRightActionTemplate: [{ type: ContentChild, args: ['listRightActionTemplate',] }],
    btnComponents: [{ type: ContentChildren, args: [ButtonComponent,] }],
    dataNavigator: [{ type: ViewChild, args: [PaginationComponent,] }],
    listItems: [{ type: ViewChildren, args: [ListItemDirective,] }]
};

const WIDGET_CONFIG$s = { widgetType: 'wm-form', hostClass: 'panel app-panel app-form' };
const LOGIN_FORM_CONFIG = { widgetType: 'wm-form', hostClass: 'app-form app-login-form' };
const LIVE_FORM_CONFIG = { widgetType: 'wm-liveform', hostClass: 'panel app-panel app-liveform liveform-inline' };
const LIVE_FILTER_CONFIG = { widgetType: 'wm-livefilter', hostClass: 'panel app-panel app-livefilter clearfix liveform-inline' };
const getWidgetConfig = (isLiveForm, isLiveFilter, role) => {
    let config = WIDGET_CONFIG$s;
    if (isLiveForm !== null) {
        config = LIVE_FORM_CONFIG;
    }
    else if (isLiveFilter !== null) {
        config = LIVE_FILTER_CONFIG;
    }
    else if (role === 'app-login') {
        config = LOGIN_FORM_CONFIG;
    }
    return config;
};
// Generate the form field with given field definition. Add a grid column wrapper around the form field.
const setMarkupForFormField = (field, columnWidth) => {
    let propsTmpl = '';
    _.forEach(field, (value, key) => {
        propsTmpl = `${propsTmpl} ${key}="${value}"`;
    });
    return `<wm-gridcolumn columnwidth="${columnWidth}">
                  <wm-form-field ${propsTmpl}></wm-form-field>
            </wm-gridcolumn>`;
};
// Function to find out the first invalid element in form
const findInvalidElement = ($formEle, ngForm) => {
    const $ele = $formEle.find('form.ng-invalid:visible, [formControlName].ng-invalid:visible').first();
    let formObj = ngForm;
    // If element is form, find out the first invalid element in this form
    if ($ele.is('form')) {
        formObj = ngForm && ngForm.controls[$ele.attr('formControlName') || $ele.attr('name')];
        if (formObj) {
            return findInvalidElement($ele, formObj);
        }
    }
    return {
        ngForm: formObj,
        $ele: $ele
    };
};
const setTouchedState = ngForm => {
    if (ngForm.valid) {
        return;
    }
    if (ngForm.controls) {
        _.forEach(ngForm.controls, ctrl => {
            setTouchedState(ctrl);
        });
    }
    else {
        ngForm.markAsTouched();
    }
};
class FormComponent extends StylableComponent {
    constructor(inj, fb, app, dynamicComponentProvider, ngZone, parentList, parentForm, onBeforeSubmitEvt, onSubmitEvt, onBeforeRenderEvt, binddataset, bindformdata, isLiveForm, isLiveFilter, role, key, name) {
        super(inj, getWidgetConfig(isLiveForm, isLiveFilter, role));
        this.fb = fb;
        this.app = app;
        this.dynamicComponentProvider = dynamicComponentProvider;
        this.ngZone = ngZone;
        this.parentList = parentList;
        this.parentForm = parentForm;
        this.onBeforeSubmitEvt = onBeforeSubmitEvt;
        this.onSubmitEvt = onSubmitEvt;
        this.onBeforeRenderEvt = onBeforeRenderEvt;
        this.binddataset = binddataset;
        this.bindformdata = bindformdata;
        this._widgetClass = '';
        this._captionClass = '';
        this.formFields = [];
        this.formfields = {};
        this.formWidgets = {};
        this.filterWidgets = {};
        this.buttonArray = [];
        this.dataoutput = {};
        this.formdata = {};
        this.statusMessage = {
            caption: '',
            type: ''
        };
        this.primaryKey = [];
        this._debouncedUpdateFieldSource = _.debounce(this.updateFieldSource, 350);
        this.validationMessages = [];
        this._debouncedSubmitForm = debounce(($event) => {
            // calling submit event in ngZone as change detection is not triggered post the submit callback and actions like notification are not shown
            this.ngZone.run(() => {
                this.submitForm($event);
            });
        }, 250);
        styler(this.nativeElement, this);
        this.isUpdateMode = true;
        this.dialogId = this.nativeElement.getAttribute('dialogId');
        this.ngform = fb.group({});
        this.addInnerNgFormToForm(key || name);
        // On value change in form, update the dataoutput
        const onValueChangeSubscription = this.ngform.valueChanges
            .subscribe(this.updateDataOutput.bind(this));
        this.registerDestroyListener(() => onValueChangeSubscription.unsubscribe());
        this.elScope = this;
        this.addEventsToContext(this.context);
    }
    set isLayoutDialog(nv) {
        if (nv) {
            removeClass(this.nativeElement, 'panel app-panel liveform-inline');
        }
        this._isLayoutDialog = nv;
    }
    get isLayoutDialog() {
        return this._isLayoutDialog;
    }
    set isUpdateMode(nv) {
        this._isUpdateMode = nv;
        this.formFields.forEach(field => {
            field.setReadOnlyState(nv);
        });
    }
    get isUpdateMode() {
        return this._isUpdateMode;
    }
    submit($event) {
        this._debouncedSubmitForm($event);
    }
    onReset() {
        this.reset();
    }
    ngAfterContentInit() {
        setTimeout(() => {
            this.componentRefs.forEach(componentRef => {
                if (componentRef.name) {
                    // Register widgets inside form with formWidgets
                    this.formWidgets[componentRef.name] = componentRef;
                }
            });
        }, 250);
    }
    findOperationType() { }
    addInnerNgFormToForm(binding) {
        if (this.parentForm && this.parentForm.ngform) {
            let counter = 1;
            let innerBinding = binding;
            // Inner forms may have same names. If same name is present, append unqiue identifier
            while (this.parentForm.ngform.controls.hasOwnProperty(innerBinding)) {
                innerBinding = `${binding}_${counter}`;
                counter++;
            }
            this.formGroupName = innerBinding;
            // If parent form is present, add the current form as as formGroup for parent form
            this.parentForm.ngform.addControl(innerBinding, this.ngform);
        }
    }
    // Expose the events on context so that they can be accessed by form actions
    addEventsToContext(context) {
        context.cancel = () => this.cancel();
        context.reset = () => this.reset();
        context.save = evt => this.save(evt);
        context.saveAndNew = () => this.saveAndNew();
        context.saveAndView = () => this.saveAndView();
        context.delete = () => this.delete();
        context.new = () => this.new();
        context.edit = () => this.edit();
        context.highlightInvalidFields = () => this.highlightInvalidFields();
        context.filter = () => this.filter();
        context.clearFilter = () => this.clearFilter();
        context.submit = evt => this.submit(evt);
    }
    // This method gets all the inner forms and validates each form.
    setValidationOnInnerForms(validateTouch) {
        const formEle = this.getNativeElement();
        const formObjs = formEle.querySelectorAll('.app-form');
        _.forEach(formObjs, e => {
            const formInstance = e.widget;
            // differentiating the validationMessages prefix based on the formGroupName
            // as the formName's are same when forms are in list
            let formName = _.get(formInstance, 'formGroupName') || formInstance.name;
            let current = formInstance;
            while (_.get(current, 'parentForm')) {
                const parentName = current.parentForm.formGroupName || current.parentForm.name;
                formName = parentName + '.' + formName;
                current = current.parentForm;
            }
            this.setValidationOnFields(formInstance, formName, validateTouch);
        });
    }
    /**
     * This method sets validation on formFields.
     * Applies to innerform and also sets innerform validation on parent form.
     * @param prefix contains the form name, which also includes its parents form name
     * @param {boolean} validateTouch
     */
    setValidationOnFields(form, prefix, validateTouch) {
        const controls = form.ngform.controls;
        const formFields = form.formFields;
        if (!formFields) {
            return;
        }
        _.forEach(controls, (v, k) => {
            const field = formFields.find(e => e.key === k);
            if (!field || (validateTouch && !v.touched)) {
                return;
            }
            // invoking the prepareValidation on both parent form and current form.
            this.prepareValidationObj(v, k, field, prefix);
            this.prepareValidationObj.call(form, v, k, field, prefix);
        });
    }
    // Assigns / updates validationMessages based on angular errors on field
    prepareValidationObj(v, k, field, prefix) {
        const index = this.validationMessages.findIndex(e => (e.field === k && e.fullyQualifiedFormName === prefix));
        if (v.invalid) {
            if (index === -1) {
                /**
                 * field contains the fieldName
                 * value contains the field value
                 * errorType contains the list of errors
                 * message contains the validation message
                 * getElement returns the element having focus-target
                 * formName returns the name of the form
                 */
                this.validationMessages.push({
                    field: k,
                    value: field.value,
                    errorType: _.keys(v.errors),
                    message: field.validationmessage || '',
                    getElement: () => {
                        return field.$element.find('[focus-target]');
                    },
                    formName: _.last(prefix.split('.')),
                    fullyQualifiedFormName: prefix
                });
            }
            else {
                this.validationMessages[index].value = field.value;
                this.validationMessages[index].errorType = _.keys(v.errors);
            }
        }
        else if (v.valid && index > -1) {
            this.validationMessages.splice(index, 1);
        }
    }
    // This will return a object containing the error details from the list of formFields that are invalid
    setValidationMsgs(validateTouch) {
        if (!this.formFields.length && _.isEmpty(this.ngform.controls)) {
            return;
        }
        this.setValidationOnFields(this, this.name, validateTouch);
        this.setValidationOnInnerForms(validateTouch);
    }
    // change and blur events are added from the template
    handleEvent(node, eventName, callback, locals) {
        if (eventName !== 'submit') {
            super.handleEvent(this.nativeElement, eventName, callback, locals);
        }
    }
    updateFieldSource() {
        if (this.formdatasource && this.formdatasource.execute(DataSource.Operation.IS_API_AWARE)) {
            return;
        }
        else if (this.formdatasource && !this.formdatasource.twoWayBinding) {
            return;
        }
        this.formFields.forEach(formField => {
            formField.setFormWidget('datavaluesource', this.formdatasource);
            formField.setFormWidget('binddatavalue', `${this.bindformdata}.${formField.key}`);
        });
    }
    // This method loops through the form fields and highlights the invalid fields by setting state to touched
    highlightInvalidFields() {
        setTouchedState(this.ngform);
    }
    // Disable the form submit if form is in invalid state. Highlight all the invalid fields if validation type is default
    validateFieldsOnSubmit() {
        this.setValidationMsgs();
        // Disable the form submit if form is in invalid state. For delete operation, do not check the validation.
        if (this.operationType !== 'delete' && (this.validationtype === 'html' || this.validationtype === 'default')
            && this.ngform && this.ngform.invalid) {
            if (this.ngform.invalid) {
                if (this.validationtype === 'default') {
                    this.highlightInvalidFields();
                }
                // Find the first invalid untoched element and set it to touched.
                // Safari does not form validations. this will ensure that error is shown for user
                const eleForm = findInvalidElement(this.$element, this.ngform);
                const $invalidForm = eleForm.ngForm;
                let $invalidEle = eleForm.$ele;
                $invalidEle = $invalidEle.parent().find('[focus-target]');
                if ($invalidEle.length) {
                    // on save click in page layout liveform, focus of autocomplete widget opens full-screen search.
                    if (!$invalidEle.hasClass('app-search-input')) {
                        $invalidEle.focus();
                    }
                    const ngEle = $invalidForm && $invalidForm.controls[$invalidEle.attr('formControlName') || $invalidEle.attr('name')];
                    if (ngEle && ngEle.markAsTouched) {
                        ngEle.markAsTouched();
                    }
                    $appDigest();
                    return true;
                }
                return true;
            }
            return false;
        }
        return false;
    }
    onPropertyChange(key, nv, ov) {
        switch (key) {
            case 'captionalign':
                this.captionAlignClass = 'align-' + nv;
                break;
            case 'captionposition':
                this.setLayoutConfig();
                break;
            case 'captionwidth':
                this.setLayoutConfig();
                break;
            case 'captionsize':
                this.captionsize = nv;
                break;
            case 'novalidate':
                //  Set validation type based on the novalidate property
                this.widget.validationtype = (nv === true || nv === 'true') ? 'none' : 'default';
                break;
            case 'formdata':
                // For livelist when multiselect is enabled, formdata will be array of objects. In this case consider the last object as formdata.
                _.isArray(nv) ? this.setFormData(_.last(nv)) : this.setFormData(nv);
                // if dataset on the formFields are not set as the datasourceChange is triggered before the formFields are registered.
                if (!this.isDataSourceUpdated && this.datasource) {
                    this.onDataSourceChange();
                }
                break;
            case 'defaultmode':
                if (!this.isLayoutDialog) {
                    if (nv && nv === 'Edit') {
                        this.updateMode = true;
                    }
                    else {
                        this.updateMode = false;
                    }
                    this.isUpdateMode = this.updateMode;
                }
                break;
            case 'datasource':
                this.onDataSourceChange();
                break;
            case 'formdatasource':
                this.onFormDataSourceChange();
                break;
            case 'metadata':
                this.generateFormFields();
                break;
            default:
                super.onPropertyChange(key, nv, ov);
        }
    }
    // Event callbacks on success/error
    onResult(data, status, event) {
        const params = { $event: event, $data: data, $operation: this.operationType };
        // whether service call success or failure call this method
        this.invokeEventCallback('result', params);
        if (status) {
            // if service call is success call this method
            this.invokeEventCallback('success', params);
        }
        else {
            // if service call fails call this method
            this.invokeEventCallback('error', params);
        }
    }
    // Display or hide the inline message/ toaster
    toggleMessage(show, msg, type, header) {
        let template;
        if (show && msg) {
            template = (type === 'error' && this.errormessage) ? this.errormessage : msg;
            if (this.messagelayout === 'Inline') {
                this.statusMessage = { 'caption': template || '', type: type };
                if (this.messageRef) {
                    this.messageRef.showMessage(this.statusMessage.caption, this.statusMessage.type);
                }
            }
            else {
                this.app.notifyApp(template, type, header);
            }
        }
        else {
            this.statusMessage.caption = '';
        }
    }
    // Hide the inline message/ toaster
    clearMessage() {
        this.toggleMessage(false);
    }
    // Set the classes on the form based on the captionposition and captionwidth properties
    setLayoutConfig() {
        let layoutConfig;
        layoutConfig = getFieldLayoutConfig(this.captionwidth, this.captionposition, _.get(this.app.selectedViewPort, 'os'));
        this._widgetClass = layoutConfig.widgetCls;
        this._captionClass = layoutConfig.captionCls;
        $appDigest();
    }
    registerFormWidget(widget) {
        const name = widget.name || widget.key;
        this.formWidgets[name] = widget;
    }
    registerFormFields(formField) {
        this.formFields.push(formField);
        this.formfields[formField.key] = formField;
        this.registerFormWidget(formField);
        this._debouncedUpdateFieldSource();
        if (this.parentForm) {
            this.parentForm.formFields.push(formField);
            this.parentForm.formfields[formField.key] = formField;
        }
    }
    registerActions(formAction) {
        this.buttonArray.push(formAction);
    }
    // Update the dataoutput whenever there is a change in inside form widget value
    updateFormDataOutput(dataObject) {
        // Set the values of the widgets inside the live form (other than form fields) in form data
        _.forEach(this.ngform.value, (val, key) => {
            if (!_.find(this.formFields, { key })) {
                dataObject[key] = val;
            }
        });
        this.dataoutput = dataObject;
    }
    // Construct the data object merging the form fields and custom widgets data
    constructDataObject() {
        const formData = {};
        const formFields = this.getFormFields();
        // Get all form fields and prepare form data as key value pairs
        formFields.forEach(field => {
            let fieldName, fieldValue;
            fieldValue = field.datavalue || field._control.value;
            fieldValue = (fieldValue === null || fieldValue === '') ? undefined : fieldValue;
            if (field.type === 'file') {
                fieldValue = getFiles(this.name, field.key + '_formWidget', field.multiple);
            }
            fieldName = field.key || field.target || field.name;
            // In case of update the field will be already present in form data
            _.set(formData, fieldName, fieldValue);
        });
        this.updateFormDataOutput(formData);
        return this.dataoutput;
    }
    updateDataOutput() {
        this.constructDataObject();
        if (this.ngform.touched) {
            this.setValidationMsgs(true);
        }
    }
    // FormFields will contain all the fields in parent and inner form also.
    // This returns the formFields in the form based on the form name.
    getFormFields() {
        return _.filter(this.formFields, formField => {
            return formField.form.name === this.name;
        });
    }
    setFormData(data) {
        const formFields = this.getFormFields();
        formFields.forEach(field => {
            field.value = _.get(data, field.key || field.name);
        });
        this.constructDataObject();
    }
    resetFormState() {
        // clearing the validationMessages on reset.
        if (this.validationMessages.length) {
            this.validationMessages = [];
        }
        if (!this.ngform) {
            return;
        }
        setTimeout(() => {
            this.ngform.markAsUntouched();
            this.ngform.markAsPristine();
        });
    }
    reset() {
        this.resetFormState();
        this.formFields.forEach(field => {
            field.value = '';
        });
        this.constructDataObject();
        this.clearMessage();
    }
    submitForm($event) {
        let formData, template, params;
        const dataSource = this.datasource;
        // Disable the form submit if form is in invalid state.
        if (this.validateFieldsOnSubmit()) {
            return;
        }
        this.resetFormState();
        formData = getClonedObject(this.constructDataObject());
        params = { $event, $formData: formData, $data: formData };
        if (this.onBeforeSubmitEvt && (this.invokeEventCallback('beforesubmit', params) === false)) {
            return;
        }
        if (this.onSubmitEvt || dataSource) {
            // If on submit is there execute it and if it returns true do service variable invoke else return
            // If its a service variable call setInput and assign form data and invoke the service
            if (dataSource) {
                performDataOperation(dataSource, formData, {})
                    .then((data) => {
                    this.onResult(data, true, $event);
                    this.toggleMessage(true, this.postmessage, 'success');
                    this.invokeEventCallback('submit', params);
                }, (error) => {
                    template = this.errormessage || error.error || error;
                    this.onResult(error, false, $event);
                    this.toggleMessage(true, template, 'error');
                    this.invokeEventCallback('submit', params);
                    $appDigest();
                });
            }
            else {
                this.onResult({}, true, $event);
                this.invokeEventCallback('submit', params);
            }
        }
        else {
            this.onResult({}, true, $event);
        }
    }
    // Method to show/hide the panel header or footer based on the buttons
    showButtons(position) {
        return _.some(this.buttonArray, btn => {
            return _.includes(btn.position, position) && btn.updateMode === this.isUpdateMode;
        });
    }
    // Expand or collapse the panel
    expandCollapsePanel() {
        if (this.collapsible) {
            // flip the active flag
            this.expanded = !this.expanded;
        }
    }
    // On form data source change. This method is overridden by live form and live filter
    onDataSourceChange() {
    }
    // On form data source change. This method is overridden by live form and live filter
    onFormDataSourceChange() {
        this.updateFieldSource();
    }
    // On form field default value change. This method is overridden by live form and live filter
    onFieldDefaultValueChange(field, nv) {
        field.value = parseValueByType(nv, undefined, field.widgettype);
    }
    // On form field value change. This method is overridden by live form and live filter
    onFieldValueChange() {
    }
    // Function to generate and compile the form fields from the metadata
    generateFormFields() {
        return __awaiter(this, void 0, void 0, function* () {
            let noOfColumns;
            let $gridLayout;
            // Check if grid layout is present or not for first time
            if (_.isUndefined(this._isGridLayoutPresent)) {
                this._isGridLayoutPresent = this.$element.find('.panel-body [wmlayoutgrid]').length > 0;
            }
            if (this._isGridLayoutPresent) {
                $gridLayout = this.$element.find('.form-elements [wmlayoutgrid]:first');
                noOfColumns = Number($gridLayout.attr('columns')) || 1;
            }
            else {
                $gridLayout = this.$element.find('.form-elements .dynamic-form-container');
                if (!$gridLayout.length) {
                    this.$element.find('.form-elements').prepend('<div class="dynamic-form-container"></div>');
                    $gridLayout = this.$element.find('.form-elements .dynamic-form-container');
                }
                noOfColumns = 1;
            }
            const columnWidth = 12 / noOfColumns;
            let fieldTemplate = '';
            let colCount = 0;
            let index;
            let userFields;
            let fields = this.metadata ? this.metadata.data || this.metadata : [];
            this.formFields = []; // empty the form fields
            if (_.isEmpty(fields)) {
                return;
            }
            if (this.onBeforeRenderEvt) {
                userFields = this.invokeEventCallback('beforerender', { $metadata: fields });
                if (userFields) {
                    fields = userFields;
                }
            }
            if (!_.isArray(fields)) {
                return;
            }
            while (fields[colCount]) {
                let colTmpl = '';
                for (index = 0; index < noOfColumns; index++) {
                    if (fields[colCount]) {
                        colTmpl += setMarkupForFormField(fields[colCount], columnWidth);
                    }
                    colCount++;
                }
                fieldTemplate += `<wm-gridrow>${colTmpl}</wm-gridrow>`;
            }
            if (!this._isGridLayoutPresent) {
                fieldTemplate = `<wm-layoutgrid>${fieldTemplate}</wm-layoutgrid>`;
            }
            this.dynamicFormRef.clear();
            if (!this._dynamicContext) {
                this._dynamicContext = Object.create(this.viewParent);
                this._dynamicContext.form = this;
            }
            const componentFactoryRef = yield this.dynamicComponentProvider.getComponentFactoryRef('app-form-dynamic-' + this.widgetId, fieldTemplate, {
                noCache: true,
                transpile: true
            });
            const component = this.dynamicFormRef.createComponent(componentFactoryRef, 0, this.inj);
            extendProto(component.instance, this._dynamicContext);
            $gridLayout[0].appendChild(component.location.nativeElement);
            this.setFormData(this.formdata);
        });
    }
    get mode() {
        return this.operationType || this.findOperationType();
    }
    get dirty() {
        return this.ngform && this.ngform.dirty;
    }
    get invalid() {
        return this.ngform && this.ngform.invalid;
    }
    get touched() {
        return this.ngform && this.ngform.touched;
    }
    invokeActionEvent($event, expression) {
        const fn = $parseEvent(expression);
        fn(this.viewParent, Object.assign(this.context, { $event }));
    }
}
FormComponent.initializeProps = registerFormProps();
FormComponent.decorators = [
    { type: Component, args: [{
                selector: 'form[wmForm]',
                template: "<ng-template #content><ng-content></ng-content></ng-template>\n\n<ng-container *ngIf=\"formlayout === 'page'; then pageLayoutTemplate else defaultTemplate\">\n</ng-container>\n\n<ng-template #defaultTemplate>\n    <div class=\"panel-heading\" *ngIf=\"!isLayoutDialog && (title || subheading || iconclass || showButtons('header'))\">\n        <h3 class=\"panel-title\">\n            <div class=\"pull-left\">\n                <i class=\"app-icon panel-icon\" aria-hidden=\"true\" [ngClass]=\"iconclass\" *ngIf=\"iconclass\"></i>\n            </div>\n            <div class=\"pull-left\">\n                <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\"></div>\n                <div class=\"description\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n            </div>\n            <div class=\"form-action panel-actions basic-btn-grp\">\n                <ng-container *ngFor=\"let btn of buttonArray | filter : 'position' : 'header'\"\n                              [ngTemplateOutlet]=\"btn.widgetType === 'button' ? buttonRef : anchorRef\" [ngTemplateOutletContext]=\"{btn:btn}\">\n                </ng-container>\n                <button type=\"button\" class=\"app-icon wi panel-action\" *ngIf=\"collapsible\" title=\"Collapse/Expand\"\n                        [ngClass]=\"expanded ? 'wi-minus': 'wi-plus'\" (click)=\"expandCollapsePanel();\"></button>\n            </div>\n        </h3>\n    </div>\n    <div class=\"panel-body\" [ngClass]=\"{'form-elements': isLayoutDialog, 'form-body': !isLayoutDialog}\" [class.hidden]=\"!expanded\">\n        <p wmMessage [hidden]=\"!statusMessage.caption.toString()\" caption.bind=\"statusMessage.caption\" type.bind=\"statusMessage.type\"></p>\n        <div [ngClass]=\"{'form-elements': !isLayoutDialog, 'form-content': isLayoutDialog}\">\n            <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n        </div>\n        <div class=\"basic-btn-grp form-action panel-footer clearfix\" [ngClass]=\"{'modal-footer': isLayoutDialog}\" [class.hidden]=\"!expanded || !showButtons('footer')\">\n            <ng-container *ngFor=\"let btn of buttonArray | filter : 'position' : 'footer'\"\n                          [ngTemplateOutlet]=\"btn.widgetType === 'button' ? buttonRef : anchorRef\" [ngTemplateOutletContext]=\"{btn:btn}\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #pageLayoutTemplate>\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</ng-template>\n\n<ng-template #buttonRef let-btn=\"btn\">\n    <button  wmButton name=\"{{btn.key}}\" caption.bind=\"btn.displayName\" class.bind=\"btn.class\" iconclass.bind=\"btn.iconclass\" show.bind=\"btn.show\"\n             (click)=\"invokeActionEvent($event, btn.action)\" type.bind=\"btn.type\" hint.bind=\"btn.title\" shortcutkey.bind=\"btn.shortcutkey\" disabled.bind=\"btn.disabled\"\n             tabindex.bind=\"btn.tabindex\" [class.hidden]=\"btn.updateMode ? !isUpdateMode : isUpdateMode\"></button>\n</ng-template>\n\n<ng-template #anchorRef let-btn=\"btn\">\n    <a wmAnchor name=\"{{btn.key}}\" caption.bind=\"btn.displayName\" class.bind=\"btn.class\" iconclass.bind=\"btn.iconclass\" show.bind=\"btn.show\"\n             (click)=\"invokeActionEvent($event, btn.action)\" hint.bind=\"btn.title\" shortcutkey.bind=\"btn.shortcutkey\"\n             hyperlink.bind=\"btn.hyperlink\" target.bind=\"btn.target\"\n             tabindex.bind=\"btn.tabindex\" [class.hidden]=\"btn.updateMode ? !isUpdateMode : isUpdateMode\"></a>\n</ng-template>\n\n<ng-container #dynamicForm></ng-container>",
                providers: [
                    provideAsWidgetRef(FormComponent)
                ]
            }] }
];
/** @nocollapse */
FormComponent.ctorParameters = () => [
    { type: Injector },
    { type: FormBuilder },
    { type: App },
    { type: DynamicComponentRefProvider },
    { type: NgZone },
    { type: ListComponent, decorators: [{ type: Optional }] },
    { type: FormComponent, decorators: [{ type: SkipSelf }, { type: Optional }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['beforesubmit.event',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['submit.event',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['beforerender.event',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['dataset.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['formdata.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['wmLiveForm',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['wmLiveFilter',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['role',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['key',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['name',] }] }
];
FormComponent.propDecorators = {
    dynamicFormRef: [{ type: ViewChild, args: ['dynamicForm', { read: ViewContainerRef },] }],
    messageRef: [{ type: ViewChild, args: [MessageComponent,] }],
    componentRefs: [{ type: ContentChildren, args: [WidgetRef, { descendants: true },] }],
    action: [{ type: HostBinding, args: ['action',] }],
    submit: [{ type: HostListener, args: ['submit', ['$event'],] }],
    onReset: [{ type: HostListener, args: ['reset',] }]
};

class DependsonDirective {
    constructor(dialogId, dependson, dialogService, app) {
        this.dialogService = dialogService;
        this.app = app;
        // If dialogId is present, form is in dialog mode
        if (dialogId) {
            this.isLayoutDialog = true;
            this.dialogId = dialogId;
        }
        this.dependson = dependson;
        // Listen to the wm-event called from subscribed widgets
        this.eventSubscription = this.app.subscribe('wm-event', this.handleEvent.bind(this));
    }
    openFormDialog() {
        this.dialogService.open(this.dialogId);
    }
    onUpdate() {
        this.form.operationType = Live_Operations.UPDATE;
        this.form.isSelected = true;
        this.form.edit();
    }
    onInsert() {
        this.form.operationType = Live_Operations.INSERT;
        this.form.isSelected = true;
        this.form.new();
    }
    handleEvent(options) {
        if (this.dependson !== options.widgetName) {
            return;
        }
        this.currentOp = options.eventName;
        switch (options.eventName) {
            case Live_Operations.UPDATE:
                if (this.isLayoutDialog) {
                    this.openFormDialog();
                }
                else {
                    this.onUpdate();
                }
                break;
            case Live_Operations.INSERT:
                if (this.isLayoutDialog) {
                    this.openFormDialog();
                }
                else {
                    this.onInsert();
                }
                break;
            case Live_Operations.DELETE:
                this.app.Widgets[this.dependson].call('delete', { row: options.row });
                break;
            case Live_Operations.READ:
                if (!this.isLayoutDialog) {
                    this.form.isUpdateMode = false;
                }
                break;
        }
    }
    onFormRender() {
        // On opening the form in dialog mode, complete the pending operations
        if (this.form && this.isLayoutDialog) {
            setTimeout(() => {
                if (this.currentOp === Live_Operations.UPDATE) {
                    this.onUpdate();
                }
                else if (this.currentOp === Live_Operations.INSERT) {
                    this.onInsert();
                }
            }, 250);
        }
    }
    ngAfterContentInit() {
        // If form instance is present, form is in inline mode. Else, it is in dialog mode and listen to form instance changes
        if (this.formChildren.first) {
            this.form = this.formChildren.first;
        }
        else {
            this.formSubscription = this.formChildren.changes.subscribe((val) => {
                this.form = val.first;
                this.onFormRender();
            });
        }
    }
    ngOnDestroy() {
        if (this.formSubscription) {
            this.formSubscription.unsubscribe();
        }
        if (this.eventSubscription) {
            this.eventSubscription();
        }
    }
}
DependsonDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dependson]'
            },] }
];
/** @nocollapse */
DependsonDirective.ctorParameters = () => [
    { type: String, decorators: [{ type: Attribute, args: ['dialogid',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['dependson',] }] },
    { type: AbstractDialogService },
    { type: App }
];
DependsonDirective.propDecorators = {
    formChildren: [{ type: ContentChildren, args: [FormComponent, { descendants: true },] }]
};

const registerProps$u = () => {
    register('wm-dialog', new Map([
        ['animation', PROP_STRING],
        ['class', PROP_STRING],
        ['closable', { value: true, PROP_BOOLEAN }],
        ['iconclass', { value: 'wi wi-file-text', PROP_STRING }],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['modal', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['name', PROP_STRING],
        ['showheader', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', Object.assign({ value: 'Information' }, PROP_STRING)],
        ['eventsource', PROP_ANY]
    ]));
};

const DIALOG_CLS$2 = 'app-dialog modal-dialog';
const WIDGET_INFO$2 = { widgetType: 'wm-dialog' };
const ɵ0$e = {};
class DialogComponent extends BaseDialog {
    constructor(inj, dialogClass, modal, closable, contexts) {
        if (modal === null || modal === undefined) {
            modal = true;
        }
        if (closable === null || closable === undefined) {
            closable = true;
        }
        // contexts[0] will refer to the self context provided by this component
        contexts[0].closeDialog = () => this.close();
        // setting the backdrop to 'static' will not close the dialog on backdrop click
        const backdrop = toBoolean(modal) ? 'static' : true;
        super(inj, WIDGET_INFO$2, {
            class: `${DIALOG_CLS$2} ${dialogClass || ''}`,
            backdrop,
            keyboard: !toBoolean(modal)
        });
    }
    getTemplateRef() {
        return this.dialogTemplate;
    }
    ngOnInit() {
        super.ngOnInit();
        this.register(this.viewParent);
    }
}
DialogComponent.initializeProps = registerProps$u();
DialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmDialog]',
                template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"\n         *ngIf=\"showheader\"\n    ></div>\n    <div wmDialogBody>\n        <ng-container *ngTemplateOutlet=\"dialogBody\"></ng-container>\n    </div>\n    <ng-container *ngTemplateOutlet=\"dialogFooter\"></ng-container>\n</ng-template>",
                providers: [
                    provideAsWidgetRef(DialogComponent),
                    provideAsDialogRef(DialogComponent),
                    { provide: Context, useValue: ɵ0$e, multi: true }
                ]
            }] }
];
/** @nocollapse */
DialogComponent.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Attribute, args: ['class',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['modal',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['closable',] }] },
    { type: Array, decorators: [{ type: Self }, { type: Inject, args: [Context,] }] }
];
DialogComponent.propDecorators = {
    dialogTemplate: [{ type: ViewChild, args: ['dialogTemplate', { read: TemplateRef },] }],
    dialogBody: [{ type: ContentChild, args: ['dialogBody', { read: TemplateRef },] }],
    dialogFooter: [{ type: ContentChild, args: ['dialogFooter', { read: TemplateRef },] }]
};

const DEFAULT_CLS$o = 'app-dialog-body modal-body';
class DialogBodyDirective {
    constructor(elRef, dialogRef, bsModal) {
        this.dialogRef = dialogRef;
        addClass(elRef.nativeElement, DEFAULT_CLS$o);
        const subscription = bsModal.onShown.subscribe(() => {
            const dialogRoot = $(elRef.nativeElement).closest('.app-dialog')[0];
            const width = this.dialogRef.width;
            if (dialogRoot) {
                if (width) {
                    setCSS(dialogRoot, 'width', width);
                }
                setAttr(dialogRoot, 'tabindex', this.dialogRef.tabindex);
                setAttr(dialogRoot, 'name', this.dialogRef.name);
            }
            subscription.unsubscribe();
        });
    }
}
DialogBodyDirective.decorators = [
    { type: Directive, args: [{
                selector: 'div[wmDialogBody]',
            },] }
];
/** @nocollapse */
DialogBodyDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DialogRef,] }] },
    { type: BsModalService }
];
DialogBodyDirective.propDecorators = {
    height: [{ type: HostBinding, args: ['style.height',] }]
};

const registerProps$v = () => {
    register('wm-dialogfooter', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const WIDGET_INFO$3 = {
    widgetType: 'wm-dialogfooter',
    hostClass: 'app-dialog-footer modal-footer'
};
class DialogFooterDirective extends BaseComponent {
    constructor(inj) {
        super(inj, WIDGET_INFO$3);
    }
}
DialogFooterDirective.initializeProps = registerProps$v();
DialogFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'div[wmDialogFooter]',
                providers: [
                    provideAsWidgetRef(DialogFooterDirective)
                ]
            },] }
];
/** @nocollapse */
DialogFooterDirective.ctorParameters = () => [
    { type: Injector }
];

const DEFAULT_CLS$p = 'app-dialog-header modal-header';
const DEFAULT_ICON_DIMENSIONS = '21px';
class DialogHeaderComponent {
    constructor(elRef, dialogRef) {
        this.dialogRef = dialogRef;
        this.iconwidth = DEFAULT_ICON_DIMENSIONS;
        this.iconheight = DEFAULT_ICON_DIMENSIONS;
        this.closable = true;
        addClass(elRef.nativeElement, DEFAULT_CLS$p);
    }
    get isClosable() {
        return toBoolean(this.closable);
    }
    closeDialog() {
        this.dialogRef.close();
    }
}
DialogHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmDialogHeader]',
                template: "<button *ngIf=\"isClosable\" aria-label=\"Close\" class=\"app-dialog-close close\" (click)=\"closeDialog();\" title=\"Close\">\n    <span aria-hidden=\"true\">&times;</span>\n</button>\n<h4 class=\"app-dialog-title modal-title\">\n    <i [ngClass]=\"iconclass\" [ngStyle]=\"{width: iconwidth, height: iconheight, margin: iconmargin}\"  *ngIf=\"iconclass && !iconurl\"></i>\n    <img data-identifier=\"img\" [src]=\"iconurl | image\" *ngIf=\"iconurl\" [ngStyle]=\"{width:iconwidth, height:iconheight, margin:iconmargin}\"/>\n    <span class=\"dialog-heading\" [textContent]=\"heading\"></span>\n    <span class=\"dialog-sub-heading\" *ngIf=\"subheading\" [title]=\"subheading\" [textContent]=\"subheading\"></span>\n</h4>"
            }] }
];
/** @nocollapse */
DialogHeaderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: BaseDialog, decorators: [{ type: Inject, args: [DialogRef,] }] }
];
DialogHeaderComponent.propDecorators = {
    iconwidth: [{ type: Input }],
    iconheight: [{ type: Input }],
    iconmargin: [{ type: Input }],
    iconclass: [{ type: Input }],
    iconurl: [{ type: Input }],
    closable: [{ type: Input }],
    heading: [{ type: Input }],
    subheading: [{ type: Input }]
};

const registerProps$w = () => {
    register('wm-footer', new Map([
        ['name', PROP_STRING],
        ['class', PROP_STRING],
        ['content', PROP_STRING]
    ]));
};

const DEFAULT_CLS$q = 'app-footer clearfix';
const WIDGET_CONFIG$t = {
    widgetType: 'wm-footer',
    hostClass: DEFAULT_CLS$q
};
class FooterDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$t);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
FooterDirective.initializeProps = registerProps$w();
FooterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmFooter]',
                providers: [
                    provideAsWidgetRef(FooterDirective)
                ]
            },] }
];
/** @nocollapse */
FooterDirective.ctorParameters = () => [
    { type: Injector }
];

const registerProps$x = () => {
    register('wm-form-action', new Map([
        ['accessroles', PROP_STRING],
        ['action', PROP_STRING],
        ['class', PROP_STRING],
        ['binding', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['display-name', PROP_STRING],
        ['hyperlink', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['iconname', PROP_STRING],
        ['key', PROP_STRING],
        ['position', Object.assign({ value: 'footer' }, PROP_STRING)],
        ['shortcutkey', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['target', PROP_STRING],
        ['title', PROP_STRING],
        ['type', Object.assign({ value: 'button' }, PROP_STRING)],
        ['update-mode', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['widget-type', Object.assign({ value: 'button' }, PROP_STRING)]
    ]));
};

const WIDGET_CONFIG$u = { widgetType: 'wm-form-action', hostClass: '' };
class FormActionDirective extends BaseComponent {
    constructor(inj, form) {
        super(inj, WIDGET_CONFIG$u);
        this.form = form;
    }
    populateAction() {
        this.buttonDef = {
            key: this.key || this.binding,
            displayName: this['display-name'],
            show: this.show,
            class: this.class ? this.class : (this['widget-type'] === 'button' ? 'btn-secondary' : ''),
            iconclass: this.iconclass || '',
            title: _.isUndefined(this.title) ? (this['display-name'] || '') : this.title,
            action: this.action,
            accessroles: this.accessroles,
            shortcutkey: this.shortcutkey,
            disabled: this.disabled,
            tabindex: this.tabindex,
            iconname: this.iconname,
            type: this.type,
            updateMode: this['update-mode'],
            position: this.position,
            widgetType: this['widget-type'],
            hyperlink: this.hyperlink,
            target: this.target
        };
        this._propsInitialized = true;
    }
    ngOnInit() {
        super.ngOnInit();
        this.populateAction();
        this.form.registerActions(this.buttonDef);
    }
    onPropertyChange(key, nv, ov) {
        if (!this._propsInitialized) {
            return;
        }
        switch (key) {
            case 'display-name':
                this.buttonDef.displayName = nv;
            default:
                this.buttonDef[key] = nv;
                break;
        }
    }
}
FormActionDirective.initializeProps = registerProps$x();
FormActionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmFormAction]',
                providers: [
                    provideAsWidgetRef(FormActionDirective)
                ]
            },] }
];
/** @nocollapse */
FormActionDirective.ctorParameters = () => [
    { type: Injector },
    { type: FormComponent, decorators: [{ type: Optional }] }
];

const colorPickerProps = new Map([
    ['class', PROP_STRING],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['name', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Select Color' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)]
]);

const numberProps = new Map([
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['localefilter', PROP_STRING],
    ['minvalue', PROP_NUMBER],
    ['maxvalue', PROP_NUMBER],
    ['name', PROP_STRING],
    ['numberfilter', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Enter number' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['regexp', PROP_STRING],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['step', Object.assign({ value: 1 }, PROP_NUMBER)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['updateon', PROP_STRING]
]);
const registerProps$z = () => {
    register('wm-number', numberProps);
};

const inputNumberTypeProps = new Map([
    ['autocomplete', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['maxchars', PROP_NUMBER],
    ['maxvalue', PROP_NUMBER],
    ['minvalue', PROP_NUMBER],
    ['name', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Enter text' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['regexp', PROP_STRING],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['step', PROP_NUMBER],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['type', PROP_STRING],
    ['updateon', PROP_STRING]
]);
const registerProps$A = () => {
    register('wm-input-number', inputNumberTypeProps);
};

const inputTextTypeProps = new Map([
    ['autocomplete', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['displayformat', PROP_STRING],
    ['hint', PROP_STRING],
    ['maxchars', PROP_NUMBER],
    ['name', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Enter text' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['regexp', PROP_STRING],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['type', Object.assign({ value: 'text' }, PROP_STRING)],
    ['updateon', PROP_STRING]
]);
const registerProps$B = () => {
    register('wm-input-text', inputTextTypeProps);
};

const inputCalendarTypeProps = new Map([
    ['autocomplete', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datasource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['maxvalue', PROP_NUMBER],
    ['minvalue', PROP_NUMBER],
    ['name', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Enter text' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['step', PROP_NUMBER],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['type', PROP_STRING],
    ['updateon', PROP_STRING]
]);
const registerProps$C = () => {
    register('wm-input-calendar', inputCalendarTypeProps);
};

const inputColorTypeProps = new Map([
    ['autocomplete', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['name', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Enter text' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['type', PROP_STRING],
    ['updateon', PROP_STRING]
]);
const registerProps$D = () => {
    register('wm-input-color', inputColorTypeProps);
};

const inputEmailTypeProps = new Map([
    ['autocomplete', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['maxchars', PROP_NUMBER],
    ['name', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Enter text' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['regexp', PROP_STRING],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['type', PROP_STRING],
    ['updateon', PROP_STRING]
]);
const registerProps$E = () => {
    register('wm-input-email', inputEmailTypeProps);
};

const radiosetProps = new Map([
    ['class', PROP_STRING],
    ['compareby', PROP_STRING],
    ['datafield', PROP_STRING],
    ['dataset', Object.assign({ value: 'Option 1, Option 2, Option 3' }, PROP_ANY)],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['displayexpression', PROP_STRING],
    ['displayfield', PROP_STRING],
    ['displayValue', PROP_STRING],
    ['itemclass', Object.assign({ value: '' }, PROP_STRING)],
    ['layout', Object.assign({ value: 'stacked' }, PROP_STRING)],
    ['listclass', Object.assign({ value: '' }, PROP_STRING)],
    ['name', PROP_STRING],
    ['orderby', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showindevice', Object.assign({ displayType: 'inline-block', value: 'all' }, PROP_STRING)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['usekeys', PROP_BOOLEAN]
]);
const registerProps$F = () => {
    register('wm-radioset', radiosetProps);
};

const ratingProps = new Map([
    ['caption', PROP_STRING],
    ['class', PROP_STRING],
    ['datafield', PROP_STRING],
    ['dataset', PROP_ANY],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['displayexpression', PROP_STRING],
    ['displayfield', PROP_STRING],
    ['hint', PROP_STRING],
    ['iconcolor', PROP_STRING],
    ['iconsize', PROP_STRING],
    ['maxvalue', Object.assign({ value: 5 }, PROP_NUMBER)],
    ['name', PROP_STRING],
    ['orderby', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showcaptions', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['usekeys', PROP_BOOLEAN]
]);

const richTextProps = new Map([
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['height', PROP_STRING],
    ['name', PROP_STRING],
    ['placeholder', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showpreview', Object.assign({ value: false }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)]
]);
const registerProps$H = () => {
    register('wm-richtexteditor', richTextProps);
};

const selectProps = new Map([
    ['autofocus', PROP_BOOLEAN],
    ['class', Object.assign({ value: '' }, PROP_STRING)],
    ['compareby', PROP_STRING],
    ['datafield', PROP_STRING],
    ['dataset', PROP_ANY],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['displayexpression', PROP_STRING],
    ['displayfield', PROP_STRING],
    ['displayValue', PROP_STRING],
    ['hint', PROP_STRING],
    ['multiple', Object.assign({ value: false }, PROP_BOOLEAN)],
    ['name', PROP_STRING],
    ['orderby', PROP_STRING],
    ['placeholder', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['usekeys', PROP_BOOLEAN]
]);
const registerProps$I = () => {
    register('wm-select', selectProps);
};

const sliderProps = new Map([
    ['class', PROP_STRING],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['maxvalue', PROP_NUMBER],
    ['minvalue', PROP_NUMBER],
    ['name', PROP_STRING],
    ['readonly', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['step', PROP_NUMBER],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)]
]);

const switchProps = new Map([
    ['class', PROP_STRING],
    ['compareby', PROP_STRING],
    ['datafield', PROP_STRING],
    ['dataset', Object.assign({ value: 'yes, no, maybe' }, PROP_ANY)],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['displayexpression', PROP_STRING],
    ['displayfield', PROP_STRING],
    ['hint', PROP_STRING],
    ['iconclass', PROP_STRING],
    ['name', PROP_STRING],
    ['orderby', PROP_STRING],
    ['required', PROP_BOOLEAN],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)]
]);
const registerProps$K = () => {
    register('wm-switch', switchProps);
};

const textareaProps = new Map([
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['maxchars', PROP_NUMBER],
    ['name', PROP_STRING],
    ['placeholder', Object.assign({ value: 'Place your text' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['updateon', PROP_STRING]
]);
const registerProps$L = () => {
    register('wm-textarea', textareaProps);
};

const timeProps = new Map([
    ['autofocus', PROP_BOOLEAN],
    ['class', PROP_STRING],
    ['datavaluesource', PROP_ANY],
    ['datavalue', PROP_STRING],
    ['disabled', PROP_BOOLEAN],
    ['hint', PROP_STRING],
    ['hourstep', Object.assign({ value: 1 }, PROP_NUMBER)],
    ['maxtime', PROP_STRING],
    ['mintime', PROP_STRING],
    ['minutestep', Object.assign({ value: 15 }, PROP_NUMBER)],
    ['name', PROP_STRING],
    ['outputformat', Object.assign({ value: 'HH:mm:ss' }, PROP_STRING)],
    ['placeholder', Object.assign({ value: 'Select time' }, PROP_STRING)],
    ['readonly', PROP_BOOLEAN],
    ['required', PROP_BOOLEAN],
    ['shortcutkey', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ['showdropdownon', Object.assign({ value: 'default' }, PROP_STRING)],
    ['secondsstep', Object.assign({ value: 1 }, PROP_NUMBER)],
    ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
    ['timepattern', PROP_STRING],
    ['timestamp', PROP_STRING]
]);
const registerProps$M = () => {
    if (isMobileApp()) {
        timeProps.set('timepattern', Object.assign({ value: 'HH:mm' }, PROP_STRING));
    }
    register('wm-time', timeProps);
};

const registerProps$N = () => {
    const uploadProps = new Map([
        ['disabled', PROP_BOOLEAN],
        ['extensions', PROP_STRING],
        ['filetype', PROP_STRING],
        ['multiple', PROP_BOOLEAN],
        ['readonly', PROP_BOOLEAN],
        ['required', PROP_BOOLEAN]
    ]);
    const textProps = new Map(inputTextTypeProps);
    const mergeTextProps = (typeProps) => {
        typeProps.forEach((v, k) => textProps.set(k, v));
    };
    mergeTextProps(inputCalendarTypeProps);
    mergeTextProps(inputColorTypeProps);
    mergeTextProps(inputEmailTypeProps);
    mergeTextProps(inputNumberTypeProps);
    const widgetPropsMap = new Map([
        [FormWidgetType.AUTOCOMPLETE, searchProps],
        [FormWidgetType.CHECKBOX, checkboxProps],
        [FormWidgetType.CHECKBOXSET, checkboxsetProps],
        [FormWidgetType.CHIPS, chipsProps],
        [FormWidgetType.COLORPICKER, colorPickerProps],
        [FormWidgetType.CURRENCY, currencyProps],
        [FormWidgetType.DATE, dateProps],
        [FormWidgetType.DATETIME, dateTimeProps],
        [FormWidgetType.NUMBER, numberProps],
        [FormWidgetType.PASSWORD, inputTextTypeProps],
        [FormWidgetType.RADIOSET, radiosetProps],
        [FormWidgetType.RATING, ratingProps],
        [FormWidgetType.RICHTEXT, richTextProps],
        [FormWidgetType.SELECT, selectProps],
        [FormWidgetType.SLIDER, sliderProps],
        [FormWidgetType.SWITCH, switchProps],
        [FormWidgetType.TEXT, textProps],
        [FormWidgetType.TEXTAREA, textareaProps],
        [FormWidgetType.TIME, timeProps],
        [FormWidgetType.TIMESTAMP, dateTimeProps],
        [FormWidgetType.TOGGLE, checkboxProps],
        [FormWidgetType.TYPEAHEAD, searchProps],
        [FormWidgetType.UPLOAD, uploadProps]
    ]);
    const formFieldMap = new Map([
        ['debouncetime', Object.assign({ value: 250 }, PROP_NUMBER)],
        ['defaultvalue', PROP_STRING],
        ['displayname', PROP_STRING],
        ['display-name', PROP_STRING],
        ['field', PROP_STRING],
        ['filterexpressions', PROP_STRING],
        ['filter-on', PROP_STRING],
        ['generator', PROP_STRING],
        ['hint', PROP_STRING],
        ['inputtype', PROP_STRING],
        ['is-primary-key', PROP_BOOLEAN],
        ['is-range', PROP_BOOLEAN],
        ['is-related', PROP_BOOLEAN],
        ['isformfield', { value: true }],
        ['key', PROP_STRING],
        ['limit', PROP_NUMBER],
        ['lookup-type', PROP_STRING],
        ['lookup-field', PROP_STRING],
        ['name', PROP_STRING],
        ['matchmode', PROP_STRING],
        ['maxdefaultvalue', PROP_STRING],
        ['maxplaceholder', PROP_STRING],
        ['mobile-display', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['period', PROP_BOOLEAN],
        ['pc-display', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['placeholder', PROP_STRING],
        ['primary-key', PROP_BOOLEAN],
        ['related-entity-name', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['type', PROP_STRING],
        ['validationmessage', PROP_STRING],
        ['viewmodewidget', PROP_STRING],
        ['widgettype', PROP_STRING]
    ]);
    widgetPropsMap.forEach((val, key) => {
        const propsMap = new Map(formFieldMap);
        const widgetProps = widgetPropsMap.get(key);
        widgetProps.forEach((v, k) => propsMap.set(k, v));
        register('wm-form-field-' + key, propsMap);
    });
};

// Custom validator to show validation error, if setValidationMessage method is used
const customValidatorFn = () => {
    return { custom: true };
};
const FILE_TYPES = {
    'image': 'image/*',
    'video': 'video/*',
    'audio': 'audio/*'
};
const ɵ1$7 = {};
class FormFieldDirective extends StylableComponent {
    constructor(inj, form, fb, parentList, binddataset, binddisplayexpression, binddisplaylabel, _widgetType, name, key, isRange, pcDisplay, mobileDisplay, contexts) {
        const WIDGET_CONFIG = {
            widgetType: 'wm-form-field',
            hostClass: '',
            widgetSubType: 'wm-form-field-' + (_widgetType || FormWidgetType.TEXT).trim()
        };
        super(inj, WIDGET_CONFIG, new Promise(res => this._initPropsRes = res));
        this._validators = [];
        this.class = '';
        this.binddataset = binddataset;
        this.binddisplayexpression = binddisplayexpression;
        this.binddisplaylabel = binddisplaylabel;
        this.form = form;
        this.fb = fb;
        this._fieldName = key || name;
        this.isRange = isRange;
        this.excludeProps = new Set(['type', 'name']);
        this.widgettype = _widgetType;
        this.parentList = parentList;
        if (this.binddataset || this.$element.attr('dataset')) {
            this.isDataSetBound = true;
        }
        contexts[0]._onFocusField = this._onFocusField.bind(this);
        contexts[0]._onBlurField = this._onBlurField.bind(this);
        this._debounceSetUpValidators = debounce(() => this.setUpValidators(), 500);
    }
    _onFocusField($evt) {
        $($evt.target).closest('.live-field').addClass('active');
    }
    _onBlurField($evt) {
        $($evt.target).closest('.live-field').removeClass('active');
        this.setUpValidators();
    }
    // Expression to be evaluated in view mode of form field
    evaluateExpr(object, displayExpr) {
        if (!displayExpr) {
            displayExpr = Object.keys(object)[0];
            // If dataset is not ready, display expression will not be defined
            if (!displayExpr) {
                return;
            }
        }
        return getEvaluatedData(object, {
            expression: displayExpr
        }, this.viewParent);
    }
    // Expression to be evaluated in view mode of form field
    getDisplayExpr() {
        const caption = [];
        const value = this.value;
        const displayExpr = this.displayexpression || this.displayfield || this.displaylabel;
        if (_.isObject(value)) {
            if (_.isArray(value)) {
                _.forEach(value, obj => {
                    if (_.isObject(obj)) {
                        caption.push(this.evaluateExpr(obj, displayExpr));
                    }
                });
            }
            else {
                caption.push(this.evaluateExpr(value, displayExpr));
            }
            return _.join(caption, ',');
        }
        return (value === undefined || value === null) ? '' : this.value;
    }
    getCaption() {
        return (this.value === undefined || this.value === null) ? (_.get(this.form.dataoutput, this._fieldName) || '') : this.value;
    }
    // Method to setup validators for reactive form control
    setUpValidators(customValidator) {
        this._validators = [];
        if (this.required && this.show !== false) {
            // For checkbox/toggle widget, required validation should consider true value only
            if (this.widgettype === FormWidgetType.CHECKBOX || this.widgettype === FormWidgetType.TOGGLE) {
                this._validators.push(Validators.requiredTrue);
            }
            else {
                this._validators.push(Validators.required);
            }
        }
        if (this.maxchars) {
            this._validators.push(Validators.maxLength(this.maxchars));
        }
        if (this.minvalue) {
            this._validators.push(Validators.min(this.minvalue));
        }
        if (this.maxvalue && this.widgettype !== FormWidgetType.RATING) {
            this._validators.push(Validators.max(this.maxvalue));
        }
        if (this.regexp) {
            this._validators.push(Validators.pattern(this.regexp));
        }
        if (_.isFunction(this.formWidget.validate)) {
            this._validators.push(this.formWidget.validate.bind(this.formWidget));
        }
        if (customValidator) {
            this._validators.push(customValidator);
        }
        if (this.ngform) {
            this._control.setValidators(this._validators);
            const opt = {};
            // updating the value only when prevData is not equal to current value.
            // emitEvent flag will prevent from emitting the valueChanges when value is equal to the prevDatavalue.
            if (this.value === this.formWidget.prevDatavalue) {
                opt['emitEvent'] = false;
            }
            this._control.updateValueAndValidity(opt);
        }
    }
    // Method to set the properties on inner form widget
    setFormWidget(key, val) {
        if (this.formWidget && this.formWidget.widget) {
            this.formWidget.widget[key] = val;
        }
    }
    // Method to set the properties on inner max form widget (when range is selected)
    setMaxFormWidget(key, val) {
        if (this.formWidgetMax) {
            this.formWidgetMax.widget[key] = val;
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key !== 'tabindex') {
            super.onPropertyChange(key, nv, ov);
        }
        if (this.excludeProps.has(key)) {
            return;
        }
        // As upload widget is an HTML widget, only required property is setup
        if (this.widgettype === FormWidgetType.UPLOAD) {
            if (key === 'required') {
                this._debounceSetUpValidators();
            }
            super.onPropertyChange(key, nv, ov);
            return;
        }
        this.setFormWidget(key, nv);
        // Placeholder should not be setup on max widget
        if (key !== 'placeholder') {
            this.setMaxFormWidget(key, nv);
        }
        switch (key) {
            case 'defaultvalue':
                this.form.onFieldDefaultValueChange(this, nv);
                break;
            case 'maxdefaultvalue':
                this.maxValue = nv;
                this.setMaxFormWidget('datavalue', nv);
                this.form.onMaxDefaultValueChange();
                break;
            case 'maxplaceholder':
                this.setMaxFormWidget('placeholder', nv);
                break;
            case 'required':
            case 'maxchars':
            case 'minvalue':
            case 'maxvalue':
            case 'regexp':
            case 'show':
                this._debounceSetUpValidators();
                break;
            case 'primary-key':
                if (nv) {
                    this.form.setPrimaryKey(this._fieldName);
                }
                break;
            case 'display-name':
                this.displayname = nv;
                break;
            case 'readonly':
                this.setReadOnlyState();
                break;
        }
    }
    onStyleChange(key, nv, ov) {
        this.setFormWidget(key, nv);
        this.setMaxFormWidget(key, nv);
        super.onStyleChange(key, nv, ov);
    }
    get datavalue() {
        return this.formWidget && this.formWidget.datavalue;
    }
    set datavalue(val) {
        if (this._control && this.widgettype !== FormWidgetType.UPLOAD) {
            this._control.setValue(val);
        }
    }
    get value() {
        return this.datavalue;
    }
    set value(val) {
        this.datavalue = val;
    }
    get maxValue() {
        return this.formWidgetMax && this.formWidgetMax.datavalue;
    }
    set maxValue(val) {
        if (this._maxControl) {
            this._maxControl.setValue(val);
        }
    }
    get minValue() {
        return this.value;
    }
    set minValue(val) {
        this.value = val;
    }
    // Get the reactive form control
    get _control() {
        return this.ngform && this.ngform.controls[this._fieldName];
    }
    // Get the reactive max form control
    get _maxControl() {
        return this.ngform && this.ngform.controls[this._fieldName + '_max'];
    }
    // Create the reactive form control
    createControl() {
        return this.fb.control(undefined, {
            validators: this._validators
        });
    }
    // On field value change, propagate event to parent form
    onValueChange(val) {
        if (!this.isDestroyed) {
            this.form.onFieldValueChange(this, val);
        }
    }
    // Method to expose validation message and set control to invalid
    setValidationMessage(val) {
        setTimeout(() => {
            this.validationmessage = val;
            this.setUpValidators(customValidatorFn);
        });
    }
    setReadOnlyState() {
        let readOnly;
        if (this.form.isUpdateMode) {
            if (this['primary-key'] && !this['is-related'] && !this.period) {
                /*If the field is primary but is assigned set readonly false.
                   Assigned is where the user inputs the value while a new entry.
                   This is not editable(in update mode) once entry is successful*/
                readOnly = !(this.generator === 'assigned' && this.form.operationType !== 'update');
            }
            else {
                readOnly = this.readonly;
            }
        }
        else {
            // In view mode, set widget state to readonly always
            readOnly = true;
        }
        this.setFormWidget('readonly', readOnly);
    }
    resetDisplayInput() {
        if ((!isDefined(this.value) || this.value === '')) {
            this.formWidget && this.formWidget.resetDisplayInput && this.formWidget.resetDisplayInput();
        }
    }
    triggerUploadEvent($event, eventName) {
        const params = { $event };
        if (eventName === 'change') {
            params.newVal = $event.target.files;
            params.oldVal = this._oldUploadVal;
            this._oldUploadVal = params.newVal;
        }
        this.invokeEventCallback(eventName, params);
    }
    registerFormField() {
        const fieldName = this._fieldName;
        if (this.parentList && !(this.form.parentList === this.parentList)) {
            let counter = 1;
            let _fieldName = fieldName;
            while (this.ngform.controls.hasOwnProperty(_fieldName)) {
                _fieldName = `${fieldName}_${counter}`;
                counter++;
            }
            this.ngform.addControl(_fieldName, this.createControl());
            this._fieldName = _fieldName;
        }
        else {
            this.ngform.addControl(fieldName, this.createControl());
        }
        const onValueChangeSubscription = this._control.valueChanges
            .pipe(debounceTime(200))
            .subscribe(this.onValueChange.bind(this));
        this.registerDestroyListener(() => onValueChangeSubscription.unsubscribe());
        if (this.isRange === 'true') {
            this.ngform.addControl(fieldName + '_max', this.createControl());
            // registering for valueChanges on MaxformWidget
            const onMaxValueChangeSubscription = this._maxControl.valueChanges
                .pipe(debounceTime(200))
                .subscribe(this.onValueChange.bind(this));
            this.registerDestroyListener(() => onMaxValueChangeSubscription.unsubscribe());
        }
        this.value = _.get(this.form.formdata, this._fieldName);
    }
    ngOnInit() {
        this.ngform = this.form.ngform;
        this.registerFormField();
        super.ngOnInit();
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.formWidget) {
            this._initPropsRes();
            // setting displayExpressions on the formwidget explicitly as expr was evaluated to "".
            this.setFormWidget('binddisplaylabel', this.binddisplaylabel);
            this.setFormWidget('binddisplayexpression', this.binddisplayexpression);
        }
        this.registerReadyStateListener(() => {
            this.key = this._fieldName || this.target || this.binding;
            this.viewmodewidget = this.viewmodewidget || getDefaultViewModeWidget(this.widgettype);
            // For upload widget, generate the permitted field
            if (this.widgettype === FormWidgetType.UPLOAD) {
                let fileType;
                // Create the accepts string from file type and extensions
                fileType = this.filetype ? FILE_TYPES[this.filetype] : '';
                this.permitted = fileType + (this.extensions ? (fileType ? ',' : '') + this.extensions : '');
            }
            if (isMobile()) {
                if (!this['mobile-display']) {
                    this.widget.show = false;
                }
            }
            else {
                if (!this['pc-display']) {
                    this.widget.show = false;
                }
            }
            // Register the form field with parent form
            this.form.registerFormFields(this.widget);
            addForIdAttributes(this.nativeElement);
            this.setReadOnlyState();
        });
    }
}
FormFieldDirective.initializeProps = registerProps$N();
FormFieldDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmFormField]',
                exportAs: 'wmFormField',
                providers: [
                    provideAsWidgetRef(FormFieldDirective),
                    provideAsNgValueAccessor(FormFieldDirective),
                    { provide: Context, useValue: ɵ1$7, multi: true }
                ]
            },] }
];
/** @nocollapse */
FormFieldDirective.ctorParameters = () => [
    { type: Injector },
    { type: FormComponent },
    { type: FormBuilder },
    { type: ListComponent, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['dataset.bind',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['displayexpression.bind',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['displaylabel.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['widgettype',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['name',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['key',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['is-range',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['pc-display',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['mobile-display',] }] },
    { type: Array, decorators: [{ type: Self }, { type: Inject, args: [Context,] }] }
];
FormFieldDirective.propDecorators = {
    formWidget: [{ type: ContentChild, args: ['formWidget',] }],
    formWidgetMax: [{ type: ContentChild, args: ['formWidgetMax',] }]
};

const registerProps$O = () => {
    register('wm-header', new Map([
        ['name', PROP_STRING],
        ['class', PROP_STRING],
        ['content', PROP_STRING]
    ]));
};

const DEFAULT_CLS$r = 'app-header clearfix';
const WIDGET_CONFIG$v = {
    widgetType: 'wm-header',
    hostClass: DEFAULT_CLS$r
};
class HeaderComponent extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$v);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
HeaderComponent.initializeProps = registerProps$O();
HeaderComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmHeader]',
                template: "<div class=\"app-header-menu\" data-role=\"page-left-panel-icon\">\n    <a class=\"app-header-action\">\n        <i class=\"wi wi-menu\"></i>\n    </a>\n</div>\n<div class=\"app-header-container\" partial-container-target></div>",
                providers: [
                    provideAsWidgetRef(HeaderComponent)
                ]
            }] }
];
/** @nocollapse */
HeaderComponent.ctorParameters = () => [
    { type: Injector }
];

const registerProps$P = () => {
    register('wm-html', new Map([
        ['class', PROP_STRING],
        ['content', PROP_STRING],
        ['hint', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

class TrustAsPipe {
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    transform(content, as) {
        if (as === 'resource' || as === SecurityContext.RESOURCE_URL) {
            if (!content) {
                return '';
            }
            return this.domSanitizer.bypassSecurityTrustResourceUrl(content);
        }
        if (as === 'html' || as === SecurityContext.HTML) {
            if (content === null || content === undefined) {
                return '';
            }
            return this.domSanitizer.sanitize(SecurityContext.HTML, content);
        }
    }
}
TrustAsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'trustAs'
            },] }
];
/** @nocollapse */
TrustAsPipe.ctorParameters = () => [
    { type: DomSanitizer }
];

const DEFAULT_CLS$s = 'app-html-container';
const WIDGET_CONFIG$w = {
    widgetType: 'wm-html',
    hostClass: DEFAULT_CLS$s
};
class HtmlDirective extends StylableComponent {
    constructor(inj, height, boundContent, trustAsPipe) {
        super(inj, WIDGET_CONFIG$w);
        this.boundContent = boundContent;
        this.trustAsPipe = trustAsPipe;
        // if the height is provided set the overflow to auto
        if (height) {
            setCSS(this.nativeElement, 'overflow', 'auto');
        }
        styler(this.nativeElement, this);
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.boundContent) {
            this.nativeElement.innerHTML = '';
        }
        if (!this.content && this.nativeElement.innerHTML) {
            this.content = this.nativeElement.innerHTML;
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'content') {
            setProperty(this.nativeElement, 'innerHTML', this.trustAsPipe.transform(nv, SecurityContext.HTML));
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
HtmlDirective.initializeProps = registerProps$P();
HtmlDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmHtml]',
                providers: [
                    provideAsWidgetRef(HtmlDirective)
                ]
            },] }
];
/** @nocollapse */
HtmlDirective.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Attribute, args: ['height',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['content.bind',] }] },
    { type: TrustAsPipe }
];

const registerProps$Q = () => {
    register('wm-icon', new Map([
        ['caption', PROP_STRING],
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['hint', PROP_STRING],
        ['iconclass', Object.assign({ value: 'wi wi-star-border' }, PROP_STRING)],
        ['iconposition', Object.assign({ value: 'left' }, PROP_STRING)],
        ['iconsize', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$t = 'app-icon-wrapper';
const WIDGET_CONFIG$x = {
    widgetType: 'wm-icon',
    hostClass: DEFAULT_CLS$t
};
class IconComponent extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$x);
        styler(this.nativeElement, this);
    }
}
IconComponent.initializeProps = registerProps$Q();
IconComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmIcon]',
                template: "<i class=\"app-icon {{iconclass}}\"></i>\n<span class=\"sr-only\" *ngIf=\"iconclass\">{{caption}} {{appLocale.LABEL_ICON}}</span>\n<label class=\"app-label\" [textContent]=\"caption\" *ngIf=\"caption\"></label>",
                providers: [
                    provideAsWidgetRef(IconComponent)
                ]
            }] }
];
/** @nocollapse */
IconComponent.ctorParameters = () => [
    { type: Injector }
];
IconComponent.propDecorators = {
    iconposition: [{ type: HostBinding, args: ['attr.icon-position',] }],
    iconsize: [{ type: HostBinding, args: ['style.fontSize',] }]
};

const registerProps$R = () => {
    register('wm-iframe', new Map([
        ['class', PROP_STRING],
        ['encodeurl', PROP_BOOLEAN],
        ['height', Object.assign({ value: '150px' }, PROP_STRING)],
        ['iframesrc', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['width', Object.assign({ value: '300px' }, PROP_STRING)]
    ]));
};

const DEFAULT_CLS$u = 'embed-responsive app-iframe';
const WIDGET_CONFIG$y = {
    widgetType: 'wm-iframe',
    hostClass: DEFAULT_CLS$u
};
class IframeComponent extends StylableComponent {
    constructor(inj, trustAsPipe) {
        super(inj, WIDGET_CONFIG$y);
        this.trustAsPipe = trustAsPipe;
        /**
         * this property member is set to true when the content request url doesn't match windows protocol
         */
        this.showContentLoadError = false;
        styler(this.nativeElement, this);
    }
    computeIframeSrc() {
        this.showContentLoadError = false;
        this._iframesrc = undefined;
        if (this.iframesrc) {
            let url = this.iframesrc;
            if (this.encodeurl) {
                url = encodeUrl(this.iframesrc);
            }
            const trustedUrl = this.trustAsPipe.transform(url, SecurityContext.RESOURCE_URL);
            if (isInsecureContentRequest(url)) {
                this.showContentLoadError = true;
                this.errorMsg = `${this.appLocale.MESSAGE_ERROR_CONTENT_DISPLAY} ${this.iframesrc}`;
                this.hintMsg = this.errorMsg;
            }
            this._iframesrc = trustedUrl;
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'iframesrc' || key === 'encodeurl') {
            this.computeIframeSrc();
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
IframeComponent.initializeProps = registerProps$R();
IframeComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmIframe]',
                template: "<iframe title=\"\" class=\"embed-responsive-item iframe-content\" role=\"document\"\n        scrolling=\"auto\"\n        marginheight=\"0\"\n        marginwidth=\"0\"\n        frameborder=\"0\"\n        [name]=\"name\"\n        [attr.src]=\"_iframesrc\"\n        seamless=\"seamless\">\n</iframe>\n<div class=\"wm-content-info readonly-wrapper\" *ngIf=\"showContentLoadError\">\n    <p class=\"wm-message\" [title]=\"hintMsg\" [textContent]=\"errMsg\"></p>\n</div>",
                providers: [
                    provideAsWidgetRef(IframeComponent)
                ]
            }] }
];
/** @nocollapse */
IframeComponent.ctorParameters = () => [
    { type: Injector },
    { type: TrustAsPipe }
];

const registerProps$S = () => {
    register('wm-iframedialog', new Map([
        ['animation', PROP_STRING],
        ['class', PROP_STRING],
        ['closable', { value: true, PROP_BOOLEAN }],
        ['encodeurl', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['height', Object.assign({ value: '400px' }, PROP_STRING)],
        ['iconclass', { value: 'wi wi-globe', PROP_STRING }],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['modal', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['name', PROP_STRING],
        ['oktext', Object.assign({ value: 'OK' }, PROP_STRING)],
        ['showactions', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showheader', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', Object.assign({ value: 'External Content' }, PROP_STRING)],
        ['url', Object.assign({ value: '//www.wavemaker.com' }, PROP_STRING)]
    ]));
};

const DIALOG_CLS$3 = 'app-dialog modal-dialog app-iframe-dialog';
const WIDGET_INFO$4 = { widgetType: 'wm-iframedialog' };
class IframeDialogComponent extends BaseDialog {
    constructor(inj, dialogClass, modal, closable) {
        if (modal === null || modal === undefined) {
            modal = false;
        }
        if (closable === null || closable === undefined) {
            closable = true;
        }
        // setting the backdrop to 'static' will not close the dialog on backdrop click
        const backdrop = toBoolean(modal) ? 'static' : true;
        super(inj, WIDGET_INFO$4, {
            class: `${DIALOG_CLS$3} ${dialogClass || ''}`,
            backdrop,
            keyboard: !toBoolean(modal)
        });
    }
    getTemplateRef() {
        return this.dialogTemplate;
    }
    /**
     * Click event handler for the ok button
     * invokes on-ok event callback
     * @param {Event} $event
     */
    onOk($event) {
        this.invokeEventCallback('ok', { $event });
    }
    ngOnInit() {
        super.ngOnInit();
        this.register(this.viewParent);
    }
}
IframeDialogComponent.initializeProps = registerProps$S();
IframeDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmIframeDialog]',
                template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"\n         *ngIf=\"showheader\"\n    ></div>\n    <div wmDialogBody>\n        <div wmIframe encodeurl.bind=\"encodeurl\" iframesrc.bind=\"url\" height.bind=\"height\" width.bind=\"width\" hint.bind=\"hint\"></div>\n    </div>\n    <div wmDialogFooter *ngIf=\"showactions\">\n        <button wmButton class=\"btn-primary ok-action\" caption.bind=\"oktext\" aria-label=\"Submit button\" (click)=\"onOk($event)\"></button>\n    </div>\n</ng-template>\n",
                providers: [
                    provideAsWidgetRef(IframeDialogComponent),
                    provideAsDialogRef(IframeDialogComponent)
                ]
            }] }
];
/** @nocollapse */
IframeDialogComponent.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Attribute, args: ['class',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['modal',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['closable',] }] }
];
IframeDialogComponent.propDecorators = {
    dialogTemplate: [{ type: ViewChild, args: ['dialogTemplate',] }]
};

class ImagePipe {
    transform(url, encode, defaultImageUrl) {
        return getImageUrl(url, encode, defaultImageUrl);
    }
}
ImagePipe.decorators = [
    { type: Pipe, args: [{
                name: 'image'
            },] }
];

const WIDGET_CONFIG$z = {
    widgetType: 'wm-input-calendar',
    hostClass: 'app-input-wrapper'
};
class InputCalendarComponent extends BaseInput {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$z);
    }
}
InputCalendarComponent.initializeProps = registerProps$C();
InputCalendarComponent.decorators = [
    { type: Component, args: [{
                selector: 'wm-input[type="date"], wm-input[type="datetime-local"], wm-input[type="month"], wm-input[type="time"], wm-input[type="week"]',
                template: "<input class=\"form-control app-textbox\"\n       focus-target\n       role=\"input\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [min]=\"minvalue\"\n       [max]=\"maxvalue\"\n       [step]=\"step\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"handleChange($event)\"\n       [autocomplete]=\"autocomplete ? 'on' : 'off'\"\n       #input>\n",
                providers: [
                    provideAsNgValueAccessor(InputCalendarComponent),
                    provideAsWidgetRef(InputCalendarComponent)
                ]
            }] }
];
/** @nocollapse */
InputCalendarComponent.ctorParameters = () => [
    { type: Injector }
];
InputCalendarComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['input',] }],
    ngModel: [{ type: ViewChild, args: [NgModel,] }]
};

const WIDGET_CONFIG$A = {
    widgetType: 'wm-input-color',
    hostClass: 'app-input-wrapper'
};
class InputColorComponent extends BaseInput {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$A);
    }
}
InputColorComponent.initializeProps = registerProps$D();
InputColorComponent.decorators = [
    { type: Component, args: [{
                selector: 'wm-input[type="color"]',
                template: "<input class=\"form-control app-textbox\"\n       focus-target\n       type=\"color\"\n       role=\"input\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [maxlength]=\"maxchars\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"handleChange($event)\"\n       #input>",
                providers: [
                    provideAsNgValueAccessor(InputColorComponent),
                    provideAsWidgetRef(InputColorComponent)
                ]
            }] }
];
/** @nocollapse */
InputColorComponent.ctorParameters = () => [
    { type: Injector }
];
InputColorComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['input',] }],
    ngModel: [{ type: ViewChild, args: [NgModel,] }]
};

const WIDGET_CONFIG$B = {
    widgetType: 'wm-input-email',
    hostClass: 'app-input-wrapper'
};
class InputEmailComponent extends BaseInput {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$B);
    }
}
InputEmailComponent.initializeProps = registerProps$E();
InputEmailComponent.decorators = [
    { type: Component, args: [{
                selector: 'wm-input[type="email"]',
                template: "<input class=\"form-control app-textbox\"\n       focus-target\n       role=\"input\"\n       type=\"email\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [ngModelOptions]=\"ngModelOptions\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [maxlength]=\"maxchars\"\n       [pattern]=\"regexp\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"handleChange($event)\"\n       [autocomplete]=\"autocomplete ? 'on' : 'off'\"\n       (keyup.enter)=\"flushViewChanges(input.value)\"\n       email\n       #input>",
                providers: [
                    provideAsNgValueAccessor(InputEmailComponent),
                    provideAsWidgetRef(InputEmailComponent)
                ]
            }] }
];
/** @nocollapse */
InputEmailComponent.ctorParameters = () => [
    { type: Injector }
];
InputEmailComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['input',] }],
    ngModel: [{ type: ViewChild, args: [NgModel,] }]
};

const WIDGET_CONFIG$C = {
    widgetType: 'wm-input-number',
    hostClass: 'app-input-wrapper'
};
class InputNumberComponent extends BaseInput {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$C);
    }
    onArrowPress($event) {
        if (this.step === 0) {
            $event.preventDefault();
        }
    }
    validateInputEntry($event) {
        if ($event.key === 'e' && $event.target.value.indexOf($event.key) !== -1) {
            return false;
        }
    }
}
InputNumberComponent.initializeProps = registerProps$A();
InputNumberComponent.decorators = [
    { type: Component, args: [{
                selector: 'wm-input[type="number"]',
                template: "<input class=\"form-control app-textbox\"\n       [ngClass]=\"{'step-hidden': step === 0}\"\n       focus-target\n       role=\"input\"\n       type=\"number\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [ngModelOptions]=\"ngModelOptions\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [maxlength]=\"maxchars\"\n       [min]=\"minvalue\"\n       [max]=\"maxvalue\"\n       [step]=\"step\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (blur)=\"handleBlur($event)\"\n       (ngModelChange)=\"handleChange($event)\"\n       [autocomplete]=\"autocomplete ? 'on' : 'off'\"\n       (keyup.enter)=\"flushViewChanges(input.value)\"\n       (keydown.ArrowUp)=\"onArrowPress($event)\"\n       (keydown.ArrowDown)=\"onArrowPress($event)\"\n       (keypress)=\"validateInputEntry($event)\"\n       #input>",
                providers: [
                    provideAsNgValueAccessor(InputNumberComponent),
                    provideAsWidgetRef(InputNumberComponent)
                ]
            }] }
];
/** @nocollapse */
InputNumberComponent.ctorParameters = () => [
    { type: Injector }
];
InputNumberComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['input',] }],
    ngModel: [{ type: ViewChild, args: [NgModel,] }]
};

const WIDGET_CONFIG$D = {
    widgetType: 'wm-input-text',
    hostClass: 'app-input-wrapper'
};
class InputTextComponent extends BaseInput {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$D);
    }
    /* Define the property change handler. This function will be triggered when there is a change in the widget property */
    onPropertyChange(key, nv, ov) {
        /*Monitoring changes for styles or properties and accordingly handling respective changes.*/
        switch (key) {
            case 'displayformat':
                this.maskVal = [];
                _.forEach(this.displayformat, (dF) => {
                    // This condition is used to support all numbers from 0-9
                    if (dF === '9') {
                        this.maskVal.push(/\d/);
                    }
                    // This condition is used to support all capital and small alphabets
                    else if (dF === 'A') {
                        this.maskVal.push(/[A-Z, a-z]/);
                    }
                    // This condition is used to support all small alphabets
                    else if (dF === 'a') {
                        this.maskVal.push(/[a-z]/);
                    }
                    // This condition is used to support all characters except new line
                    else if (dF === '*') {
                        this.maskVal.push(/\w/);
                    }
                    else {
                        this.maskVal.push(dF);
                    }
                });
                break;
            default:
                super.onPropertyChange(key, nv, ov);
        }
    }
    get mask() {
        if (this.displayformat) {
            return { mask: this.maskVal, showMask: true };
        }
        else {
            return { mask: false };
        }
    }
}
InputTextComponent.initializeProps = registerProps$B();
InputTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'wm-input[type="text"], wm-input:not([type]), wm-input[type="password"], wm-input[type="search"], wm-input[type="tel"], wm-input[type="url"]',
                template: "<input class=\"form-control app-textbox\"\n       focus-target\n       role=\"input\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [(ngModel)]=\"datavalue\"\n       [textMask]=\"mask\"\n       [ngModelOptions]=\"ngModelOptions\"\n       [readonly]=\"readonly\"\n       [required]=\"required\"\n       [disabled]=\"disabled\"\n       [maxlength]=\"maxchars\"\n       [pattern]=\"regexp\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (ngModelChange)=\"handleChange($event)\"\n       (blur)=\"handleBlur($event)\"\n       [autocomplete]=\"autocomplete ? 'on' : 'off'\"\n       (keyup.enter)=\"flushViewChanges(input.value)\"\n       #input>",
                providers: [
                    provideAsNgValueAccessor(InputTextComponent),
                    provideAsWidgetRef(InputTextComponent)
                ]
            }] }
];
/** @nocollapse */
InputTextComponent.ctorParameters = () => [
    { type: Injector }
];
InputTextComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['input',] }],
    ngModel: [{ type: ViewChild, args: [NgModel,] }]
};

const registerProps$T = () => {
    register('wm-table', new Map([
        ['boundarylinks', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['class', PROP_STRING],
        ['confirmdelete', Object.assign({ value: 'Are you sure you want to delete this?' }, PROP_STRING)],
        ['datasource', PROP_STRING],
        ['dataset', PROP_ANY],
        ['deletecanceltext', PROP_STRING],
        ['deleteoktext', PROP_STRING],
        ['deletemessage', Object.assign({ value: 'Record deleted successfully' }, PROP_STRING)],
        ['directionlinks', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['editmode', PROP_STRING],
        ['enablecolumnselection', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['enablesort', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['errormessage', PROP_STRING],
        ['exportformat', PROP_STRING],
        ['exportdatasize', Object.assign({ value: 100 }, PROP_NUMBER)],
        ['filtermode', PROP_STRING],
        ['filternullrecords', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['forceellipses', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['formposition', PROP_STRING],
        ['gridclass', Object.assign({ value: 'table-bordered table-striped table-hover' }, PROP_STRING)],
        ['gridfirstrowselect', PROP_BOOLEAN],
        ['iconclass', PROP_STRING],
        ['insertmessage', Object.assign({ value: 'Record added successfully' }, PROP_STRING)],
        ['isdynamictable', PROP_BOOLEAN],
        ['loadingdatamsg', Object.assign({ value: 'Loading...' }, PROP_STRING)],
        ['loadingicon', Object.assign({ value: 'fa fa-circle-o-notch fa-spin' }, PROP_STRING)],
        ['maxsize', Object.assign({ value: 5 }, PROP_NUMBER)],
        ['multiselect', PROP_BOOLEAN],
        ['name', PROP_STRING],
        ['navigation', Object.assign({ value: 'Basic' }, PROP_STRING)],
        ['navigationalign', Object.assign({ value: 'left' }, PROP_STRING)],
        ['nodatamessage', Object.assign({ value: 'No data found.' }, PROP_STRING)],
        ['pagesize', PROP_NUMBER],
        ['radioselect', PROP_BOOLEAN],
        ['rowclass', PROP_STRING],
        ['rowngclass', PROP_STRING],
        ['searchlabel', Object.assign({ value: 'Search' }, PROP_STRING)],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showheader', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['shownewrow', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showrecordcount', PROP_BOOLEAN],
        ['showrowindex', PROP_BOOLEAN],
        ['spacing', Object.assign({ value: 'normal' }, PROP_STRING)],
        ['subheading', PROP_STRING],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', PROP_STRING],
        ['updatemessage', Object.assign({ value: 'Record updated successfully' }, PROP_STRING)]
    ]));
};

const DEFAULT_CLS$v = 'app-grid app-panel panel';
const WIDGET_CONFIG$E = { widgetType: 'wm-table', hostClass: DEFAULT_CLS$v };
const exportIconMapping = {
    EXCEL: 'fa fa-file-excel-o',
    CSV: 'fa fa-file-text-o'
};
const ROW_OPS_FIELD = 'rowOperations';
const noop$2 = () => { };
const isInputBodyWrapper = target => {
    const classes = ['.dropdown-menu', '.uib-typeahead-match', '.modal-dialog', '.toast'];
    let isInput = false;
    classes.forEach(cls => {
        if (target.closest(cls).length) {
            isInput = true;
            return false;
        }
    });
    const attrs = ['bsdatepickerdaydecorator'];
    if (!isInput) {
        attrs.forEach(attr => {
            if (target[0].hasAttribute(attr)) {
                isInput = true;
                return false;
            }
        });
    }
    return isInput;
};
class TableComponent extends StylableComponent {
    constructor(inj, fb, app, dynamicComponentProvider, binddataset, binddatasource, readonlygrid, ngZone) {
        super(inj, WIDGET_CONFIG$E);
        this.inj = inj;
        this.fb = fb;
        this.app = app;
        this.dynamicComponentProvider = dynamicComponentProvider;
        this.binddataset = binddataset;
        this.binddatasource = binddatasource;
        this.readonlygrid = readonlygrid;
        this.ngZone = ngZone;
        this.rowActionsCompiledTl = {};
        this.rowFilterCompliedTl = {};
        this.inlineCompliedTl = {};
        this.inlineNewCompliedTl = {};
        this.customExprCompiledTl = {};
        this.rowDefInstances = {};
        this.rowDefMap = {};
        this.rowExpansionActionTl = {};
        this.columns = {};
        this.formfields = {};
        this.enablesort = true;
        this.selectedItems = [];
        this.selectedItemChange = new Subject();
        this.selectedItemChange$ = this.selectedItemChange.asObservable();
        this.actions = [];
        this._actions = {
            'header': [],
            'footer': []
        };
        this.exportOptions = [];
        this.headerConfig = [];
        this.items = [];
        this.rowActions = [];
        this.shownavigation = false;
        this.documentClickBind = noop$2;
        this.fieldDefs = [];
        this.rowDef = {};
        this.rowInstance = {};
        this.fullFieldDefs = [];
        this.applyProps = new Map();
        this.redraw = _.debounce(this._redraw, 150);
        this.debouncedHandleLoading = _.debounce(this.handleLoading, 350);
        // Filter and Sort Methods
        this.rowFilter = {};
        this._searchSortHandler = noop$2;
        this.searchSortHandler = (...args) => { this._searchSortHandler.apply(this, args); };
        this.onRowFilterChange = noop$2;
        this.onFilterConditionSelect = noop$2;
        this.showClearIcon = noop$2;
        this.clearRowFilter = noop$2;
        this.gridOptions = {
            data: [],
            colDefs: [],
            startRowIndex: 1,
            sortInfo: {
                field: '',
                direction: ''
            },
            filtermode: '',
            searchLabel: '',
            rowActions: [],
            headerConfig: [],
            rowClass: '',
            editmode: '',
            formPosition: '',
            isMobile: false,
            rowExpansionEnabled: false,
            rowDef: {
                position: '0'
            },
            name: '',
            messages: {
                selectField: 'Select Field'
            },
            onDataRender: () => {
                this.ngZone.run(() => {
                    if (this.gridData.length) {
                        this.invokeEventCallback('datarender', { $data: this.gridData, data: this.gridData });
                    }
                    // select rows selected in previous pages. (Not finding intersection of data and selecteditems as it will be heavy)
                    if (!this.multiselect) {
                        this.items.length = 0;
                    }
                    this.callDataGridMethod('selectRows', this.items);
                    this.selectedItems = this.callDataGridMethod('getSelectedRows');
                    this.selectedItemChange.next(this.selectedItems);
                    // On render, apply the filters set for query service variable
                    if (this._isPageSearch && this.filterInfo) {
                        this.searchSortHandler(this.filterInfo, undefined, 'search');
                    }
                });
            },
            onRowSelect: (row, e) => {
                this.ngZone.run(() => {
                    this.selectedItems = this.callDataGridMethod('getSelectedRows');
                    this.selectedItemChange.next(this.selectedItems);
                    const rowData = this.addRowIndex(row);
                    this.invokeEventCallback('rowselect', { $data: rowData, $event: e, row: rowData });
                });
            },
            // assigns the items on capture phase of the click handler.
            assignSelectedItems: (row, e) => {
                this.ngZone.run(() => {
                    /*
                     * in case of single select, update the items with out changing the reference.
                     * for multi select, keep old selected items in tact
                     */
                    if (this.multiselect) {
                        if (_.findIndex(this.items, row) === -1) {
                            this.items.push(row);
                        }
                    }
                    else {
                        this.items.length = 0;
                        this.items.push(row);
                    }
                });
            },
            onRowDblClick: (row, e) => {
                const rowData = this.addRowIndex(row);
                this.invokeEventCallback('rowdblclick', { $data: rowData, $event: e, row: rowData });
            },
            onRowDeselect: (row, e) => {
                if (this.multiselect) {
                    this.ngZone.run(() => {
                        this.items = _.pullAllWith(this.items, [row], _.isEqual);
                        this.selectedItems = this.callDataGridMethod('getSelectedRows');
                        this.invokeEventCallback('rowdeselect', { $data: row, $event: e, row });
                    });
                }
            },
            callOnRowDeselectEvent: (row, e) => {
                this.invokeEventCallback('rowdeselect', { $data: row, $event: e, row });
            },
            callOnRowClickEvent: (row, e) => {
                // Call row click only if click is triggered by user
                if (e && e.hasOwnProperty('originalEvent')) {
                    const rowData = this.addRowIndex(row);
                    this.invokeEventCallback('rowclick', { $data: rowData, $event: e, row: rowData });
                }
            },
            closePopover: closePopover,
            onColumnSelect: (col, e) => {
                this.selectedColumns = this.callDataGridMethod('getSelectedColumns');
                this.invokeEventCallback('columnselect', { $data: col, $event: e });
            },
            onColumnDeselect: (col, e) => {
                this.selectedColumns = this.callDataGridMethod('getSelectedColumns');
                this.invokeEventCallback('columndeselect', { $data: col, $event: e });
            },
            onHeaderClick: (col, e) => {
                // if onSort function is registered invoke it when the column header is clicked
                this.invokeEventCallback('headerclick', { $event: e, $data: col, column: col });
            },
            onRowDelete: (row, cancelRowDeleteCallback, e, callBack, options) => {
                this.ngZone.run(() => {
                    this.deleteRecord(_.extend({}, options, { row, 'cancelRowDeleteCallback': cancelRowDeleteCallback, 'evt': e, 'callBack': callBack }));
                });
            },
            onRowInsert: (row, e, callBack, options) => {
                this.insertRecord(_.extend({}, options, { row, event: e, 'callBack': callBack }));
            },
            beforeRowUpdate: (row, eventName) => {
                if (this._liveTableParent) {
                    this._liveTableParent.updateRow(row, eventName);
                }
                this.prevData = getClonedObject(row);
            },
            afterRowUpdate: (row, e, callBack, options) => {
                this.updateRecord(_.extend({}, options, { row, 'prevData': this.prevData, 'event': e, 'callBack': callBack }));
            },
            onBeforeRowUpdate: (row, e, options) => {
                return this.invokeEventCallback('beforerowupdate', { $event: e, $data: row, row, options: options });
            },
            onBeforeRowInsert: (row, e, options) => {
                return this.invokeEventCallback('beforerowinsert', { $event: e, $data: row, row, options: options });
            },
            onBeforeRowDelete: (row, e, options) => {
                const rowData = this.addRowIndex(row);
                return this.invokeEventCallback('beforerowdelete', { $event: e, row: rowData, options: options });
            },
            onFormRender: ($row, e, operation, alwaysNewRow) => {
                const widget = alwaysNewRow ? 'inlineInstanceNew' : 'inlineInstance';
                setTimeout(() => {
                    this.formWidgets = {};
                    this.fieldDefs.forEach(col => {
                        if (col[widget]) {
                            this.formWidgets[col.field] = col[widget];
                            this.setDisabledOnField(operation, col, widget);
                        }
                    });
                    this.invokeEventCallback('formrender', { $event: e, formWidgets: this.formWidgets, $operation: operation });
                }, 250);
            },
            onBeforeFormRender: (row, e, operation) => {
                return this.invokeEventCallback('beforeformrender', { $event: e, row, $operation: operation });
            },
            registerRowNgClassWatcher: (rowData, index) => {
                if (!this.rowngclass) {
                    return;
                }
                const row = this.getClonedRowObject(rowData);
                const watchName = `${this.widgetId}_rowNgClass_${index}`;
                $unwatch(watchName);
                this.registerDestroyListener($watch(this.rowngclass, this.viewParent, { row }, (nv, ov) => {
                    this.callDataGridMethod('applyRowNgClass', getConditionalClasses(nv, ov), index);
                }, watchName));
            },
            registerColNgClassWatcher: (rowData, colDef, rowIndex, colIndex) => {
                if (!colDef['col-ng-class']) {
                    return;
                }
                const row = this.getClonedRowObject(rowData);
                const watchName = `${this.widgetId}_colNgClass_${rowIndex}_${colIndex}`;
                $unwatch(watchName);
                this.registerDestroyListener($watch(colDef['col-ng-class'], this.viewParent, { row }, (nv, ov) => {
                    this.callDataGridMethod('applyColNgClass', getConditionalClasses(nv, ov), rowIndex, colIndex);
                }, watchName));
            },
            clearCustomExpression: () => {
                this.customExprViewRef.clear();
                this.customExprCompiledTl = {};
            },
            clearRowDetailExpression: () => {
                this.rowDetailViewRef.clear();
                this.rowDefMap = {};
                this.rowDefInstances = {};
            },
            generateCustomExpressions: (rowData, index) => {
                const row = this.getClonedRowObject(rowData);
                const compileTemplate = (tmpl) => {
                    if (!tmpl) {
                        return;
                    }
                    const colDef = {};
                    const context = {
                        row,
                        colDef
                    };
                    this.addEventsToContext(context);
                    const customExprView = this.customExprViewRef.createEmbeddedView(tmpl, context);
                    const rootNode = customExprView.rootNodes[0];
                    const fieldName = rootNode.getAttribute('data-col-identifier');
                    _.extend(colDef, this.columns[fieldName]);
                    this.customExprCompiledTl[fieldName + index] = rootNode;
                };
                if (this.isdynamictable) {
                    this.fieldDefs.forEach(col => {
                        compileTemplate(col.customExprTmpl);
                    });
                    return;
                }
                // For all the columns inside the table, generate the custom expression
                this.customExprTmpl.forEach(compileTemplate.bind(this));
            },
            generateRowExpansionCell: (rowData, index) => {
                const row = this.getClonedRowObject(rowData);
                // For all the columns inside the table, generate the inline widget
                this.rowExpansionActionTmpl.forEach((tmpl) => {
                    this.rowExpansionActionTl[index] = this.rowExpansionActionViewRef.createEmbeddedView(tmpl, { row }).rootNodes;
                });
            },
            getRowExpansionAction: (index) => {
                return this.rowExpansionActionTl[index];
            },
            generateRowDetailView: ($event, rowData, rowId, $target, $overlay, callback) => {
                const row = this.getClonedRowObject(rowData);
                const rowDef = getClonedObject(this.rowDef);
                if (this.rowInstance.invokeEventCallback('beforerowexpand', { $event, $data: rowDef, row }) === false) {
                    return;
                }
                if (!rowDef.content) {
                    return;
                }
                // Expand the row detail
                callback();
                // Row is already rendered. Return here
                if (this.rowDefMap[rowId] && this.rowDefMap[rowId].content === rowDef.content) {
                    this.rowInstance.invokeEventCallback('rowexpand', { $event, row, $data: this.rowDefInstances[rowId] });
                    return;
                }
                this.rowDefMap[rowId] = rowDef;
                $target.empty();
                $target.hide();
                $overlay.show();
                const context = {
                    row,
                    rowDef,
                    containerLoad: (widget) => {
                        setTimeout(() => {
                            $overlay.hide();
                            $target.show();
                            this.rowDefInstances[rowId] = widget;
                            this.rowInstance.invokeEventCallback('rowexpand', { $event, row, $data: widget });
                        }, 500);
                    }
                };
                const rootNode = this.rowDetailViewRef.createEmbeddedView(this.rowExpansionTmpl, context).rootNodes[0];
                $target[0].appendChild(rootNode);
                $appDigest();
            },
            onBeforeRowCollapse: ($event, row, rowId) => {
                return this.rowInstance.invokeEventCallback('beforerowcollapse', { $event, row, $data: this.rowDefInstances[rowId] });
            },
            onRowCollapse: ($event, row) => {
                this.rowInstance.invokeEventCallback('rowcollapse', { $event, row });
            },
            getCustomExpression: (fieldName, index) => {
                return this.customExprCompiledTl[fieldName + index] || '';
            },
            clearRowActions: () => {
                this.rowActionsViewRef.clear();
                this.rowActionsCompiledTl = {};
                this.rowExpansionActionViewRef.clear();
                this.rowExpansionActionTl = {};
            },
            generateRowActions: (rowData, index) => {
                const row = this.getClonedRowObject(rowData);
                this.rowActionsCompiledTl[index] = [];
                // For all the columns inside the table, generate the inline widget
                this.rowActionTmpl.forEach((tmpl) => {
                    this.rowActionsCompiledTl[index].push(...this.rowActionsViewRef.createEmbeddedView(tmpl, { row }).rootNodes);
                });
            },
            getRowAction: (index) => {
                return this.rowActionsCompiledTl[index];
            },
            generateInlineEditRow: (rowData, alwaysNewRow) => {
                const row = this.getClonedRowObject(rowData);
                if (alwaysNewRow) {
                    // Clear the view container ref
                    this.inlineEditNewViewRef.clear();
                    this.inlineNewCompliedTl = {};
                    // For all the columns inside the table, generate the inline widget
                    this.inlineWidgetNewTmpl.forEach(tmpl => {
                        let fieldName;
                        const context = {
                            row,
                            getControl: () => {
                                return this.ngform.controls[fieldName + '_new'] || {};
                            },
                            getValidationMessage: () => {
                                return this.columns[fieldName] && this.columns[fieldName].validationmessage;
                            }
                        };
                        const rootNode = this.inlineEditNewViewRef.createEmbeddedView(tmpl, context).rootNodes[0];
                        fieldName = rootNode.getAttribute('data-col-identifier');
                        this.inlineNewCompliedTl[fieldName] = rootNode;
                    });
                    this.clearForm(true);
                    return;
                }
                // Clear the view container ref
                this.inlineEditViewRef.clear();
                this.inlineCompliedTl = {};
                this.clearForm();
                // For all the columns inside the table, generate the inline widget
                this.inlineWidgetTmpl.forEach(tmpl => {
                    let fieldName;
                    const context = {
                        row,
                        getControl: () => {
                            return this.ngform.controls[fieldName] || {};
                        },
                        getValidationMessage: () => {
                            return this.columns[fieldName] && this.columns[fieldName].validationmessage;
                        }
                    };
                    const rootNode = this.inlineEditViewRef.createEmbeddedView(tmpl, context).rootNodes[0];
                    fieldName = rootNode.getAttribute('data-col-identifier');
                    this.inlineCompliedTl[fieldName] = rootNode;
                });
            },
            getInlineEditWidget: (fieldName, value, alwaysNewRow) => {
                if (alwaysNewRow) {
                    this.gridOptions.setFieldValue(fieldName + '_new', value);
                    return this.inlineNewCompliedTl[fieldName];
                }
                this.gridOptions.setFieldValue(fieldName, value);
                return this.inlineCompliedTl[fieldName];
            },
            setFieldValue: (fieldName, value) => {
                const control = this.ngform.controls && this.ngform.controls[fieldName];
                if (control) {
                    control.setValue(value);
                }
            },
            getFieldValue: fieldName => {
                const control = this.ngform.controls && this.ngform.controls[fieldName];
                return control && control.value;
            },
            generateFilterRow: () => {
                // Clear the view container ref
                this.filterViewRef.clear();
                this.rowFilterCompliedTl = {};
                // For all the columns inside the table, generate the compiled filter template
                this.filterTmpl.forEach((tmpl) => {
                    const rootNode = this.filterViewRef.createEmbeddedView(tmpl, {
                        changeFn: this.onRowFilterChange.bind(this),
                        isDisabled: (fieldName) => {
                            return this.emptyMatchModes.indexOf(this.rowFilter[fieldName] && this.rowFilter[fieldName].matchMode) > -1;
                        }
                    }).rootNodes[0];
                    this.rowFilterCompliedTl[rootNode.getAttribute('data-col-identifier')] = rootNode;
                });
            },
            getFilterWidget: (fieldName) => {
                // Move the generated filter template to the filter row
                return this.rowFilterCompliedTl[fieldName];
            },
            setGridEditMode: (val) => {
                this.ngZone.run(() => {
                    this.isGridEditMode = val;
                    $appDigest();
                });
            },
            setGridState: (val) => {
                this.isLoading = val === 'loading';
            },
            noChangesDetected: () => {
                this.toggleMessage(true, 'info', 'No Changes Detected');
            },
            // Function to redraw the widgets on resize of columns
            redrawWidgets: () => {
                this.fieldDefs.forEach(col => {
                    triggerFn(col.inlineInstance && col.inlineInstance.redraw);
                    triggerFn(col.inlineInstanceNew && col.inlineInstanceNew.redraw);
                    triggerFn(col.filterInstance && col.filterInstance.redraw);
                });
            },
            searchHandler: this.searchSortHandler.bind(this),
            sortHandler: this.searchSortHandler.bind(this),
            timeoutCall: (fn, delay) => {
                setTimeout(fn, delay);
            },
            runInNgZone: fn => {
                this.ngZone.run(fn);
            },
            safeApply: () => {
                $appDigest();
            },
            setTouched: (name) => {
                const ctrl = this.ngform.controls[name];
                if (ctrl) {
                    ctrl.markAsTouched();
                }
            },
            clearForm: this.clearForm.bind(this)
        };
        this._onChange = () => { };
        this._onTouched = () => { };
        styler(this.nativeElement, this);
        this.ngform = fb.group({});
        this.addEventsToContext(this.context);
        // Show loading status based on the variable life cycle
        this.app.subscribe('toggle-variable-state', options => {
            if (this.datasource && this.datasource.execute(DataSource.Operation.IS_API_AWARE) && isDataSourceEqual(options.variable, this.datasource)) {
                isDefined(this.variableInflight) ? this.debouncedHandleLoading(options) : this.handleLoading(options);
            }
        });
        this.deleteoktext = this.appLocale.LABEL_OK;
        this.deletecanceltext = this.appLocale.LABEL_CANCEL;
    }
    set gridData(newValue) {
        this._gridData = newValue;
        let startRowIndex = 0;
        let gridOptions;
        this._onChange(newValue);
        this._onTouched();
        if (isDefined(newValue)) {
            /*Setting the serial no's only when show navigation is enabled and data navigator is compiled
             and its current page is set properly*/
            if (this.isNavigationEnabled() && this.dataNavigator.dn.currentPage) {
                startRowIndex = ((this.dataNavigator.dn.currentPage - 1) * (this.dataNavigator.maxResults || 1)) + 1;
                this.setDataGridOption('startRowIndex', startRowIndex);
            }
            /* If colDefs are available, but not already set on the datagrid, then set them.
             * This will happen while switching from markup to design tab. */
            gridOptions = this.callDataGridMethod('getOptions');
            if (!gridOptions) {
                return;
            }
            if (!gridOptions.colDefs.length && this.fieldDefs.length) {
                this.setDataGridOption('colDefs', getClonedObject(this.fieldDefs));
            }
            // If data and colDefs are present, call on before data render event
            if (!this.isdynamictable && !_.isEmpty(newValue) && gridOptions.colDefs.length) {
                this.invokeEventCallback('beforedatarender', { $data: newValue, $columns: this.columns, data: newValue, columns: this.columns });
            }
            this.setDataGridOption('data', getClonedObject(newValue));
        }
    }
    get gridData() {
        return this._gridData || [];
    }
    get selecteditem() {
        if (this.multiselect) {
            return getClonedObject(this.items);
        }
        if (_.isEmpty(this.items)) {
            return {};
        }
        return getClonedObject(this.items[0]);
    }
    set selecteditem(val) {
        // Select the rows in the table based on the new selected items passed
        this.items.length = 0;
        this.callDataGridMethod('selectRows', val);
    }
    onKeyPress($event) {
        if ($event.which === 13) {
            this.invokeEventCallback('enterkeypress', { $event, $data: this.gridData });
        }
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        const runModeInitialProperties = {
            showrowindex: 'showRowIndex',
            multiselect: 'multiselect',
            radioselect: 'showRadioColumn',
            filternullrecords: 'filterNullRecords',
            enablesort: 'enableSort',
            showheader: 'showHeader',
            enablecolumnselection: 'enableColumnSelection',
            shownewrow: 'showNewRow',
            gridfirstrowselect: 'selectFirstRow'
        };
        if (this._liveTableParent) {
            this.isPartOfLiveGrid = true;
        }
        if (this.readonlygrid || !this.editmode) {
            if (this.readonlygrid === 'true') {
                this.editmode = '';
            }
            else {
                if (this.isPartOfLiveGrid) {
                    this.editmode = this.isPartOfLiveGrid.formlayout === 'inline' ? EDIT_MODE.FORM : EDIT_MODE.DIALOG;
                }
                else {
                    this.editmode = this.readonlygrid ? EDIT_MODE.INLINE : '';
                }
            }
        }
        this.gridOptions.colDefs = this.fullFieldDefs;
        this.gridOptions.rowActions = this.rowActions;
        this.gridOptions.headerConfig = this.headerConfig;
        this.gridOptions.rowClass = this.rowclass;
        this.gridOptions.editmode = this.editmode;
        this.gridOptions.formPosition = this.formposition;
        this.gridOptions.filtermode = this.filtermode;
        this.gridOptions.searchLabel = this.searchlabel;
        this.gridOptions.isMobile = isMobile();
        this.gridOptions.name = this.name;
        // When loadondemand property is enabled(deferload="true") and show is true, only the column titles of the datatable are rendered, the data(body of the datatable) is not at all rendered.
        // Because the griddata is setting before the datatable dom is rendered but we are sending empty data to the datatable.
        if (!_.isEmpty(this.gridData)) {
            this.gridOptions.data = getClonedObject(this.gridData);
        }
        this.gridOptions.messages = {
            'selectField': 'Select Field'
        };
        this.datagridElement = $(this._tableElement.nativeElement);
        this.gridElement = this.$element;
        this.$element.css({ 'position': 'relative' });
        _.forEach(runModeInitialProperties, (value, key) => {
            if (isDefined(this[key])) {
                this.gridOptions[value] = (this[key] === 'true' || this[key] === true);
            }
        });
        this.renderOperationColumns();
        this.gridOptions.colDefs = this.fieldDefs;
        this.datagridElement.datatable(this.gridOptions);
        this.callDataGridMethod('setStatus', 'loading', this.loadingdatamsg);
        this.applyProps.forEach(args => this.callDataGridMethod(...args));
        if (this.editmode === EDIT_MODE.QUICK_EDIT) {
            this.documentClickBind = this._documentClickBind.bind(this);
            document.addEventListener('click', this.documentClickBind);
        }
    }
    ngOnDestroy() {
        document.removeEventListener('click', this.documentClickBind);
        if (this.navigatorResultWatch) {
            this.navigatorResultWatch.unsubscribe();
        }
        if (this.navigatorMaxResultWatch) {
            this.navigatorMaxResultWatch.unsubscribe();
        }
        super.ngOnDestroy();
    }
    addRowIndex(row) {
        const rowData = getClonedObject(row);
        const rowIndex = _.indexOf(this.gridOptions.data, row);
        if (rowIndex < 0) {
            return row;
        }
        rowData.$index = rowIndex + 1;
        rowData.$isFirst = rowData.$index === 1;
        rowData.$isLast = this.gridData.length === rowData.$index;
        return rowData;
    }
    addEventsToContext(context) {
        context.addNewRow = () => this.addNewRow();
        context.deleteRow = () => this.deleteRow();
        context.editRow = () => this.editRow();
    }
    execute(operation, options) {
        if ([DataSource.Operation.IS_API_AWARE, DataSource.Operation.IS_PAGEABLE, DataSource.Operation.SUPPORTS_SERVER_FILTER].includes(operation)) {
            return false;
        }
        return this.datasource ? this.datasource.execute(operation, options) : {};
    }
    isNavigationEnabled() {
        return this.shownavigation && this.dataNavigator && this.dataNavigatorWatched;
    }
    getClonedRowObject(rowData) {
        const row = getClonedObject(rowData);
        row.getProperty = field => {
            return _.get(row, field);
        };
        row.$isFirst = row.$index === 1;
        row.$isLast = this.gridData.length === row.$index;
        delete row.$$index;
        delete row.$$pk;
        return row;
    }
    handleLoading(data) {
        this.variableInflight = data.active;
        // based on the active state and response toggling the 'loading data...' and 'no data found' messages.
        if (data.active) {
            this.callDataGridMethod('setStatus', 'loading', this.loadingdatamsg);
        }
        else {
            // If grid is in edit mode or grid has data, dont show the no data message
            if (!this.isGridEditMode && _.isEmpty(this.dataset)) {
                this.callDataGridMethod('setStatus', 'nodata', this.nodatamessage);
            }
            else {
                this.callDataGridMethod('setStatus', 'ready');
            }
        }
    }
    setDisabledOnField(operation, colDef, widgetType) {
        if (operation !== 'new' && colDef['primary-key'] && colDef.generator === 'assigned' && !colDef['related-entity-name'] && !colDef.period) {
            colDef[widgetType].disabled = true;
        }
    }
    resetFormControl(ctrl) {
        ctrl.markAsUntouched();
        ctrl.markAsPristine();
    }
    clearForm(newRow) {
        const ctrls = this.ngform.controls;
        _.keys(this.ngform.controls).forEach(key => {
            // If new row, clear the controls in the new row. Else, clear the controls in edit row
            if (!key.endsWith('_filter') && ((key.endsWith('_new') && newRow) || (!key.endsWith('_new') && !newRow))) {
                ctrls[key].setValue('');
                this.resetFormControl(ctrls[key]);
            }
        });
    }
    /* Check whether it is non-empty row. */
    isEmptyRecord(record) {
        const properties = Object.keys(record);
        let data, isDisplayed;
        return properties.every((prop, index) => {
            data = record[prop];
            /* If fieldDefs are missing, show all columns in data. */
            isDisplayed = (this.fieldDefs.length && isDefined(this.fieldDefs[index]) &&
                (isMobile() ? this.fieldDefs[index].mobileDisplay : this.fieldDefs[index].pcDisplay)) || true;
            /*Validating only the displayed fields*/
            if (isDisplayed) {
                return (data === null || data === undefined || data === '');
            }
            return true;
        });
    }
    /* Function to remove the empty data. */
    removeEmptyRecords(serviceData) {
        const allRecords = serviceData;
        let filteredData = [];
        if (allRecords && allRecords.length) {
            /*Comparing and pushing the non-empty data columns*/
            filteredData = allRecords.filter(record => {
                return record && !this.isEmptyRecord(record);
            });
        }
        return filteredData;
    }
    setGridData(serverData) {
        const data = this.filternullrecords ? this.removeEmptyRecords(serverData) : serverData;
        if (!this.variableInflight) {
            if (data && data.length === 0) {
                this.callDataGridMethod('setStatus', 'nodata', this.nodatamessage);
            }
            else {
                this.callDataGridMethod('setStatus', 'ready');
            }
        }
        this.gridData = data;
    }
    setDataGridOption(optionName, newVal, forceSet = false) {
        if (!this.datagridElement || !this.datagridElement.datatable || !this.datagridElement.datatable('instance')) {
            return;
        }
        const option = {};
        if (isDefined && (!_.isEqual(newVal, this.gridOptions[optionName]) || forceSet)) {
            option[optionName] = newVal;
            this.datagridElement.datatable('option', option);
            this.gridOptions[optionName] = newVal;
        }
    }
    callDataGridMethod(...args) {
        if (!this.datagridElement || !this.datagridElement.datatable('instance')) {
            this.applyProps.set(args[1], args);
            return; // If datagrid is not initiliazed or destroyed, return here
        }
        return this.datagridElement.datatable.apply(this.datagridElement, args);
    }
    renderOperationColumns() {
        let rowActionCol, insertPosition;
        const rowOperationsColumn = getRowOperationsColumn(), config = {
            'name': rowOperationsColumn.field,
            'field': rowOperationsColumn.field,
            'isPredefined': true
        };
        // Return if no fieldDefs are present
        if (!this.fieldDefs.length) {
            return;
        }
        rowActionCol = _.find(this.fullFieldDefs, { 'field': ROW_OPS_FIELD, type: 'custom' }); // Check if column is fetched from markup
        _.remove(this.fieldDefs, { type: 'custom', field: ROW_OPS_FIELD }); // Removing operations column
        _.remove(this.headerConfig, { field: rowOperationsColumn.field });
        /*Add the column for row operations only if at-least one operation has been enabled.*/
        if (this.rowActions.length) {
            if (rowActionCol) { // If column is present in markup, push the column or push the default column
                insertPosition = rowActionCol.rowactionsposition ? _.toNumber(rowActionCol.rowactionsposition) : this.fieldDefs.length;
                this.fieldDefs.splice(insertPosition, 0, rowActionCol);
                if (insertPosition === 0) {
                    this.headerConfig.unshift(config);
                }
                else {
                    this.headerConfig.push(config);
                }
            }
            else {
                this.fieldDefs.push(rowOperationsColumn);
                this.headerConfig.push(config);
            }
        }
        this.setDataGridOption('headerConfig', this.headerConfig);
    }
    enablePageNavigation() {
        if (this.dataset && this.binddataset && this.dataNavigator) {
            /*Check for sanity*/
            this.dataNavigatorWatched = true;
            if (this.navigatorResultWatch) {
                this.navigatorResultWatch.unsubscribe();
            }
            /*Register a watch on the "result" property of the "dataNavigator" so that the paginated data is displayed in the live-list.*/
            this.navigatorResultWatch = this.dataNavigator.resultEmitter.subscribe((newVal) => {
                /* Check for sanity. */
                if (isDefined(newVal)) {
                    // Watch will not be triggered if dataset and new value are equal. So trigger the property change handler manually
                    // This happens in case, if dataset is directly updated.
                    if (_.isEqual(this.dataset, newVal)) {
                        this.watchVariableDataSet(newVal);
                    }
                    else {
                        if (_.isArray(newVal)) {
                            this.widget.dataset = [].concat(newVal);
                        }
                        else if (_.isObject(newVal)) {
                            this.widget.dataset = _.extend({}, newVal);
                        }
                        else {
                            this.widget.dataset = newVal;
                        }
                    }
                }
                else {
                    this.widget.dataset = undefined;
                }
            }, true);
            /*De-register the watch if it is exists */
            if (this.navigatorMaxResultWatch) {
                this.navigatorMaxResultWatch.unsubscribe();
            }
            /*Register a watch on the "maxResults" property of the "dataNavigator" so that the "pageSize" is displayed in the live-list.*/
            this.navigatorMaxResultWatch = this.dataNavigator.maxResultsEmitter.subscribe((newVal) => {
                this.pagesize = newVal;
            });
            // If dataset is a pageable object, data is present inside the content property
            this.__fullData = this.dataset;
            this.dataNavigator.widget.maxResults = this.pagesize || 5;
            this.dataNavigator.options = {
                maxResults: this.pagesize || 5
            };
            this.removePropertyBinding('dataset');
            this.dataNavigator.setBindDataSet(this.binddataset, this.viewParent, this.datasource, this.dataset, this.binddatasource);
        }
    }
    resetPageNavigation() {
        /*Check for sanity*/
        if (this.dataNavigator) {
            this.dataNavigator.resetPageNavigation();
        }
    }
    isDataValid() {
        let error;
        const dataset = this.dataset || {};
        /*In case "data" contains "error" & "errorMessage", then display the error message in the grid.*/
        if (dataset.error) {
            error = dataset.error;
        }
        if (dataset.data && dataset.data.error) {
            if (dataset.data.errorMessage) {
                error = dataset.data.errorMessage;
            }
        }
        if (error) {
            this.setGridData([]);
            this.callDataGridMethod('setStatus', 'error', error);
            return false;
        }
        return true;
    }
    // Function to populate the grid with data.
    populateGridData(serviceData) {
        let data;
        serviceData = transformData(serviceData, this.name);
        // Apply filter and sort, if data is refreshed through Refresh data method
        if (!this.isNavigationEnabled() && this._isClientSearch) {
            data = getClonedObject(serviceData);
            data = this.getSearchResult(data, this.filterInfo);
            data = this.getSortResult(data, this.sortInfo);
            this.serverData = data;
        }
        else {
            this.serverData = serviceData;
        }
        // If fielddefs are not present, generate fielddefs from data
        // Removing fielddefs check because When loadondemand property is enabled(deferload="true"), the dataset propertychangehanlder is triggered first before the dom is getting rendered.
        // So at that time fielddefs length is zero, due to this the columns are created dynamically.
        if (this.isdynamictable) {
            this.createGridColumns(this.serverData);
        }
        else {
            this.setGridData(this.serverData);
        }
    }
    // Function to generate and compile the form fields from the metadata
    generateDynamicColumns(columns) {
        return __awaiter(this, void 0, void 0, function* () {
            this.fieldDefs = []; // empty the form fields
            // empty the filter field template refs.
            this.filterTmpl._results = [];
            if (_.isEmpty(columns)) {
                return;
            }
            let tmpl = '';
            columns.forEach(col => {
                let attrsTmpl = '';
                let customTmpl = '';
                _.forEach(col, (val, key) => {
                    if (val) {
                        // If custom expression is present, keep it inside table column. Else, keep as attribute
                        if (key === 'customExpression') {
                            customTmpl = val;
                        }
                        else {
                            attrsTmpl += ` ${key}="${val}"`;
                        }
                    }
                });
                tmpl += `<wm-table-column ${attrsTmpl} tableName="${this.name}">${customTmpl}</wm-table-column>`;
            });
            this.dynamicTableRef.clear();
            if (!this._dynamicContext) {
                this._dynamicContext = Object.create(this.viewParent);
                this._dynamicContext[this.getAttr('wmTable')] = this;
            }
            this.noOfColumns = columns.length;
            const componentFactoryRef = yield this.dynamicComponentProvider.getComponentFactoryRef('app-table-dynamic-' + this.widgetId, tmpl, {
                noCache: true,
                transpile: true
            });
            const component = this.dynamicTableRef.createComponent(componentFactoryRef, 0, this.inj);
            extendProto(component.instance, this._dynamicContext);
            this.$element.find('.dynamic-table-container')[0].appendChild(component.location.nativeElement);
        });
    }
    prepareColDefs(data) {
        let defaultFieldDefs;
        let properties;
        this.fieldDefs = [];
        this.headerConfig = [];
        this.columns = {};
        /* if properties map is existed then fetch the column configuration for all nested levels using util function */
        properties = data;
        /*call utility function to prepare fieldDefs for grid against given data (A MAX OF 10 COLUMNS ONLY)*/
        defaultFieldDefs = prepareFieldDefs(properties);
        /*append additional properties*/
        _.forEach(defaultFieldDefs, columnDef => {
            columnDef.binding = columnDef.field;
            columnDef.caption = columnDef.displayName;
            columnDef.pcDisplay = true;
            columnDef.mobileDisplay = true;
            columnDef.searchable = true;
            columnDef.type = 'string';
        });
        defaultFieldDefs.forEach(col => {
            this.columns[col.field] = col;
        });
        this.invokeEventCallback('beforedatarender', { $data: data, $columns: this.columns, data: data, columns: this.columns });
        defaultFieldDefs = [];
        // Apply the changes made by the user
        _.forEach(this.columns, val => {
            defaultFieldDefs.push(val);
        });
        this.generateDynamicColumns(defaultFieldDefs);
    }
    createGridColumns(data) {
        /* this call back function receives the data from the variable */
        /* check whether data is valid or not */
        const dataValid = data && !data.error;
        /*if the data is type json object, make it an array of the object*/
        if (dataValid && !_.isArray(data)) {
            data = [data];
        }
        /* if the data is empty, show nodatamessage */
        if (_.isEmpty(data)) {
            this.setGridData(data);
            return;
        }
        if (!dataValid) {
            return;
        }
        /* if new columns to be rendered, prepare default fieldDefs for the data provided*/
        this.prepareColDefs(data);
        this.serverData = data;
        this.setGridData(this.serverData);
    }
    getSortExpr() {
        let sortExp;
        let pagingOptions;
        if (this.datasource && this.datasource.execute(DataSource.Operation.IS_PAGEABLE)) {
            pagingOptions = this.datasource.execute(DataSource.Operation.GET_PAGING_OPTIONS);
            sortExp = _.isEmpty(pagingOptions) ? '' : getOrderByExpr(pagingOptions.sort);
        }
        return sortExp || '';
    }
    watchVariableDataSet(newVal) {
        let result;
        // After the setting the watch on navigator, dataset is triggered with undefined. In this case, return here.
        if (this.dataNavigatorWatched && _.isUndefined(newVal) && this.__fullData) {
            return;
        }
        // If variable is in loading state, show loading icon
        if (this.variableInflight) {
            this.callDataGridMethod('setStatus', 'loading', this.loadingdatamsg);
        }
        result = getValidJSON(newVal);
        // Converting newval to object if it is an Object that comes as a string "{"data" : 1}"
        if (result) {
            newVal = result;
        }
        /*Return if data is invalid.*/
        if (!this.isDataValid()) {
            return;
        }
        // If value is empty or in studio mode, dont enable the navigation
        if (newVal) {
            if (this.shownavigation && !this.dataNavigatorWatched) {
                this.enablePageNavigation();
                return;
            }
        }
        else {
            this.resetPageNavigation();
            /*for run mode, disabling the loader and showing no data found message if dataset is not valid*/
            if (!this.variableInflight) {
                this.callDataGridMethod('setStatus', 'nodata', this.nodatamessage);
            }
            this.setDataGridOption('selectFirstRow', this.gridfirstrowselect);
        }
        if (!this.isNavigationEnabled() && newVal) {
            this.checkFiltersApplied(this.getSortExpr());
        }
        if (!_.isObject(newVal) || newVal === '' || (newVal && newVal.dataValue === '')) {
            if (!this.variableInflight) {
                // If variable has finished loading and resultSet is empty, ender empty data
                this.setGridData([]);
            }
            return;
        }
        if (newVal) {
            this.populateGridData(newVal);
        }
    }
    onDataSourceChange() {
        this.fieldDefs.forEach(col => {
            triggerFn(col.onDataSourceChange && col.onDataSourceChange.bind(col));
        });
    }
    onPropertyChange(key, nv, ov) {
        let enableNewRow;
        switch (key) {
            case 'datasource':
                this.watchVariableDataSet(this.dataset);
                this.onDataSourceChange();
                break;
            case 'dataset':
                if (this.binddatasource && !this.datasource) {
                    return;
                }
                this.watchVariableDataSet(nv);
                break;
            case 'filtermode':
                this.setDataGridOption('filtermode', nv);
                break;
            case 'searchlabel':
                this.setDataGridOption('searchLabel', nv);
                break;
            case 'navigation':
                if (nv === 'Advanced') { // Support for older projects where navigation type was advanced instead of clasic
                    this.navigation = 'Classic';
                    return;
                }
                if (nv !== 'None') {
                    this.shownavigation = true;
                }
                this.navControls = nv;
                break;
            case 'gridfirstrowselect':
                this.setDataGridOption('selectFirstRow', nv);
                break;
            case 'gridclass':
                this.callDataGridMethod('option', 'cssClassNames.grid', nv);
                break;
            case 'nodatamessage':
                this.callDataGridMethod('option', 'dataStates.nodata', nv);
                break;
            case 'loadingdatamsg':
                this.callDataGridMethod('option', 'dataStates.loading', nv);
                break;
            case 'loadingicon':
                this.callDataGridMethod('option', 'loadingicon', nv);
                break;
            case 'spacing':
                this.callDataGridMethod('option', 'spacing', nv);
                if (nv === 'condensed') {
                    this.navigationSize = 'small';
                }
                else {
                    this.navigationSize = '';
                }
                break;
            case 'exportformat':
                this.exportOptions = [];
                if (nv) {
                    // Populate options for export drop down menu
                    _.forEach(_.split(nv, ','), type => {
                        this.exportOptions.push({
                            label: type,
                            icon: exportIconMapping[type]
                        });
                    });
                }
                break;
            case 'shownewrow':
                // Enable new row if shownew is true or addNewRow buton is present
                enableNewRow = nv || _.some(this.actions, act => _.includes(act.action, 'addNewRow()'));
                this.callDataGridMethod('option', 'actionsEnabled.new', enableNewRow);
                break;
            case 'show':
                if (nv) {
                    this.invokeEventCallback('show');
                }
                else {
                    this.invokeEventCallback('hide');
                }
            default:
                super.onPropertyChange(key, nv, ov);
        }
    }
    onStyleChange(key, nv, ov) {
        switch (key) {
            case 'width':
                this.callDataGridMethod('setGridDimensions', 'width', nv);
                break;
            case 'height':
                this.callDataGridMethod('setGridDimensions', 'height', nv);
                break;
        }
        super.onStyleChange(key, nv, ov);
    }
    populateActions() {
        this._actions.header = [];
        this._actions.footer = [];
        _.forEach(this.actions, (action) => {
            if (_.includes(action.position, 'header')) {
                this._actions.header.push(action);
            }
            if (_.includes(action.position, 'footer')) {
                this._actions.footer.push(action);
            }
        });
    }
    // this method will render the filter row.
    renderDynamicFilterColumn(filteTemRef) {
        // For dynamic table manually pushing the filtertemplateRef as templateRef will not be available prior.
        if (this.isdynamictable) {
            this.filterTmpl._results.push(filteTemRef);
        }
    }
    registerColumns(tableColumn) {
        if (isMobile()) {
            if (!tableColumn.mobileDisplay) {
                return;
            }
        }
        else {
            if (!tableColumn.pcDisplay) {
                return;
            }
        }
        const colCount = this.fieldDefs.push(tableColumn);
        this.fullFieldDefs.push(tableColumn);
        this.rowFilter[tableColumn.field] = {
            value: undefined
        };
        this.fieldDefs.forEach(col => {
            this.columns[col.field] = col;
        });
        // If dynamic datatable and last column, pass the columns to jquery datatable
        if (this.isdynamictable && colCount === this.noOfColumns) {
            this.renderOperationColumns();
            this.setDataGridOption('colDefs', this.fieldDefs);
        }
    }
    registerFormField(name, formField) {
        this.formfields[name] = formField;
    }
    registerActions(tableAction) {
        this.actions.push(tableAction);
        this.populateActions();
    }
    registerRow(tableRow, rowInstance) {
        this.rowDef = tableRow;
        this.rowInstance = rowInstance;
        this.callDataGridMethod('option', 'cssClassNames.rowExpandIcon', this.rowDef.expandicon);
        this.callDataGridMethod('option', 'cssClassNames.rowCollapseIcon', this.rowDef.collapseicon);
        this.gridOptions.rowExpansionEnabled = true;
        this.gridOptions.rowDef = this.rowDef;
    }
    registerRowActions(tableRowAction) {
        this.rowActions.push(tableRowAction);
    }
    selectItem(item, data) {
        /* server is not updating immediately, so set the server data to success callback data */
        if (data) {
            this.serverData = data;
        }
        if (_.isObject(item)) {
            item = _.omitBy(item, (value) => {
                return _.isArray(value) && _.isEmpty(value);
            });
        }
        this.callDataGridMethod('selectRow', item, true);
    }
    /* deselect the given item*/
    deselectItem(item) {
        this.callDataGridMethod('deselectRow', item);
    }
    onDataNavigatorDataSetChange(nv) {
        let data;
        this.__fullData = nv;
        this.checkFiltersApplied(this.getSortExpr());
        if (this._isClientSearch) {
            data = getClonedObject(this.__fullData);
            if (_.isObject(data) && !_.isArray(data)) {
                data = [data];
            }
            data = this.getSearchResult(data, this.filterInfo);
            data = this.getSortResult(data, this.sortInfo);
            return data;
        }
        return nv;
    }
    toggleMessage(show, type, msg, header) {
        if (show && msg) {
            this.app.notifyApp(msg, type, header);
        }
    }
    export($item) {
        let filterFields;
        const sortOptions = _.isEmpty(this.sortInfo) ? '' : this.sortInfo.field + ' ' + this.sortInfo.direction;
        const columns = {};
        let isValid;
        let requestData;
        this.fieldDefs.forEach(fieldDef => {
            // Do not add the row operation actions column to the exported file.
            if (fieldDef.field === ROW_OPS_FIELD || !fieldDef.show) {
                return;
            }
            const option = {
                'header': fieldDef.displayName
            };
            // If column has exportexpression, then send form the expression as required by backend.
            // otherwise send the field name.
            if (fieldDef.exportexpression) {
                option.expression = fieldDef.exportexpression;
            }
            else {
                option.field = fieldDef.field;
            }
            columns[fieldDef.field] = option;
        });
        filterFields = this.getFilterFields(this.filterInfo);
        requestData = {
            matchMode: 'anywhereignorecase',
            filterFields: filterFields,
            orderBy: sortOptions,
            exportType: $item.label,
            logicalOp: 'AND',
            exportSize: this.exportdatasize,
            columns: columns
        };
        isValid = this.invokeEventCallback('beforeexport', { $data: requestData });
        if (isValid === false) {
            return;
        }
        requestData.fields = _.values(requestData.columns);
        this.datasource.execute(DataSource.Operation.DOWNLOAD, { data: requestData });
    }
    expandRow(rowId) {
        this.callDataGridMethod('expandRow', rowId);
    }
    collapseRow(rowId) {
        this.callDataGridMethod('collapseRow', rowId);
    }
    _documentClickBind(event) {
        const $target = event.target;
        // If click triggered from same grid or a dialog, do not save the row
        if (this.$element[0].contains($target) || event.target.doctype || isInputBodyWrapper($($target))) {
            return;
        }
        this.callDataGridMethod('saveRow');
    }
    _redraw(forceRender) {
        if (forceRender) {
            this.datagridElement.datatable(this.gridOptions);
        }
        else {
            setTimeout(() => {
                this.callDataGridMethod('setColGroupWidths');
                this.callDataGridMethod('addOrRemoveScroll');
            });
        }
    }
    invokeActionEvent($event, expression) {
        const fn = $parseEvent(expression);
        fn(this.viewParent, Object.assign(this.context, { $event }));
    }
    // change and blur events are added from the template
    handleEvent(node, eventName, callback, locals) {
        if (eventName !== 'select') {
            super.handleEvent(this.nativeElement, eventName, callback, locals);
        }
    }
    triggerUploadEvent($event, eventName, fieldName, row) {
        const params = { $event, row };
        if (!this.columns[fieldName]) {
            return;
        }
        if (eventName === 'change') {
            params.newVal = $event.target.files;
            params.oldVal = this.columns[fieldName]._oldUploadVal;
            this.columns[fieldName]._oldUploadVal = params.newVal;
        }
        this.columns[fieldName].invokeEventCallback(eventName, params);
    }
    registerFormWidget() { }
    // Form control accessor methods. This will be used for table inside form
    writeValue() { }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
}
TableComponent.initializeProps = registerProps$T();
TableComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmTable]',
                template: "<div class=\"panel-heading\" *ngIf=\"title || subheading || iconclass || exportOptions.length || _actions.header.length\">\n    <h3 class=\"panel-title\">\n        <div class=\"pull-left\">\n            <i class=\"app-icon panel-icon {{iconclass}}\" *ngIf=\"iconclass\"></i>\n        </div>\n        <div class=\"pull-left\">\n            <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\"></div>\n            <div class=\"description\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n        </div>\n        <div class=\"panel-actions app-datagrid-actions\" *ngIf=\"exportOptions.length || _actions.header.length\">\n            <ng-container *ngFor=\"let btn of _actions.header\"\n                          [ngTemplateOutlet]=\"btn.widgetType === 'button' ? buttonRef : anchorRef\" [ngTemplateOutletContext]=\"{btn:btn}\">\n            </ng-container>\n            <div wmMenu dropdown caption.bind=\"appLocale.LABEL_EXPORT\" *ngIf=\"exportOptions.length\"  autoclose=\"always\" attr.name=\"{{name}}-export\"\n                dataset.bind=\"exportOptions\" select.event=\"export($item)\" menuposition=\"down,left\"></div>\n        </div>\n    </h3>\n</div>\n<div class=\"app-datagrid\" #datagridElement></div>\n<div class=\"panel-footer clearfix\" [hidden]=\"!_actions.footer.length && (!shownavigation || dataNavigator?.dataSize <= pagesize)\">\n    <div class=\"app-datagrid-paginator\" [hidden]=\"!dataNavigator?.dataSize || !shownavigation || dataNavigator?.dataSize <= pagesize\">\n        <nav wmPagination show.bind=\"shownavigation\" navigationalign.bind=\"navigationalign\"\n             navigationsize.bind=\"navigationSize\"\n             navigation.bind=\"navControls\" showrecordcount.bind=\"showrecordcount\" maxsize.bind=\"maxsize\"\n             boundarylinks.bind=\"boundarylinks\"\n             forceellipses.bind=\"forceellipses\" directionlinks.bind=\"directionlinks\"></nav>\n    </div>\n    <div class=\"app-datagrid-actions\" *ngIf=\"_actions.footer.length\">\n        <ng-container *ngFor=\"let btn of _actions.footer\"\n                      [ngTemplateOutlet]=\"btn.widgetType === 'button' ? buttonRef : anchorRef\" [ngTemplateOutletContext]=\"{btn:btn}\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #buttonRef let-btn=\"btn\">\n    <button wmButton caption.bind=\"btn.displayName\" show.bind=\"btn.show\" class.bind=\"btn.class\"  iconclass.bind=\"btn.iconclass\" (click)=\"invokeActionEvent($event, btn.action)\"\n            [ngClass]=\"{'btn-sm': spacing === 'condensed', 'disabled-new': btn.key === 'addNewRow' && (isGridEditMode || isLoading)}\"\n            type=\"button\" shortcutkey.bind=\"btn.shortcutkey\" tabindex.bind=\"btn.tabindex\" hint.bind=\"btn.title\" disabled.bind=\"btn.disabled\" conditionalclass.bind=\"btn.conditionalclass\" conditionalstyle.bind=\"btn.conditionalstyle\"></button>\n</ng-template>\n\n<ng-template #anchorRef let-btn=\"btn\">\n    <a wmAnchor caption.bind=\"btn.displayName\" show.bind=\"btn.show\" class.bind=\"btn.class\"  iconclass.bind=\"btn.iconclass\" (click)=\"invokeActionEvent($event, btn.action)\"\n            [ngClass]=\"{'btn-sm': spacing === 'condensed', 'disabled-new': btn.key === 'addNewRow' && (isGridEditMode || isLoading)}\"\n            shortcutkey.bind=\"btn.shortcutkey\" tabindex.bind=\"btn.tabindex\" hint.bind=\"btn.title\"\n            hyperlink.bind=\"btn.hyperlink\" target.bind=\"btn.target\" conditionalclass.bind=\"btn.conditionalclass\" conditionalstyle.bind=\"btn.conditionalstyle\"></a>\n</ng-template>\n\n<div hidden>\n    <ng-container #multiColumnFilterView></ng-container>\n\n    <ng-container #inlineEditView></ng-container>\n\n    <ng-container #inlineEditNewView></ng-container>\n\n    <ng-container #rowActionsView></ng-container>\n\n    <ng-container #rowExpansionActionView></ng-container>\n\n    <ng-container #customExprView></ng-container>\n\n    <ng-container #dynamicTable></ng-container>\n\n    <ng-container #rowDetailView></ng-container>\n\n    <div class=\"dynamic-table-container\"></div>\n</div>\n",
                providers: [
                    provideAsNgValueAccessor(TableComponent),
                    provideAsWidgetRef(TableComponent)
                ]
            }] }
];
/** @nocollapse */
TableComponent.ctorParameters = () => [
    { type: Injector },
    { type: FormBuilder },
    { type: App },
    { type: DynamicComponentRefProvider },
    { type: undefined, decorators: [{ type: Attribute, args: ['dataset.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['datasource.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['readonlygrid',] }] },
    { type: NgZone }
];
TableComponent.propDecorators = {
    dataNavigator: [{ type: ViewChild, args: [PaginationComponent,] }],
    _tableElement: [{ type: ViewChild, args: ['datagridElement',] }],
    rowActionTmpl: [{ type: ContentChildren, args: ['rowActionTmpl',] }],
    rowActionsViewRef: [{ type: ViewChild, args: ['rowActionsView', { read: ViewContainerRef },] }],
    filterTmpl: [{ type: ContentChildren, args: ['filterTmpl', { descendants: true },] }],
    filterViewRef: [{ type: ViewChild, args: ['multiColumnFilterView', { read: ViewContainerRef },] }],
    inlineWidgetTmpl: [{ type: ContentChildren, args: ['inlineWidgetTmpl', { descendants: true },] }],
    inlineEditViewRef: [{ type: ViewChild, args: ['inlineEditView', { read: ViewContainerRef },] }],
    inlineWidgetNewTmpl: [{ type: ContentChildren, args: ['inlineWidgetTmplNew', { descendants: true },] }],
    inlineEditNewViewRef: [{ type: ViewChild, args: ['inlineEditNewView', { read: ViewContainerRef },] }],
    customExprTmpl: [{ type: ContentChildren, args: ['customExprTmpl', { descendants: true },] }],
    customExprViewRef: [{ type: ViewChild, args: ['customExprView', { read: ViewContainerRef },] }],
    rowExpansionActionTmpl: [{ type: ContentChildren, args: ['rowExpansionActionTmpl',] }],
    rowExpansionTmpl: [{ type: ContentChild, args: ['rowExpansionTmpl',] }],
    rowDetailViewRef: [{ type: ViewChild, args: ['rowDetailView', { read: ViewContainerRef },] }],
    rowExpansionActionViewRef: [{ type: ViewChild, args: ['rowExpansionActionView', { read: ViewContainerRef },] }],
    dynamicTableRef: [{ type: ViewChild, args: ['dynamicTable', { read: ViewContainerRef },] }],
    onKeyPress: [{ type: HostListener, args: ['keypress', ['$event'],] }]
};

class FormWidgetDirective {
    constructor(form, table, componentInstance, fb, name, key) {
        this.componentInstance = componentInstance;
        this.name = name;
        this.key = key;
        this.fb = fb;
        this.parent = form || table;
        this.ngform = this.parent.ngform;
        this.componentInstance.registerPropertyChangeListener((k, nv) => {
            if (k === 'datavalue' && this._control) {
                this._control.setValue(nv);
            }
            else if (k === 'name' && !this._control) {
                this.addControl(this.key || nv);
            }
        });
    }
    get _control() {
        const fieldName = this.key || this.name;
        if (!fieldName) {
            return undefined;
        }
        return this.ngform && this.ngform.controls[fieldName];
    }
    addControl(fieldName) {
        this.ngform.addControl(fieldName, this.createControl());
    }
    createControl() {
        return this.fb.control(this.componentInstance.datavalue);
    }
    ngOnInit() {
        const fieldName = this.key || this.name;
        if (fieldName && !this._control) {
            this.addControl(fieldName);
            this.parent.registerFormWidget(this.componentInstance);
        }
    }
}
FormWidgetDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmFormWidget]'
            },] }
];
/** @nocollapse */
FormWidgetDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FormComponent,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TableComponent,] }] },
    { type: undefined, decorators: [{ type: Self }, { type: Inject, args: [WidgetRef,] }] },
    { type: FormBuilder },
    { type: undefined, decorators: [{ type: Attribute, args: ['name',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['key',] }] }
];

const registerProps$U = () => {
    register('wm-label', new Map([
        ['caption', Object.assign({ value: 'Label' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['hint', PROP_STRING],
        ['name', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$w = 'app-label';
const WIDGET_CONFIG$F = {
    widgetType: 'wm-label',
    hostClass: DEFAULT_CLS$w,
    displayType: DISPLAY_TYPE.INLINE_BLOCK
};
class LabelDirective extends StylableComponent {
    constructor(inj, trustAsPipe) {
        super(inj, WIDGET_CONFIG$F);
        this.trustAsPipe = trustAsPipe;
        styler(this.nativeElement, this);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'caption') {
            if (_.isObject(nv)) {
                setProperty(this.nativeElement, 'textContent', JSON.stringify(nv));
            }
            else {
                setProperty(this.nativeElement, 'innerHTML', this.trustAsPipe.transform(nv, SecurityContext.HTML));
            }
        }
        else if (key === 'required') {
            toggleClass(this.nativeElement, 'required', nv);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
LabelDirective.initializeProps = registerProps$U();
LabelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLabel]',
                providers: [
                    provideAsWidgetRef(LabelDirective)
                ]
            },] }
];
/** @nocollapse */
LabelDirective.ctorParameters = () => [
    { type: Injector },
    { type: TrustAsPipe }
];

const registerProps$V = () => {
    register('wm-gridcolumn', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['columnwidth', PROP_NUMBER],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$x = 'app-grid-column';
const WIDGET_CONFIG$G = {
    widgetType: 'wm-gridcolumn',
    hostClass: DEFAULT_CLS$x
};
class LayoutGridColumnDirective extends StylableComponent {
    constructor(inj, height) {
        super(inj, WIDGET_CONFIG$G);
        // if the height is provided set the overflow to auto
        if (height) {
            setCSS(this.nativeElement, 'overflow', 'auto');
        }
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
    onPropertyChange(key, nv, ov) {
        const prefix = isMobileApp() ? 'xs' : 'sm';
        if (key === 'columnwidth') {
            switchClass(this.nativeElement, `col-${prefix}-${nv}`, ov ? `col-${prefix}-${ov}` : '');
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
LayoutGridColumnDirective.initializeProps = registerProps$V();
LayoutGridColumnDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLayoutGridColumn]',
                providers: [
                    provideAsWidgetRef(LayoutGridColumnDirective)
                ]
            },] }
];
/** @nocollapse */
LayoutGridColumnDirective.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Attribute, args: ['height',] }] }
];

const registerProps$W = () => {
    register('wm-layoutgrid', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$y = 'app-grid-layout clearfix';
const WIDGET_CONFIG$H = {
    widgetType: 'wm-layoutgrid',
    hostClass: DEFAULT_CLS$y
};
class LayoutgridDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$H);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
LayoutgridDirective.initializeProps = registerProps$W();
LayoutgridDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLayoutGrid]',
                providers: [
                    provideAsWidgetRef(LayoutgridDirective)
                ]
            },] }
];
/** @nocollapse */
LayoutgridDirective.ctorParameters = () => [
    { type: Injector }
];

const registerProps$X = () => {
    register('wm-layout-grid-row', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$z = 'app-grid-row clearfix';
const WIDGET_CONFIG$I = {
    widgetType: 'wm-layout-grid-row',
    hostClass: DEFAULT_CLS$z
};
class LayoutGridRowDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$I);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
LayoutGridRowDirective.initializeProps = registerProps$X();
LayoutGridRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLayoutGridRow]',
                providers: [
                    provideAsWidgetRef(LayoutGridRowDirective)
                ]
            },] }
];
/** @nocollapse */
LayoutGridRowDirective.ctorParameters = () => [
    { type: Injector }
];

class LazyLoadDirective {
    constructor(inj, templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.viewParent = inj.view.component;
        this.context = inj.view.context;
    }
    set lazyLoad(expr) {
        this.unSubscribeFn = $watch(expr, this.viewParent, this.context, (val) => {
            if (!this.embeddedView && val) {
                this.embeddedView = this.viewContainer.createEmbeddedView(this.templateRef, this.context);
                this.unSubscribeFn();
            }
        });
    }
    ngOnDestroy() {
        this.unSubscribeFn();
    }
}
LazyLoadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[lazyLoad]'
            },] }
];
/** @nocollapse */
LazyLoadDirective.ctorParameters = () => [
    { type: Injector },
    { type: TemplateRef },
    { type: ViewContainerRef }
];
LazyLoadDirective.propDecorators = {
    lazyLoad: [{ type: Input }]
};

const registerProps$Y = () => {
    register('wm-left-panel', new Map([
        ['animation', Object.assign({ value: 'slide-in' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['columnwidth', Object.assign({ value: 3 }, PROP_NUMBER)],
        ['content', PROP_STRING],
        ['gestures', Object.assign({ value: 'on' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['xscolumnwidth', Object.assign({ value: 10 }, PROP_NUMBER)]
    ]));
};

class LeftPanelAnimator extends SwipeAnimation {
    constructor(leftPanel) {
        super();
        this.leftPanel = leftPanel;
        this.init(this.leftPanel.$ele, this.leftPanel.$page);
    }
    bounds() {
        let offset = 0;
        this.setGesturesEnabled(this.leftPanel.isGesturesEnabled());
        if (!this._width) {
            this._pageContainerWidth = this.leftPanel.$page.width();
            this._leftPanelWidth = this.leftPanel.$ele.width();
            this._maxX = this._leftPanelWidth / this._pageContainerWidth * 100;
            this._width = this.leftPanel.animation === AnimationType.SLIDE_IN ? this._pageContainerWidth : this._leftPanelWidth;
        }
        this._expanded = this.leftPanel.expanded;
        if (this._expanded) {
            return {
                'center': this._leftPanelWidth,
                'lower': -(this._leftPanelWidth - offset)
            };
        }
        if (this.leftPanel.app.isTabletApplicationType) {
            offset = 53.32;
        }
        return {
            'center': 0,
            'upper': this._leftPanelWidth - offset
        };
    }
    context() {
        return {
            'w': this._width,
            'pageW': this._pageContainerWidth,
            'leftW': this._leftPanelWidth,
            'maxX': this._maxX,
            'limit': (min, v, max) => {
                if (v < min) {
                    return min;
                }
                if (v > max) {
                    return max;
                }
                return v;
            }
        };
    }
    animation() {
        this._$animatedElements = this.leftPanel.$ele;
        if (this.leftPanel.animation === AnimationType.SLIDE_IN) {
            this._$animatedElements = this._$animatedElements.add(this.leftPanel.$page);
            if (this.leftPanel.app.isTabletApplicationType) {
                return [
                    {
                        'target': this.leftPanel.$ele,
                        'css': {
                            'transform': 'translate3d(${{ limit(-100, -($d * 100 / leftW), 0) + \'%\' }}, 0, 0)'
                        }
                    },
                    {
                        'target': this.leftPanel.$page,
                        'css': {
                            'transform': 'translate3d(${{ (($d) * 100 / pageW) + \'%\' }}, 0, 0)',
                            'width': '${{ (pageW - $d) + \'px\' }}',
                            'z-index': 101
                        }
                    }
                ];
            }
            return [
                {
                    'target': this.leftPanel.$ele,
                    'css': {
                        'transform': 'translate3d(-100%, 0, 0)',
                        'opacity': 1,
                        'z-index': 101
                    }
                },
                {
                    'target': this.leftPanel.$page,
                    'css': {
                        'transform': 'translate3d(${{ limit( 0, ((($D + $d) * 100 / w)), maxX ) + \'%\' }}, 0, 0)',
                        'opacity': 1,
                        'z-index': 101
                    }
                }
            ];
        }
        else {
            return {
                'transform': 'translate3d(${{ limit( -100, ((($D + $d) * 100 / w) - 100), 0 ) + \'%\'}}, 0, 0)',
                'opacity': 1,
                'z-index': 101
            };
        }
    }
    onLower() {
        this._expanded = false;
        this.leftPanel.collapse();
        this.resetTransition();
        $appDigest();
    }
    onUpper() {
        this._expanded = true;
        this.leftPanel.expand();
        this.resetTransition();
        $appDigest();
    }
    resetTransition() {
        if (this._$animatedElements) {
            /*
             * This timeout is for preventing UI flicker at the end of animation.
             */
            setTimeout(() => {
                this._$animatedElements.css({
                    'transform': '',
                    'opacity': '',
                    'z-index': '',
                    'width': ''
                });
            }, 100);
        }
    }
}

const registerProps$Z = () => {
    register('wm-page', new Map([
        ['pagetitle', PROP_STRING]
    ]));
};

var CLASS_NAME;
(function (CLASS_NAME) {
    CLASS_NAME["LEFT_PANEL"] = "page-left-panel";
    CLASS_NAME["RIGHT_PANEL"] = "page-right-panel";
    CLASS_NAME["SWIPE_ELEM"] = "page-left-panel-icon";
    CLASS_NAME["CONTENT"] = "app-content-column";
    CLASS_NAME["HEADER"] = "page-header";
    CLASS_NAME["SEARCH"] = "app-search";
})(CLASS_NAME || (CLASS_NAME = {}));
/**
 * method returns jquery class selector for given roleName
 * @param roleName
 * @returns {string}
 */
const roleSelector = (roleName) => `[data-role='${roleName}']`;
/*setup touch event handler*/
const bindTapEvtHandler = (selector, handler) => {
    /*
     * In Iphone safari browser, tap event of HammerJs is breaking
     * functionalities of other controls like input[type="range"].
     * So, replaced the hammer Js handler with click event handler.
     */
    $(selector).off('click.deviceview').on('click.deviceview', handler);
};
/**
 * hide the mobile toolbar actions
 */
const hidePageContainers = (leftNavEle, searchEle) => {
    if (isMobile()) {
        if (leftNavEle) {
            try {
                leftNavEle.widget.collapse();
            }
            catch (e) {
                //
            }
        }
        if (searchEle) {
            setCSS(searchEle, 'display', 'none');
        }
    }
};
/**
 * binds the touch event for content
 */
const bindContentEvents = (leftNavEle, pageContainer, searchContainer, isTablet = false) => {
    if (!isTablet) {
        // touch content to hide nav pane and left panel
        bindTapEvtHandler(pageContainer, hidePageContainers.bind(this, leftNavEle, searchContainer));
    }
};
const bindLeftPanelEvents = (leftNavEle, searchEle) => {
    // tap left to show/hide left panel
    bindTapEvtHandler(roleSelector(CLASS_NAME.SWIPE_ELEM), () => {
        if (leftNavEle) {
            leftNavEle.widget.toggle();
            // Hide search container when left panel is open
            if (leftNavEle.classList.contains('visible')) {
                if (searchEle) {
                    setCSS(searchEle, 'display', 'none');
                }
            }
        }
    });
};
/**
 * binds the touch event for content
 */
const bindRightPanelEvents = (rightNavEle) => {
    bindTapEvtHandler(rightNavEle, hidePageContainers);
};
/**
 * toggles the search container
 */
const toggleSearchContainer = (searchEle, leftNavEle) => {
    if ($(searchEle).css('display') === 'none') {
        hidePageContainers(leftNavEle);
        setCSS(searchEle, 'display', 'inline-table');
    }
    else {
        hidePageContainers(leftNavEle, searchEle);
    }
};
/**
 * Bind event with Search icon in header
 */
const bindSearchIconEvent = (searchElements, leftNavEle) => {
    $(searchElements).each((index, ele) => {
        const searchEle = $('<a class="app-header-action"><i class="wi wi-search"></i></a>');
        $(ele).before(searchEle);
        // Tap icon to show/hide search box
        bindTapEvtHandler(searchEle, () => toggleSearchContainer(ele, leftNavEle));
    });
};
const updateDeviceView = (element, isTablet = false) => {
    const leftNavEle = element.querySelector(roleSelector(CLASS_NAME.LEFT_PANEL));
    const rightNavEle = element.querySelector(roleSelector(CLASS_NAME.RIGHT_PANEL));
    const headerEle = element.querySelector(roleSelector(CLASS_NAME.HEADER));
    const searchEle = headerEle && headerEle.querySelector(`.${CLASS_NAME.SEARCH}`);
    const pageEle = element.querySelector(`.${CLASS_NAME.CONTENT}`);
    bindContentEvents(leftNavEle, pageEle, searchEle, isTablet);
    if (leftNavEle) {
        bindLeftPanelEvents(leftNavEle, searchEle);
    }
    else {
        // remove the icon
        $(headerEle).find(roleSelector(CLASS_NAME.SWIPE_ELEM)).remove();
    }
    if (rightNavEle) {
        bindRightPanelEvents(rightNavEle);
    }
    if (searchEle) {
        bindSearchIconEvent(searchEle, leftNavEle);
    }
};

const DEFAULT_CLS$A = 'app-page container';
const WIDGET_CONFIG$J = { widgetType: 'wm-page', hostClass: DEFAULT_CLS$A };
class PageDirective extends StylableComponent {
    constructor(inj, titleService) {
        super(inj, WIDGET_CONFIG$J);
        this.titleService = titleService;
        this._eventNotifier = new EventNotifier(false);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'pagetitle') {
            this.titleService.setTitle(nv);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    /**
     * A child component can notify page using this method. Notified event will be passed to
     * subscribed children only after page initialization.
     *
     * @param {string} eventName
     * @param data
     */
    notify(eventName, ...data) {
        this._eventNotifier.notify.apply(this._eventNotifier, arguments);
    }
    /**
     * The main purpose of this function is to provide communication between page children objects.
     * Child component can subscribe for an event that will be emitted by another child component.
     *
     * @param eventName
     * @param {(data: any) => void} callback
     * @returns {any}
     */
    subscribe(eventName, callback) {
        return this._eventNotifier.subscribe(eventName, callback);
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this._eventNotifier.start();
            updateDeviceView(this.nativeElement, this.getAppInstance().isTabletApplicationType);
        }, 1);
    }
    ngOnDestroy() {
        this._eventNotifier.destroy();
    }
}
PageDirective.initializeProps = registerProps$Z();
PageDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmPage]',
                providers: [
                    provideAsWidgetRef(PageDirective)
                ]
            },] }
];
/** @nocollapse */
PageDirective.ctorParameters = () => [
    { type: Injector },
    { type: Title }
];

const DEFAULT_CLS$B = 'app-left-panel left-panel-collapsed';
const WIDGET_CONFIG$K = {
    widgetType: 'wm-left-panel',
    hostClass: DEFAULT_CLS$B
};
var AnimationType;
(function (AnimationType) {
    AnimationType["SLIDE_IN"] = "slide-in";
    AnimationType["SLIDE_OVER"] = "slide-over";
})(AnimationType || (AnimationType = {}));
class LeftPanelDirective extends StylableComponent {
    constructor(app, page, inj) {
        super(inj, WIDGET_CONFIG$K);
        this.app = app;
        this.page = page;
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
        this.$ele = this.$element;
        this.$page = page.$element;
        addClass(this.$page[0], 'left-panel-collapsed-container');
        if (this.columnwidth) {
            this.setLeftPanelWidth(['md', 'sm'], this.columnwidth);
        }
        if (this.app.isTabletApplicationType) {
            addClass(this.nativeElement, 'wm-tablet-app-left-panel');
        }
    }
    collapse() {
        addClass(this.nativeElement, 'swipee-transition');
        switchClass(this.nativeElement, 'left-panel-collapsed', 'left-panel-expanded');
        this.expanded = false;
        switchClass(this.$page[0], 'left-panel-collapsed-container', 'left-panel-expanded-container');
        if (this.animation === AnimationType.SLIDE_IN) {
            this.setPageWidthAndPosition(['md', 'sm'], null, this.columnwidth);
            this.setPageWidthAndPosition(['xs'], null, this.xscolumnwidth);
        }
        if (this._destroyCollapseActionListener) {
            this._destroyCollapseActionListener();
        }
        this.page.notify('wmLeftPanel:collapse');
    }
    expand() {
        removeClass(this.nativeElement, 'swipee-transition');
        switchClass(this.nativeElement, 'left-panel-expanded', 'left-panel-collapsed');
        this.expanded = true;
        if (!(this.app.isTabletApplicationType && this.animation === AnimationType.SLIDE_IN)) {
            this._destroyCollapseActionListener = this.listenForCollapseAction();
        }
        switchClass(this.$page[0], 'left-panel-expanded-container', 'left-panel-collapsed-container');
        if (this.animation === AnimationType.SLIDE_IN) {
            this.setPageWidthAndPosition(['md', 'sm'], this.columnwidth);
            this.setPageWidthAndPosition(['xs'], this.xscolumnwidth);
        }
        this.page.notify('wmLeftPanel:expand');
    }
    isGesturesEnabled() {
        return this.gestures === 'on';
    }
    isVisible() {
        return this.expanded;
    }
    onPropertyChange(key, nv, ov) {
        switch (key) {
            case 'animation':
                if (nv === AnimationType.SLIDE_IN) {
                    removeClass(this.$page[0], 'slide-over-left-panel-container');
                    addClass(this.$page[0], 'slide-in-left-panel-container');
                    this.setPageWidthAndPosition(['md', 'sm'], this.columnwidth);
                    this.setPageWidthAndPosition(['xs'], this.xscolumnwidth);
                }
                else if (nv === AnimationType.SLIDE_OVER) {
                    removeClass(this.$page[0], 'slide-in-left-panel-container');
                    addClass(this.$page[0], 'slide-over-left-panel-container');
                }
                this._leftPanelAnimator = new LeftPanelAnimator(this);
                switchClass(this.nativeElement, nv, ov);
                break;
            case 'columnwidth':
                this.setLeftPanelWidth(['md', 'sm'], nv, ov);
                if (this.animation === AnimationType.SLIDE_IN) {
                    this.setPageWidthAndPosition(['md', 'sm'], nv, ov);
                }
                break;
            case 'expanded':
                toggleClass(this.nativeElement, 'left-panel-expanded', nv);
                toggleClass(this.nativeElement, 'left-panel-collapsed', !nv);
                break;
            case 'xscolumnwidth':
                this.setLeftPanelWidth(['xs'], nv, ov);
                if (this.animation === AnimationType.SLIDE_IN) {
                    this.setPageWidthAndPosition(['xs'], nv, ov);
                }
                break;
            default:
                super.onPropertyChange(key, nv, ov);
        }
    }
    toggle() {
        if (this.app.isTabletApplicationType) {
            setTimeout(() => {
                this.expanded ? this.collapse() : this.expand();
            }, 50);
        }
        else {
            this.$ele.swipeAnimation(this.expanded ? 'gotoLower' : 'gotoUpper');
        }
    }
    listenForCollapseAction() {
        const eventName = 'click.leftNavToggle';
        let skipEvent = false;
        this.$ele.on(eventName, () => {
            skipEvent = true;
        });
        this.$page.on(eventName, () => {
            if (!skipEvent) {
                this.toggle();
            }
            skipEvent = false;
        });
        return () => {
            this.$ele.off(eventName);
            this.$page.off(eventName);
        };
    }
    setLeftPanelWidth(devices, newVal, oldVal) {
        devices.forEach(device => {
            if (newVal) {
                addClass(this.nativeElement, `col-${device}-${newVal}`);
            }
            if (oldVal) {
                removeClass(this.nativeElement, `col-${device}-${oldVal}`);
            }
        });
    }
    setPageWidthAndPosition(devices, newVal, oldVal) {
        devices.forEach(device => {
            if (newVal) {
                addClass(this.$page[0], `left-panel-container-${device}-${12 - newVal}`);
            }
            if (oldVal) {
                removeClass(this.$page[0], `left-panel-container-${device}-${12 - oldVal}`);
            }
        });
    }
}
LeftPanelDirective.initializeProps = registerProps$Y();
LeftPanelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLeftPanel]',
                providers: [
                    provideAsWidgetRef(LeftPanelDirective)
                ]
            },] }
];
/** @nocollapse */
LeftPanelDirective.ctorParameters = () => [
    { type: App },
    { type: PageDirective },
    { type: Injector }
];

class LiveActionsDirective {
    constructor(subscribedWidget, app, dialogService) {
        this.subscribedWidget = subscribedWidget;
        this.app = app;
        this.dialogService = dialogService;
        subscribedWidget.addRow = this.addRow.bind(this);
        subscribedWidget.updateRow = this.updateRow.bind(this);
        subscribedWidget.deleteRow = this.deleteRow.bind(this);
        subscribedWidget.call = this.call.bind(this);
    }
    addRow() {
        this.app.notify('wm-event', { eventName: Live_Operations.INSERT, widgetName: this.subscribedWidget.name, row: this.subscribedWidget.selecteditem });
    }
    updateRow() {
        this.app.notify('wm-event', { eventName: Live_Operations.UPDATE, widgetName: this.subscribedWidget.name, row: this.subscribedWidget.selecteditem });
    }
    deleteRow() {
        this.app.notify('wm-event', { eventName: Live_Operations.DELETE, widgetName: this.subscribedWidget.name, row: this.subscribedWidget.selecteditem });
    }
    successHandler(options, response) {
        triggerFn(options.success, response);
    }
    errorHandler(options, error) {
        this.app.notifyApp(error, 'error', 'ERROR');
        triggerFn(options.error, error);
    }
    getRecords(options, operation) {
        let index;
        let dataNavigator;
        if (this.subscribedWidget.navigation !== 'None' && this.subscribedWidget.dataNavigator) {
            dataNavigator = this.subscribedWidget.dataNavigator;
            // If operation is delete, decrease the data size and check if navigation to previous page is required
            if (operation === Live_Operations.DELETE) {
                dataNavigator.dataSize -= 1;
                dataNavigator.calculatePagingValues();
                index = dataNavigator.pageCount < dataNavigator.dn.currentPage ? 'prev' : undefined;
            }
            else {
                // If operation is insert, go to last page. If update operation, stay on current page
                index = operation === Live_Operations.INSERT ? 'last' : 'current';
                if (index === 'last') {
                    dataNavigator.dataSize += 1;
                }
                dataNavigator.calculatePagingValues();
            }
            dataNavigator.navigatePage(index, null, true, response => {
                this.successHandler(options, response);
            });
        }
        else {
            this.subscribedWidget.datasource.execute(DataSource.Operation.LIST_RECORDS, {
                'skipToggleState': true
            }).then(response => {
                this.successHandler(options, response);
            }, err => {
                this.errorHandler(options, err);
            });
        }
    }
    performCUDOperation(requestData, operation, options) {
        performDataOperation(this.subscribedWidget.datasource, requestData, {
            operationType: operation
        }).then(response => {
            if (response.error) {
                this.errorHandler(options, response.error);
                return;
            }
            this.getRecords(options, operation);
            // show delete success toaster
            if (operation === 'delete') {
                this.app.notifyApp(this.app.appLocale.MESSAGE_DELETE_RECORD_SUCCESS, 'success');
            }
        }, (error) => {
            this.errorHandler(options, error);
        });
    }
    insertRecord(requestData, operation, options) {
        this.performCUDOperation(requestData, operation, options);
    }
    updateRecord(requestData, operation, options) {
        this.performCUDOperation(requestData, operation, options);
    }
    deleteRecord(requestData, operation, options) {
        // Show the delete confirmation dialog. On Ok, delete the record.
        this.dialogService.showAppConfirmDialog({
            title: this.app.appLocale.MESSAGE_DELETE_RECORD || 'Delete Record',
            iconclass: 'wi wi-delete fa-lg',
            message: this.subscribedWidget.confirmdelete || 'Are you sure you want to delete this?',
            oktext: this.subscribedWidget.deleteoktext || 'Ok',
            canceltext: this.subscribedWidget.deletecanceltext || 'Cancel',
            onOk: () => {
                this.performCUDOperation(requestData, operation, options);
                this.dialogService.closeAppConfirmDialog();
            },
            onCancel: () => {
                triggerFn(options.cancelDeleteCallback);
                this.dialogService.closeAppConfirmDialog();
            }
        });
    }
    performOperation(operation, options) {
        const requestData = {
            row: options.row,
            prevData: {},
            rowData: {},
            transform: true,
            skipNotification: true
        };
        if (operation === Live_Operations.UPDATE) {
            requestData.rowData = options.rowData;
            requestData.prevData = options.prevData;
        }
        /* decide routine based on CRUD operation to be performed */
        switch (operation) {
            case Live_Operations.INSERT:
                this.insertRecord(requestData, operation, options);
                break;
            case Live_Operations.UPDATE:
                this.updateRecord(requestData, operation, options);
                break;
            case Live_Operations.DELETE:
                this.deleteRecord(requestData, operation, options);
                break;
            case Live_Operations.READ:
                this.getRecords(options, operation);
                break;
        }
    }
    // API exposed to make CRUD operations
    call(operation, options, success, error) {
        options.success = success;
        options.error = error;
        this.performOperation(operation, options);
    }
}
LiveActionsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLiveActions]'
            },] }
];
/** @nocollapse */
LiveActionsDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Self }, { type: Inject, args: [ListComponent,] }] },
    { type: App },
    { type: AbstractDialogService }
];

const registerProps$_ = () => {
    register('wm-livetable', new Map([
        ['class', PROP_STRING],
        ['formlayout', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ]));
};

const DEFAULT_CLS$C = 'app-livegrid';
const WIDGET_CONFIG$L = { widgetType: 'wm-livetable', hostClass: DEFAULT_CLS$C };
class LiveTableComponent extends StylableComponent {
    constructor(inj, elRef, cdr, dialogService, app, layoutType, dialogId) {
        super(inj, WIDGET_CONFIG$L);
        this.dialogService = dialogService;
        this.app = app;
        this.$queue = [];
        this.tableOptions = {
            'multiselect': false,
            'setGridEditMode': ''
        };
        styler(this.nativeElement, this);
        if (layoutType === 'dialog') {
            this.isLayoutDialog = true;
            this.dialogId = dialogId;
        }
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.table) {
            this.table._liveTableParent = this;
            this.table.datagridElement.datatable('option', this.tableOptions);
            this.table.selectedItemChange$
                .pipe(debounceTime(250))
                .subscribe(this.onSelectedItemChange.bind(this));
            if (!this.isLayoutDialog && !this.form) {
                this.table.datagridElement.datatable('option', {
                    'beforeRowUpdate': () => {
                        this.showErrorMessage();
                    },
                    'beforeRowDelete': () => {
                        this.showErrorMessage();
                    },
                    'beforeRowInsert': () => {
                        this.showErrorMessage();
                    }
                });
            }
        }
    }
    openDialog() {
        this.dialogService.open(this.dialogId);
        $appDigest();
    }
    closeDialog() {
        this.dialogService.close(this.dialogId);
    }
    focusFirstInput() {
        const $firstInput = $(this.form.$element).find('[role="input"]:first');
        $firstInput.focus();
        $firstInput.select();
    }
    onDialogOpen() {
        this.focusFirstInput();
    }
    setFormData(val) {
        if (!this.form.isDestroyed) {
            this.form.getWidget().formdata = val;
        }
    }
    _addNewRow() {
        this.form.isSelected = true;
        this.setFormData('');
        this.form.new();
        if (this.isLayoutDialog) {
            this.onDialogOpen();
        }
    }
    addNewRow() {
        if (this.isLayoutDialog) {
            this.openDialog();
            this.$queue.push(this._addNewRow.bind(this));
            return;
        }
        this._addNewRow();
    }
    _updateRow(row, eventName) {
        this.setFormData(row);
        this.form.isSelected = true;
        this.form.edit();
        if (this.isLayoutDialog) {
            this.form.isUpdateMode = (eventName === 'dblclick') ? this.form.updateMode : true;
            this.onDialogOpen();
        }
    }
    updateRow(row, eventName) {
        if (this.isLayoutDialog) {
            this.openDialog();
            this.$queue.push(this._updateRow.bind(this, row, eventName));
            return;
        }
        this._updateRow(row, eventName);
    }
    onSelectedItemChange(newValue) {
        let rowData;
        if (!this.form || !this.table) {
            return;
        }
        if (newValue && newValue.length > 0 && !this.form.isSelected) {
            this.form.isSelected = true;
        }
        /*Update the rowdata of only that grid form that is associated with the specific grid on which row selection is being performed...
         * Since both the grid & gridform are associated with the same "parentgrid", match the same*/
        if (newValue && newValue.length > 0) {
            if (this.table.multiselect) {
                rowData = newValue[0];
            }
            else {
                rowData = newValue[newValue.length - 1];
            }
            this.setFormData(getClonedObject(rowData));
            /*If the form is already in update mode, call the form update function*/
            if (this.form.isUpdateMode) {
                this.form.edit();
            }
        }
        else {
            this.form.isSelected = false;
            this.setFormData('');
            this.form.clearData();
        }
    }
    onCancel() {
        this.form.isUpdateMode = false;
        if (this.isLayoutDialog) {
            this.closeDialog();
        }
    }
    onResult(operation, response, newForm, updateMode) {
        this.form.isUpdateMode = isDefined(updateMode) ? updateMode : newForm ? true : false;
        switch (operation) {
            case 'insert':
                if (newForm) {
                    /*if new form is to be shown after insert, skip the highlight of the row*/
                    this.table.gridfirstrowselect = false;
                    this.table.initiateSelectItem(this.table.getNavigationTargetBySortInfo(), response, true);
                }
                else {
                    /*The new row would always be inserted at the end of all existing records. Hence navigate to the last page and highlight the inserted row.*/
                    this.table.initiateSelectItem(this.table.getNavigationTargetBySortInfo(), response);
                }
                break;
            case 'update':
                /*The updated row would be found in the current page itself. Hence simply highlight the row in the current page.*/
                if (newForm) {
                    this.table.gridfirstrowselect = false;
                    this.table.initiateSelectItem('current', response, true);
                }
                else {
                    this.table.initiateSelectItem('current', response);
                }
                break;
            case 'delete':
                this.table.onRecordDelete();
                break;
        }
        this.table.updateVariable();
        if (this.isLayoutDialog) {
            /*if new form is to be shown after update or insert, don't close the dialog*/
            if (newForm) {
                if (operation === 'insert') {
                    this.form.new();
                }
                else if (operation === 'update') {
                    this.form.edit();
                }
            }
            else {
                this.closeDialog();
            }
        }
    }
    showErrorMessage() {
        this.app.notifyApp(this.appLocale.LABEL_ACCESS_DENIED, 'error');
    }
    // In dialog mode, on form render call the queued functions
    onFormReady(form) {
        this.form = form;
        setTimeout(() => {
            triggerFn(this.$queue.pop());
        });
    }
}
LiveTableComponent.initializeProps = registerProps$_();
LiveTableComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmLiveTable]',
                template: "<ng-content></ng-content>",
                providers: [
                    provideAsWidgetRef(LiveTableComponent)
                ]
            }] }
];
/** @nocollapse */
LiveTableComponent.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: AbstractDialogService },
    { type: App },
    { type: String, decorators: [{ type: Attribute, args: ['formlayout',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['dialogid',] }] }
];
LiveTableComponent.propDecorators = {
    table: [{ type: ContentChild, args: [TableComponent,] }]
};

const isTimeType = field => field.widgettype === DataType.TIME || (field.type === DataType.TIME && !field.widgettype);
const getValidTime = val => {
    if (val) {
        const date = (new Date()).toDateString();
        return (new Date(`${date} ${val}`)).getTime();
    }
    return undefined;
};
class LiveFormDirective {
    constructor(form, liveTable, datePipe, dialogService, formlayout) {
        this.form = form;
        this.datePipe = datePipe;
        this.dialogService = dialogService;
        this._debouncedSavePrevDataValues = debounce(() => {
            this.savePrevDataValues();
        }, 250);
        // If parent live table is present and this form is first child of live table, set this form instance on livetable
        if (liveTable && !this.form.parentForm) {
            this.form._liveTableParent = liveTable;
            this.form.isLayoutDialog = liveTable.isLayoutDialog;
            liveTable.onFormReady(this.form);
        }
        else {
            this.form.isLayoutDialog = formlayout === 'dialog';
        }
        // CUD operations
        form.edit = this.edit.bind(this);
        form.cancel = this.cancel.bind(this);
        form.reset = this.reset.bind(this);
        form.new = this.new.bind(this);
        form.delete = this.delete.bind(this);
        form.save = this.save.bind(this);
        form.saveAndNew = this.saveAndNew.bind(this);
        form.saveAndView = this.saveAndView.bind(this);
        form.setPrimaryKey = this.setPrimaryKey.bind(this);
        form.constructDataObject = this.constructDataObject.bind(this);
        form.changeDataObject = this.setFormData.bind(this);
        form.setFormData = this.setFormData.bind(this);
        form.findOperationType = this.findOperationType.bind(this);
        form.clearData = this.clearData.bind(this);
        form.onFieldDefaultValueChange = this.onFieldDefaultValueChange.bind(this);
        form.onDataSourceChange = this.onDataSourceChange.bind(this);
        form.onFieldValueChange = this.onFieldValueChange.bind(this);
        form.submitForm = this.submitForm.bind(this);
    }
    onDataSourceChange() {
        if (_.get(this.form.formFields, 'length')) {
            this.form.isDataSourceUpdated = true;
        }
        const formFields = this.form.getFormFields();
        formFields.forEach(field => {
            if (!field.isDataSetBound && isDataSetWidget(field.widgettype)) {
                if (field['is-related']) {
                    field.isDataSetBound = true;
                    fetchRelatedFieldData(this.form.datasource, field.widget, {
                        relatedField: field.key,
                        datafield: ALLFIELDS,
                        widget: 'widgettype',
                    });
                }
                else {
                    getDistinctValuesForField(this.form.datasource, field.widget, {
                        widget: 'widgettype',
                        enableemptyfilter: this.form.enableemptyfilter
                    });
                    applyFilterOnField(this.form.datasource, field.widget, formFields, field.value, { isFirst: true });
                }
            }
        });
    }
    onFieldDefaultValueChange(field, nv) {
        // In Edit, do  not set default values
        if (this.form.operationType === 'update') {
            return;
        }
        // Set the default value only if it exists.
        if (isDefined(nv) && nv !== null && nv !== '' && nv !== 'null') {
            field.value = parseValueByType(nv, field.type, field.widgettype);
        }
        else {
            field.value = undefined;
        }
        this._debouncedSavePrevDataValues();
    }
    onFieldValueChange(field, nv) {
        applyFilterOnField(this.form.datasource, field.widget, this.form.formFields, nv);
    }
    getBlobURL(dataObj, key, value) {
        let href = '';
        let primaryKeys;
        let primaryKey;
        if (value === null || value === undefined || !this.form.datasource) {
            return href;
        }
        primaryKeys = this.form.datasource.execute(DataSource.Operation.GET_PRIMARY_KEY) || [];
        primaryKey = dataObj[primaryKeys[0]];
        // TODO: Handle mobile case
        // if (CONSTANTS.hasCordova && CONSTANTS.isRunMode) {
        //     href += $rootScope.project.deployedUrl;
        // }
        href += this.form.datasource.execute(DataSource.Operation.GET_BLOB_URL, {
            primaryValue: primaryKey,
            columnName: key
        });
        href += '?' + Math.random();
        return href;
    }
    resetFileUploadWidget(field, skipValueSet) {
        const $formEle = this.form.$element;
        $formEle.find('[name="' + field.key + '_formWidget"]').val('');
        field._control.reset();
        if (!skipValueSet) {
            field.href = '';
            field.value = null;
        }
    }
    setDefaultValues() {
        this.form.formFields.forEach(field => {
            this.onFieldDefaultValueChange(field, field.defaultvalue);
        });
    }
    setFormData(dataObj) {
        if (!dataObj) {
            return;
        }
        const formFields = this.form.getFormFields();
        formFields.forEach(field => {
            const value = _.get(dataObj, field.key || field.name);
            if (isTimeType(field)) {
                field.value = getValidTime(value);
            }
            else if (field.type === DataType.BLOB) {
                this.resetFileUploadWidget(field, true);
                field.href = this.getBlobURL(dataObj, field.key, value);
                field.value = _.isString(value) ? '' : value;
            }
            else {
                field.value = value;
            }
        });
        this.savePrevDataValues();
        this.form.constructDataObject();
    }
    onDataSourceUpdate(response, newForm, updateMode) {
        if (newForm) {
            this.form.new();
        }
        else {
            this.form.setFormData(response);
            this.closeDialog();
        }
        this.form.isUpdateMode = isDefined(updateMode) ? updateMode : true;
    }
    savePrevformFields() {
        this.form.prevformFields = getClonedObject(this.form.formFields.map(field => {
            return {
                'key': field.key,
                'type': field.type,
                'widgettype': field.widgettype,
                'outputformat': field.outputformat,
                'value': field.value
            };
        }));
    }
    getPrevformFields() {
        this.form.formFields.map(field => {
            const prevField = this.form.prevformFields.find(pField => pField.key === field.key);
            field.value = prevField.value;
        });
    }
    getDataObject() {
        if (this.form.operationType === Live_Operations.INSERT) {
            return {};
        }
        if (isDefined(this.form.prevDataObject) && !isEmptyObject(this.form.prevDataObject)) {
            return getClonedObject(this.form.prevDataObject);
        }
        return getClonedObject(this.form.formdata || {});
    }
    constructDataObject(isPreviousData) {
        const dataObject = this.getDataObject();
        const formName = this.form.name;
        let formFields;
        formFields = isPreviousData ? this.form.prevformFields : this.form.getFormFields();
        formFields.forEach(field => {
            let dateTime, fieldValue;
            const fieldTarget = _.split(field.key, '.');
            const fieldName = fieldTarget[0] || field.key;
            /*collect the values from the fields and construct the object*/
            /*Format the output of date time widgets to the given output format*/
            if ((field.widgettype && isDateTimeType(field.widgettype)) || isDateTimeType(field.type)) {
                if (field.value) {
                    dateTime = getValidDateObject(field.value);
                    if (field.outputformat === DataType.TIMESTAMP || field.type === DataType.TIMESTAMP) {
                        fieldValue = field.value ? dateTime : null;
                    }
                    else if (field.outputformat) {
                        fieldValue = this.datePipe.transform(dateTime, field.outputformat);
                    }
                    else {
                        fieldValue = field.value;
                    }
                }
                else {
                    fieldValue = undefined;
                }
            }
            else if (field.type === DataType.BLOB) {
                fieldValue = getFiles(formName, fieldName + '_formWidget', field.multiple);
            }
            else if (field.type === DataType.LIST) {
                fieldValue = field.value || undefined;
            }
            else {
                fieldValue = (field.value === null || field.value === '') ? undefined : field.value;
            }
            if (fieldTarget.length === 1) {
                dataObject[fieldName] = fieldValue;
            }
            else {
                dataObject[fieldName] = dataObject[fieldName] || {};
                dataObject[fieldName][fieldTarget[1]] = fieldValue;
            }
        });
        if (!isPreviousData) {
            this.form.updateFormDataOutput(dataObject);
            return this.form.dataoutput;
        }
        return dataObject;
    }
    setPrimaryKey(fieldName) {
        /*Store the primary key of data*/
        this.form.primaryKey = this.form.primaryKey || [];
        if (this.form.primaryKey.indexOf(fieldName) === -1) {
            this.form.primaryKey.push(fieldName);
        }
    }
    findOperationType() {
        let operation;
        let isPrimary = false;
        const sourceOperation = this.form.datasource && this.form.datasource.execute(DataSource.Operation.GET_OPERATION_TYPE);
        if (sourceOperation && sourceOperation !== 'read') {
            return sourceOperation;
        }
        /*If OperationType is not set then based on the formdata object return the operation type,
            this case occurs only if the form is outside a livegrid*/
        /*If the formdata object has primary key value then return update else insert*/
        if (this.form.primaryKey && !_.isEmpty(this.form.formdata)) {
            /*If only one column is primary key*/
            if (this.form.primaryKey.length === 1) {
                if (this.form.formdata[this.form.primaryKey[0]]) {
                    operation = Live_Operations.UPDATE;
                }
                /*If only no column is primary key*/
            }
            else if (this.form.primaryKey.length === 0) {
                _.forEach(this.form.formdata, (value) => {
                    if (value) {
                        isPrimary = true;
                    }
                });
                if (isPrimary) {
                    operation = Live_Operations.UPDATE;
                }
                /*If multiple columns are primary key*/
            }
            else {
                isPrimary = _.some(this.form.primaryKey, (primaryKey) => {
                    if (this.form.formdata[primaryKey]) {
                        return true;
                    }
                });
                if (isPrimary) {
                    operation = Live_Operations.UPDATE;
                }
            }
        }
        return operation || Live_Operations.INSERT;
    }
    getPrevDataValues() {
        const prevDataValues = _.fromPairs(_.map(this.form.prevDataValues, (item) => {
            return [item.key, item.value];
        })); // Convert of array of values to an object
        this.form.formFields.forEach(field => {
            field.value = prevDataValues[field.key] || '';
            field.resetDisplayInput();
        });
        return prevDataValues;
    }
    savePrevDataValues() {
        this.form.prevDataValues = this.form.formFields.map((obj) => {
            return { 'key': obj.key, 'value': obj.value };
        });
    }
    emptyDataModel() {
        this.form.formFields.forEach(field => {
            if (isDefined(field)) {
                if (field.type === DataType.BLOB) {
                    this.resetFileUploadWidget(field);
                }
                else {
                    field.datavalue = '';
                }
            }
        });
    }
    clearData() {
        this.form.toggleMessage(false);
        this.emptyDataModel();
    }
    setReadonlyFields() {
        this.form.formFields.forEach(field => {
            field.setReadOnlyState();
        });
    }
    edit() {
        this.form.resetFormState();
        this.form.clearMessage();
        this.form.operationType = Live_Operations.UPDATE;
        if (this.form.isSelected) {
            this.savePrevformFields();
            this.savePrevDataValues();
        }
        this.form.prevDataObject = getClonedObject(this.form.formdata || {});
        this.setReadonlyFields();
        this.form.isUpdateMode = true;
        $appDigest();
    }
    reset() {
        let prevDataValues;
        this.form.resetFormState();
        prevDataValues = this.getPrevDataValues();
        this.form.formFields.forEach(field => {
            if (field.type === DataType.BLOB) {
                this.resetFileUploadWidget(field, true);
                field.href = this.getBlobURL(prevDataValues, field.key, field.value);
            }
        });
        this.form.constructDataObject();
    }
    closeDialog() {
        if (this.form.isLayoutDialog) {
            this.dialogService.close(this.form.dialogId);
        }
    }
    cancel() {
        this.form.clearMessage();
        this.form.isUpdateMode = false;
        this.form.reset();
        /*Show the previous selected data*/
        if (this.form.isSelected) {
            this.getPrevformFields();
        }
        this.form.isUpdateMode = false;
        this.closeDialog();
        if (this.form._liveTableParent) {
            this.form._liveTableParent.onCancel();
        }
        $appDigest();
    }
    new() {
        this.form.resetFormState();
        this.form.operationType = Live_Operations.INSERT;
        this.form.clearMessage();
        if (this.form.isSelected) {
            this.savePrevformFields();
        }
        this.emptyDataModel();
        setTimeout(() => {
            this.setDefaultValues();
            this.savePrevDataValues();
            this.form.constructDataObject();
        });
        this.form.isUpdateMode = true;
    }
    delete(callBackFn) {
        this.form.resetFormState();
        this.form.operationType = Live_Operations.DELETE;
        this.form.prevDataObject = getClonedObject(this.form.formdata || {});
        this.form.save(undefined, undefined, undefined, callBackFn);
    }
    // Function use to save the form and open new form after save
    saveAndNew() {
        this.save(undefined, true, true);
    }
    // Function use to save the form and open new form after save
    saveAndView() {
        this.save(undefined, false);
    }
    submitForm($event) {
        this.save($event);
    }
    save(event, updateMode, newForm) {
        if (!this.form.datasource) {
            return;
        }
        let data, prevData, operationType, isValid;
        const requestData = {};
        operationType = this.form.operationType = this.form.operationType || this.findOperationType();
        // Disable the form submit if form is in invalid state.
        if (this.form.validateFieldsOnSubmit()) {
            return;
        }
        data = getClonedObject(this.form.constructDataObject());
        prevData = this.form.prevformFields ? this.form.constructDataObject(true) : data;
        try {
            isValid = this.form.invokeEventCallback('beforeservicecall', { $event: event, $operation: this.form.operationType, $data: data, options: requestData });
            if (isValid === false) {
                return;
            }
            if (isValid && isValid.error) {
                this.form.toggleMessage(true, isValid.error, 'error');
                return;
            }
        }
        catch (err) {
            if (err.message === 'Abort') {
                return;
            }
        }
        // If operation is update, form is not touched and current data and previous data is same, Show no changes detected message
        if (this.form.operationType === Live_Operations.UPDATE && this.form.ngform && this.form.ngform.pristine &&
            (this.form.isSelected && _.isEqual(data, prevData))) {
            this.form.toggleMessage(true, this.form.appLocale.MESSAGE_NO_CHANGES, 'info', '');
            $appDigest();
            return;
        }
        this.form.resetFormState();
        requestData.row = data;
        requestData.transform = true;
        requestData.skipNotification = true;
        if (operationType === Live_Operations.UPDATE) {
            requestData.rowData = this.form.formdata;
            requestData.prevData = prevData;
        }
        performDataOperation(this.form.datasource, requestData, {
            operationType: operationType
        }).then((response) => {
            const msg = operationType === Live_Operations.INSERT ? this.form.insertmessage : (operationType === Live_Operations.UPDATE ?
                this.form.updatemessage : this.form.deletemessage);
            if (operationType === Live_Operations.DELETE) {
                this.form.onResult(requestData.row, true, event);
                this.emptyDataModel();
                this.form.prevDataValues = [];
                this.form.isSelected = false;
            }
            else {
                this.form.onResult(response, true, event);
            }
            this.form.toggleMessage(true, msg, 'success');
            if (this.form._liveTableParent) {
                // highlight the current updated row
                this.form._liveTableParent.onResult(operationType, response, newForm, updateMode);
            }
            else {
                /*get updated data without refreshing page*/
                this.form.datasource.execute(DataSource.Operation.LIST_RECORDS, {
                    'skipToggleState': true
                });
                this.onDataSourceUpdate(response, newForm, updateMode);
            }
        }, (error) => {
            this.form.onResult(error, false, event);
            this.form.toggleMessage(true, error, 'error');
            $appDigest();
        });
    }
}
LiveFormDirective.initializeProps = registerLiveFormProps();
LiveFormDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLiveForm]'
            },] }
];
/** @nocollapse */
LiveFormDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Self }, { type: Inject, args: [FormComponent,] }] },
    { type: LiveTableComponent, decorators: [{ type: Optional }] },
    { type: ToDatePipe },
    { type: AbstractDialogService },
    { type: String, decorators: [{ type: Attribute, args: ['formlayout',] }] }
];

const FILTER_CONSTANTS = {
    'EMPTY_KEY': 'EMPTY_NULL_FILTER'
};
class LiveFilterDirective {
    constructor(form) {
        this.form = form;
        // debounce the filter function. If multiple filter calls are made at same time, calls will be delayed and last call is fired
        this._filter = debounce(options => {
            this.filter(options);
        }, 250);
        form.clearFilter = this.clearFilter.bind(this);
        form.applyFilter = this.applyFilter.bind(this);
        form.filter = this.filter.bind(this);
        form.filterOnDefault = this.filterOnDefault.bind(this);
        form.execute = this.execute.bind(this);
        form.onFieldDefaultValueChange = this.onFieldDefaultValueChange.bind(this);
        form.onMaxDefaultValueChange = this.onMaxDefaultValueChange.bind(this);
        form.onDataSourceChange = this.onDataSourceChange.bind(this);
        form.onFieldValueChange = this.onFieldValueChange.bind(this);
        form.submitForm = this.submitForm.bind(this);
        form.registerFormWidget = this.registerFormWidget.bind(this);
    }
    execute(operation, options) {
        if (operation === DataSource.Operation.LIST_RECORDS || operation === DataSource.Operation.DOWNLOAD) {
            return this.applyFilter(options);
        }
        if (operation === DataSource.Operation.GET_OPTIONS) {
            return this._options || {};
        }
        if (operation === DataSource.Operation.GET_PAGING_OPTIONS) {
            return this.form.pagination;
        }
        if (!this.form.datasource) {
            return {};
        }
        if (operation === DataSource.Operation.FETCH_DISTINCT_VALUES) {
            return fetchDistinctValues(this.form.datasource, this.form.formFields, {
                widget: 'widgettype',
                enableemptyfilter: this.form.enableemptyfilter,
                EMPTY_VALUE: this.form.appLocale.LABEL_NO_VALUE
            });
        }
        return this.form.datasource.execute(operation, options);
    }
    onFieldDefaultValueChange(field, nv) {
        field.minValue = nv;
        field.value = nv;
        this.filterOnDefault();
    }
    onFieldValueChange(field, nv) {
        applyFilterOnField(this.form.datasource, field.widget, this.form.formFields, nv, {
            EMPTY_VALUE: this.form.appLocale.LABEL_NO_VALUE
        });
        if (this.form.autoupdate && isDefined(nv)) {
            this._filter();
        }
    }
    onMaxDefaultValueChange() {
        setTimeout(() => {
            this.filterOnDefault();
        });
    }
    onDataSourceChange() {
        const dataSource = this.form.datasource;
        if (!dataSource) {
            return;
        }
        this.form.formFields.forEach(field => {
            if (isDataSetWidget(field.widgettype)) {
                getDistinctValuesForField(dataSource, field.widget, {
                    widget: 'widgettype',
                    enableemptyfilter: this.form.enableemptyfilter,
                    EMPTY_VALUE: this.form.appLocale.LABEL_NO_VALUE
                });
                applyFilterOnField(dataSource, field.widget, this.form.formFields, field.value, {
                    isFirst: true,
                    EMPTY_VALUE: this.form.appLocale.LABEL_NO_VALUE
                });
            }
        });
        // On load check if default value exists and apply filter, Call the filter with the result options
        this._filter(this._options);
    }
    clearFilter() {
        this.form.resetFormState();
        this.form.formFields.forEach(filterField => {
            // Added check for range field
            if (!filterField.readonly && filterField.show) {
                if (filterField.widgettype === FormWidgetType.AUTOCOMPLETE || filterField.widgettype === FormWidgetType.TYPEAHEAD) {
                    this.form.$element.find('div[name=' + filterField.name + '] input').val('');
                }
                if (filterField['is-range']) {
                    filterField.minValue = '';
                    filterField.maxValue = '';
                }
                else {
                    filterField.value = '';
                    filterField.resetDisplayInput();
                }
            }
        });
        // If variable has any bindings, wait for the bindings to be updated
        setTimeout(() => {
            // Setting result to the default data
            this._filter();
        });
    }
    submitForm() {
        this.filter();
    }
    applyFilter(options) {
        options = options ? (options.data || options) : {};
        options.page = options.page || 1;
        options.orderBy = isDefined(options.orderBy) ? options.orderBy : this.orderBy;
        return this.filter(options);
    }
    filter(options) {
        if (!this.form.datasource) {
            return;
        }
        const filterFields = {};
        const dataModel = {};
        let page = 1, orderBy, isValid;
        options = options || {};
        page = options.page || page;
        orderBy = isDefined(options.orderBy) ? options.orderBy : (this.orderBy || '');
        this.orderBy = orderBy; // Store the order by in scope. This can be used to retain the sort after filtering
        // Copy the values to be sent to the user as '$data' before servicecall
        this.form.formFields.forEach(field => {
            const fieldSelector = 'div[name=' + field.name + '] input';
            const $el = this.form.$element;
            let fieldEle;
            if ((field.widgettype === FormWidgetType.AUTOCOMPLETE || field.widgettype === FormWidgetType.TYPEAHEAD) && $el) {
                fieldEle = $el.find(fieldSelector);
                if (!field['is-range']) {
                    dataModel[field.field] = {
                        'value': isDefined(field.value) ? field.value : fieldEle.val() // For autocomplete, set the datavalue. If not present, set query value
                    };
                }
                else {
                    dataModel[field.field] = {
                        'minValue': isDefined(field.minValue) ? field.minValue : fieldEle.first().val(),
                        'maxValue': isDefined(field.maxValue) ? field.maxValue : fieldEle.last().val()
                    };
                }
                return;
            }
            if (!field['is-range']) {
                dataModel[field.field] = {
                    'value': field.value
                };
            }
            else {
                dataModel[field.field] = {
                    'minValue': field.minValue,
                    'maxValue': field.maxValue
                };
            }
        });
        /*Perform this function for the event onBeforeservicecall*/
        try {
            isValid = this.form.invokeEventCallback('beforeservicecall', { $data: dataModel });
            if (isValid === false) {
                return;
            }
            if (isValid && isValid.error) {
                this.form.toggleMessage(true, isValid.error, 'error', 'ERROR');
                return;
            }
            /*Update these values in the formFields with new reference, inorder to maintain the UI values*/
            this.form.formFields.forEach(filterField => {
                if (!filterField['is-range']) {
                    filterField._value = dataModel[filterField.field].value;
                }
                else {
                    filterField._minValue = dataModel[filterField.field].minValue;
                    filterField._maxValue = dataModel[filterField.field].maxValue;
                }
            });
        }
        catch (err) {
            if (err.message === 'Abort') {
                return;
            }
        }
        /* Construct the formFields Variable to send it to the queryBuilder */
        this.form.formFields.forEach(filterField => {
            let fieldValue;
            let matchMode;
            let colName = filterField.field;
            const minValue = filterField._minValue;
            const maxvalue = filterField._maxValue;
            /* if field is part of a related entity, column name will be 'entity.fieldName' */
            if (filterField['is-related']) {
                colName += '.' + filterField['lookup-field'];
            }
            if (filterField['is-range']) {
                /*Based on the min and max values, decide the matchmode condition*/
                fieldValue = getRangeFieldValue(minValue, maxvalue);
                matchMode = getRangeMatchMode(minValue, maxvalue);
                if (isDefined(fieldValue)) {
                    filterFields[colName] = {
                        'value': fieldValue,
                        'matchMode': matchMode,
                        'logicalOp': 'AND'
                    };
                }
            }
            else {
                switch (filterField.widgettype) {
                    case FormWidgetType.SELECT:
                    case FormWidgetType.RADIOSET:
                        if (getEnableEmptyFilter(this.form.enableemptyfilter) && filterField._value === FILTER_CONSTANTS.EMPTY_KEY) {
                            matchMode = getEmptyMatchMode(this.form.enableemptyfilter);
                            fieldValue = filterField._value;
                        }
                        else {
                            if (filterField.type === DataType.BOOLEAN) {
                                if (isDefined(filterField._value) && filterField._value !== '') {
                                    fieldValue = JSON.parse(filterField._value);
                                }
                            }
                            else {
                                fieldValue = filterField._value;
                            }
                        }
                        break;
                    case FormWidgetType.CHECKBOXSET:
                    case FormWidgetType.CHIPS:
                        if (filterField._value && filterField._value.length) {
                            fieldValue = filterField._value;
                        }
                        break;
                    case FormWidgetType.CHECKBOX:
                    case FormWidgetType.TOGGLE:
                        if (isDefined(filterField._value) && filterField._value !== '') {
                            fieldValue = filterField.type === DataType.BOOLEAN ? JSON.parse(filterField._value) : filterField._value;
                        }
                        break;
                    default:
                        fieldValue = filterField._value;
                        break;
                }
                if (isDefined(fieldValue) && fieldValue !== '' && fieldValue !== null) {
                    filterFields[colName] = {};
                    if (matchMode) {
                        filterFields[colName].matchMode = matchMode;
                        fieldValue = undefined;
                    }
                    else if (filterField.type === DataType.STRING || filterField.isRelated) { // Only for string types and related fields, custom match modes are enabled.
                        filterFields[colName].matchMode = matchMode || filterField.matchmode ||
                            this.form.datasource.execute(DataSource.Operation.GET_MATCH_MODE);
                    }
                    filterFields[colName].value = fieldValue;
                    filterFields[colName].logicalOp = 'AND';
                    filterFields[colName].type = filterField.type;
                }
            }
        });
        if (options.exportType) {
            return this.form.datasource.execute(DataSource.Operation.DOWNLOAD, {
                data: {
                    matchMode: 'anywhereignorecase',
                    filterFields: filterFields,
                    orderBy: orderBy,
                    exportType: options.exportType,
                    logicalOp: 'AND',
                    exportSize: options.exportSize,
                    fields: options.fields,
                    fileName: options.fileName
                }
            });
        }
        return this.form.datasource.execute(DataSource.Operation.LIST_RECORDS, {
            filterFields: filterFields,
            orderBy: orderBy,
            page: page,
            pagesize: this.form.pagesize || 20,
            skipDataSetUpdate: true,
            inFlightBehavior: 'executeAll'
        }).then(response => {
            const data = response.data;
            this.form.pagination = response.pagination;
            if (data.error) {
                // disable readonly and show the appropriate error
                this.form.toggleMessage(true, data.error, 'error', 'ERROR');
                this.form.onResult(data, false);
            }
            else {
                this._options = {
                    'page': page,
                    'orderBy': orderBy
                };
                this.form.result = getClonedObject(data);
                this.form.onResult(data, true);
            }
            $appDigest();
            return this.form.result;
        }, error => {
            this.form.toggleMessage(true, error, 'error', 'ERROR');
            this.form.onResult(error, false);
            return error;
        });
    }
    // Calls the filter function if default values are present
    filterOnDefault() {
        /*Check if default value is present for any filter field*/
        const defaultObj = _.find(this.form.formFields, obj => {
            return isDefined(obj.value) || isDefined(obj.minValue) || isDefined(obj.maxValue);
        });
        /*If default value exists and data is loaded, apply the filter*/
        if (defaultObj) {
            this._filter(this._options);
        }
    }
    registerFormWidget(widget) {
        const name = widget.key || widget.name;
        this.form.filterWidgets[name] = widget;
    }
}
LiveFilterDirective.initializeProps = registerLiveFilterProps();
LiveFilterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLiveFilter]'
            },] }
];
/** @nocollapse */
LiveFilterDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Self }, { type: Inject, args: [FormComponent,] }] }
];

const registerProps$10 = () => {
    register('wm-marquee', new Map([
        ['class', PROP_STRING],
        ['direction', PROP_STRING],
        ['name', PROP_STRING],
        ['scrollamount', PROP_NUMBER],
        ['scrolldelay', PROP_NUMBER],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$D = 'app-marquee app-container';
const WIDGET_CONFIG$M = {
    widgetType: 'wm-marquee',
    hostClass: DEFAULT_CLS$D
};
class MarqueeDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$M);
        styler(this.nativeElement, this);
    }
}
MarqueeDirective.initializeProps = registerProps$10();
MarqueeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmMarquee]',
                providers: [
                    provideAsWidgetRef(MarqueeDirective)
                ]
            },] }
];
/** @nocollapse */
MarqueeDirective.ctorParameters = () => [
    { type: Injector }
];

const animationClasses = {
    scale: {
        'name': 'wmScaleInLeft',
        'down,right': 'wmScaleInLeft',
        'down,left': 'wmScaleInRight',
        'up,right': 'wmScaleInTopLeft',
        'up,left': 'wmScaleInTopRight'
    },
    fade: {
        'name': 'fadeIn',
        'down,right': 'fadeIn',
        'down,left': 'fadeIn',
        'up,right': 'fadeIn',
        'up,left': 'fadeIn'
    },
    slide: {
        'name': 'wmSlideInDown',
        'down,right': 'wmSlideInDown',
        'down,left': 'wmSlideInDown',
        'up,right': 'wmSlideInUp',
        'up,left': 'wmSlideInUp'
    }
};
const DEFAULT_CLS$E = 'dropdown-menu';
class MenuDropdownComponent {
    constructor(elRef, menuRef) {
        this.menuRef = menuRef;
        this.nativeElement = elRef.nativeElement;
        addClass(this.nativeElement, DEFAULT_CLS$E);
    }
    ngAfterViewInit() {
        const animateItems = this.menuRef.animateitems;
        let animationClass = '';
        if (animateItems) {
            animationClass = `animated ${(animationClasses[animateItems][this.menuRef.menuposition] || animationClasses[animateItems].name)}`;
        }
        addClass(this.nativeElement, `dropdown-menu ${this.menuRef.menualign} ${animationClass}`, true);
    }
}
MenuDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'ul[wmMenuDropdown]',
                template: "<li wmMenuDropdownItem *ngFor=\"let item of items\"\n    [item]=\"item\"\n    [ngClass]=\"{disabled: item.disabled, 'dropdown-submenu': item.children.length > 0}\"\n    class=\"{{item.class}}\">\n</li>"
            }] }
];
/** @nocollapse */
MenuDropdownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MenuComponent }
];
MenuDropdownComponent.propDecorators = {
    items: [{ type: Input }]
};

const menuAlignClass = {
    'pull-right': 'fa-caret-left',
    'dropinline-menu': 'fa-caret-down',
    'pull-left': 'fa-caret-right'
};
const MENU_LAYOUT_TYPE = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
};
class MenuDropdownItemComponent {
    constructor(menuRef, userDefinedExecutionContext, parentNav, elRef) {
        this.menuRef = menuRef;
        this.userDefinedExecutionContext = userDefinedExecutionContext;
        this.parentNav = parentNav;
        this.onSelect = ($event, item) => {
            if (this.nativeElement !== $($event.target).closest('.app-menu-item').get(0)) {
                return;
            }
            // prevent event event propagation if auto close is outside click.
            if (this.menuRef.autoclose === 'outsideClick') {
                $event.stopPropagation();
            }
            $event.preventDefault();
            const args = { $event, $item: item };
            const linkTarget = item.target || this.menuRef.linktarget;
            const itemAction = item.action;
            let menuLink = item.link;
            this.menuRef.onMenuItemSelect(args);
            if (itemAction) {
                if (!this.itemActionFn) {
                    this.itemActionFn = $parseEvent(itemAction);
                }
                this.itemActionFn(this.userDefinedExecutionContext, Object.create(item));
            }
            if (menuLink) {
                if (menuLink.startsWith('#/') && (!linkTarget || linkTarget === '_self')) {
                    const queryParams = getUrlParams(menuLink);
                    menuLink = getRouteNameFromLink(menuLink);
                    this.menuRef.route.navigate([menuLink], { queryParams });
                }
                else {
                    openLink(menuLink, linkTarget);
                }
            }
        };
        this.nativeElement = elRef.nativeElement;
        addClass(this.nativeElement, 'app-menu-item');
        this.menualign = menuAlignClass[this.menuRef.menualign] || menuAlignClass['pull-left'];
    }
    ngOnInit() {
        // add active class to the item only if it is in nav component.
        if (this.parentNav) {
            if (isActiveNavItem(this.item.link, this.menuRef.route.url)) {
                // add active class to the li, if the menu item's link is same as the current page name.
                addClass(this.nativeElement, 'active');
            }
        }
    }
    getInitialKeyMovements() {
        const KEY_MOVEMENTS = _.clone(KEYBOARD_MOVEMENTS);
        if (this.menuRef.menulayout === MENU_LAYOUT_TYPE.HORIZONTAL) {
            KEY_MOVEMENTS.MOVE_UP = 'LEFT-ARROW';
            KEY_MOVEMENTS.MOVE_LEFT = 'UP-ARROW';
            KEY_MOVEMENTS.MOVE_RIGHT = 'DOWN-ARROW';
            KEY_MOVEMENTS.MOVE_DOWN = 'RIGHT-ARROW';
        }
        else {
            if (this.menuRef.menuposition === MENU_POSITION.DOWN_LEFT || this.menuRef.menuposition === MENU_POSITION.UP_LEFT) {
                KEY_MOVEMENTS.MOVE_LEFT = 'RIGHT-ARROW';
                KEY_MOVEMENTS.MOVE_RIGHT = 'LEFT-ARROW';
            }
            else if (this.menuRef.menuposition === 'inline') {
                KEY_MOVEMENTS.MOVE_UP = 'LEFT-ARROW';
                KEY_MOVEMENTS.MOVE_LEFT = 'UP-ARROW';
                KEY_MOVEMENTS.MOVE_RIGHT = 'DOWN-ARROW';
                KEY_MOVEMENTS.MOVE_DOWN = 'RIGHT-ARROW';
            }
        }
        return KEY_MOVEMENTS;
    }
    onKeyDown($event, eventAction) {
        const $li = $(this.nativeElement);
        const $ul = $(this.nativeElement).closest('ul.dropdown-menu');
        const $parentUl = this.menuRef.$element.find('> ul.dropdown-menu');
        const ARROW_KEYS = ['LEFT-ARROW', 'RIGHT-ARROW', 'UP-ARROW', 'DOWN-ARROW'];
        const KEY_MOVEMENTS = this.getInitialKeyMovements();
        if (_.includes(ARROW_KEYS, eventAction)) {
            // preventing from page scroll when up/down arrow is pressed, in case of menu is opened.
            $event.preventDefault();
        }
        if ((eventAction === KEY_MOVEMENTS.ON_TAB && $parentUl.children().last()[0] === this.nativeElement) || eventAction === KEY_MOVEMENTS.ON_ESCAPE) {
            /*closing all the children elements when
            * 1. Tab is clicked on the last $element
            * 2. When Escape key is clicked*/
            $event.preventDefault();
            this.menuRef.bsDropdown.hide();
        }
        else if ((eventAction === KEY_MOVEMENTS.ON_ENTER && !this.item.link) || eventAction === KEY_MOVEMENTS.MOVE_RIGHT) {
            // when there is no link for the menu, on enter open the inner child elements and focus the first $element
            $event.stopPropagation();
            if (this.item.children.length) {
                $li.toggleClass('open');
                $li.find('li:first > a').focus();
            }
            else {
                $li.find('> a').focus();
            }
        }
        else if (eventAction === KEY_MOVEMENTS.MOVE_LEFT || (eventAction === KEY_MOVEMENTS.ON_TAB && $ul.children().last()[0] === this.nativeElement)) {
            if ($parentUl[0] !== $ul[0]) {
                const $parentItem = $ul.parent();
                $parentItem.toggleClass('open').find('li.open').removeClass('open');
                $parentItem.find('> a').focus();
                $event.preventDefault();
                $event.stopPropagation();
            }
        }
        else if (eventAction === KEY_MOVEMENTS.MOVE_UP) {
            if ($parentUl[0] !== $ul[0] || $parentUl.find('> li:first')[0] !== this.nativeElement) {
                $event.stopPropagation();
                $li.prev().find('> a').focus();
            }
        }
        else if (eventAction === KEY_MOVEMENTS.MOVE_DOWN) {
            $event.stopPropagation();
            if ($parentUl.find('> li:last')[0] === this.nativeElement && (this.menuRef.menulayout !== MENU_LAYOUT_TYPE.HORIZONTAL && this.menuRef.menuposition === MENU_POSITION.UP_RIGHT || this.menuRef.menuposition === MENU_POSITION.UP_LEFT)) {
                this.menuRef.bsDropdown.hide();
            }
            else {
                $li.next().find('> a').focus();
            }
        }
        else if (eventAction === KEY_MOVEMENTS.ON_ENTER) {
            this.onSelect($event, this.item);
        }
        else {
            $event.stopPropagation();
        }
    }
}
MenuDropdownItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'li[wmMenuDropdownItem]',
                template: "<a href=\"javascript:void(0);\" [title]=\"item.label\" [wmNavigationControl]=\"item.link\" [disableMenuContext]=\"menuRef.disableMenuContext || !!item.action\">\n    <span *ngIf=\"item.children.length\" class=\"pull-right fa caret {{menualign}}\"></span>\n    <i class=\"app-icon {{item.icon}}\"></i>\n    <span class=\"anchor-caption\">{{item.label}}</span>\n\n</a>\n<ng-container [ngTemplateOutlet]=\"nestedMenuDropdown\" *ngIf=\"item.children.length\" [ngTemplateOutletContext]=\"{item: item}\"></ng-container>\n\n<ng-template #nestedMenuDropdown let-item=\"item\">\n    <ul wmMenuDropdown [items]=\"item.children\"></ul>\n</ng-template>\n"
            }] }
];
/** @nocollapse */
MenuDropdownItemComponent.ctorParameters = () => [
    { type: MenuComponent },
    { type: UserDefinedExecutionContext },
    { type: NavComponent, decorators: [{ type: Optional }] },
    { type: ElementRef }
];
MenuDropdownItemComponent.propDecorators = {
    item: [{ type: Input }],
    onKeyDown: [{ type: HostListener, args: ['keydown.tab', ['$event', '"TAB"'],] }, { type: HostListener, args: ['keydown.escape', ['$event', '"ESC"'],] }, { type: HostListener, args: ['keydown.enter', ['$event', '"ENTER"'],] }, { type: HostListener, args: ['keydown.arrowup', ['$event', '"UP-ARROW"'],] }, { type: HostListener, args: ['keydown.arrowdown', ['$event', '"DOWN-ARROW"'],] }, { type: HostListener, args: ['keydown.arrowright', ['$event', '"RIGHT-ARROW"'],] }, { type: HostListener, args: ['keydown.arrowleft', ['$event', '"LEFT-ARROW"'],] }],
    onSelect: [{ type: HostListener, args: ['click', ['$event', 'item'],] }]
};

const registerProps$11 = () => {
    register('wm-navbar', new Map([
        ['class', Object.assign({ value: '' }, PROP_STRING)],
        ['homelink', PROP_STRING],
        ['imgsrc', PROP_STRING],
        ['menuiconclass', Object.assign({ value: 'wi wi-more-vert' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['title', PROP_STRING]
    ]));
};

const DEFAULT_CLS$F = 'navbar navbar-default app-navbar';
const WIDGET_CONFIG$N = { widgetType: 'wm-navbar', hostClass: DEFAULT_CLS$F };
class NavbarComponent extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$N);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
    toggleCollapse() {
        const $navContent = $(this.navContent.nativeElement);
        $navContent.animate({ 'height': 'toggle' });
        if ($navContent.hasClass('in')) {
            setTimeout(() => this.toggleNavCollapse(), 500);
        }
        else {
            this.toggleNavCollapse();
        }
    }
    toggleNavCollapse() {
        this.navContent.nativeElement.classList.toggle('in');
    }
}
NavbarComponent.initializeProps = registerProps$11();
NavbarComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmNavbar]',
                template: "<div class=\"container-fluid\">\n    <div class=\"navbar-header\">\n        <button type=\"button\" class=\"btn-transparent navbar-toggle collapsed\" data-toggle=\"collapse\" (click)=\"toggleCollapse()\" aria-expanded=\"false\">\n            <span class=\"sr-only\">Toggle navigation</span>\n            <i [ngClass]=\"menuiconclass\"></i>\n        </button>\n        <a class=\"navbar-brand\" [href]=\"(homelink | trustAs: 'resource') || '#/'\" *ngIf=\"title || imgsrc\">\n            <img data-identifier=\"img\" class=\"brand-image\" [alt]=\"Brand\" height=\"20\" *ngIf=\"imgsrc\" [src]=\"imgsrc | image\"/>\n            <span class=\"title\" [textContent]=\"title\"></span>\n        </a>\n    </div>\n    <div class=\"collapse navbar-collapse\" #navContent>\n        <ng-content></ng-content>\n    </div>\n</div>",
                providers: [
                    provideAsWidgetRef(NavbarComponent)
                ]
            }] }
];
/** @nocollapse */
NavbarComponent.ctorParameters = () => [
    { type: Injector }
];
NavbarComponent.propDecorators = {
    navContent: [{ type: ViewChild, args: ['navContent',] }]
};

const WIDGET_CONFIG$O = {
    widgetType: 'wm-number',
    hostClass: 'app-input-wrapper'
};
class NumberComponent extends NumberLocale {
    constructor(inj, i18nService, decimalPipe) {
        super(inj, WIDGET_CONFIG$O, i18nService, decimalPipe);
    }
}
NumberComponent.initializeProps = registerProps$z();
NumberComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmNumber]',
                template: "<input class=\"form-control app-textbox app-number-input\"\n       inputmode=\"numeric\"\n       focus-target\n       [attr.name]=\"name\"\n       role=\"input\"\n       type=\"text\"\n       [ngModel]=\"displayValue\"\n       [readonly]=\"readonly\"\n       [disabled]=\"disabled\"\n       [pattern]=\"regexp\"\n       [attr.tabindex]=\"tabindex\"\n       [attr.placeholder]=\"placeholder\"\n       [attr.accesskey]=\"shortcutkey\"\n       [autofocus]=\"autofocus\"\n       (ngModelChange)=\"datavalue=$event\"\n       (blur)=\"handleBlur($event)\"\n       [ngModelOptions]=\"ngModelOptions\"\n       [required]=\"required\"\n       (keypress)=\"validateInputEntry($event)\"\n       (keydown.enter)=\"onEnter($event)\"\n       (keydown.ArrowUp)=\"onArrowPress($event, 'UP')\"\n       (keydown.ArrowDown)=\"onArrowPress($event, 'DOWN')\"\n       #input>",
                providers: [
                    provideAsNgValueAccessor(NumberComponent),
                    provideAsNgValidators(NumberComponent),
                    provideAsWidgetRef(NumberComponent)
                ]
            }] }
];
/** @nocollapse */
NumberComponent.ctorParameters = () => [
    { type: Injector },
    { type: AbstractI18nService },
    { type: DecimalPipe }
];
NumberComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['input',] }],
    ngModel: [{ type: ViewChild, args: [NgModel,] }]
};

const registerProps$12 = () => {
    register('wm-page-content', new Map([
        ['class', PROP_STRING],
        ['columnwidth', PROP_NUMBER],
        ['content', PROP_STRING],
        ['name', PROP_STRING],
        ['pulltorefresh', Object.assign({ value: isMobileApp() }, PROP_BOOLEAN)]
    ]));
};

class PullToRefresh extends SwipeAnimation {
    constructor($el, app, onPullToRefresh) {
        super();
        this.$el = $el;
        this.app = app;
        this.onPullToRefresh = onPullToRefresh;
        this.count = 0;
        const template = '<div class="refresh-container"></div>';
        this.$el.prepend(template);
        this.infoContainer = this.$el.find('.refresh-container');
        if (isIos()) {
            this.infoContainer.addClass('ios-refresh-container');
        }
        this.init(this.$el);
    }
    threshold() {
        return 10;
    }
    direction() {
        return $.fn.swipey.DIRECTIONS.VERTICAL;
    }
    subscribe() {
        // Subscribing for variable updates, wait till the response and stop the animation.
        this.cancelSubscription = this.app.subscribe('toggle-variable-state', (data) => {
            // data.active is true means the variable update has just started whereas false means update has ended.
            if (data.active && this.animationInProgress) {
                this.count++;
                this.wait();
            }
            else if (this.count > 0) {
                this.count--;
            }
            // call stop animation only when animation has started.
            if (!this.count && this.animationInProgress) {
                this.stopAnimation();
            }
        });
    }
    bounds($event, $d) {
        const pageIscroll = this.$el[0].iscroll;
        // If scroll position is not at the top of the page then do not trigger the animation.
        if ($d < 0 || (pageIscroll && !isNaN(pageIscroll.y) && pageIscroll.y !== 0)) {
            return {
                lower: undefined,
                upper: undefined
            };
        }
        if (!this.spinner) {
            this.spinner = isIos() ? new IOSSpinner(this.infoContainer) : new AndroidSpinner(this.infoContainer);
            this.subscribe();
        }
        return {
            lower: 0,
            center: 0,
            upper: isIos() ? 0 : 150,
            strict: !isIos()
        };
    }
    context() {
        this.infoContainer.show();
        if (isIos()) {
            this.infoContainer.addClass('entry');
        }
        return {
            spin: $d => {
                this.spinner.setRotation($d * 2);
            }
        };
    }
    animation() {
        if (isIos()) {
            return {
                css: {
                    transform: 'translate3d(0, ${{$D + $d}}px, 0)',
                    spin: '${{spin($d)}}'
                }
            };
        }
        return {
            target: this.infoContainer,
            css: {
                transform: 'translate3d(0, ${{$D + $d}}px, 0)',
                spin: '${{spin($d)}}',
                opacity: '${{min(($D + $d) / 100, 1)}}'
            }
        };
    }
    // Start the spinner animation and invokes the pulltorefresh event. Stops the animation after the wait time.
    onAnimation() {
        this.animationInProgress = true;
        this.spinner.start();
        if (this.onPullToRefresh) {
            this.onPullToRefresh();
        }
        setTimeout(() => {
            // if listenToAnimation is set, then wait for stopAnimation to be invoked. Otherwise call stopAnimation manually.
            if (this.runAnimation) {
                return;
            }
            this.stopAnimation();
        });
    }
    stopAnimation() {
        setTimeout(() => {
            this.runAnimation = false;
            this.animationInProgress = false;
            this.spinner.stop();
            this.infoContainer.hide();
            setCSS(this.infoContainer[0], 'transform', 'none');
            if (!isIos()) {
                setCSS(this.infoContainer[0], 'opacity', 0);
            }
            this.infoContainer.removeClass('entry');
        }, 800);
    }
    wait() {
        this.runAnimation = true;
    }
}
// Android Spinner implementation
class AndroidSpinner {
    constructor($el, options) {
        this.$el = $el;
        this.options = options || {};
    }
    polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY + (radius * Math.sin(angleInRadians))
        };
    }
    describeArc(x, y, radius, startAngle, endAngle) {
        const start = this.polarToCartesian(x, y, radius, endAngle);
        const end = this.polarToCartesian(x, y, radius, startAngle);
        const arcSweep = endAngle - startAngle <= 180 ? '0' : '1';
        return [
            'M', start.x, start.y,
            'A', radius, radius, 0, arcSweep, 0, end.x, end.y,
            'L', end.x, end.y
        ].join(' ');
    }
    init() {
        if (this.initialized) {
            return;
        }
        // append the svg to the element on which spinner has to be shown.
        const androidTemplate = $('<svg><path id="arc1"/></svg>');
        const container = $('<div class="android-spinner"></div>');
        container.append(androidTemplate);
        this.$el.append(container);
        this.cx = container.outerWidth() / 2;
        this.cy = container.outerHeight() / 2;
        this.r = this.cx * 0.6;
        this.path = container.find('path');
        this.initialized = true;
        this.container = container;
    }
    // sets rotation to the path
    setRotation(deg) {
        this.init();
        this.path.attr('d', this.describeArc(this.cx, this.cy, this.r, 0, deg));
    }
    // animate the path to rotate continuously with some interval
    start() {
        this.init();
        const self = this, totalTime = this.options.time || 1800, degreesToTraverse = 10;
        let i = 0;
        this.container.addClass('spin');
        this.intervalId = setInterval(() => {
            let deg;
            i = i + degreesToTraverse;
            if (i > 720) {
                deg = i = 0;
            }
            else if (i > 360) {
                deg = 720 - i;
            }
            else {
                deg = i;
            }
            self.path.attr('d', this.describeArc(self.cx, self.cy, self.r, 0, deg));
        }, (totalTime * degreesToTraverse / 360));
    }
    // Removes the animation by clearing the intervals
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = 0;
        }
        this.container.removeClass('spin');
    }
}
// iOS spinner implementation
class IOSSpinner {
    constructor($el) {
        this.$el = $el;
    }
    // create the iOS spinner using svg
    init() {
        if (this.svg) {
            return;
        }
        const container = $('<div class="ios-spinner"><svg></svg></div>');
        const svg = container.find('svg');
        this.$el.append(container);
        const d = container.width();
        for (let i = 0; i < 12; i++) {
            svg[0].innerHTML += `<line y1="${0.15 * d}" y2="${0.3 * d}"
                                    transform="translate(${0.5 * d}, ${0.5 * d}) rotate(${i * 30})">
                                </line>`;
        }
        container.append(svg);
        this.svg = svg;
    }
    // Sets the svg to rotate depending on "d" value
    setRotation(d) {
        this.init();
        this.svg.css('transform', `rotateZ( ${Math.round(d / 30) * 30}deg)`);
    }
    // Triggers the rotation with some interval
    start() {
        this.init();
        let i = 0;
        this.intervalId = setInterval(() => {
            i += 10;
            this.setRotation(i);
        }, 20);
    }
    // Removes the animation by clearing the intervals
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = 0;
        }
    }
}

const DEFAULT_CLS$G = 'app-page-content app-content-column';
const WIDGET_CONFIG$P = { widgetType: 'wm-page-content', hostClass: DEFAULT_CLS$G };
class PageContentComponent extends StylableComponent {
    constructor(inj, app) {
        super(inj, WIDGET_CONFIG$P);
        this.app = app;
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
        this.registerDestroyListener(this.app.subscribe('pullToRefresh:enable', () => {
            this.childPullToRefresh = true;
            this.initPullToRefresh();
        }));
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'columnwidth') {
            switchClass(this.nativeElement, `col-md-${nv} col-sm-${nv}`, `col-md-${ov} col-sm-${ov}`);
        }
        else if (key === 'pulltorefresh' && nv) {
            // creating instance after timeout as the smoothscroll styles where getting added on pull refresh-container
            setTimeout(() => {
                this.initPullToRefresh();
            });
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    // when list component is ready, pulltorefresh instance is created and this appends pullToRefresh element on the page content.
    initPullToRefresh() {
        const hasPullToRefreshEvent = this.hasEventCallback('pulltorefresh');
        if (!this.pullToRefreshIns && (this.childPullToRefresh || hasPullToRefreshEvent) && this.pulltorefresh) {
            this.pullToRefreshIns = new PullToRefresh($(this.nativeElement), this.app, () => {
                if (hasPullToRefreshEvent) {
                    this.invokeEventCallback('pulltorefresh');
                }
                else {
                    this.app.notify('pulltorefresh');
                }
            });
            this.registerDestroyListener(() => {
                if (this.pullToRefreshIns.cancelSubscription) {
                    this.pullToRefreshIns.cancelSubscription();
                }
            });
        }
    }
}
PageContentComponent.initializeProps = registerProps$12();
PageContentComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmPageContent]',
                template: "<ng-content></ng-content>",
                providers: [
                    provideAsWidgetRef(PageContentComponent)
                ]
            }] }
];
/** @nocollapse */
PageContentComponent.ctorParameters = () => [
    { type: Injector },
    { type: App }
];

const registerProps$13 = () => {
    register('wm-panel', new Map([
        ['actions', {}],
        ['badgetype', Object.assign({ value: 'default' }, PROP_STRING)],
        ['badgevalue', PROP_STRING],
        ['class', PROP_STRING],
        ['closable', PROP_BOOLEAN],
        ['collapsible', PROP_BOOLEAN],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['content', PROP_STRING],
        ['datafield', PROP_STRING],
        ['enablefullscreen', PROP_BOOLEAN],
        ['expanded', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['fullscreen', PROP_BOOLEAN],
        ['helptext', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['itemaction', PROP_STRING],
        ['itemchildren', PROP_STRING],
        ['itemicon', PROP_STRING],
        ['itemlabel', PROP_STRING],
        ['itemlink', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['subheading', PROP_STRING],
        ['title', PROP_STRING],
        ['userrole', PROP_STRING]
    ]));
};

const DEFAULT_CLS$H = 'app-panel panel';
const WIDGET_CONFIG$Q = { widgetType: 'wm-panel', hostClass: DEFAULT_CLS$H };
class PanelComponent extends MenuAdapterComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$Q);
        this.$lazyLoad = noop;
        this.expanded = true;
        this.helpClass = '';
        this.helptext = '';
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.SHELL);
        this.fullScreenTitle = `${this.appLocale.LABEL_FULLSCREEN}/${this.appLocale.LABEL_EXITFULLSCREEN}`;
        this.expandCollapseTitle = `${this.appLocale.LABEL_COLLAPSE}/${this.appLocale.LABEL_EXPAND}`;
        removeAttr(this.nativeElement, 'title');
    }
    // conditions to show the footer
    get hideFooter() {
        return !this.hasFooter || !this.expanded;
    }
    // conditions to show header
    get showHeader() {
        return this.iconurl || this.iconclass || this.collapsible || this.actions || this.title || this.subheading || this.enablefullscreen;
    }
    // toggle the panel state between collapsed - expanded. invoke the respective callbacks
    toggle($event) {
        if (this.collapsible) {
            this.invokeEventCallback(this.expanded ? 'collapse' : 'expand', { $event });
            this.expanded = !this.expanded;
            if (this.expanded) {
                this.$lazyLoad();
                this.reDrawChildren();
            }
        }
    }
    expand($event) {
        if (!this.expanded) {
            this.toggle($event);
        }
    }
    collapse($event) {
        if (this.expanded) {
            this.toggle($event);
        }
    }
    // toggle the fullscreen state of the panel. invoke the respective callbacks
    toggleFullScreen($event) {
        if (this.enablefullscreen) {
            this.invokeEventCallback(this.fullscreen ? 'exitfullscreen' : 'fullscreen', { $event });
            this.fullscreen = !this.fullscreen;
            toggleClass(this.nativeElement, 'fullscreen', this.fullscreen);
            // Re-plot the widgets inside panel
            this.reDrawChildren();
        }
        this.computeDimensions();
    }
    // show/hide help
    toggleHelp() {
        this.helpClass = this.helpClass ? '' : 'show-help';
        toggleClass(this.nativeElement, 'show-help', !!this.helpClass);
        $appDigest();
    }
    // hide the panel and invoke the respective event handler
    close($event) {
        this.getWidget().show = false;
        this.invokeEventCallback('close', { $event });
    }
    // calculation of dimensions when the panel the panel state changes from/to fullscreen
    computeDimensions() {
        const headerHeight = this.panelHeader.nativeElement.offsetHeight;
        const footer = this.nativeElement.querySelector('.panel-footer');
        const content = this.panelContent.nativeElement;
        const vHeight = window.innerHeight;
        let inlineHeight;
        if (this.fullscreen) {
            inlineHeight = this.hideFooter ? (vHeight - headerHeight) : vHeight - (footer.offsetHeight + headerHeight);
        }
        else {
            inlineHeight = this.height || '';
        }
        setCSS(content, 'height', inlineHeight);
    }
    // notify the redrawable components(charts, grid)
    reDrawChildren() {
        setTimeout(() => {
            if (this.reDrawableComponents) {
                this.reDrawableComponents.forEach(c => c.redraw());
            }
        }, 100);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'expanded') {
            this.expanded = nv;
        }
        else if (key === 'content') {
            setTimeout(() => {
                if (this.expanded || !this.collapsible) {
                    this.$lazyLoad();
                }
            }, 20);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        this.hasFooter = !!this.nativeElement.querySelector('[wmPanelFooter]');
        styler(this.panelBody.nativeElement, this, APPLY_STYLES_TYPE.INNER_SHELL);
    }
}
PanelComponent.initializeProps = registerProps$13();
PanelComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmPanel]',
                template: "<div class=\"panel-heading {{helpClass}}\" *ngIf=\"showHeader\" #panelHeading>\n    <h3 class=\"panel-title\">\n        <a href=\"javascript:void(0)\" class=\"panel-toggle\" (click)=\"toggle($event)\">\n            <div class=\"pull-left\">\n                <i class=\"app-icon panel-icon {{iconclass}}\" *ngIf=\"iconclass && !iconurl\"></i>\n                <img data-identifier=\"img\" title=\"iconurl\" alt=\"Panel icon\" class=\"panel-image-icon\" [src]=\"iconurl | image\" *ngIf=\"iconurl\"\n                     [ngStyle]=\"{width: iconwidth ,height: iconheight, margin: iconmargin}\"/>\n            </div>\n            <div class=\"pull-left\">\n                <div class=\"heading\" [innerHTML]=\"title | trustAs: 'html'\" [title]=\"title\"></div>\n                <div class=\"description\" [innerHTML]=\"subheading | trustAs: 'html'\"></div>\n            </div>\n        </a>\n        <div class=\"panel-actions\">\n            <span *ngIf=\"badgevalue\" aria-label=\"badge\" class=\"app-badge label label-{{badgetype}}\">{{badgevalue}}</span>\n            <div wmMenu aria-label=\"dropdown\"\n                 dropdown\n                 type=\"anchor\"\n                 class=\"panel-action\"\n                 dataset.bind=\"actions\"\n                 *ngIf=\"actions\"\n                 caption=\"\"\n                 menuposition=\"down,left\"\n                 iconclass=\"wi wi-more-vert\"\n                 datafield.bind=\"datafield\"\n                ></div>\n            <button type=\"button\" aria-label=\"Help\" class=\"app-icon panel-action wi\" [title]=\"appLocale.LABEL_HELP\" *ngIf=\"helptext\"\n                    (click)=\"toggleHelp()\"><i class=\"wi-question\"></i></button>\n            <button type=\"button\" aria-label=\"Collapse/Expand\" class=\"app-icon wi panel-action\" *ngIf=\"collapsible\" [title]=\"expandCollapseTitle\"\n                    (click)=\"toggle($event);\"><i [ngClass]=\"expanded ? 'wi-minus' : 'wi-plus'\"></i></button>\n            <button type=\"button\" aria-label=\"Fullscreen/Exit\" class=\"app-icon panel-action wi\" *ngIf=\"enablefullscreen\"\n                    [title]=\"fullScreenTitle\"\n                    (click)=\"toggleFullScreen($event);\"><i [ngClass]=\"fullscreen ? 'wi-fullscreen-exit' : 'wi-fullscreen'\"></i></button>\n            <button type=\"button\" aria-label=\"Close button\" class=\"app-icon panel-action\" title=\"{{appLocale.LABEL_CLOSE}}\" *ngIf=\"closable\"\n                    (click)=\"close($event)\"><i class=\"wi wi-close\"></i></button>\n        </div>\n    </h3>\n</div>\n<div class=\"panel-content\" [hidden]=\"!expanded\" #panelContent>\n    <!-- Todo Bandhavya - implement smooth scroll -->\n    <div partial-container-target #panelBody [ngClass]=\"['panel-body', helpClass]\">\n        <ng-content></ng-content>\n    </div>\n    <aside class=\"panel-help-message\" [ngClass]=\"helpClass\">\n        <h5 class=\"panel-help-header\" [textContent]=\"appLocale.LABEL_HELP\"></h5>\n        <div class=\"panel-help-content\" [innerHTML]=\"helptext | trustAs : 'html'\"></div>\n    </aside>\n</div>\n<div class=\"app-panel-footer panel-footer clearfix\" [hidden]=\"hideFooter\">\n    <ng-content select=\"[wmPanelFooter]\"></ng-content>\n</div>",
                providers: [
                    provideAsWidgetRef(PanelComponent)
                ]
            }] }
];
/** @nocollapse */
PanelComponent.ctorParameters = () => [
    { type: Injector }
];
PanelComponent.propDecorators = {
    panelHeader: [{ type: ViewChild, args: ['panelHeading',] }],
    panelContent: [{ type: ViewChild, args: ['panelContent',] }],
    panelBody: [{ type: ViewChild, args: ['panelBody',] }],
    reDrawableComponents: [{ type: ContentChildren, args: [RedrawableDirective, { descendants: true },] }]
};

const registerProps$14 = () => {
    register('wm-partialdialog', new Map([
        ['animation', PROP_STRING],
        ['class', PROP_STRING],
        ['closable', { value: true, PROP_BOOLEAN }],
        ['content', PROP_STRING],
        ['iconclass', { value: 'wi wi-file', PROP_STRING }],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['modal', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['name', PROP_STRING],
        ['oktext', Object.assign({ value: 'OK' }, PROP_STRING)],
        ['showactions', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', Object.assign({ value: 'Page Content' }, PROP_STRING)]
    ]));
};

const DIALOG_CLS$4 = 'app-dialog modal-dialog app-page-dialog';
const WIDGET_INFO$5 = { widgetType: 'wm-partialdialog' };
class PartialDialogComponent extends BaseDialog {
    constructor(inj, dialogClass, modal, closable) {
        if (modal === null || modal === undefined) {
            modal = false;
        }
        if (closable === null || closable === undefined) {
            closable = true;
        }
        // setting the backdrop to 'static' will not close the dialog on backdrop click
        const backdrop = toBoolean(modal) ? 'static' : true;
        super(inj, WIDGET_INFO$5, {
            class: `${DIALOG_CLS$4} ${dialogClass || ''}`,
            backdrop,
            keyboard: !toBoolean(modal)
        });
    }
    getTemplateRef() {
        return this.dialogTemplate;
    }
    /**
     * Click event handler for the ok button
     * invokes on-ok event callback
     * @param {Event} $event
     */
    onOk($event) {
        this.invokeEventCallback('ok', { $event });
    }
    ngOnInit() {
        super.ngOnInit();
        this.register(this.viewParent);
    }
}
PartialDialogComponent.initializeProps = registerProps$14();
PartialDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmPartialDialog]',
                template: "<ng-template #dialogTemplate>\n    <div wmDialogHeader [closable]=\"closable\"\n         [iconclass]=\"iconclass\"\n         [iconurl]=\"iconurl\"\n         [iconwidth]=\"iconwidth\"\n         [iconheight]=\"iconheight\"\n         [iconmargin]=\"iconmargin\"\n         [heading]=\"title\"\n    ></div>\n    <div wmDialogBody>\n        <ng-container *ngTemplateOutlet=\"dialogContent\"></ng-container>\n    </div>\n    <div wmDialogFooter *ngIf=\"showactions\">\n        <button wmButton class=\"btn-primary ok-action\" caption.bind=\"oktext\" aria-label=\"Submit button\" (click)=\"onOk($event)\"></button>\n    </div>\n</ng-template>\n",
                providers: [
                    provideAsWidgetRef(PartialDialogComponent),
                    provideAsDialogRef(PartialDialogComponent)
                ]
            }] }
];
/** @nocollapse */
PartialDialogComponent.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Attribute, args: ['class',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['modal',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['closable',] }] }
];
PartialDialogComponent.propDecorators = {
    dialogTemplate: [{ type: ViewChild, args: ['dialogTemplate',] }],
    dialogContent: [{ type: ContentChild, args: [TemplateRef,] }]
};

const registerProps$15 = () => {
    register('wm-partial', new Map([
        ['name', PROP_STRING]
    ]));
};

const DEFAULT_CLS$I = 'app-partial clearfix';
const WIDGET_CONFIG$R = { widgetType: 'wm-partial', hostClass: DEFAULT_CLS$I };
class PartialDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$R);
    }
}
PartialDirective.initializeProps = registerProps$15();
PartialDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmPartial]',
                providers: [
                    provideAsWidgetRef(PartialDirective)
                ]
            },] }
];
/** @nocollapse */
PartialDirective.ctorParameters = () => [
    { type: Injector }
];

class PartialParamHandlerDirective {
    constructor(widgetRef) {
        this.widgetRef = widgetRef;
        this.widgetRef.partialParams = {};
        this.widgetRef.pageParams = this.widgetRef.partialParams;
        this.widgetRef.params$ = new Subject();
    }
    registerParams(name, value, bindExpr, type) {
        this.widgetRef.partialParams[name] = value;
        if (!value && bindExpr) {
            this.widgetRef.registerDestroyListener($watch(bindExpr, this.widgetRef.getViewParent(), _.get(this.widgetRef, 'context'), nv => {
                this.widgetRef.partialParams[name] = nv;
                // notify the partial container of the param changes
                this.widgetRef.params$.next();
            }));
        }
        else {
            this.widgetRef.params$.next();
        }
    }
}
PartialParamHandlerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[partialContainer]',
            },] }
];
/** @nocollapse */
PartialParamHandlerDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Self }, { type: Inject, args: [WidgetRef,] }] }
];
class PartialParamDirective {
    constructor(bindValue, type, partialParamsProvider) {
        this.bindValue = bindValue;
        this.type = type;
        this.partialParamsProvider = partialParamsProvider;
    }
    ngOnInit() {
        this.partialParamsProvider.registerParams(this.name, this.value, this.bindValue, this.type);
    }
}
PartialParamDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmParam]',
            },] }
];
/** @nocollapse */
PartialParamDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Attribute, args: ['value.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['type',] }] },
    { type: PartialParamHandlerDirective }
];
PartialParamDirective.propDecorators = {
    name: [{ type: Input }],
    value: [{ type: Input }]
};

const registerProps$16 = () => {
    register('wm-prefab-container', new Map([
        ['class', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
    ]));
};

const DEFAULT_CLS$J = 'app-prefab-container full-height';
const WIDGET_CONFIG$S = {
    widgetType: 'wm-prefab-container',
    hostClass: DEFAULT_CLS$J
};
class PrefabContainerDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$S);
        styler(this.nativeElement, this);
    }
}
PrefabContainerDirective.initializeProps = registerProps$16();
PrefabContainerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmPrefabContainer]',
                providers: [
                    provideAsWidgetRef(PrefabContainerDirective)
                ]
            },] }
];
/** @nocollapse */
PrefabContainerDirective.ctorParameters = () => [
    { type: Injector }
];

const registerProps$17 = () => {
    const props = new Map([
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['encodeurl', PROP_STRING],
        ['hint', PROP_STRING],
        ['name', PROP_STRING],
        ['pictureaspect', Object.assign({ value: 'None' }, PROP_STRING)],
        ['pictureplaceholder', PROP_STRING],
        ['picturesource', PROP_STRING],
        ['shape', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)]
    ]);
    if (isMobileApp()) {
        props.set('offline', Object.assign({ value: true }, PROP_BOOLEAN));
    }
    register('wm-picture', props);
};

const DEFAULT_CLS$K = 'app-picture';
const WIDGET_CONFIG$T = {
    widgetType: 'wm-picture',
    hostClass: DEFAULT_CLS$K,
    displayType: DISPLAY_TYPE.INLINE_BLOCK
};
class PictureDirective extends StylableComponent {
    constructor(inj, imagePipe) {
        super(inj, WIDGET_CONFIG$T);
        this.imagePipe = imagePipe;
        styler(this.nativeElement, this);
    }
    setImgSource() {
        this.imgSource = this.imagePipe.transform(this.picturesource, this.encodeurl, this.pictureplaceholder);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'pictureaspect') {
            let width = '';
            let height = '';
            switch (nv) {
                case 'None':
                    width = this.width;
                    height = this.height;
                    break;
                case 'H':
                    width = '100%';
                    break;
                case 'V':
                    height = '100%';
                    break;
                case 'Both':
                    width = '100%';
                    height = '100%';
                    break;
            }
            setCSS(this.nativeElement, 'width', width, true);
            setCSS(this.nativeElement, 'height', height, true);
        }
        else if (key === 'encodeurl' || key === 'pictureplaceholder') {
            this.setImgSource();
        }
        else if (key === 'shape') {
            switchClass(this.nativeElement, `img-${nv}`, `img-${ov}`);
        }
        else if (key === 'hint') {
            setAttr(this.nativeElement, 'alt', nv);
        }
        super.onPropertyChange(key, nv, ov);
    }
    onStyleChange(key, nv, ov) {
        if (key === 'picturesource') {
            this.setImgSource();
        }
        else {
            super.onStyleChange(key, nv, ov);
        }
    }
    ngOnInit() {
        this.setImgSource();
        super.ngOnInit();
    }
}
PictureDirective.initializeProps = registerProps$17();
PictureDirective.decorators = [
    { type: Directive, args: [{
                selector: 'img[wmPicture]',
                providers: [
                    provideAsWidgetRef(PictureDirective)
                ]
            },] }
];
/** @nocollapse */
PictureDirective.ctorParameters = () => [
    { type: Injector },
    { type: ImagePipe }
];
PictureDirective.propDecorators = {
    imgSource: [{ type: HostBinding, args: ['src',] }]
};

const registerProps$18 = () => {
    register('wm-popover', new Map([
        ['badgevalue', PROP_STRING],
        ['caption', Object.assign({ value: 'Link' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['content', PROP_STRING],
        ['contentanimation', PROP_STRING],
        ['contentsource', Object.assign({ value: 'partial' }, PROP_STRING)],
        ['encodeurl', PROP_BOOLEAN],
        ['hint', PROP_STRING],
        ['hyperlink', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['iconheight', PROP_STRING],
        ['iconmargin', PROP_STRING],
        ['iconposition', PROP_STRING],
        ['iconurl', PROP_STRING],
        ['iconwidth', PROP_STRING],
        ['interaction', Object.assign({ value: 'click' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['popoverarrow', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['popoverheight', PROP_STRING],
        ['popoverplacement', Object.assign({ value: 'bottom' }, PROP_STRING)],
        ['popoverwidth', PROP_STRING],
        ['shortcutkey', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', PROP_STRING]
    ]));
};

const DEFAULT_CLS$L = 'app-popover-wrapper';
const WIDGET_CONFIG$U = {
    widgetType: 'wm-popover',
    hostClass: DEFAULT_CLS$L
};
const eventsMap = {
    click: 'click',
    hover: 'mouseenter:click',
    default: 'click mouseenter'
};
let activePopover;
class PopoverComponent extends StylableComponent {
    constructor(inj, app, evtMngrPlugins) {
        super(inj, WIDGET_CONFIG$U);
        this.app = app;
        this.isOpen = false;
        this.canPopoverOpen = true;
        // KeyEventsPlugin
        this.keyEventPlugin = evtMngrPlugins[1];
        this.popoverContainerCls = `app-popover-${this.widgetId}`;
    }
    // This mehtod is used to show/open the popover. This refers to the same method showPopover.
    open() {
        this.showPopover();
    }
    // This mehtod is used to hide/close the popover.
    close() {
        this.isOpen = false;
    }
    // Trigger on hiding popover
    onHidden() {
        this.invokeEventCallback('hide', { $event: { type: 'hide' } });
    }
    setFocusToPopoverLink() {
        setTimeout(() => this.anchorRef.nativeElement.focus(), 10);
    }
    adjustPopoverPosition(popoverElem, parentDimesion, popoverLeftShift) {
        const arrowLeftShift = (parentDimesion.left + (parentDimesion.width / 2)) - popoverLeftShift;
        this.bsPopoverDirective._popover._ngZone.onStable.subscribe(() => {
            popoverElem.css('left', popoverLeftShift + 'px');
            popoverElem.find('.popover-arrow').css('left', arrowLeftShift + 'px');
        });
    }
    calculatePopoverPostion(element) {
        const popoverElem = $(element);
        const popoverLeft = _.parseInt(popoverElem.css('left'));
        const popoverWidth = _.parseInt(popoverElem.css('width'));
        const viewPortWidth = $(window).width();
        const parentDimesion = this.anchorRef.nativeElement.getBoundingClientRect();
        // Adjusting popover position, if it is not visible at left side
        if (popoverLeft < 0) {
            const popoverLeftShift = 4;
            this.adjustPopoverPosition(popoverElem, parentDimesion, popoverLeftShift);
        }
        // Adjusting popover position, if it is not visible at right side
        if (popoverLeft + popoverWidth > viewPortWidth) {
            const popoverLeftAdjust = (popoverLeft + popoverWidth) - viewPortWidth;
            const popoverLeftShift = popoverLeft - popoverLeftAdjust - 50;
            this.adjustPopoverPosition(popoverElem, parentDimesion, popoverLeftShift);
        }
    }
    // Trigger on showing popover
    onShown() {
        if (activePopover && activePopover.isOpen) {
            activePopover.isOpen = false;
        }
        activePopover = this;
        activePopover.isOpen = true;
        const popoverContainer = document.querySelector(`.${this.popoverContainerCls}`);
        setCSSFromObj(popoverContainer, {
            height: this.popoverheight,
            minWidth: this.popoverwidth
        });
        if (!this.popoverarrow) {
            addClass(popoverContainer.querySelector('.arrow'), 'hidden');
        }
        if (this.interaction === 'hover' || this.interaction === 'default') {
            // do not use addEventListener here
            // attaching the event this way will override the existing event handlers
            popoverContainer.onmouseenter = () => clearTimeout(this.closePopoverTimeout);
            popoverContainer.onmouseleave = () => this.hidePopover();
            this.anchorRef.nativeElement.onmouseenter = () => clearTimeout(this.closePopoverTimeout);
            this.anchorRef.nativeElement.onmouseleave = () => this.hidePopover();
        }
        const deRegister = this.eventManager.addEventListener(popoverContainer, 'keydown.esc', () => {
            this.isOpen = false;
            this.setFocusToPopoverLink();
            deRegister();
        });
        const popoverStartBtn = popoverContainer.querySelector('.popover-start');
        const popoverEndBtn = popoverContainer.querySelector('.popover-end');
        popoverStartBtn.onkeydown = (event) => {
            const action = this.keyEventPlugin.constructor.getEventFullKey(event);
            // Check for Shift+Tab key
            if (action === 'shift.tab') {
                this.bsPopoverDirective.hide();
                this.setFocusToPopoverLink();
            }
        };
        popoverEndBtn.onkeydown = (event) => {
            const action = this.keyEventPlugin.constructor.getEventFullKey(event);
            // Check for Tab key
            if (action === 'tab') {
                this.bsPopoverDirective.hide();
                this.setFocusToPopoverLink();
            }
        };
        setAttr(popoverContainer, 'tabindex', 0);
        setTimeout(() => popoverStartBtn.focus(), 50);
        // Adjusting popover position if the popover placement is top or bottom
        setTimeout(() => {
            if (this.popoverplacement === 'bottom' || this.popoverplacement === 'top') {
                this.calculatePopoverPostion(popoverContainer);
            }
            // triggering onload and onshow events after popover content has rendered
            this.triggerPopoverEvents();
        });
    }
    triggerPopoverEvents() {
        if (this.contentsource === 'partial') {
            const cancelSubscription = this.app.subscribe('partialLoaded', (data) => {
                const parEle = this.partialRef.nativeElement;
                let partialScope;
                if (parEle) {
                    partialScope = parEle.widget;
                    this.Widgets = partialScope.Widgets;
                    this.Variables = partialScope.Variables;
                    this.Actions = partialScope.Actions;
                    this.invokeEventCallback('load');
                    this.invokeEventCallback('show', { $event: { type: 'show' } });
                }
                cancelSubscription();
            });
        }
        else {
            this.Widgets = this.viewParent.Widgets;
            this.Variables = this.viewParent.Variables;
            this.Actions = this.viewParent.Actions;
            this.invokeEventCallback('show', { $event: { type: 'show' } });
        }
    }
    hidePopover() {
        this.closePopoverTimeout = setTimeout(() => this.isOpen = false, 500);
    }
    showPopover() {
        this.bsPopoverDirective.show();
    }
    onPopoverAnchorKeydown($event) {
        // if there is no content available, the popover should not open through enter key. So checking whether the canPopoverOpen flag is true or not.
        if (!this.canPopoverOpen) {
            return;
        }
        const action = this.keyEventPlugin.constructor.getEventFullKey(event);
        if (action === 'enter') {
            $event.stopPropagation();
            this.showPopover();
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'class' || key === 'tabindex') {
            return;
        }
        if (key === 'contentsource') {
            // if there is no partial content available, the popover should not open
            if (this.contentsource === 'partial' && !this.content) {
                this.canPopoverOpen = false;
            }
        }
        if (key === 'content' && nv) {
            this.canPopoverOpen = true;
        }
        super.onPropertyChange(key, nv, ov);
    }
    ngOnInit() {
        super.ngOnInit();
        this.event = eventsMap[this.interaction];
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.anchorRef.nativeElement, this);
    }
}
PopoverComponent.initializeProps = registerProps$18();
PopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'wm-popover',
                template: "<a [popover]=\"popoverTemplate\"\n   [popoverContext]=\"context\"\n   [popoverTitle]=\"title\"\n   [placement]=\"popoverplacement\"\n   [outsideClick]=\"true\"\n   [triggers]=\"event\"\n   (onShown)=\"onShown()\"\n   (onHidden)=\"onHidden()\"\n   containerClass=\"app-popover animated {{contentanimation}} {{popoverContainerCls}}\"\n   container=\"body\"\n   [isOpen]=\"isOpen\"\n   [tabindex]=\"tabindex\"\n   [name]=\"name\"\n   [class] = \"class\"\n   [ngClass]=\"{'disable-popover': !canPopoverOpen}\"\n\n   #anchor\n   name.bind=\"name\"\n   wmAnchor\n   animation.bind=\"animation\"\n   badgevalue.bind=\"badgevalue\"\n   caption.bind=\"caption\"\n   encodeurl.bind=\"encodeurl\"\n   hint.bind=\"hint\"\n   hyperlink.bind=\"hyperlink\"\n   iconurl.bind=\"iconurl\"\n   iconwidth.bind=\"iconwidth\"\n   iconheight.bind=\"iconheight\"\n   iconmargin.bind=\"iconmargin\"\n   iconclass.bind=\"iconclass\"\n   iconposition.bind=\"iconposition\"\n   shortcutkey.bind=\"shortcutkey\"\n   tabindex.bind=\"tabindex\"\n   (keydown)=\"onPopoverAnchorKeydown($event)\">\n</a>",
                providers: [
                    provideAsWidgetRef(PopoverComponent)
                ]
            }] }
];
/** @nocollapse */
PopoverComponent.ctorParameters = () => [
    { type: Injector },
    { type: App },
    { type: undefined, decorators: [{ type: Inject, args: [EVENT_MANAGER_PLUGINS,] }] }
];
PopoverComponent.propDecorators = {
    bsPopoverDirective: [{ type: ViewChild, args: [PopoverDirective,] }],
    anchorRef: [{ type: ViewChild, args: ['anchor',] }],
    popoverTemplate: [{ type: ContentChild, args: [TemplateRef,] }],
    partialRef: [{ type: ContentChild, args: ['partial',] }]
};

const prefabProps = new Map([
    ['class', Object.assign({ value: '' }, PROP_STRING)],
    ['name', PROP_STRING],
    ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
]);

const DEFAULT_CLS$M = 'app-prefab';
const registeredPropsSet = new Set();
class PrefabDirective extends StylableComponent {
    constructor(inj, elRef, cdr, prefabName) {
        const widgetType = `wm-prefab-${prefabName}`;
        const WIDGET_CONFIG = { widgetType, hostClass: DEFAULT_CLS$M };
        super(inj, WIDGET_CONFIG, new Promise(res => this.propsReady = res));
        this.prefabName = prefabName;
        this.widgetType = widgetType;
        this.name = elRef.nativeElement.getAttribute('name');
        styler(this.nativeElement, this);
        // Call on property change on name to set name attribute on element.
        this.registerReadyStateListener(() => {
            super.onPropertyChange('name', this.name);
        });
    }
    onStyleChange(key, nv, ov) {
        if (key === 'height') {
            setCSS(this.nativeElement, 'overflow', 'auto');
        }
    }
    setProps(config) {
        if (!config || !config.properties) {
            return;
        }
        if (!registeredPropsSet.has(this.widgetType)) {
            register(this.widgetType, this.prepareProps(config.properties));
        }
        this.propsReady();
    }
    handleEvent() {
        // do not call the super;
        // prevent events from getting registered
    }
    prepareProps(props = {}) {
        const propsMap = new Map(prefabProps);
        Object.entries(props).forEach(([k, v]) => {
            let type = PROP_TYPE.STRING;
            if (v.type === 'boolean') {
                type = PROP_TYPE.BOOLEAN;
            }
            else if (v.type === 'number') {
                type = PROP_TYPE.NUMBER;
            }
            else if (v.type !== 'string') {
                type = v.type;
            }
            // Do not set the 'bind:*' values
            propsMap.set(k, { type, value: _.startsWith(v.value, 'bind:') ? undefined : v.value });
        });
        registeredPropsSet.add(this.widgetType);
        return propsMap;
    }
}
PrefabDirective.decorators = [
    { type: Directive, args: [{
                selector: 'section[wmPrefab]',
                providers: [
                    provideAsWidgetRef(PrefabDirective)
                ]
            },] }
];
/** @nocollapse */
PrefabDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Attribute, args: ['prefabname',] }] }
];

const DEFAULT_CLS$N = 'app-radioset list-group';
const WIDGET_CONFIG$V = { widgetType: 'wm-radioset', hostClass: DEFAULT_CLS$N };
class RadiosetComponent extends DatasetAwareFormComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$V);
        this.layout = '';
        styler(this.nativeElement, this);
        this.multiple = false;
    }
    /**
     * On click of the option, update the datavalue
     */
    onRadioLabelClick($event, key) {
        if (!$($event.target).is('input')) {
            return;
        }
        this.modelByKey = key;
        this.invokeOnTouched();
        // invoke on datavalue change.
        this.invokeOnChange(this.datavalue, $event || {}, true);
    }
    // change and blur events are added from the template
    handleEvent(node, eventName, callback, locals) {
        if (eventName === 'click') {
            this.eventManager.addEventListener(node, eventName, e => {
                if (!$(e.target).is('input')) {
                    return;
                }
                locals.$event = e;
                return callback();
            });
        }
        else if (!_.includes(['change'], eventName)) {
            super.handleEvent(node, eventName, callback, locals);
        }
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'tabindex') {
            return;
        }
        if (key === 'layout') {
            switchClass(this.nativeElement, nv, ov);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
RadiosetComponent.initializeProps = registerProps$F();
RadiosetComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmRadioset]',
                exportAs: 'wmRadioset',
                template: "<li [ngClass]=\"['radio', 'app-radio', itemclass]\"\n    [class.active]=\"item.selected\"\n    *ngFor=\"let item of datasetItems;let i = index\"\n    (click)=\"onRadioLabelClick($event, item.key)\">\n    <label class=\"app-radioset-label\"\n           [ngClass]=\"{'disabled':disabled || readonly}\"\n           [title]=\"item.label\">\n        <input [name]=\"'radioset_' + widgetId\" type=\"radio\" [attr.aria-checked]=\"item.selected\" [attr.data-attr-index]=\"i\"\n               [value]=\"item.key\" [disabled]=\"disabled || readonly\" [tabindex]=\"tabindex\" [checked]=\"item.selected\"/>\n        <span class=\"caption\" [textContent]=\"item.label\"></span>\n    </label>\n</li>\n\n<input [disabled]=\"disabled || readonly\" hidden class=\"model-holder\">\n<div *ngIf=\"readonly || disabled\" aria-readonly=\"true\" class=\"readonly-wrapper\"></div>",
                providers: [
                    provideAsNgValueAccessor(RadiosetComponent),
                    provideAsWidgetRef(RadiosetComponent)
                ]
            }] }
];
/** @nocollapse */
RadiosetComponent.ctorParameters = () => [
    { type: Injector }
];

const WIDGET_INFO$6 = { widgetType: 'wm-richtexteditor', hostClass: 'app-richtexteditor clearfix' };
const getChangeEvt = () => {
    let changeEvt;
    // for IE the event constructor doesn't work so use the createEvent proto
    if (typeof (Event) === 'function') {
        changeEvt = new Event('change');
    }
    else {
        changeEvt = document.createEvent('Event');
        changeEvt.initEvent('change', true, true);
    }
    return changeEvt;
};
// override summernote methods
const origFn = $.summernote.ui.button.bind($.summernote);
$.summernote.ui.button = (...args) => {
    const retVal = origFn(...args);
    const origCallback = retVal.callback;
    retVal.callback = ($node, options) => {
        // add bs3 btn class to the buttons
        $node.addClass('btn');
        return origCallback($node, options);
    };
    return retVal;
};
//
class RichTextEditorComponent extends BaseFormCustomComponent {
    constructor(inj, domSanitizer, ngZone) {
        super(inj, WIDGET_INFO$6);
        this.domSanitizer = domSanitizer;
        this.ngZone = ngZone;
        this._operationStack = [];
        this.isEditorLoaded = false;
        this.EDITOR_DEFAULT_OPTIONS = {
            toolbar: [
                // [groupName, [list of button]]
                ['misc', ['undo', 'redo']],
                ['style', ['style']],
                ['fontname', ['fontname']],
                ['fontsize', ['fontsize']],
                ['height', ['height']],
                ['style', ['bold', 'italic', 'underline', 'clear']],
                ['font', ['strikethrough', 'superscript', 'subscript']],
                ['color', ['color']],
                ['insert', ['table', 'picture', 'link', 'video', 'hr']],
                ['para', ['ul', 'ol', 'paragraph']],
                ['misc', ['codeview', 'fullscreen', 'help']]
            ],
            callbacks: {
                onInit: () => {
                    this.isEditorLoaded = true;
                    if (this._operationStack.length) {
                        this._operationStack.forEach(operationParam => {
                            const key = Array.from(operationParam.keys())[0], val = operationParam.get(key);
                            this.performEditorOperation(key, val);
                        });
                        this._operationStack = [];
                    }
                },
                onChange: (contents, editable) => {
                    this.proxyModel = this.domSanitizer.sanitize(SecurityContext.HTML, contents.toString());
                    this.invokeOnChange(contents, getChangeEvt(), true);
                    this.invokeOnTouched();
                }
            },
            fontNames: ['Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Merriweather'],
            placeholder: '',
            height: 100,
            disableResizeEditor: true
        };
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER, ['height']);
    }
    get htmlcontent() {
        return this.performEditorOperation('code');
    }
    get datavalue() {
        return this.htmlcontent;
    }
    set datavalue(nv) {
        if (nv !== undefined && nv !== null) {
            this.$hiddenInputEle.val(nv);
            this.performEditorOperation('reset');
            this.performEditorOperation('insertText', nv);
        }
    }
    ngOnInit() {
        this.$richTextEditor = $(this.nativeElement.querySelector('[richTextEditor]'));
        this.$hiddenInputEle = $(this.nativeElement.querySelector('input.model-holder'));
        super.ngOnInit();
        this.initEditor();
    }
    initEditor() {
        this.ngZone.runOutsideAngular(() => {
            this.$richTextEditor.summernote(this.EDITOR_DEFAULT_OPTIONS);
        });
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'placeholder') {
            this.EDITOR_DEFAULT_OPTIONS.placeholder = nv;
            this.performEditorOperation({
                placeholder: nv
            });
        }
        else if (key === 'disabled' || key === 'readonly') {
            this.performEditorOperation(nv ? 'disable' : 'enable');
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    onStyleChange(key, nv, ov) {
        if (key === 'height') {
            this.EDITOR_DEFAULT_OPTIONS.height = nv;
            this.performEditorOperation({
                height: nv
            });
        }
    }
    performEditorOperation(key, value) {
        if (this.isEditorLoaded) {
            return this.$richTextEditor.summernote(key, value);
        }
        else {
            const op = new Map();
            op.set(key, value);
            this._operationStack.push(op);
            return;
        }
    }
    getCurrentPosition() {
        return this.performEditorOperation('createRange');
    }
    undo() {
        this.performEditorOperation('undo');
    }
    focus() {
        this.performEditorOperation('focus');
    }
    ngOnDestroy() {
        this.performEditorOperation('destroy');
        super.ngOnDestroy();
    }
}
RichTextEditorComponent.initializeProps = registerProps$H();
RichTextEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmRichTextEditor]',
                template: "<div richTextEditor></div>\n<div [innerHTML]=\"proxyModel\" class=\"ta-preview\" *ngIf=\"showpreview\"></div>\n<input class=\"model-holder\" [disabled]=\"disabled\" hidden>\n",
                providers: [
                    provideAsNgValueAccessor(RichTextEditorComponent),
                    provideAsWidgetRef(RichTextEditorComponent)
                ]
            }] }
];
/** @nocollapse */
RichTextEditorComponent.ctorParameters = () => [
    { type: Injector },
    { type: DomSanitizer },
    { type: NgZone }
];

const registerProps$19 = () => {
    register('wm-right-panel', new Map([
        ['class', PROP_STRING],
        ['columnwidth', PROP_NUMBER],
        ['content', PROP_STRING],
        ['name', PROP_STRING]
    ]));
};

const DEFAULT_CLS$O = 'app-right-panel';
const WIDGET_CONFIG$W = {
    widgetType: 'wm-right-panel',
    hostClass: DEFAULT_CLS$O
};
class RightPanelDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$W);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'columnwidth') {
            switchClass(this.nativeElement, `col-sm-${nv}`, ov ? ` col-sm-${ov}` : '');
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
RightPanelDirective.initializeProps = registerProps$19();
RightPanelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmRightPanel]',
                providers: [
                    provideAsWidgetRef(RightPanelDirective)
                ]
            },] }
];
/** @nocollapse */
RightPanelDirective.ctorParameters = () => [
    { type: Injector }
];

class ScrollableDirective {
    constructor(inj, searchRef) {
        this.searchRef = searchRef;
        this.elementRef = inj.get(ElementRef);
    }
    ngAfterContentInit() {
        // add the scroll event listener on the ul element.
        this.elementRef.nativeElement.addEventListener('scroll', this.notifyParent.bind(this));
        this.searchRef.dropdownEl = $(this.elementRef.nativeElement);
        this.searchRef.onDropdownOpen();
    }
    ngAfterViewInit() {
        // assigning width for the dropdown.
        const typeAheadInput = this.searchRef.$element.find('input:first');
        this.searchRef.dropdownEl.width(typeAheadInput.outerWidth());
    }
    notifyParent(evt) {
        this.searchRef.onScroll(this.elementRef.nativeElement, evt);
    }
}
ScrollableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[scrollable]'
            },] }
];
/** @nocollapse */
ScrollableDirective.ctorParameters = () => [
    { type: Injector },
    { type: SearchComponent }
];

const WIDGET_CONFIG$X = { widgetType: 'wm-select', hostClass: 'app-select-wrapper' };
class SelectComponent extends DatasetAwareFormComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$X);
        this.acceptsArray = true;
    }
    set datasource(ds) {
        if (ds && ds.execute && ds.execute(DataSource.Operation.IS_BOUND_TO_LOCALE)) {
            this.datavalue = ds.execute(DataSource.Operation.GET_DEFAULT_LOCALE);
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.selectEl.nativeElement, this);
    }
    // Change event is registered from the template, Prevent the framework from registering one more event
    handleEvent(node, eventName, eventCallback, locals) {
        if (!_.includes(['blur', 'change'], eventName)) {
            super.handleEvent(this.selectEl.nativeElement, eventName, eventCallback, locals);
        }
    }
    onSelectValueChange($event) {
        if (this.readonly) {
            if (this.placeholder) {
                this.selectEl.nativeElement.value = this.placeholder;
            }
            else {
                this.selectEl.nativeElement.value = '';
            }
            this.datavalue = this.prevDatavalue;
            return;
        }
        this.invokeOnTouched();
        // invoke on datavalue change.
        this.invokeOnChange(this.datavalue, $event || {}, true);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'class' || key === 'tabindex') {
            return;
        }
        else if (key === 'readonly') {
            (nv === true) ? setAttr(this.selectEl.nativeElement, 'readonly', 'readonly') : removeAttr(this.selectEl.nativeElement, 'readonly');
        }
        super.onPropertyChange(key, nv, ov);
    }
}
SelectComponent.initializeProps = registerProps$I();
SelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'wm-select',
                template: "<select role=\"input\" aria-haspopup=\"true\" aria-expanded=\"false\" #select\n        focus-target\n        [ngClass]=\"['app-select form-control', class]\"\n        [disabled]=\"disabled\"\n        [required]=\"required\"\n        [tabindex]=\"tabindex\"\n        [(ngModel)]=\"modelByKey\"\n        [multiple]=\"multiple\"\n        (change)=\"onSelectValueChange($event)\"\n        (blur)=\"invokeOnTouched($event)\"\n        [attr.name]=\"name\"\n        [autofocus]=\"autofocus\"\n>\n  <option selected value=\"undefined\" [textContent]=\"placeholder\" [hidden]=\"!placeholder\" ></option>\n  <option\n          *ngFor=\"let item of datasetItems\"\n          [value]=\"item.key\" [selected]=\"item.selected\" [textContent]=\"item.label\"></option>\n</select>\n",
                providers: [
                    provideAsNgValueAccessor(SelectComponent),
                    provideAsWidgetRef(SelectComponent)
                ]
            }] }
];
/** @nocollapse */
SelectComponent.ctorParameters = () => [
    { type: Injector }
];
SelectComponent.propDecorators = {
    selectEl: [{ type: ViewChild, args: ['select', { read: ElementRef },] }]
};

class ShowInDeviceDirective {
    constructor(elRef, showInDevice, widget) {
        const displayType = widget.getDisplayType();
        if (showInDevice) {
            showInDevice.split(',').forEach(deviceType => {
                addClass(elRef.nativeElement, `visible-${deviceType}-${displayType}`);
            });
        }
    }
}
ShowInDeviceDirective.decorators = [
    { type: Directive, args: [{
                selector: '[showInDevice]'
            },] }
];
/** @nocollapse */
ShowInDeviceDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: String, decorators: [{ type: Attribute, args: ['showInDevice',] }] },
    { type: BaseComponent, decorators: [{ type: Inject, args: [WidgetRef,] }] }
];

class SmoothScrollDirective {
    constructor(inj, elRef, app) {
        this._isEnabled = false;
        this._lastScrollY = -1;
        this._waitRefreshTill = -1;
        this.pendingIscrolls = [];
        this._$el = $(elRef.nativeElement);
        this.app = app;
    }
    ngOnInit() {
        this.cancelSubscription = this.app.subscribe('no-iscroll', el => {
            this.pendingIscrolls.push(el);
        });
    }
    ngDoCheck() {
        if (this._isEnabled) {
            if (!this._smoothScrollInstance) {
                this._smoothScrollInstance = this.applySmoothScroll();
            }
            else {
                this.refreshIScroll();
            }
        }
        else if (this._smoothScrollInstance && this._smoothScrollInstance.destroy) {
            this._smoothScrollInstance.destroy();
        }
    }
    ngOnDestroy() {
        if (this._smoothScrollInstance && this._smoothScrollInstance.destroy) {
            this._smoothScrollInstance.destroy();
        }
        if (this.cancelSubscription) {
            this.cancelSubscription();
        }
    }
    set wmSmoothscroll(val) {
        this._isEnabled = (val === true || val === 'true');
        if (this._isEnabled) {
            if (!this._smoothScrollInstance) {
                this._smoothScrollInstance = this.applySmoothScroll();
            }
        }
        else {
            this.ngOnDestroy();
        }
    }
    applySmoothScroll($events, activeEl) {
        if (!isMobileApp() || isKitkatDevice()) {
            return null;
        }
        // Set the fadeScrollbars to true only when content is scrollable inside the smoothscroll-container
        const scrollOptions = {
            scrollbars: true,
            preventDefault: false,
            momentum: true,
            bounce: false,
            mouseWheel: true,
            disablePointer: true,
            disableTouch: false,
            disableMouse: false // false to be usable with a mouse (desktop)
        }, el = this._$el[0];
        if (!el.children.length) {
            return null;
        }
        this._$el.addClass('smoothscroll-wrapper');
        if (activeEl && activeEl.tagName === 'INPUT') {
            activeEl.focus();
        }
        // Add fadeScrollbars options only when smoothscroll container is included, which means content is scrollable.
        if ($events) {
            scrollOptions['fadeScrollbars'] = true;
        }
        let iScroll = new IScroll(el, scrollOptions);
        if ($events) {
            // map all events on previous iscroll to the newly created iscroll.
            _.forEach($events, (listeners, key) => {
                _.forEach(listeners, l => {
                    iScroll.on(key, l);
                });
            });
            iScroll.on('scrollStart', function () {
                this._scrolling = true;
            });
            iScroll.on('scrollEnd', function () {
                this._scrolling = false;
            });
            iScroll.refresh();
        }
        // refresh the indicators.
        iScroll.indicatorRefresh = () => {
            const indicators = this._$el[0].iscroll.indicators;
            let i;
            if (indicators.length) {
                for (i = 0; i < indicators.length; i++) {
                    indicators[i].refresh();
                }
            }
        };
        this._$el[0].iscroll = iScroll;
        _.forEach(this.pendingIscrolls, (_el, index) => {
            if (_el.isSameNode(this._$el[0])) {
                this.app.notify('iscroll-update', { el: _el });
                this.pendingIscrolls.splice(index, 1);
                return;
            }
        });
        this.app.notify('iscroll-update', {});
        return {
            iScroll: iScroll,
            destroy: function () {
                iScroll.destroy();
                $(iScroll.scroller).css({
                    'transition-timing-function': '',
                    'transition-duration': '',
                    'transform': ''
                });
                iScroll = null;
                delete el.iscroll;
            }
        };
    }
    /*
     * When element has scroll (i.e. scrollHeight > clientHeight), a div with smoothscroll-container class will be added.
     * new iScroll will be initialised on the element after the div addition, by removing the existing iscroll on the element.
     * This div will have no height, so the elements inside this div will inherit this height, i.e. no height,
     * Scenario: tabs with 100% height, as it covers the pageContent with no scroll, this div will not be added.
     * TODO: Scenario: tabs with 100% height and add others widgets after/before, as it has scroll, this div will be added.
     *          But tabs having 100% height will not be honoured as div is having no height.
     */
    refreshIScroll() {
        const iScroll = this._smoothScrollInstance.iScroll;
        const waitTime = 500;
        if (iScroll._scrolling || this._waitRefreshTill > Date.now()) {
            return;
        }
        // Check for scrollable content and if smoothscroll-container div is already added.
        if (iScroll.wrapper
            && !_.includes(iScroll.wrapper.children[0].classList, 'smoothscroll-container')
            && iScroll.wrapper.scrollHeight > iScroll.wrapper.clientHeight) {
            const cloneEvents = iScroll._events;
            const prevActiveEl = document.activeElement;
            // Adds the smoothscroll container div wrapper only when element has scrollable content.
            $(iScroll.wrapper.children).wrapAll('<div class="smoothscroll-container"></div>');
            this._smoothScrollInstance.destroy();
            // create new iscroll instance on the element
            this._smoothScrollInstance = this.applySmoothScroll(cloneEvents, prevActiveEl);
        }
        if (this._lastScrollY !== this._$el[0].iscroll.maxScrollY) {
            refreshIscrolls(this._smoothScrollInstance.iScroll);
            this._lastScrollY = this._$el[0].iscroll.maxScrollY;
        }
        else {
            this._smoothScrollInstance.iScroll.refresh();
        }
        this._waitRefreshTill = Date.now() + waitTime;
    }
}
SmoothScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmSmoothscroll]'
            },] }
];
/** @nocollapse */
SmoothScrollDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef },
    { type: App }
];
SmoothScrollDirective.propDecorators = {
    wmSmoothscroll: [{ type: Input }]
};
/**
 * Refreshes the given iScorll or all iScrolls in the page.
 * @param iScroll
 */
const refreshIscrolls = function (iScroll) {
    const scrollContainer = !iScroll && $('.smoothscroll-container');
    // Fix for issue: keyboard hides the input on focus.
    // On input focus or window resize, keypad in device has to adjust.
    if (($(document.activeElement).offset().top + document.activeElement.clientHeight) > window.innerHeight * 0.9) {
        document.activeElement.scrollIntoView({ behavior: 'auto', block: 'end', inline: 'end' });
    }
    if (iScroll) {
        // refresh specify iscroll on change.
        if (iScroll.indicatorRefresh) {
            iScroll.indicatorRefresh();
        }
        if (iScroll.refresh) {
            iScroll.refresh();
        }
    }
    else if (scrollContainer.length) {
        // refresh all the iscrolls in pagecontent.
        scrollContainer.parent().each((i, el) => {
            el.iscroll.indicatorRefresh();
            el.iscroll.refresh();
        });
    }
};
// on window resize, recalculate the iscroll position and refresh scrollers.
window.addEventListener('resize', debounce(refreshIscrolls, 200));

const registerProps$1a = () => {
    register('wm-spinner', new Map([
        ['animation', { value: 'spin', PROP_STRING }],
        ['caption', Object.assign({ value: 'Loading...' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['iconclass', Object.assign({ value: 'fa fa-circle-o-notch fa-spin' }, PROP_STRING)],
        ['iconsize', PROP_STRING],
        ['image', PROP_STRING],
        ['imageheight', PROP_STRING],
        ['imagewidth', Object.assign({ value: '20px' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['type', Object.assign({ value: 'icon' }, PROP_STRING)],
        ['servicevariabletotrack', PROP_STRING]
    ]));
};

const DEFAULT_CLS$P = 'app-spinner';
const WIDGET_CONFIG$Y = { widgetType: 'wm-spinner', hostClass: DEFAULT_CLS$P };
class SpinnerComponent extends StylableComponent {
    constructor(inj, imagePipe) {
        super(inj, WIDGET_CONFIG$Y);
        this.imagePipe = imagePipe;
        this.iconclass = '';
        this.animation = '';
        this.showCaption = true;
        styler(this.nativeElement, this);
    }
    get spinnerMessages() {
        return this._spinnerMessages;
    }
    set spinnerMessages(newVal) {
        this.showCaption = _.isEmpty(newVal);
        this._spinnerMessages = newVal;
    }
    listenOnDataSource() {
        const variables = _.split(this.servicevariabletotrack, ',');
        this.getAppInstance().subscribe('toggle-variable-state', data => {
            const name = data.variable.execute(DataSource.Operation.GET_NAME);
            if (_.includes(variables, name) && validateDataSourceCtx(data.variable, this.getViewParent())) {
                this.widget.show = data.active;
            }
        });
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'image') {
            this.picture = this.imagePipe.transform(nv);
        }
        else if (key === 'animation') {
            if (nv === 'spin') {
                this.animation = 'fa-spin';
            }
            else {
                this.animation = nv || '';
            }
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngOnInit() {
        super.ngOnInit();
        // if variables are to be listened to, hide the widget and set the listener
        if (this.servicevariabletotrack) {
            this.widget.show = false;
            this.listenOnDataSource();
        }
    }
}
SpinnerComponent.initializeProps = registerProps$1a();
SpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmSpinner]',
                template: "<div class=\"spinner-message\" aria-label=\"loading gif\">\n    <span class=\"spinner-image animated infinite\" [ngClass]=\"animation\" aria-hidden=\"true\"\n        [ngStyle]=\"{width: imagewidth, height: imageheight, backgroundImage: 'url(' + picture + ')', backgroundSize: imagewidth}\"\n        *ngIf=\"type === 'image'\"></span>\n    <i class=\"spinner-image animated infinite\" [ngClass]=\"[iconclass, animation]\" [style.fonSize]=\"iconsize\" *ngIf=\"type === 'icon'\"></i>\n    <span class=\"spinner-text\" [innerHTML]=\"caption | trustAs: 'html'\" *ngIf=\"showCaption\"></span>\n    <div class=\"spinner-messages\" *ngIf=\"!showCaption && spinnerMessages\">\n        <p *ngFor=\"let value of spinnerMessages\" [textContent]=\"value\"></p>\n    </div>\n</div>",
                providers: [
                    provideAsWidgetRef(SpinnerComponent)
                ]
            }] }
];
/** @nocollapse */
SpinnerComponent.ctorParameters = () => [
    { type: Injector },
    { type: ImagePipe }
];

const DEFAULT_CLS$Q = 'app-switch';
const WIDGET_CONFIG$Z = { widgetType: 'wm-switch', hostClass: DEFAULT_CLS$Q };
class SwitchComponent extends DatasetAwareFormComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$Z);
        this.options = [];
        this._debounceSetSelectedValue = debounce((val) => {
            this.setSelectedValue();
            this.updateHighlighter(val);
            // only for default value trigger app digest to apply the selectedItem
            if (val) {
                $appDigest();
            }
        }, 200);
        const datasetSubscription = this.dataset$.subscribe(() => this.updateSwitchOptions());
        this.registerDestroyListener(() => datasetSubscription.unsubscribe());
        const datavalueSubscription = this.datavalue$.subscribe(() => {
            this._debounceSetSelectedValue(true);
        });
        this.registerDestroyListener(() => datavalueSubscription.unsubscribe());
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.nativeElement, this);
    }
    onStyleChange(key, nv, ov) {
        if (key === 'height') {
            setCSS(this.nativeElement, 'overflow', nv ? 'auto' : '');
        }
        else {
            super.onStyleChange(key, nv, ov);
        }
    }
    // This function sets the selectedItem by either using compareby fields or selected flag on datasetItems.
    setSelectedValue() {
        if (isDefined(this.datavalue) || isDefined(this.toBeProcessedDatavalue)) {
            this.selectedItem = _.find(this.datasetItems, { selected: true });
            return;
        }
        // If no value is provided, set first value as default if options are available else set -1 ie no selection
        this.selectOptAtIndex(0);
    }
    // set the css for switch overlay element.
    // set the selected index from the datasetItems and highlight the datavalue on switch.
    updateSwitchOptions() {
        if (this.datasetItems.length) {
            this.btnwidth = (100 / this.datasetItems.length);
            setCSS(this.nativeElement.querySelector('.app-switch-overlay'), 'width', this.btnwidth + '%');
        }
        this._debounceSetSelectedValue(true);
    }
    // This function animates the highlighted span on to the selected value.
    updateHighlighter(skipAnimation) {
        const handler = $(this.nativeElement).find('span.app-switch-overlay');
        this.setSelectedValue();
        let left, index = this.selectedItem ? _.findIndex(this.datasetItems, { key: this.selectedItem.key }) : -1;
        if (index === undefined || index === null) {
            index = -1;
        }
        left = index * this.btnwidth;
        if (skipAnimation) {
            handler.css('left', left + '%');
        }
        else {
            handler.animate({
                left: left + '%'
            }, 300);
        }
    }
    selectOptAtIndex($index) {
        if (!this.datasetItems.length) {
            return;
        }
        const opt = this.datasetItems[$index];
        this._modelByValue = opt.value;
    }
    // Triggered on selected the option from the switch.
    // set the index and highlight the default value. Invoke onchange event handler.
    selectOpt($event, $index, option) {
        this.modelByKey = option.key;
        this.invokeOnTouched();
        $event.preventDefault();
        if (this.disabled) {
            return;
        }
        if (this.selectedItem && $index === _.findIndex(this.datasetItems, { key: this.selectedItem.key })) {
            if (this.datasetItems.length === 2) {
                $index = $index === 1 ? 0 : 1;
            }
            else {
                return;
            }
        }
        this.selectedItem = this.datasetItems[$index];
        this.updateHighlighter();
        // invoke on datavalue change.
        this.invokeOnChange(this.datavalue, $event || {}, true);
        $appDigest();
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'disabled' && !toBoolean(nv)) {
            this.nativeElement.removeAttribute(key);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
SwitchComponent.initializeProps = registerProps$K();
SwitchComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmSwitch]',
                template: "<div role=\"group\" aria-label=\"button switch\" class=\"btn-group btn-group-justified\">\n    <a *ngFor=\"let opt of datasetItems; let $index = index;\"\n       [title]=\"opt.label\" focus-target\n       href=\"javascript:void(0);\"\n       class=\"btn btn-default\"\n       [name]=\"'wm-switch-' + opt.key\"\n       [ngClass]=\"{'selected': opt.selected, 'disabled': disabled}\"\n       (click)=\"selectOpt($event, $index, opt)\"\n    >\n        <i *ngIf=\"opt.dataObject && opt.dataObject[iconclass]\" aria-hidden=\"true\" [ngClass]=\"['app-icon', opt.dataObject[iconclass] || opt['icon']]\"></i>\n        <span class=\"caption\" [textContent]=\"opt[displayfield] || opt.label\"></span>\n    </a>\n</div>\n<span [title]=\"selectedItem ? selectedItem.label : modelByKey\"\n      class=\"btn btn-primary app-switch-overlay switch-handle\">\n    <i *ngIf=\"iconclass\"\n       class=\"app-icon {{(selectedItem && selectedItem.dataObject) && selectedItem.dataObject[iconclass]}}\"></i>\n    {{selectedItem ? selectedItem.label : modelByKey}}\n</span>\n<input [name]=\"name\" class=\"model-holder ng-hide\" [disabled]=\"disabled\" [value]=\"modelByKey\" [required]=\"required\">\n",
                providers: [
                    provideAsNgValueAccessor(SwitchComponent),
                    provideAsWidgetRef(SwitchComponent)
                ]
            }] }
];
/** @nocollapse */
SwitchComponent.ctorParameters = () => [
    { type: Injector }
];

const registerProps$1b = () => {
    register('wm-table-action', new Map([
        ['accessroles', PROP_STRING],
        ['action', PROP_STRING],
        ['caption', PROP_STRING],
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['disabled', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['display-name', PROP_STRING],
        ['hyperlink', PROP_STRING],
        ['icon', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['key', PROP_STRING],
        ['position', Object.assign({ value: 'footer' }, PROP_STRING)],
        ['shortcutkey', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['title', PROP_STRING],
        ['target', PROP_STRING],
        ['widget-type', Object.assign({ value: 'button' }, PROP_STRING)]
    ]));
};

const WIDGET_CONFIG$_ = { widgetType: 'wm-table-action', hostClass: '' };
class TableActionDirective extends BaseComponent {
    constructor(inj, table) {
        super(inj, WIDGET_CONFIG$_);
        this.table = table;
    }
    populateAction() {
        this.buttonDef = {
            key: this.key,
            displayName: this['display-name'] || this.caption || '',
            show: this.show,
            class: this.class || '',
            iconclass: this.iconclass || '',
            title: _.isUndefined(this.title) ? (this['display-name'] || '') : this.title,
            action: this.action,
            accessroles: this.accessroles,
            shortcutkey: this.shortcutkey,
            disabled: this.disabled,
            tabindex: this.tabindex,
            icon: this.icon,
            position: this.position,
            widgetType: this['widget-type'],
            hyperlink: this.hyperlink,
            target: this.target,
            conditionalclass: this.conditionalclass || '',
            conditionalstyle: this.conditionalstyle || {}
        };
        this._propsInitialized = true;
    }
    ngOnInit() {
        super.ngOnInit();
        this.populateAction();
        this.table.registerActions(this.buttonDef);
    }
    onPropertyChange(key, nv) {
        if (!this._propsInitialized) {
            return;
        }
        if (key === 'display-name') {
            this.buttonDef.displayName = nv;
        }
        else {
            this.buttonDef[key] = nv;
        }
    }
}
TableActionDirective.initializeProps = registerProps$1b();
TableActionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTableAction]',
                providers: [
                    provideAsWidgetRef(TableActionDirective)
                ]
            },] }
];
/** @nocollapse */
TableActionDirective.ctorParameters = () => [
    { type: Injector },
    { type: TableComponent, decorators: [{ type: Optional }] }
];

const registerProps$1c = () => {
    register('wm-table-column', new Map([
        ['accessroles', PROP_STRING],
        ['backgroundcolor', PROP_STRING],
        ['binding', PROP_STRING],
        ['caption', PROP_STRING],
        ['checkedvalue', PROP_STRING],
        ['col-class', PROP_STRING],
        ['col-ng-class', PROP_STRING],
        ['currencypattern', PROP_STRING],
        ['customExpression', PROP_BOOLEAN],
        ['datafield', PROP_STRING],
        ['dataoptions', PROP_ANY],
        ['dataset', PROP_ANY],
        ['datasource', PROP_STRING],
        ['datepattern', PROP_STRING],
        ['debouncetime', Object.assign({ value: 250 }, PROP_NUMBER)],
        ['defaultvalue', PROP_STRING],
        ['disabled', PROP_BOOLEAN],
        ['displayfield', PROP_STRING],
        ['displaylabel', PROP_STRING],
        ['editdatepattern', PROP_STRING],
        ['edit-widget-type', PROP_STRING],
        ['editinputtype', PROP_STRING],
        ['exportexpression', PROP_STRING],
        ['filterdataset', PROP_STRING],
        ['filterdatafield', PROP_STRING],
        ['filterdisplayfield', PROP_STRING],
        ['filterdisplaylabel', PROP_STRING],
        ['filterexpressions', Object.assign({ value: '{}' }, PROP_STRING)],
        ['filtersearchkey', PROP_STRING],
        ['filter-on', PROP_STRING],
        ['filteronfilter', PROP_STRING],
        ['filterplaceholder', PROP_STRING],
        ['filterwidget', PROP_STRING],
        ['filterinputtype', PROP_STRING],
        ['formatpattern', PROP_STRING],
        ['fractionsize', PROP_STRING],
        ['generator', PROP_STRING],
        ['limit', PROP_NUMBER],
        ['matchmode', PROP_STRING],
        ['maxchars', PROP_NUMBER],
        ['maxvalue', PROP_NUMBER],
        ['mobiledisplay', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['minvalue', PROP_NUMBER],
        ['pcdisplay', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['period', PROP_BOOLEAN],
        ['placeholder', PROP_STRING],
        ['prefix', PROP_STRING],
        ['primary-key', PROP_BOOLEAN],
        ['readonly', PROP_BOOLEAN],
        ['regexp', PROP_ANY],
        ['related-entity-name', PROP_STRING],
        ['required', PROP_BOOLEAN],
        ['rowactionsposition', PROP_STRING],
        ['searchkey', PROP_STRING],
        ['searchable', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['suffix', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['showdropdownon', Object.assign({ value: 'default' }, PROP_STRING)],
        ['sortable', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['textalignment', Object.assign({ value: 'left' }, PROP_STRING)],
        ['textcolor', PROP_STRING],
        ['type', Object.assign({ value: 'string' }, PROP_STRING)],
        ['uncheckedvalue', PROP_STRING],
        ['validationmessage', PROP_STRING],
        ['widget-type', PROP_STRING],
        ['width', PROP_STRING],
    ]));
};

const registerProps$1d = () => {
    register('wm-table-column-group', new Map([
        ['backgroundcolor', PROP_STRING],
        ['caption', PROP_STRING],
        ['col-class', PROP_STRING],
        ['name', PROP_STRING],
        ['textalignment', Object.assign({ value: 'center' }, PROP_STRING)]
    ]));
};

const WIDGET_CONFIG$10 = { widgetType: 'wm-table-column-group', hostClass: '' };
class TableColumnGroupDirective extends BaseComponent {
    constructor(inj, group, table) {
        super(inj, WIDGET_CONFIG$10);
        this.group = group;
        this.table = table;
        this.config = {};
    }
    populateConfig() {
        this.config = {
            field: this.name,
            displayName: this.caption || '',
            columns: [],
            isGroup: true,
            accessroles: this.accessroles,
            textAlignment: this.textalignment || 'center',
            backgroundColor: this.backgroundcolor,
            class: this['col-class']
        };
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'caption') {
            this.config.displayName = nv || '';
            this.table.callDataGridMethod('setColumnProp', this.config.field, 'displayName', nv, true);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngOnInit() {
        super.ngOnInit();
        this.populateConfig();
        setHeaderConfigForTable(this.table.headerConfig, this.config, this.group && this.group.name);
    }
}
TableColumnGroupDirective.initializeProps = registerProps$1d();
TableColumnGroupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTableColumnGroup]',
                providers: [
                    provideAsWidgetRef(TableColumnGroupDirective)
                ]
            },] }
];
/** @nocollapse */
TableColumnGroupDirective.ctorParameters = () => [
    { type: Injector },
    { type: TableColumnGroupDirective, decorators: [{ type: SkipSelf }, { type: Optional }] },
    { type: TableComponent, decorators: [{ type: Optional }] }
];

const WIDGET_CONFIG$11 = { widgetType: 'wm-table-column', hostClass: '' };
let inlineWidgetProps = ['datafield', 'displayfield', 'placeholder', 'searchkey', 'matchmode', 'displaylabel',
    'checkedvalue', 'uncheckedvalue', 'showdropdownon', 'dataset'];
const validationProps = ['maxchars', 'regexp', 'minvalue', 'maxvalue', 'required'];
inlineWidgetProps = [...inlineWidgetProps, ...validationProps];
class FieldDef {
    constructor(widget) {
        this.widget = widget;
    }
    focus() {
        this.widget.focus();
    }
    setProperty(prop, newval) {
        // Get the scope of the current editable widget and set the value
        prop = prop === 'value' ? 'datavalue' : prop;
        this.widget[prop] = newval;
    }
    getProperty(prop) {
        prop = prop === 'value' ? 'datavalue' : prop;
        return this.widget[prop];
    }
}
class TableColumnDirective extends BaseComponent {
    constructor(inj, appDefaults, table, group, bindfilterdataset, binddataset) {
        super(inj, WIDGET_CONFIG$11);
        this.appDefaults = appDefaults;
        this.table = table;
        this.group = group;
        this.bindfilterdataset = bindfilterdataset;
        this.binddataset = binddataset;
        this._debounceSetUpValidators = debounce(this.setUpValidators.bind(this, 'inlineInstance'), 250);
        this._debounceSetUpValidatorsNew = debounce(this.setUpValidators.bind(this, 'inlineInstanceNew'), 250);
    }
    get dataoptions() {
        return this._dataoptions;
    }
    set dataoptions(options) {
        this._dataoptions = options;
    }
    get datasource() {
        return this._datasource;
    }
    set datasource(ds) {
        this._datasource = ds;
    }
    ngOnInit() {
        super.ngOnInit();
        // Set the default values and register with table
        this.populateFieldDef();
        // Register column with header config to create group structure
        setHeaderConfigForTable(this.table.headerConfig, {
            field: this.field,
            displayName: this.displayName
        }, this.group && this.group.name);
        this.table.registerColumns(this.widget);
        this._isRowFilter = this.table.filtermode === 'multicolumn' && this.searchable;
        this._isInlineEditable = !this.readonly && (this.table.editmode !== EDIT_MODE.DIALOG && this.table.editmode !== EDIT_MODE.FORM);
        this._isNewEditableRow = this._isInlineEditable && this.table.editmode === EDIT_MODE.QUICK_EDIT && this.table.shownewrow;
        this.setUpControls();
        this._propsInitialized = true;
    }
    ngAfterContentInit() {
        if (this._isRowFilter) {
            // Listen on the inner row filter widget and setup the widget
            const s1 = this._filterInstances.changes.subscribe((val) => {
                this.filterInstance = val.first && val.first.widget;
                this.setUpFilterWidget();
            });
            this.registerDestroyListener(() => s1.unsubscribe());
        }
        if (this._isInlineEditable) {
            const s2 = this._inlineInstances.changes.subscribe((val) => {
                // Listen on the inner inline widget and setup the widget
                this.inlineInstance = val.first && val.first.widget;
                this.table.registerFormField(this.binding, new FieldDef(this.inlineInstance));
                this.setUpInlineWidget('inlineInstance');
            });
            this.registerDestroyListener(() => s2.unsubscribe());
            if (this._isNewEditableRow) {
                const s3 = this._inlineInstancesNew.changes.subscribe((val) => {
                    // Listen on the inner inline widget and setup the widget
                    this.inlineInstanceNew = val.first && val.first.widget;
                    this.setUpInlineWidget('inlineInstanceNew');
                });
                this.registerDestroyListener(() => s3.unsubscribe());
            }
        }
        super.ngAfterContentInit();
    }
    ngAfterViewInit() {
        // manually listing the table column templateRef as templateRef will not be available prior.
        if (this.filterTemplateRef) {
            this.table.renderDynamicFilterColumn(this.filterTemplateRef);
        }
    }
    addFormControl(suffix) {
        const ctrlName = suffix ? (this.binding + suffix) : this.binding;
        this.table.ngform.addControl(ctrlName, this.table.fb.control(''));
    }
    getFormControl(suffix) {
        const ctrlName = suffix ? (this.binding + suffix) : this.binding;
        return this.table.ngform.controls[ctrlName];
    }
    // Setup the inline edit and filter widget
    setUpControls() {
        if (this._isInlineEditable) {
            if (this.editWidgetType === FormWidgetType.UPLOAD) {
                return;
            }
            this.addFormControl();
            const control = this.getFormControl();
            if (control) {
                const onValueChangeSubscription = control.valueChanges.subscribe(this.onValueChange.bind(this));
                this.registerDestroyListener(() => onValueChangeSubscription.unsubscribe());
            }
            if (this._isNewEditableRow) {
                this.addFormControl('_new');
                const newControl = this.getFormControl('_new');
                if (newControl) {
                    const onNewValueChangeSubscription = newControl.valueChanges.subscribe(this.onValueChange.bind(this));
                    this.registerDestroyListener(() => onNewValueChangeSubscription.unsubscribe());
                }
            }
        }
        if (this._isRowFilter) {
            this.addFormControl('_filter');
            this.filterControl = this.getFormControl('_filter');
            if (this.filterControl) {
                const onFilterValueSubscription = this.filterControl.valueChanges.subscribe(this.onFilterValueChange.bind(this));
                this.registerDestroyListener(() => onFilterValueSubscription.unsubscribe());
            }
        }
    }
    // Reset the row filter value
    resetFilter() {
        if (this.filterControl) {
            this.filterControl.setValue('');
        }
        if (this.filterwidget === FormWidgetType.AUTOCOMPLETE) {
            this.filterInstance.query = '';
            this.filterInstance.queryModel = '';
        }
    }
    // On field value change, propagate event to parent form
    onFilterValueChange(val) {
        this.table.rowFilter[this.field].value = val;
    }
    // On field value change, apply cascading filter
    onValueChange(val) {
        if (val !== null) {
            applyFilterOnField(this.table.datasource, this.widget, this.table.fieldDefs, val, {
                widget: 'edit-widget-type'
            });
        }
    }
    loadFilterData() {
        // If filterdataset is not bound, get the data implicitly
        if (this._isRowFilter && isDataSetWidget(this.filterwidget) && !this.bindfilterdataset) {
            // For live variable, get the data using distinct API
            if (this.table.datasource.execute(DataSource.Operation.SUPPORTS_DISTINCT_API)) {
                // check for related entity columns
                if (this.relatedEntityName) {
                    this.widget['is-related'] = true;
                    this.widget['lookup-type'] = this.relatedEntityName;
                    this.widget['lookup-field'] = _.last(_.split(this.field, '.'));
                }
                if (this.filterwidget === FormWidgetType.AUTOCOMPLETE) {
                    this.filterInstance.dataoptions = getDistinctFieldProperties(this.table.datasource, this);
                    this.filterInstance.datasource = this.table.datasource;
                }
                else {
                    getDistinctValues(this.table.datasource, this.widget, 'filterwidget').then((res) => {
                        this._filterDataSet = res.data;
                        this.setFilterWidgetDataSet();
                    });
                }
            }
            else {
                // For other datasources, get the data from datasource bound to table
                this.registerDestroyListener($watch(this.table.binddataset, this.viewParent, {}, nv => this.widget.filterdataset = nv, getWatchIdentifier(this.widgetId, 'filterdataset')));
            }
        }
    }
    loadInlineWidgetData() {
        // If dataset is not bound, get the data implicitly
        if (isDataSetWidget(this['edit-widget-type']) && !this.binddataset && !this.readonly) {
            const dataSource = this.table.datasource;
            if (this['related-entity-name'] && this['primary-key']) {
                // Fetch the data for the related fields
                this.isDataSetBound = true;
                const bindings = _.split(this.binding, '.');
                fetchRelatedFieldData(dataSource, this.widget, {
                    relatedField: _.head(bindings),
                    datafield: _.last(bindings),
                    widget: 'edit-widget-type'
                });
            }
            else if (dataSource.execute(DataSource.Operation.SUPPORTS_DISTINCT_API)) {
                getDistinctValuesForField(dataSource, this.widget, {
                    widget: 'edit-widget-type'
                });
            }
        }
    }
    // On table datasource change, get the data for row filters
    onDataSourceChange() {
        this.loadFilterData();
        this.loadInlineWidgetData();
    }
    // Set the data on the row filter widget
    setFilterWidgetDataSet() {
        if (this.filterInstance) {
            this.filterInstance.dataset = this._filterDataSet;
        }
    }
    // Set the props on the row filter widget
    setUpFilterWidget() {
        this.filterInstance.registerReadyStateListener(() => {
            if (isDataSetWidget(this.filterwidget)) {
                // if binding is department.deptId then field will be deptId
                const field = _.last(this.binding.split('.'));
                this.filterInstance.dataset = this._filterDataSet;
                this.filterInstance.datafield = this.filterdatafield || field;
                this.filterInstance.displayfield = this.filterdisplayfield || field;
                if (this.filterwidget === FormWidgetType.AUTOCOMPLETE) {
                    this.filterInstance.displaylabel = this.filterdisplaylabel || field;
                    this.filterInstance.searchkey = this.filtersearchkey || field;
                }
            }
            if (this.filterwidget === FormWidgetType.TIME) {
                this.filterInstance.timepattern = this.appDefaults.timeFormat || 'hh:mm:ss a';
            }
            this.filterInstance.placeholder = this.filterplaceholder || '';
        });
    }
    // On change of any validation property, set the angular form validators
    setUpValidators(widget) {
        const control = this.getFormControl(widget === 'inlineInstanceNew' ? '_new' : undefined);
        if (!control) {
            return;
        }
        const validators = [];
        if (this.required) {
            // For checkbox/toggle widget, required validation should consider true value only
            if (this.editWidgetType === FormWidgetType.CHECKBOX || this.editWidgetType === FormWidgetType.TOGGLE) {
                validators.push(Validators.requiredTrue);
            }
            else {
                validators.push(Validators.required);
            }
        }
        if (this.maxchars) {
            validators.push(Validators.maxLength(this.maxchars));
        }
        if (this.minvalue) {
            validators.push(Validators.min(this.minvalue));
        }
        if (this.maxvalue) {
            validators.push(Validators.max(this.maxvalue));
        }
        if (this.regexp) {
            validators.push(Validators.pattern(this.regexp));
        }
        if (this[widget] && _.isFunction(this[widget].validate)) {
            validators.push(this[widget].validate.bind(this[widget]));
        }
        control.setValidators(validators);
        control.updateValueAndValidity();
    }
    // Set the props on the inline edit widget
    setInlineWidgetProp(widget, prop, nv) {
        if (prop === 'datepattern' && this.editWidgetType === FormWidgetType.TIME) {
            prop = 'timepattern';
        }
        if (this[widget] && isDefined(nv)) {
            this[widget][prop] = nv;
        }
        if (validationProps.includes(prop)) {
            this._debounceSetUpValidators();
            this._debounceSetUpValidatorsNew();
        }
    }
    // Initialize the inline edit widget
    setUpInlineWidget(widget) {
        this[widget].registerReadyStateListener(() => {
            if (isDataSetWidget(this['edit-widget-type'])) {
                this[widget].dataset = this.dataset;
            }
            inlineWidgetProps.forEach(key => {
                this.setInlineWidgetProp(widget, key, this[key]);
            });
            this[widget].datasource = this._datasource;
            this[widget].dataoptions = this._dataoptions;
            this.setInlineWidgetProp(widget, 'datepattern', this.editdatepattern);
        });
    }
    getStyleDef() {
        return `width: ${this.width || ''}; background-color: ${this.backgroundcolor || ''}; color: ${this.textcolor || ''};`;
    }
    populateFieldDef() {
        this.width = this.width === 'px' ? '' : (this.width || '');
        this.field = this.binding;
        this.displayName = this.caption || '';
        this.pcDisplay = this.pcdisplay;
        this.mobileDisplay = this.mobiledisplay;
        this.textAlignment = this.textalignment;
        this.backgroundColor = this.backgroundcolor;
        this.textColor = this.textcolor;
        this.primaryKey = this['primary-key'];
        this.relatedEntityName = this['related-entity-name'];
        this.style = this.getStyleDef();
        this.class = this['col-class'];
        this.ngclass = this['col-ng-class'];
        this.formatpattern = this.formatpattern === 'toNumber' ? 'numberToString' : this.formatpattern;
        this.searchable = (this.type === 'blob' || this.type === 'clob') ? false : this.searchable;
        this.limit = this.limit ? +this.limit : undefined;
        this.editWidgetType = this['edit-widget-type'] = this['edit-widget-type'] || getEditModeWidget(this);
        this.filterOn = this['filter-on'];
        this.readonly = isDefined(this.getAttr('readonly')) ? this.getAttr('readonly') === 'true' : (this['related-entity-name'] ? !this['primary-key'] : _.includes(['identity', 'uniqueid', 'sequence'], this.generator));
        this.filterwidget = this.filterwidget || getDataTableFilterWidget(this.type || 'string');
        this.isFilterDataSetBound = !!this.bindfilterdataset;
        this.defaultvalue = getDefaultValue(this.defaultvalue, this.type, this.editWidgetType);
        // For date time data types, if date pattern is not specified, set the app format or default format
        if (isDateTimeType(this.type) && this.formatpattern === 'toDate' && !this.datepattern) {
            const defaultFormat = getDisplayDateTimeFormat(this.type);
            if (this.type === DataType.DATE) {
                this.datepattern = this.appDefaults.dateFormat || defaultFormat;
            }
            else if (this.type === DataType.TIME) {
                this.datepattern = this.appDefaults.timeFormat || defaultFormat;
            }
            else if (this.type === DataType.TIMESTAMP || this.type === DataType.DATETIME) {
                this.datepattern = this.appDefaults.dateTimeFormat || defaultFormat;
            }
        }
    }
    onPropertyChange(key, nv, ov) {
        if (!this._propsInitialized) {
            return;
        }
        switch (key) {
            case 'caption':
                this.displayName = nv || '';
                this.setProperty('displayName', this.displayName);
                break;
            case 'defaultvalue':
                this.defaultvalue = getDefaultValue(this.defaultvalue, this.type, this.editWidgetType);
                break;
            case 'show':
                this.table.redraw(true);
                break;
            case 'filterdataset':
                this._filterDataSet = nv;
                this.setFilterWidgetDataSet();
                break;
            case 'editdatepattern':
                this.setInlineWidgetProp('inlineInstance', 'datepattern', nv);
                this.setInlineWidgetProp('inlineInstanceNew', 'datepattern', nv);
                break;
            default:
                if (inlineWidgetProps.includes(key)) {
                    this.setInlineWidgetProp('inlineInstance', key, nv);
                    this.setInlineWidgetProp('inlineInstanceNew', key, nv);
                }
                break;
        }
        super.onPropertyChange(key, nv, ov);
    }
    setProperty(property, nv) {
        this[property] = nv;
        switch (property) {
            case 'displayName':
                this.table.callDataGridMethod('setColumnProp', this.field, property, nv);
                break;
            default:
                this.table.redraw(true);
        }
    }
}
TableColumnDirective.initializeProps = registerProps$1c();
TableColumnDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTableColumn]',
                providers: [
                    provideAsWidgetRef(TableColumnDirective)
                ]
            },] }
];
/** @nocollapse */
TableColumnDirective.ctorParameters = () => [
    { type: Injector },
    { type: AppDefaults },
    { type: TableComponent, decorators: [{ type: Optional }] },
    { type: TableColumnGroupDirective, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['filterdataset.bind',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['dataset.bind',] }] }
];
TableColumnDirective.propDecorators = {
    _filterInstances: [{ type: ContentChildren, args: ['filterWidget',] }],
    _inlineInstances: [{ type: ContentChildren, args: ['inlineWidget',] }],
    _inlineInstancesNew: [{ type: ContentChildren, args: ['inlineWidgetNew',] }],
    customExprTmpl: [{ type: ContentChild, args: ['customExprTmpl',] }],
    filterTemplateRef: [{ type: ContentChild, args: ['filterTmpl',] }]
};

const OPERATION = {
    'NEW': 'new',
    'EDIT': 'edit',
    'DELETE': 'delete'
};
class TableCUDDirective {
    constructor(table, dialogService, app) {
        this.table = table;
        this.dialogService = dialogService;
        this.app = app;
        table.initiateSelectItem = this.initiateSelectItem.bind(this);
        table.updateVariable = this.updateVariable.bind(this);
        table.updateRecord = this.updateRecord.bind(this);
        table.deleteRecord = this.deleteRecord.bind(this);
        table.insertRecord = this.insertRecord.bind(this);
        table.editRow = this.editRow.bind(this);
        table.addNewRow = this.addNewRow.bind(this);
        table.addRow = this.addNewRow.bind(this);
        table.deleteRow = this.deleteRow.bind(this);
        table.onRecordDelete = this.onRecordDelete.bind(this);
        table.hideEditRow = this.hideEditRow.bind(this);
        table.saveRow = this.saveRow.bind(this);
        table.cancelRow = this.cancelRow.bind(this);
    }
    selectItemOnSuccess(row, skipSelectItem, callBack) {
        /*$timeout is used so that by then $is.dataset has the updated value.
         * Selection of the item is done in the callback of page navigation so that the item that needs to be selected actually exists in the grid.*/
        /*Do not select the item if skip selection item is specified*/
        setTimeout(() => {
            if (!skipSelectItem) {
                this.table.selectItem(row, this.table.dataset);
            }
            triggerFn(callBack);
        }, 250);
    }
    initiateSelectItem(index, row, skipSelectItem, isStaticVariable, callBack) {
        /*index === "last" indicates that an insert operation has been successfully performed and navigation to the last page is required.
         * Hence increment the "dataSize" by 1.*/
        if (index === 'last') {
            if (!isStaticVariable) {
                this.table.dataNavigator.dataSize += 1;
            }
            /*Update the data in the current page in the grid after insert/update operations.*/
            if (!this.table.isNavigationEnabled()) {
                index = 'current';
            }
        }
        /*Re-calculate the paging values like pageCount etc that could change due to change in the dataSize.*/
        this.table.dataNavigator.calculatePagingValues();
        this.table.dataNavigator.navigatePage(index, null, true, () => {
            if (this.table.isNavigationEnabled() || isStaticVariable) {
                this.selectItemOnSuccess(row, skipSelectItem, callBack);
            }
        });
    }
    updateVariable(row, callBack) {
        const dataSource = this.table.datasource;
        if (!dataSource) {
            return;
        }
        dataSource.execute(DataSource.Operation.FETCH_DISTINCT_VALUES);
        if (!this.table.isNavigationEnabled()) {
            const sortInfo = this.table.sortInfo;
            const sortOptions = sortInfo && sortInfo.direction ? (sortInfo.field + ' ' + sortInfo.direction) : '';
            refreshDataSource(dataSource, {
                page: 1,
                filterFields: this.table.getFilterFields(this.table.filterInfo),
                orderBy: sortOptions,
                matchMode: 'anywhereignorecase'
            }).then(() => {
                $appDigest();
                this.selectItemOnSuccess(row, true, callBack);
            });
        }
    }
    insertSuccessHandler(response, options) {
        /*Display appropriate error message in case of error.*/
        if (response.error) {
            this.table.invokeEventCallback('error', { $event: options.event, $operation: OPERATION.NEW, $data: response.error });
            this.table.toggleMessage(true, 'error', this.table.errormessage || response.error);
            triggerFn(options.error, response);
        }
        else {
            if (options.event) {
                const row = $(options.event.target).closest('tr');
                this.table.callDataGridMethod('hideRowEditMode', row);
            }
            this.table.toggleMessage(true, 'success', this.table.insertmessage);
            if (this.table.datasource.execute(DataSource.Operation.SUPPORTS_CRUD)) {
                this.table.initiateSelectItem(this.table.getNavigationTargetBySortInfo(), response, undefined, false, options.callBack);
                this.updateVariable(response, options.callBack);
            }
            else if (!this.table.datasource.execute(DataSource.Operation.IS_API_AWARE)) {
                this.table.initiateSelectItem(this.table.getNavigationTargetBySortInfo(), response, undefined, false, options.callBack);
            }
            triggerFn(options.success, response);
            this.table.invokeEventCallback('rowinsert', { $event: options.event, $data: response, row: response });
        }
    }
    insertRecord(options) {
        const dataSource = this.table.datasource;
        if (!dataSource) {
            return;
        }
        const dataObject = {
            row: options.row,
            skipNotification: true,
            period: options.period
        };
        if (dataSource.execute(DataSource.Operation.SUPPORTS_CRUD) || !dataSource.execute(DataSource.Operation.IS_API_AWARE)) {
            if (!dataSource.execute(DataSource.Operation.IS_API_AWARE)) {
                dataSource.execute(DataSource.Operation.ADD_ITEM, { item: options.row });
                this.insertSuccessHandler(options.row, options);
                return;
            }
            dataSource.execute(DataSource.Operation.INSERT_RECORD, dataObject).then(response => {
                this.insertSuccessHandler(response, options);
            }, error => {
                this.table.invokeEventCallback('error', { $event: options.event, $operation: OPERATION.NEW, $data: error });
                this.table.toggleMessage(true, 'error', this.table.errormessage || error);
                triggerFn(options.error, error);
                triggerFn(options.callBack, undefined, true);
            });
        }
        else {
            this.table.invokeEventCallback('rowinsert', { $event: options.event, row: options.row });
        }
    }
    updateSuccessHandler(response, options) {
        /*Display appropriate error message in case of error.*/
        if (response.error) {
            this.table.invokeEventCallback('error', { $event: options.event, $operation: OPERATION.EDIT, $data: response.error });
            /*disable readonly and show the appropriate error*/
            this.table.toggleMessage(true, 'error', this.table.errormessage || response.error);
            triggerFn(options.error, response);
        }
        else {
            if (options.event) {
                const row = $(options.event.target).closest('tr');
                this.table.callDataGridMethod('hideRowEditMode', row);
            }
            this.table.toggleMessage(true, 'success', this.table.updatemessage);
            if (this.table.datasource.execute(DataSource.Operation.SUPPORTS_CRUD)) {
                this.table.initiateSelectItem('current', response, undefined, false, options.callBack);
                this.updateVariable(response, options.callBack);
            }
            triggerFn(options.success, response);
            this.table.invokeEventCallback('rowupdate', { $event: options.event, $data: response, row: response });
        }
    }
    updateRecord(options) {
        const dataSource = this.table.datasource;
        if (!dataSource) {
            return;
        }
        const dataObject = {
            row: options.row,
            prevData: options.prevData,
            skipNotification: true,
            period: options.period
        };
        if (dataSource.execute(DataSource.Operation.SUPPORTS_CRUD) || !dataSource.execute(DataSource.Operation.IS_API_AWARE)) {
            if (!dataSource.execute(DataSource.Operation.IS_API_AWARE)) {
                dataSource.execute(DataSource.Operation.SET_ITEM, { prevItem: options.prevData, item: options.row });
                this.updateSuccessHandler(options.row, options);
                return;
            }
            dataSource.execute(DataSource.Operation.UPDATE_RECORD, dataObject).then(response => {
                this.updateSuccessHandler(response, options);
            }, error => {
                this.table.invokeEventCallback('error', { $event: options.event, $operation: OPERATION.EDIT, $data: error });
                this.table.toggleMessage(true, 'error', this.table.errormessage || error);
                triggerFn(options.error, error);
                triggerFn(options.callBack, undefined, true);
            });
        }
        else {
            this.table.invokeEventCallback('rowupdate', { $event: options.event, row: options.row });
        }
    }
    onRecordDelete(callBack) {
        let index;
        /*Check for sanity*/
        if (this.table.dataNavigator) {
            this.table.dataNavigator.dataSize -= 1;
            this.table.dataNavigator.calculatePagingValues();
            /*If the current page does not contain any records due to deletion, then navigate to the previous page.*/
            index = this.table.dataNavigator.pageCount < this.table.dataNavigator.dn.currentPage ? 'prev' : undefined;
            this.table.dataNavigator.navigatePage(index, null, true, () => {
                setTimeout(() => {
                    triggerFn(callBack);
                }, undefined, false);
            });
        }
    }
    deleteSuccessHandler(row, response, evt, callBack) {
        /* check the response whether the data successfully deleted or not , if any error occurred show the
         * corresponding error , other wise remove the row from grid */
        if (response && response.error) {
            this.table.toggleMessage(true, 'error', this.table.errormessage || response.error);
            return;
        }
        this.onRecordDelete(callBack);
        if (this.table.datasource.execute(DataSource.Operation.SUPPORTS_CRUD)) {
            this.updateVariable(row, callBack);
        }
        this.table.toggleMessage(true, 'success', this.table.deletemessage);
        // custom EventHandler for row deleted event
        this.table.invokeEventCallback('rowdelete', { $event: evt, $data: row, row });
        this.table.invokeEventCallback('rowdeleted', { $event: evt, $data: row, row });
    }
    deleteFn(options) {
        const dataSource = this.table.datasource;
        if (!dataSource) {
            return;
        }
        if (dataSource.execute(DataSource.Operation.SUPPORTS_CRUD) || !dataSource.execute(DataSource.Operation.IS_API_AWARE)) {
            if (!dataSource.execute(DataSource.Operation.IS_API_AWARE)) {
                dataSource.execute(DataSource.Operation.REMOVE_ITEM, { item: options.row });
                this.deleteSuccessHandler(options.row, undefined, options.evt, options.callBack);
                return;
            }
            dataSource.execute(DataSource.Operation.DELETE_RECORD, {
                row: options.row,
                skipNotification: true,
                period: options.period
            }).then(response => {
                this.deleteSuccessHandler(response, options.row, options.evt, options.callBack);
            }, error => {
                triggerFn(options.callBack, undefined, true);
                this.table.invokeEventCallback('error', { $event: options.evt, $operation: OPERATION.DELETE, $data: error });
                this.table.toggleMessage(true, 'error', this.table.errormessage || error);
            });
        }
        else {
            this.table.invokeEventCallback('rowdelete', { $event: options.evt, row: options.row });
        }
        triggerFn(options.cancelRowDeleteCallback);
    }
    deleteRecord(options) {
        if (!this.table.confirmdelete) {
            this.deleteFn(options);
            triggerFn(options.cancelRowDeleteCallback);
            return;
        }
        this.dialogService.showAppConfirmDialog({
            title: this.app.appLocale.MESSAGE_DELETE_RECORD || 'Delete Record',
            iconclass: 'wi wi-delete fa-lg',
            message: this.table.confirmdelete,
            oktext: this.table.deleteoktext,
            canceltext: this.table.deletecanceltext,
            onOk: () => {
                this.deleteFn(options);
                this.dialogService.closeAppConfirmDialog();
            },
            onCancel: () => {
                triggerFn(options.cancelRowDeleteCallback);
                this.dialogService.closeAppConfirmDialog();
            },
            onOpen: () => {
                // Focus the cancel button on open
                $('.cancel-action').focus();
            }
        });
    }
    editRow(evt) {
        let row;
        if (evt && evt.target) {
            this.table.callDataGridMethod('toggleEditRow', evt, { 'selectRow': true, action: 'edit' });
        }
        else {
            // For live form, call the update function with selected item
            if (this.table.editmode === 'form' || this.table.editmode === 'dialog') {
                row = evt || this.table.selectedItems[0];
                this.table.gridOptions.beforeRowUpdate(row);
            }
            else {
                // Wait for the selected item to get updated
                setTimeout(() => {
                    row = this.table.datagridElement.find('tr.active');
                    if (row.length) {
                        this.table.callDataGridMethod('toggleEditRow', undefined, { $row: row, action: 'edit' });
                    }
                });
            }
        }
    }
    addNewRow() {
        if (!this.table.isGridEditMode) { // If grid is already in edit mode, do not add new row
            this.table.callDataGridMethod('addNewRow');
            if (this.table._liveTableParent) {
                this.table._liveTableParent.addNewRow();
            }
        }
    }
    deleteRow(evt) {
        let row;
        if (evt && evt.target) {
            this.table.callDataGridMethod('deleteRowAndUpdateSelectAll', evt);
        }
        else {
            // Wait for the selected item to get updated
            setTimeout(() => {
                row = evt || this.table.selectedItems[0];
                this.deleteRecord({ row });
            });
        }
    }
    // Function to hide the edited row
    hideEditRow() {
        const $row = this.table.datagridElement.find('tr.row-editing');
        if ($row.length) {
            this.table.callDataGridMethod('hideRowEditMode', $row);
        }
    }
    // Function to save the row
    saveRow() {
        this.table.callDataGridMethod('saveRow');
    }
    // Function to cancel the edit
    cancelRow() {
        const $row = this.table.datagridElement.find('tr.row-editing');
        if ($row.length) {
            this.table.callDataGridMethod('cancelEdit', $row);
        }
    }
}
TableCUDDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTableCUD]'
            },] }
];
/** @nocollapse */
TableCUDDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Self }, { type: Inject, args: [TableComponent,] }] },
    { type: AbstractDialogService },
    { type: App }
];

const emptyMatchModes = ['null', 'empty', 'nullorempty', 'isnotnull', 'isnotempty'];
// Get search value based on the time
const getSearchValue = (value, type) => {
    if (!isDefined(value) || value === '') {
        return undefined;
    }
    if (isNumberType(type)) {
        return _.toNumber(value);
    }
    if (type === DataType.DATETIME) {
        return moment(value).valueOf();
    }
    return _.toString(value).toLowerCase();
};
// Filter the data based on the search value and conditions
const getFilteredData = (data, searchObj) => {
    const searchVal = getSearchValue(searchObj.value, searchObj.type);
    let currentVal;
    if (!isDefined(searchVal) && !_.includes(emptyMatchModes, searchObj.matchMode)) {
        return data;
    }
    data = data.filter((obj) => {
        let isExists;
        if (searchObj.field) {
            currentVal = getSearchValue(_.get(obj, searchObj.field), searchObj.type);
        }
        else {
            currentVal = _.values(obj).join(' ').toLowerCase(); // If field is not there, search on all the columns
        }
        switch (searchObj.matchMode) {
            case 'start':
                isExists = _.startsWith(currentVal, searchVal);
                break;
            case 'end':
                isExists = _.endsWith(currentVal, searchVal);
                break;
            case 'exact':
                isExists = _.isEqual(currentVal, searchVal);
                break;
            case 'notequals':
                isExists = !_.isEqual(currentVal, searchVal);
                break;
            case 'null':
                isExists = _.isNull(currentVal);
                break;
            case 'isnotnull':
                isExists = !_.isNull(currentVal);
                break;
            case 'empty':
                isExists = _.isEmpty(currentVal);
                break;
            case 'isnotempty':
                isExists = !_.isEmpty(currentVal);
                break;
            case 'nullorempty':
                isExists = _.isNull(currentVal) || _.isEmpty(currentVal);
                break;
            case 'lessthan':
                isExists = currentVal < searchVal;
                break;
            case 'lessthanequal':
                isExists = currentVal <= searchVal;
                break;
            case 'greaterthan':
                isExists = currentVal > searchVal;
                break;
            case 'greaterthanequal':
                isExists = currentVal >= searchVal;
                break;
            default:
                isExists = isNumberType(searchObj.type) ? _.isEqual(currentVal, searchVal) : _.includes(currentVal, searchVal);
                break;
        }
        return isExists;
    });
    return data;
};
// Set the filter fields as required by datasource
const setFilterFields = (filterFields, searchObj) => {
    const field = searchObj && searchObj.field;
    /*Set the filter options only when a field/column has been selected.*/
    if (field) {
        filterFields[field] = {
            'value': searchObj.value,
            'logicalOp': 'AND'
        };
        if (searchObj.matchMode) {
            filterFields[field].matchMode = searchObj.matchMode;
        }
    }
};
// Transform filter fields from array to object having field names as keys
const transformFilterField = (userFilters, filterField) => {
    if (filterField.field) {
        userFilters[filterField.field] = {
            value: filterField.value,
            matchMode: filterField.matchMode,
            type: filterField.type
        };
    }
};
class TableFilterSortDirective {
    constructor(table) {
        this.table = table;
        table._searchSortHandler = this.searchSortHandler.bind(this);
        table.getSearchResult = this.getSearchResult.bind(this);
        table.getSortResult = this.getSortResult.bind(this);
        table.checkFiltersApplied = this.checkFiltersApplied.bind(this);
        table.getFilterFields = this.getFilterFields.bind(this);
        table.onRowFilterChange = this.onRowFilterChange.bind(this);
        table.onFilterConditionSelect = this.onFilterConditionSelect.bind(this);
        table.showClearIcon = this.showClearIcon.bind(this);
        table.clearRowFilter = this.clearRowFilter.bind(this);
        table.matchModeTypesMap = getMatchModeTypesMap();
        table.matchModeMsgs = getMatchModeMsgs(table.appLocale);
        table.emptyMatchModes = emptyMatchModes;
        table.getNavigationTargetBySortInfo = this.getNavigationTargetBySortInfo.bind(this);
        table.refreshData = this.refreshData.bind(this);
        table.clearFilter = this.clearFilter.bind(this);
    }
    // Get first or last page based on sort info of primary key
    getNavigationTargetBySortInfo() {
        return this.table.sortInfo && this.table.sortInfo.direction === 'desc' &&
            _.includes(this.table.primaryKey, this.table.sortInfo.field) ? 'first' : 'last';
    }
    // Get the filter fields as required by datasource
    getFilterFields(searchObj) {
        const filterFields = {};
        if (_.isArray(searchObj)) {
            _.forEach(searchObj, obj => {
                setFilterFields(filterFields, obj);
            });
        }
        else {
            setFilterFields(filterFields, searchObj);
        }
        return filterFields;
    }
    // Reset the sort based on sort returned by the call
    resetSortStatus(variableSort) {
        let gridSortString;
        if (!_.isEmpty(this.table.sortInfo) && this.table.datasource) {
            gridSortString = this.table.sortInfo.field + ' ' + this.table.sortInfo.direction;
            variableSort = this.table.datasource.execute(DataSource.Operation.GET_OPTIONS).orderBy || variableSort;
            if (variableSort) { // If multiple order by fields are present, compare with the first one
                variableSort = _.head(_.split(variableSort, ','));
            }
            if (gridSortString !== variableSort) {
                this.table.callDataGridMethod('resetSortIcons');
                this.table.sortInfo = {};
                this.table.setDataGridOption('sortInfo', {});
            }
        }
    }
    // Clear the all the filters applied
    clearFilter(skipFilter) {
        let $gridElement;
        this.table.filterInfo = {};
        if (this.table.filtermode === 'multicolumn') {
            this.table.fieldDefs.forEach(col => {
                if (col.resetFilter) {
                    col.resetFilter();
                }
            });
            if (!skipFilter) {
                this.table.onRowFilterChange();
            }
        }
        else if (this.table.filtermode === 'search') {
            $gridElement = this.table.datagridElement;
            $gridElement.find('[data-element="dgSearchText"]').val('');
            $gridElement.find('[data-element="dgFilterValue"]').val('');
            if (!skipFilter) {
                $gridElement.find('.app-search-button').trigger('click');
            }
        }
    }
    // Check the filters applied and remove if dat does not contain any filters
    checkFiltersApplied(variableSort) {
        if (!this.table.datasource) {
            return;
        }
        if (this.table.datasource.execute(DataSource.Operation.SUPPORTS_SERVER_FILTER)) {
            if (_.isEmpty(this.table.datasource.execute(DataSource.Operation.GET_OPTIONS).filterFields) && _.isEmpty(this.table.filterInfo)) {
                this.clearFilter(true);
            }
            this.resetSortStatus(variableSort);
            return;
        }
        if (this.table.datasource.execute(DataSource.Operation.IS_PAGEABLE)) {
            this.resetSortStatus(variableSort);
        }
    }
    // Returns data filtered using searchObj
    getSearchResult(data, searchObj) {
        if (!searchObj) {
            return data;
        }
        if (_.isArray(searchObj)) {
            searchObj.forEach((obj) => {
                data = getFilteredData(data, obj);
            });
        }
        else {
            data = getFilteredData(data, searchObj);
        }
        return data;
    }
    // Returns data sorted using sortObj
    getSortResult(data, sortObj) {
        if (sortObj && sortObj.direction) {
            data = _.orderBy(data, sortObj.field, sortObj.direction);
        }
        return data;
    }
    // This method handles the client side sort and search
    handleClientSideSortSearch(searchSortObj, e, type) {
        this.table._isClientSearch = true;
        let data;
        data = this.table.isNavigationEnabled() ? getClonedObject(this.table.__fullData) : getClonedObject(this.table.dataset);
        if (type === 'search') {
            this.table.filterInfo = searchSortObj;
        }
        else {
            this.table.sortInfo = searchSortObj;
        }
        if (_.isObject(data) && !_.isArray(data)) {
            data = [data];
        }
        /*Both the functions return same 'data' if arguments are undefined*/
        data = this.getSearchResult(data, this.table.filterInfo);
        data = this.getSortResult(data, this.table.sortInfo);
        this.table.serverData = data;
        if (type === 'sort') {
            // Calling 'onSort' event
            this.table.invokeEventCallback('sort', { $event: e, $data: {
                    data: this.table.serverData,
                    sortDirection: this.table.sortInfo.direction,
                    colDef: this.table.columns[this.table.sortInfo.field]
                } });
        }
        if (this.table.isNavigationEnabled()) {
            // Reset the page number to 1
            this.table.dataNavigator.dn.currentPage = 1;
            this.table.dataNavigator.setPagingValues(data);
        }
        else {
            this.table.setGridData(this.table.serverData);
        }
    }
    // This method handles the search for pageable datasource
    handleSinglePageSearch(searchObj) {
        this.table._isPageSearch = true;
        let data = getClonedObject(this.table.gridData);
        const $rows = this.table.datagridElement.find('tbody tr.app-datagrid-row');
        this.table.filterInfo = searchObj;
        data = this.getSearchResult(data, searchObj);
        // Compared the filtered data and original data, to show or hide the rows
        _.forEach(this.table.gridData, (value, index) => {
            const $row = $($rows[index]);
            if (_.find(data, obj => _.isEqual(obj, value))) {
                $row.show();
            }
            else {
                $row.hide();
            }
        });
        if (data && data.length) {
            this.table.callDataGridMethod('setStatus', 'ready');
            // Select the first row after the search for single select
            if (this.table.gridfirstrowselect && !this.table.multiselect) {
                this.table.callDataGridMethod('selectFirstRow', true, true);
            }
        }
        else {
            this.table.callDataGridMethod('setStatus', 'nodata', this.table.nodatamessage);
            this.table.selecteditem = undefined;
        }
        this.table.callDataGridMethod('updateSelectAllCheckboxState');
    }
    // This method handles the search for server side variables
    handleServerSideSearch(searchObj) {
        this.table.filterInfo = searchObj;
        if (!this.table.datasource) {
            return;
        }
        const sortInfo = this.table.sortInfo;
        const sortOptions = sortInfo && sortInfo.direction ? (sortInfo.field + ' ' + sortInfo.direction) : '';
        const filterFields = this.getFilterFields(searchObj);
        refreshDataSource(this.table.datasource, {
            page: 1,
            filterFields: filterFields,
            orderBy: sortOptions
        }).then(() => {
            $appDigest();
        }, () => {
            this.table.toggleMessage(true, 'error', this.table.nodatamessage);
        });
    }
    // This method handles the sort for server side variables
    handleSeverSideSort(sortObj, e) {
        // Update the sort info for passing to datagrid
        this.table.gridOptions.sortInfo.field = sortObj.field;
        this.table.gridOptions.sortInfo.direction = sortObj.direction;
        this.table.sortInfo = getClonedObject(sortObj);
        const sortOptions = sortObj && sortObj.direction ? (sortObj.field + ' ' + sortObj.direction) : '';
        const filterFields = this.getFilterFields(this.table.filterInfo);
        refreshDataSource(this.table.datasource, {
            page: 1,
            filterFields: filterFields,
            orderBy: sortOptions
        }).then((response) => {
            $appDigest();
            const data = (response && response.data) ? response.data : response;
            this.table.invokeEventCallback('sort', { $event: e, $data: {
                    data,
                    sortDirection: sortObj.direction,
                    colDef: this.table.columns[sortObj.field]
                } });
        });
    }
    searchHandler(searchSortObj, e, type) {
        let filterFields = getClonedObject(searchSortObj);
        const dataSource = this.table.datasource;
        if (!dataSource) {
            return;
        }
        let output;
        const userFilters = {};
        // Transform filter fields from array to object having field names as keys
        if (_.isArray(filterFields)) {
            filterFields.forEach(filterField => {
                transformFilterField(userFilters, filterField);
            });
        }
        else {
            transformFilterField(userFilters, filterFields);
        }
        output = this.table.invokeEventCallback('beforefilter', { $event: e, $data: userFilters, columns: userFilters });
        // If callback returns false, don't trigger the filter call
        if (output === false) {
            return;
        }
        // Transform back the filter fields from object to array
        filterFields = [];
        _.forEach(userFilters, (val, key) => {
            filterFields.push({
                field: key,
                matchMode: val.matchMode,
                type: val.type,
                value: val.value
            });
        });
        if (dataSource.execute(DataSource.Operation.SUPPORTS_SERVER_FILTER)) {
            this.handleServerSideSearch(filterFields);
            return;
        }
        if (dataSource.execute(DataSource.Operation.IS_API_AWARE) && dataSource.execute(DataSource.Operation.IS_PAGEABLE)) {
            this.handleSinglePageSearch(filterFields);
        }
        else {
            this.handleClientSideSortSearch(filterFields, e, type);
        }
    }
    sortHandler(searchSortObj, e, type) {
        const dataSource = this.table.datasource;
        if (!dataSource) {
            return;
        }
        if (dataSource.execute(DataSource.Operation.IS_PAGEABLE)) {
            this.handleSeverSideSort(searchSortObj, e);
        }
        else {
            this.handleClientSideSortSearch(searchSortObj, e, type);
        }
    }
    // This method is triggered by jquery table
    searchSortHandler(searchSortObj, e, type) {
        if (type === 'search') {
            this.searchHandler(searchSortObj, e, type);
        }
        else {
            this.sortHandler(searchSortObj, e, type);
        }
    }
    // Method to show/hide clear icon in multi column filter
    showClearIcon(fieldName) {
        const value = this.table.rowFilter[fieldName] && this.table.rowFilter[fieldName].value;
        return isDefined(value) && value !== '' && value !== null;
    }
    // Method clear the filter value in multi column filter
    clearRowFilter(fieldName) {
        if (this.table.rowFilter && this.table.rowFilter[fieldName]) {
            this.table.columns[fieldName].resetFilter();
            this.onRowFilterChange(fieldName);
        }
    }
    // This method is triggered on select of condition in multi column filter
    onFilterConditionSelect(fieldName, condition) {
        this.table.rowFilter[fieldName] = this.table.rowFilter[fieldName] || {};
        this.table.rowFilter[fieldName].matchMode = condition;
        // For empty match modes, clear off the value and call filter
        if (_.includes(this.table.emptyMatchModes, condition)) {
            this.table.columns[fieldName].resetFilter();
            this.table.onRowFilterChange();
        }
        else {
            // If value is present, call the filter. Else, focus on the field
            if (isDefined(this.table.rowFilter[fieldName].value) && this.table.rowFilter[fieldName].value !== '') {
                this.table.onRowFilterChange();
            }
            else {
                setTimeout(() => {
                    this.table.columns[fieldName].filterInstance.focus();
                });
            }
        }
    }
    // Method to get the updated values when filter on field is changed for multicolumn filter
    getFilterOnFieldValues(filterDef) {
        if (!this.table.datasource || !this.table.datasource.execute(DataSource.Operation.SUPPORTS_DISTINCT_API)) {
            return;
        }
        const fieldName = filterDef.field;
        const formFields = this.table.fullFieldDefs;
        const filterOnFields = _.filter(formFields, { 'filteronfilter': fieldName });
        const newVal = _.get(this.table.rowFilter, [fieldName, 'value']);
        // Loop over the fields for which the current field is filter on field
        _.forEach(filterOnFields, filterField => {
            const filterOn = filterField.filteronfilter;
            const filterKey = filterField.field;
            const filterFields = {};
            const filterWidget = filterField.filterwidget;
            if (!isDataSetWidget(filterWidget) || filterOn === filterKey || filterField.isFilterDataSetBound) {
                return;
            }
            filterFields[filterOn] = (isDefined(newVal) && newVal !== '' && newVal !== null) ? { 'value': newVal } : {};
            if (filterWidget === FormWidgetType.AUTOCOMPLETE && filterField.filterInstance.dataoptions) {
                filterField.filterInstance.dataoptions.filterFields = filterFields;
            }
            else {
                this.table.datasource.execute(DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS, {
                    'fields': filterKey,
                    'filterFields': filterFields
                }).then(data => {
                    filterField.filterdataset = data.data;
                });
            }
        });
    }
    // This method is triggered on value change in multi column filter
    onRowFilterChange(fieldName) {
        const searchObj = [];
        const field = _.find(this.table.fullFieldDefs, { 'field': fieldName });
        // Convert row filters to a search object and call search handler
        _.forEach(this.table.rowFilter, (value, key) => {
            if ((isDefined(value.value) && value.value !== '') || _.includes(this.table.emptyMatchModes, value.matchMode)) {
                if (field && key === field.field) {
                    value.type = value.type || field.type;
                    value.matchMode = value.matchMode || _.get(this.table.matchModeTypesMap[value.type], 0);
                }
                searchObj.push({
                    field: key,
                    value: value.value,
                    matchMode: value.matchMode,
                    type: value.type
                });
            }
        });
        this.table.gridOptions.searchHandler(searchObj, undefined, 'search');
        // If field is passed, update any filter on field values if present
        if (field) {
            this.getFilterOnFieldValues(field);
        }
    }
    refreshData(isSamePage) {
        if (!this.table.datasource) {
            return;
        }
        const page = isSamePage ? this.table.dataNavigator.dn.currentPage : 1;
        const sortInfo = this.table.sortInfo;
        const sortOptions = sortInfo && sortInfo.direction ? (sortInfo.field + ' ' + sortInfo.direction) : '';
        const filterFields = this.getFilterFields(this.table.filterInfo);
        refreshDataSource(this.table.datasource, {
            page: page,
            filterFields: filterFields,
            orderBy: sortOptions
        });
    }
}
TableFilterSortDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTableFilterSort]'
            },] }
];
/** @nocollapse */
TableFilterSortDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Self }, { type: Inject, args: [TableComponent,] }] }
];

const registerProps$1e = () => {
    register('wm-table-row-action', new Map([
        ['accessroles', PROP_STRING],
        ['action', PROP_STRING],
        ['caption', PROP_STRING],
        ['class ', Object.assign({ value: 'btn-secondary' }, PROP_STRING)],
        ['disabled', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['display-name', PROP_STRING],
        ['hyperlink', PROP_STRING],
        ['iconclass', PROP_STRING],
        ['key', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['tabindex', Object.assign({ value: 0 }, PROP_NUMBER)],
        ['target', PROP_STRING],
        ['title', PROP_STRING],
        ['widget-type', Object.assign({ value: 'button' }, PROP_STRING)]
    ]));
};

const WIDGET_CONFIG$12 = { widgetType: 'wm-table-row-action', hostClass: '' };
const ɵ0$n = {};
class TableRowActionDirective extends BaseComponent {
    constructor(inj, table, contexts) {
        super(inj, WIDGET_CONFIG$12);
        this.table = table;
        contexts[0].editRow = (evt) => this.table.editRow(evt);
        contexts[0].deleteRow = (evt) => this.table.deleteRow(evt);
        contexts[0].addNewRow = (evt) => this.table.addNewRow(evt);
    }
    getTitle() {
        return _.isUndefined(this.title) ? (this['display-name'] || '') : this.title;
    }
    populateAction() {
        this.buttonDef = {
            key: this.key,
            displayName: this['display-name'] || this.caption || '',
            show: this.show,
            class: this.class || '',
            iconclass: this.iconclass || '',
            title: this.getTitle(),
            action: this.action,
            accessroles: this.accessroles,
            disabled: this.disabled,
            tabindex: this.tabindex ? +this.tabindex : undefined,
            widgetType: this['widget-type'] || 'button',
            hyperlink: this.hyperlink,
            target: this.target,
            conditionalclass: this.conditionalclass || '',
            conditionalstyle: this.conditionalstyle || {}
        };
    }
    ngOnInit() {
        super.ngOnInit();
        this.populateAction();
        this.table.registerRowActions(this.buttonDef);
    }
}
TableRowActionDirective.initializeProps = registerProps$1e();
TableRowActionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTableRowAction]',
                providers: [
                    provideAsWidgetRef(TableRowActionDirective),
                    { provide: Context, useValue: ɵ0$n, multi: true }
                ]
            },] }
];
/** @nocollapse */
TableRowActionDirective.ctorParameters = () => [
    { type: Injector },
    { type: TableComponent, decorators: [{ type: Optional }] },
    { type: Array, decorators: [{ type: Self }, { type: Inject, args: [Context,] }] }
];

const registerProps$1f = () => {
    register('wm-table-row', new Map([
        ['class', PROP_STRING],
        ['closeothers', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['content', PROP_STRING],
        ['columnwidth', Object.assign({ value: '30px' }, PROP_STRING)],
        ['collapseicon', PROP_STRING],
        ['expandicon', PROP_STRING],
        ['height', PROP_STRING],
        ['position', Object.assign({ value: '0' }, PROP_STRING)]
    ]));
};

const WIDGET_CONFIG$13 = { widgetType: 'wm-table-row', hostClass: '' };
class TableRowDirective extends BaseComponent {
    constructor(inj, table) {
        super(inj, WIDGET_CONFIG$13);
        this.table = table;
    }
    populateConfig() {
        this.config = {
            closeothers: this.closeothers,
            content: this.content,
            columnwidth: this.columnwidth,
            expandicon: this.expandicon,
            collapseicon: this.collapseicon,
            height: this.height,
            position: this.position
        };
    }
    ngOnInit() {
        super.ngOnInit();
        this.populateConfig();
        this.table.registerRow(this.config, this);
    }
    onPropertyChange(key, nv) {
        if (key === 'content' && this.config) {
            this.config.content = this.content;
        }
    }
}
TableRowDirective.initializeProps = registerProps$1f();
TableRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTableRow]',
                providers: [
                    provideAsWidgetRef(TableRowDirective)
                ]
            },] }
];
/** @nocollapse */
TableRowDirective.ctorParameters = () => [
    { type: Injector },
    { type: TableComponent, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

const WIDGET_CONFIG$14 = {
    widgetType: 'wm-textarea',
    hostClass: 'app-input-wrapper'
};
class TextareaComponent extends BaseInput {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$14);
    }
}
TextareaComponent.initializeProps = registerProps$L();
TextareaComponent.decorators = [
    { type: Component, args: [{
                selector: 'wm-textarea',
                template: "<textarea class=\"form-control app-textarea\"\n          focus-target\n          role=\"input\"\n          [attr.name]=\"name\"\n          [(ngModel)]=\"datavalue\"\n          [ngModelOptions]=\"ngModelOptions\"\n          [readonly]=\"readonly\"\n          [required]=\"required\"\n          [disabled]=\"disabled\"\n          [maxlength]=\"maxchars\"\n          [attr.tabindex]=\"tabindex\"\n          [attr.placeholder]=\"placeholder\"\n          [attr.accesskey]=\"shortcutkey\"\n          [autofocus]=\"autofocus\"\n          (blur)=\"handleBlur($event)\"\n          (ngModelChange)=\"handleChange($event)\"\n          #textarea\n></textarea>",
                providers: [
                    provideAsNgValueAccessor(TextareaComponent),
                    provideAsWidgetRef(TextareaComponent)
                ]
            }] }
];
/** @nocollapse */
TextareaComponent.ctorParameters = () => [
    { type: Injector }
];
TextareaComponent.propDecorators = {
    inputEl: [{ type: ViewChild, args: ['textarea',] }],
    ngModel: [{ type: ViewChild, args: [NgModel,] }]
};

class TextContentDirective {
    constructor(elRef) {
        this.elRef = elRef;
    }
    set textContent(nv) {
        let v = nv;
        if (nv === undefined || nv === null) {
            v = '';
        }
        this.elRef.nativeElement.textContent = v;
    }
}
TextContentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[textContent]'
            },] }
];
/** @nocollapse */
TextContentDirective.ctorParameters = () => [
    { type: ElementRef }
];
TextContentDirective.propDecorators = {
    textContent: [{ type: Input }]
};

const registerProps$1g = () => {
    register('wm-tile', new Map([
        ['class', PROP_STRING],
        ['conditionalclass', PROP_ANY],
        ['conditionalstyle', PROP_ANY],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)]
    ]));
};

const DEFAULT_CLS$R = 'app-tile';
const WIDGET_CONFIG$15 = { widgetType: 'wm-tile', hostClass: DEFAULT_CLS$R };
class TileDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$15);
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.CONTAINER);
    }
}
TileDirective.initializeProps = registerProps$1g();
TileDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTile]',
                providers: [
                    provideAsWidgetRef(TileDirective)
                ]
            },] }
];
/** @nocollapse */
TileDirective.ctorParameters = () => [
    { type: Injector }
];

const CURRENT_TIME = 'CURRENT_TIME';
const DEFAULT_CLS$S = 'input-group app-timeinput';
const WIDGET_CONFIG$16 = { widgetType: 'wm-time', hostClass: DEFAULT_CLS$S };
class TimeComponent extends BaseDateTimeComponent {
    constructor(inj, ngZone, appDefaults, evtMngrPlugins) {
        super(inj, WIDGET_CONFIG$16);
        this.ngZone = ngZone;
        this.appDefaults = appDefaults;
        /**
         * This is an internal property used to toggle the timepicker dropdown
         */
        this.status = { isopen: false };
        // KeyEventsPlugin
        this.keyEventPlugin = evtMngrPlugins[1];
        styler(this.nativeElement, this);
        /**
         * Destroy the timer once the date widget is gone
         */
        this.registerDestroyListener(() => this.clearTimeInterval());
        this.timepattern = this.appDefaults.timeFormat || getDisplayDateTimeFormat(FormWidgetType.TIME);
        this.updateFormat('timepattern');
    }
    get timestamp() {
        return this.bsTimeValue ? this.bsTimeValue.valueOf() : undefined;
    }
    get datavalue() {
        if (this.isCurrentTime && !this.bsTimeValue) {
            return CURRENT_TIME;
        }
        return getFormattedDate(this.datePipe, this.bsTimeValue, this.outputformat) || '';
    }
    /**Todo[Shubham]: needs to be redefined
     * This property sets the default value for the time selection
     */
    set datavalue(newVal) {
        if (newVal) {
            if (newVal === CURRENT_TIME) {
                this.isCurrentTime = true;
                this.setTimeInterval();
            }
            else {
                this.clearTimeInterval();
                this.bsTimeValue = getNativeDateObject(newVal);
                this.isCurrentTime = false;
            }
        }
        else {
            this.bsTimeValue = undefined;
            this.clearTimeInterval();
            this.isCurrentTime = false;
        }
        this.invokeOnChange(this.datavalue);
        $appDigest();
    }
    get displayValue() {
        return getFormattedDate(this.datePipe, this.bsTimeValue, this.timepattern) || '';
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'tabindex') {
            return;
        }
        if (key === 'timepattern') {
            this.updateFormat('timepattern');
        }
        if (key === 'mintime') {
            this.minTime = getNativeDateObject(nv); // TODO it is supposed to be time conversion, not to the day
            this.mintimeMaxtimeValidation();
        }
        else if (key === 'maxtime') {
            this.maxTime = getNativeDateObject(nv);
            this.mintimeMaxtimeValidation();
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    /**
     * This is an internal method used to validate mintime and maxtime
     */
    mintimeMaxtimeValidation() {
        this.timeNotInRange = this.minTime && this.maxTime && (this.bsTimeValue < this.minTime || this.bsTimeValue > this.maxTime);
        this.invokeOnChange(this.datavalue, undefined, false);
    }
    /**
     * This is an internal method used to toggle the dropdown of the time widget
     */
    toggleDropdown($event) {
        if ($event.type === 'click') {
            this.invokeEventCallback('click', { $event: $event });
        }
        if ($event.target && $($event.target).is('input') && !(this.isDropDownDisplayEnabledOnInput(this.showdropdownon))) {
            return;
        }
        this.ngZone.run(() => {
            this.status.isopen = !this.status.isopen;
        });
        this.addBodyClickListener(this.status.isopen);
    }
    /**
     * This is an internal method used to Prevent time picker close while changing time value
     */
    preventTpClose($event) {
        $event.stopImmediatePropagation();
    }
    addBodyClickListener(skipListener) {
        if (!skipListener) {
            return;
        }
        const bodyElement = document.querySelector('body');
        setTimeout(() => {
            const dropdownElement = $(bodyElement).find('>bs-dropdown-container .dropdown-menu').get(0);
            this.deregisterEventListener = addEventListenerOnElement(bodyElement, dropdownElement, this.nativeElement, 'click', this.isDropDownDisplayEnabledOnInput(this.showdropdownon), () => {
                this.status.isopen = false;
            }, 0 /* ONCE */, true);
        }, 350);
    }
    /**
     * This is an internal method triggered when pressing key on the time input
     */
    onDisplayKeydown(event) {
        if (this.isDropDownDisplayEnabledOnInput(this.showdropdownon)) {
            event.stopPropagation();
            const action = this.keyEventPlugin.constructor.getEventFullKey(event);
            if (action === 'enter' || action === 'arrowdown') {
                event.preventDefault();
                this.toggleDropdown(event);
            }
            else {
                this.hideTimepickerDropdown();
            }
        }
        else {
            this.hideTimepickerDropdown();
        }
    }
    /**
     * This is an internal method triggered when the time input changes
     */
    onDisplayTimeChange($event) {
        const newVal = getNativeDateObject($event.target.value);
        // time pattern validation
        // if invalid pattern is entered, device is showing an error.
        if (!this.formatValidation(newVal, $event.target.value)) {
            return;
        }
        this.invalidDateTimeFormat = false;
        this.onTimeChange(newVal);
    }
    onInputBlur($event) {
        if (!$($event.relatedTarget).hasClass('bs-timepicker-field')) {
            this.invokeOnTouched();
            this.invokeEventCallback('blur', { $event });
        }
    }
    /**
     * This is an internal method used to execute the on time change functionality
     */
    onTimeChange(newVal, isNativePicker) {
        let timeValue, timeInputValue, minTimeMeridian, maxTimeMeridian;
        // For nativePicker, newVal is event, get the dateobject from the event.
        if (isNativePicker) {
            newVal = getNativeDateObject(newVal.target.value);
        }
        if (newVal) {
            this.bsTimeValue = newVal;
            // if the newVal is valid but not in the given range then highlight the input field
            this.timeNotInRange = this.minTime && this.maxTime && (newVal < this.minTime || newVal > this.maxTime);
        }
        else {
            // sometimes library is not returning the correct value when the min and max time are given, displaying the datavalue based on the value given by the user
            if (this.bsTimePicker && this.bsTimePicker.min && this.bsTimePicker.max) {
                minTimeMeridian = moment(new Date(this.bsTimePicker.min)).format('A');
                maxTimeMeridian = moment(new Date(this.bsTimePicker.max)).format('A');
                timeValue = this.bsTimePicker.hours + ':' + (this.bsTimePicker.minutes || 0) + ':' + (this.bsTimePicker.seconds || 0) + (this.bsTimePicker.showMeridian ? (' ' + minTimeMeridian) : '');
                timeInputValue = getNativeDateObject(timeValue);
                this.bsTimePicker.meridian = minTimeMeridian;
                this.timeNotInRange = (this.bsTimePicker.min > timeInputValue || this.bsTimePicker.max < timeInputValue);
            }
            this.bsTimeValue = timeInputValue;
        }
        this.invokeOnTouched();
        this.invokeOnChange(this.datavalue, {}, true);
    }
    /**
     * This is an internal method used to maintain a time interval to update the time model when the data value is set to CURRENT_TIME
     */
    setTimeInterval() {
        if (this.timeinterval) {
            return;
        }
        this.timeinterval = setInterval(() => {
            const now = new Date();
            now.setSeconds(now.getSeconds() + 1);
            this.datavalue = CURRENT_TIME;
            this.onTimeChange(now);
        }, 1000);
    }
    /**
     * This is an internal method used to clear the time interval created
     */
    clearTimeInterval() {
        if (this.timeinterval) {
            clearInterval(this.timeinterval);
            this.timeinterval = null;
        }
    }
    /**
     * This function sets the value isOpen/isTimeOpen (i.e when datepicker popup is closed) based on widget type(i.e  DateTime, Time)
     * @param val - isOpen/isTimeOpen is set based on the timepicker popup is open/closed
     */
    setIsTimeOpen(val) {
        this.status.isopen = val;
    }
    // Change event is registered from the template, Prevent the framework from registering one more event
    handleEvent(node, eventName, eventCallback, locals) {
        if (!_.includes(['blur', 'focus', 'change', 'click'], eventName)) {
            super.handleEvent(node, eventName, eventCallback, locals);
        }
    }
    hideTimepickerDropdown() {
        this.invokeOnTouched();
        this.status.isopen = false;
        if (this.deregisterEventListener) {
            this.deregisterEventListener();
        }
    }
    isValid(event) {
        if (!event) {
            const enteredDate = $(this.nativeElement).find('input').val();
            const newVal = getNativeDateObject(enteredDate);
            if (!this.formatValidation(newVal, enteredDate)) {
                return;
            }
        }
    }
    /**
     * This is an internal method to add css class for dropdown while opening the time dropdown
     */
    onShown() {
        const tpElements = document.querySelectorAll('timepicker');
        _.forEach(tpElements, element => {
            addClass(element.parentElement, 'app-datetime', true);
        });
        this.focusTimePickerPopover(this);
        this.bindTimePickerKeyboardEvents();
        adjustContainerPosition($('bs-dropdown-container'), this.nativeElement, this.bsDropdown._dropdown, $('bs-dropdown-container .dropdown-menu'));
    }
}
TimeComponent.initializeProps = registerProps$M();
TimeComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmTime]',
                template: "<ng-container *ngIf=\"useDatapicker; then timePickerTemplate else nativeTimeTemplate\">\n</ng-container>\n\n<ng-template #timePickerTemplate>\n    <div dropdown [isOpen]=\"status.isopen\" (onShown)=\"onShown()\" (onHidden)=\"hideTimepickerDropdown()\" container=\"body\" style=\"display: inherit\">\n        <input class=\"form-control app-textbox display-input\" aria-label=\"Set the time\"\n               focus-target\n               [tabindex]=\"tabindex\"\n               [name]=\"name\"\n               type=\"text\"\n               [value]=\"displayValue\"\n               [disabled]=\"disabled || readonly || isCurrentTime\"\n               [autofocus]=\"autofocus\"\n               [required]=\"required\"\n               [attr.placeholder]=\"placeholder\"\n               [attr.accesskey]=\"shortcutkey\"\n               [required]=\"required\"\n               (click)=\"toggleDropdown($event)\"\n               (focus)=\"invokeOnFocus($event)\"\n               (blur)=\"onInputBlur($event)\"\n               (change)=\"onDisplayTimeChange($event)\"\n               (keydown)=\"onDisplayKeydown($event)\">\n        <span class=\"input-group-btn dropdown-toggle\">\n          <button type=\"button\" class=\"btn btn-default btn-date\" [tabindex]=\"tabindex\" [disabled]=\"disabled || readonly || isCurrentTime\" aria-label=\"Select time\" aria-haspopup=\"true\" aria-expanded=\"false\" (click)=\"toggleDropdown($event)\"><i aria-hidden=\"true\" class=\"app-icon wi wi-access-time\"></i></button>\n        </span>\n        <div *dropdownMenu class=\"dropdown-menu\" (click)=\"preventTpClose($event)\">\n            <timepicker class=\"model-holder\"\n                        [showMeridian]=\"ismeridian\"\n                        [readonlyInput]=\"isDisabled\"\n                        [(ngModel)]=\"bsTimeValue\"\n                        [disabled]=\"disabled || readonly || isCurrentTime\"\n                        [min]=\"minTime\"\n                        [max]=\"maxTime\"\n                        [hourStep]=\"hourstep\"\n                        [minuteStep]=\"minutestep\"\n                        [secondsStep]=\"secondsstep\"\n                        [mousewheel]=\"true\"\n                        [arrowkeys]=\"true\"\n                        (isValid)=\"isValid($event)\"\n                        [showSeconds]=\"showseconds\" (ngModelChange)=\"onTimeChange($event)\"></timepicker>\n        </div>\n    </div>\n</ng-template>\n<ng-template #nativeTimeTemplate>\n    <input type=\"time\" class=\"form-control app-textbox\"\n           role=\"input\"\n           [value]=\"displayValue\"\n           [required]=\"required\"\n           [disabled]=\"disabled || readonly || isCurrentTime\"\n           (change)=\"onTimeChange($event, true)\"\n           (focus)=\"invokeOnFocus($event)\"\n           (blur)=\"invokeOnTouched($event)\">\n</ng-template>\n",
                providers: [
                    provideAsNgValueAccessor(TimeComponent),
                    provideAsNgValidators(TimeComponent),
                    provideAsWidgetRef(TimeComponent)
                ]
            }] }
];
/** @nocollapse */
TimeComponent.ctorParameters = () => [
    { type: Injector },
    { type: NgZone },
    { type: AppDefaults },
    { type: undefined, decorators: [{ type: Inject, args: [EVENT_MANAGER_PLUGINS,] }] }
];
TimeComponent.propDecorators = {
    bsTimePicker: [{ type: ViewChild, args: [TimepickerComponent,] }]
};

const registerProps$1h = () => {
    register('wm-top-nav', new Map([
        ['name', PROP_STRING],
        ['content', PROP_STRING]
    ]));
};

const DEFAULT_CLS$T = 'app-top-nav';
const WIDGET_CONFIG$17 = { widgetType: 'wm-top-nav', hostClass: DEFAULT_CLS$T };
class TopNavDirective extends StylableComponent {
    constructor(inj) {
        super(inj, WIDGET_CONFIG$17);
        styler(this.nativeElement, this);
    }
}
TopNavDirective.initializeProps = registerProps$1h();
TopNavDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmTopNav]',
                providers: [
                    provideAsWidgetRef(TopNavDirective)
                ]
            },] }
];
/** @nocollapse */
TopNavDirective.ctorParameters = () => [
    { type: Injector }
];

const registerProps$1i = () => {
    register('wm-wizard', new Map([
        ['actionsalignment', Object.assign({ value: 'right' }, PROP_STRING)],
        ['cancelable', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['cancelbtnlabel', Object.assign({ value: 'Cancel' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['defaultstep', Object.assign({ value: 'none' }, PROP_STRING)],
        ['donebtnlabel', Object.assign({ value: 'Done' }, PROP_STRING)],
        ['name', PROP_STRING],
        ['nextbtnlabel', Object.assign({ value: 'Next' }, PROP_STRING)],
        ['previousbtnlabel', Object.assign({ value: 'Previous' }, PROP_STRING)],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['stepstyle', Object.assign({ value: 'auto' }, PROP_STRING)]
    ]));
};

const registerProps$1j = () => {
    register('wm-wizardstep', new Map([
        ['class', PROP_STRING],
        ['enableskip', Object.assign({ value: false }, PROP_BOOLEAN)],
        ['iconclass', PROP_STRING],
        ['name', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['title', Object.assign({ value: 'Step Title' }, PROP_STRING)]
    ]));
};

const DEFAULT_CLS$U = 'app-wizard-step-content';
const WIDGET_CONFIG$18 = {
    widgetType: 'wm-wizardstep',
    hostClass: DEFAULT_CLS$U,
};
class WizardStepDirective extends BaseComponent {
    constructor(inj, ngForm) {
        super(inj, WIDGET_CONFIG$18);
        this.ngForm = ngForm;
        this.status = 2 /* DISABLED */;
    }
    get isCurrent() {
        return this.active;
    }
    get isValid() {
        return this.ngForm.valid;
    }
    get enableNext() {
        return !this.disablenext;
    }
    get enableDone() {
        return !this.disabledone;
    }
    get enablePrev() {
        return !this.disableprevious;
    }
    set active(nv) {
        const isActive = this.active;
        this.status = 1 /* CURRENT */;
        if (nv && !isActive) {
            this.invokeEventCallback('load');
            this.redrawChildren();
        }
    }
    get active() {
        return this.status === 1 /* CURRENT */;
    }
    set done(nv) {
        if (nv) {
            this.status = 3 /* COMPLETED */;
        }
    }
    get done() {
        return this.status === 3 /* COMPLETED */;
    }
    set disabled(nv) {
        if (nv) {
            this.status = 2 /* DISABLED */;
        }
    }
    get disabled() {
        return this.status === 2 /* DISABLED */;
    }
    onNext(index) {
        return this.invokeEventCallback('next', { currentStep: this, stepIndex: index });
    }
    onPrev(index) {
        return this.invokeEventCallback('prev', { currentStep: this, stepIndex: index });
    }
    onSkip(index) {
        return this.invokeEventCallback('skip', { currentStep: this, stepIndex: index });
    }
    // redraw all the projected components which are projected.
    redrawChildren() {
        setTimeout(() => {
            if (this.reDrawableComponents) {
                this.reDrawableComponents.forEach(c => c.redraw());
            }
        }, 100);
    }
}
WizardStepDirective.initializeProps = registerProps$1j();
WizardStepDirective.decorators = [
    { type: Directive, args: [{
                selector: 'form[wmWizardStep]',
                providers: [
                    provideAsWidgetRef(WizardStepDirective)
                ],
                exportAs: 'wmWizardStep'
            },] }
];
/** @nocollapse */
WizardStepDirective.ctorParameters = () => [
    { type: Injector },
    { type: NgForm, decorators: [{ type: Self }] }
];
WizardStepDirective.propDecorators = {
    reDrawableComponents: [{ type: ContentChildren, args: [RedrawableDirective, { descendants: true },] }],
    isCurrent: [{ type: HostBinding, args: ['class.current',] }]
};

const DEFAULT_CLS$V = 'app-wizard panel clearfix';
const WIDGET_CONFIG$19 = {
    widgetType: 'wm-wizard',
    hostClass: DEFAULT_CLS$V
};
class WizardComponent extends StylableComponent {
    constructor(inj) {
        let resolveFn = noop;
        super(inj, WIDGET_CONFIG$19, new Promise(res => resolveFn = res));
        styler(this.nativeElement, this, APPLY_STYLES_TYPE.SHELL);
        this.promiseResolverFn = resolveFn;
        // initialize the message object with default values
        this.message = {
            caption: '',
            type: ''
        };
    }
    get hasPrevStep() {
        return !this.isFirstStep(this.currentStep);
    }
    get hasNextStep() {
        return !this.isLastStep(this.currentStep);
    }
    get showDoneBtn() {
        if (!this.currentStep) {
            return;
        }
        return !this.hasNextStep && this.currentStep.enableDone;
    }
    get enablePrev() {
        if (!this.currentStep) {
            return;
        }
        return this.currentStep.enablePrev;
    }
    get enableNext() {
        if (!this.currentStep) {
            return;
        }
        return this.currentStep.enableNext && this.currentStep.isValid;
    }
    get enableDone() {
        if (!this.currentStep) {
            return;
        }
        return this.currentStep.enableDone && this.currentStep.isValid;
    }
    /**
     * returns next valid step. the index passed is also checked if its valid step
     * @param index
     * @returns {WizardStepDirective}
     */
    getNextValidStepFormIndex(index) {
        for (let i = index; i < this.steps.length; i++) {
            const step = this.getStepRefByIndex(i);
            if (step.show) {
                return step;
            }
        }
    }
    /**
     * returns previous valid step. the index passed is also checked if its valid step
     * @param index
     * @returns {WizardStepDirective}
     */
    getPreviousValidStepFormIndex(index) {
        for (let i = index; i >= 0; i--) {
            const step = this.getStepRefByIndex(i);
            if (step.show) {
                return step;
            }
        }
    }
    /**
     * returns current step index value.
     * @returns {number}
     */
    getCurrentStepIndex() {
        return this.getStepIndexByRef(this.currentStep);
    }
    /**
     * returns stepRef when index is passed.
     * @param {number} index
     * @returns {WizardStepDirective}
     */
    getStepRefByIndex(index) {
        return this.steps.toArray()[index];
    }
    /**
     * returns the index value of the step.
     * @param {WizardStepDirective} wizardStep
     * @returns {number}
     */
    getStepIndexByRef(wizardStep) {
        return this.steps.toArray().indexOf(wizardStep);
    }
    /**
     * gets stepRef by searching on the name property.
     * @param {string} name
     * @returns {WizardStepDirective}
     */
    getStepRefByName(name) {
        return this.steps.find(step => step.name === name);
    }
    /**
     * sets default step as current step if configured
     * or finds first valid step and set it as current step.
     * @param {WizardStepDirective} step
     */
    setDefaultStep(step) {
        // If the default step has show true then only update the currentStep
        if (step && step.show) {
            this.currentStep = step;
            step.active = true;
            step.isInitialized = true;
            // Mark all previous step status COMPLETED
            let index = this.getStepIndexByRef(step) - 1;
            while (index >= 0) {
                const prevStep = this.getStepRefByIndex(index);
                prevStep.done = true;
                prevStep.isInitialized = true;
                index--;
            }
        }
        else {
            // set next valid step as current step
            step = this.getNextValidStepFormIndex(0);
            if (step) {
                this.setDefaultStep(step);
            }
        }
    }
    /**
     * Selects the associated step when the wizard header is clicked.
     * @param $event
     * @param {WizardStepDirective} currentStep
     */
    onWizardHeaderClick($event, currentStep) {
        // select the step if it's status is done
        if (currentStep.done) {
            // set all the next steps status as disabled and previous steps as done
            this.steps.forEach((step, index) => {
                if (index < this.getStepIndexByRef(currentStep)) {
                    step.done = true;
                }
                else {
                    step.disabled = true;
                }
            });
            // set the selected step as current step and make it active
            this.currentStep = currentStep;
            this.currentStep.active = true;
        }
    }
    // Method to navigate to next step
    next(eventName = 'next') {
        const currentStep = this.currentStep;
        const currentStepIndex = this.getCurrentStepIndex();
        let nextStep;
        // abort if onSkip method returns false
        if (eventName === 'skip') {
            if (currentStep.onSkip(currentStepIndex) === false) {
                return;
            }
        }
        else if (eventName === 'next') {
            if (currentStep.onNext(currentStepIndex) === false) {
                return;
            }
        }
        nextStep = this.getNextValidStepFormIndex(currentStepIndex + 1);
        nextStep.isInitialized = true;
        // If there are any steps which has show then only change state of current step else remain same
        if (nextStep) {
            currentStep.done = true;
            nextStep.active = true;
            this.currentStep = nextStep;
        }
    }
    // Method to navigate to previous step
    prev() {
        const currentStep = this.currentStep;
        const currentStepIndex = this.getCurrentStepIndex();
        let prevStep;
        // abort if onPrev method returns false.
        if (currentStep.onPrev(currentStepIndex) === false) {
            return;
        }
        prevStep = this.getPreviousValidStepFormIndex(currentStepIndex - 1);
        // If there are any steps which has show then only change state of current step else remain same
        if (prevStep) {
            currentStep.disabled = true;
            prevStep.active = true;
            this.currentStep = prevStep;
        }
    }
    skip() {
        this.next('skip');
    }
    // Method to invoke on-Done event on wizard
    done() {
        this.invokeEventCallback('done', { steps: this.steps.toArray() });
    }
    // Method to invoke on-Cancel event on wizard
    cancel() {
        this.invokeEventCallback('cancel', { steps: this.steps.toArray() });
    }
    isFirstStep(stepRef) {
        return this.steps.first === stepRef;
    }
    isLastStep(stepRef) {
        return this.steps.last === stepRef;
    }
    // Define the property change handler. This Method will be triggered when there is a change in the widget property
    onPropertyChange(key, nv, ov) {
        // Monitoring changes for properties and accordingly handling respective changes
        if (key === 'stepstyle') {
            this.stepClass = nv === 'justified' ? 'nav-justified' : '';
        }
        else if (key === 'defaultstep') {
            this.setDefaultStep(this.getStepRefByName(nv));
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        this.promiseResolverFn();
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        styler(this.nativeElement.querySelector('.panel-body'), this, APPLY_STYLES_TYPE.INNER_SHELL);
    }
}
WizardComponent.initializeProps = registerProps$1i();
WizardComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[wmWizard]',
                template: "<div class=\"app-wizard-heading\" role=\"tab\">\n    <ul class=\"app-wizard-steps nav nav-pills {{stepClass}}\">\n        <li class=\"app-wizard-step\" *ngFor=\"let step of steps\" [hidden]=\"!step.show\"\n            [ngClass]=\"{active: step.done, current: step.active, disabled: step.disabled}\"\n            (click)=\"onWizardHeaderClick($event, step)\">\n            <a href=\"javascript:void(0)\" [attr.aria-label]=\"step.title\" [attr.title]=\"step.title\">\n                <span class=\"arrow\"></span>\n                <i class=\"app-icon {{step.iconclass}}\" *ngIf=\"step.iconclass\"></i>\n                <span class=\"step-title\" [textContent]=\"step.title\"></span>\n            </a>\n        </li>\n    </ul>\n</div>\n<div class=\"app-wizard-body panel-body\" role=\"tabpanel\">\n    <p wmMessage *ngIf=\"message.caption\" caption.bind=\"message.caption\" type.bind=\"message.type\"></p>\n    <ng-content select=\"form[wmWizardStep]\"></ng-content>\n</div>\n<div class=\"app-wizard-actions panel-footer {{actionsalignment}}\">\n    <a class=\"app-wizard-skip\" name=\"skipStep_{{name}}\" *ngIf=\"currentStep?.enableskip\" title=\"Skip step\" (click)=\"skip()\">Skip &raquo;</a>\n    <div class=\"app-wizard-actions-right\">\n        <button type=\"button\" name=\"cancelBtn_{{name}}\" class=\"btn app-button btn-secondary\" *ngIf=\"cancelable\"\n                (click)=\"cancel()\" [title]=\"cancelbtnlabel\" [textContent]=\"cancelbtnlabel\"></button>\n        <button type=\"button\" name=\"previousBtn_{{name}}\" class=\"btn app-button btn-secondary\"\n                *ngIf=\"hasPrevStep\" (click)=\"prev()\" [disabled]=\"!enablePrev\">\n            <i class=\"app-icon wi wi-chevron-left\"></i>\n            <span class=\"btn-caption\" [textContent]=\"previousbtnlabel\"></span>\n        </button>\n        <button type=\"button\" name=\"nextBtn_{{name}}\" class=\"btn app-button btn-primary\"\n                *ngIf=\"hasNextStep\" (click)=\"next()\" [disabled]=\"!enableNext\">\n            <span class=\"btn-caption\" [textContent]=\"nextbtnlabel\"></span>\n            <i class=\"app-icon wi wi-chevron-right\"></i>\n        </button>\n        <button type=\"button\" name=\"doneBtn_{{name}}\" class=\"btn app-button btn-success\"\n                *ngIf=\"showDoneBtn\" (click)=\"done()\"\n                [disabled]=\"!enableDone\">\n            <i class=\"app-icon wi wi-done\"></i>\n            <span class=\"btn-caption\" [textContent]=\"donebtnlabel\"></span>\n        </button>\n    </div>\n</div>\n",
                providers: [
                    provideAsWidgetRef(WizardComponent)
                ]
            }] }
];
/** @nocollapse */
WizardComponent.ctorParameters = () => [
    { type: Injector }
];
WizardComponent.propDecorators = {
    steps: [{ type: ContentChildren, args: [WizardStepDirective,] }]
};

class OnFileSelectDirective {
}
OnFileSelectDirective.decorators = [
    { type: Directive, args: [{
                selector: '[onFileSelect]'
            },] }
];

const registerProps$1k = () => {
    register('wm-fileupload', new Map([
        ['caption', PROP_STRING],
        ['name', PROP_STRING],
        ['tabindex', PROP_NUMBER],
        ['multiple', PROP_BOOLEAN],
        ['fileuploadmessage', PROP_STRING],
        ['show', Object.assign({ value: true }, PROP_BOOLEAN)],
        ['disabled', PROP_BOOLEAN],
        ['contenttype', PROP_STRING],
        ['maxfilesize', PROP_NUMBER],
        ['iconclass', Object.assign({ value: 'wi wi-file-upload' }, PROP_STRING)],
        ['class', PROP_STRING],
        ['uploadpath', Object.assign({}, PROP_STRING)],
        ['datasource', PROP_STRING],
        ['selectedFiles', PROP_STRING],
        ['destination', PROP_STRING],
        ['filelistheight', PROP_NUMBER],
    ]));
};

const DEFAULT_CLS$W = 'app-fileupload';
const WIDGET_CONFIG$1a = {
    widgetType: 'wm-fileupload',
    hostClass: DEFAULT_CLS$W
};
class FileUploadComponent extends StylableComponent {
    constructor(inj, app, onSelectEvt) {
        super(inj, WIDGET_CONFIG$1a);
        this.app = app;
        this.onSelectEvt = onSelectEvt;
        this.selectedFiles = [];
        this.fileTransfers = {};
        this.caption = 'Upload';
        this.formName = '';
        this.DEFAULT_CAPTIONS = {
            MULTIPLE_SELECT: 'Drop your files here.',
            SELECT: 'Select'
        };
        this.DEVICE_CONTENTTYPES = {
            IMAGE: 'image',
            VIDEO: 'video',
            AUDIO: 'audio',
            FILES: 'files'
        };
        this.FILESIZE_MB = 1048576;
        // parentPrefabScope = element.closest('.app-prefab').isolateScope(),
        this.CONSTANT_FILE_SERVICE = 'FileService';
        this.uploadData = {
            file: undefined,
            uploadPath: undefined
        };
        this.chooseFilter = '';
        this.fileUploadMessage = 'You can also browse for files';
        this.uploadedFiles = {
            fileName: '',
            path: '',
            length: '',
            status: ''
        };
        this.uploadUrl = 'services';
        // styler(this.nativeElement, this);
    }
    /*_hasOnSuccessEvt = WM.isDefined(attrs.onSuccess);
     _hasOnErrorEvt = WM.isDefined(attrs.onError);*/
    // Checking if the selected file is valid for the choosen filter type
    isValidFile(filename, contenttype, extensionName, isMobileType) {
        let isValid, contentTypes;
        if (!contenttype) {
            return true;
        }
        contentTypes = _.toLower(contenttype).split(',');
        if (_.includes(contentTypes, 'image/*') || (_.includes(contentTypes, 'image') && isMobileType)) {
            isValid = isImageFile(filename);
            // If one of the content type chosen is image and user uploads image it is valid file
            if (isValid) {
                return isValid;
            }
        }
        if (_.includes(contentTypes, 'audio/*') || (_.includes(contentTypes, 'audio') && isMobileType)) {
            isValid = isAudioFile(filename);
            // If one of the content type chosen is audio/* and user uploads audio it is valid file
            if (isValid) {
                return isValid;
            }
        }
        if (_.includes(contentTypes, 'video/*') || (_.includes(contentTypes, 'video') && isMobileType)) {
            isValid = isVideoFile(filename);
            // If one of the content type chosen is video/* and user uploads video it is valid file
            if (isValid) {
                return isValid;
            }
        }
        /*content type and the uploaded file extension should be same*/
        if (_.includes(contentTypes, '.' + _.toLower(extensionName))) {
            isValid = true;
        }
        return isValid;
    }
    /* this return the array of files which are having the file size not more than maxfilesize and filters based on contenttype */
    getValidFiles($files) {
        const validFiles = [];
        const errorFiles = [];
        const MAXFILEUPLOAD_SIZE = parseFloat(this.maxfilesize) * this.FILESIZE_MB || this.FILESIZE_MB;
        const MAX_FILE_UPLOAD_FORMATTED_SIZE = (this.maxfilesize || '1') + 'MB';
        // if contenttype is files for mobile projects.
        if (this.chooseFilter === this.DEVICE_CONTENTTYPES.FILES) {
            this.chooseFilter = '';
        }
        _.forEach($files, (file) => {
            /* check for the file content type before uploading */
            if (!this.isValidFile(file.name, this.chooseFilter, this.getFileExtension(file.name), this._isMobileType)) {
                const msg = `${this.appLocale.LABEL_FILE_EXTENTION_VALIDATION_MESSAGE} ${this.chooseFilter}`;
                this.app.notifyApp(msg, 'Error');
                const error = {
                    key: 'INVALID_FILE_EXTENSION',
                    message: msg
                };
                file.error = error;
                errorFiles.push(file);
                return;
            }
            if (file.size > MAXFILEUPLOAD_SIZE) {
                const msg = `${this.appLocale.LABEL_FILE_EXCEED_VALIDATION_MESSAGE} ${MAX_FILE_UPLOAD_FORMATTED_SIZE}`;
                this.app.notifyApp(msg, 'Error');
                const error = {
                    key: 'INVALID_FILE_SIZE',
                    message: msg
                };
                file.error = error;
                errorFiles.push(file);
                return;
            }
            validFiles.push(file);
        });
        return {
            validFiles: validFiles,
            errorFiles: errorFiles
        };
    }
    /*Overwrite the caption only if they are default*/
    getCaption(caption, isMultiple, isMobileType) {
        if (_.includes(this.DEFAULT_CAPTIONS, caption)) {
            return isMultiple && !isMobileType ? this.DEFAULT_CAPTIONS.MULTIPLE_SELECT : this.DEFAULT_CAPTIONS.SELECT;
        }
        return caption;
    }
    /* change server path based on user option */
    changeServerUploadPath(path) {
        this.selectedUploadTypePath = path;
    }
    /* this function returns the fileextension */
    getFileExtension(fileName) {
        if (fileName && _.includes(fileName, '.')) {
            return fileName.substring(fileName.lastIndexOf('.') + 1);
        }
        return 'file';
    }
    /**
     * Calls select Event
     * @param $event
     * @param $files
     */
    onSelectEventCall($event, $files) {
        this.selectedFiles = $files;
        setTimeout(() => {
            this.invokeEventCallback('select', {
                $event: $.extend($event.$files || {}, $files),
                selectedFiles: $files
            });
        });
    }
    onFileElemClick() {
        const fileInputElem = $('.file-input')[0];
        fileInputElem.value = null;
    }
    /*this function to append upload status dom elements to widget */
    onFileSelect($event, $files) {
        let beforeSelectVal;
        const files = this.getValidFiles($files);
        $files = files.validFiles;
        // Trigger error callback event if any invalid file found.
        if (!_.isEmpty(files.errorFiles)) {
            this.invokeEventCallback('error', {
                $event,
                files: files.errorFiles
            });
        }
        // Make call if there are valid files else no call is made
        if ($files.length) {
            this.progressObservable = new Subject();
            // EVENT: ON_BEFORE_SELECT
            beforeSelectVal = this.invokeEventCallback('beforeselect', {
                $event: $.extend($event.$files || {}, $files),
                files: $files
            });
            if (this.datasource) {
                this.datasource._progressObservable = this.progressObservable;
                this.datasource._progressObservable.asObservable().subscribe((progressObj) => {
                    _.forEach(this.selectedFiles, (file) => {
                        if (file.name === progressObj.fileName) {
                            file.progress = progressObj.progress;
                            if (file.progress === 100) {
                                file.status = 'success';
                            }
                            else {
                                file.status = progressObj.status;
                            }
                        }
                    });
                });
            }
            else {
                this.selectedFiles = $files;
            }
            if (beforeSelectVal !== false) {
                // EVENT: ON_SELECT
                this.onSelectEventCall($event, $files);
            }
        }
    }
    /**
     * Aborts a file upload request
     * @param $file, the file for which the request is to be aborted
     */
    abortFileUpload($file) {
        this.datasource.execute(DataSource.Operation.CANCEL, $file);
    }
    /* Define the property change handler. This function will be triggered when there is a change in the widget property */
    onPropertyChange(key, nv, ov) {
        /*Monitoring changes for styles or properties and accordingly handling respective changes.*/
        switch (key) {
            case 'uploadpath':
                // TODO Srinivas: why do we need uploadpath
                this.changeServerUploadPath(nv);
                break;
            case 'contenttype':
                this.chooseFilter = nv.split(' ').join(',');
                break;
            case 'multiple':
                this.formName = this.name + (this.multiple ? '-multiple-fileupload' : '-single-fileupload');
                this.caption = this.getCaption(this.caption, this.multiple, this._isMobileType);
                break;
            case 'fileuploadmessage':
                this.fileUploadMessage = nv;
        }
        super.onPropertyChange(key, nv, ov);
    }
    ngOnInit() {
        super.ngOnInit();
    }
    ngAfterViewInit() {
        styler(this.nativeElement.querySelector('.app-button, .drop-box'), this);
    }
}
FileUploadComponent.initializeProps = registerProps$1k();
FileUploadComponent.decorators = [
    { type: Component, args: [{
                selector: '[wmFileUpload]',
                template: "<div class=\"app-fileupload\" init-widget>\n    <!-- drag and drop files UI in web -->\n    <div class=\"app-multi-file-upload\" *ngIf=\"!_isMobileType && multiple\">\n        <div class=\"drop-box\" drag-files=\"onFileSelect($event,$event.target.files)\">\n            <i class=\"{{iconclass}}\"></i>\n            <div class=\"message\">\n                <label [innerHtml]=\"caption\" class=\"caption\"></label>\n                <form class=\"form-horizontal\" name=\"{{formName}}\">\n                    <input class=\"file-input\" aria-label=\"Select File\" type=\"file\" name=\"files\" *ngIf=\"multiple\" [disabled]=\"disabled\" [accept]=\"chooseFilter\" (click)=\"onFileElemClick()\" (change)=\"onFileSelect($event, $event.target.files)\" multiple >\n                    <a href=\"javascript:void(0);\" class=\"app-anchor\">{{fileUploadMessage}}</a>\n                </form>\n            </div>\n        </div>\n    </div>\n    <!-- single file upload in web and single , multiple file upload UI in mobile runmode -->\n    <div class=\"app-single-file-upload\" *ngIf=\"!_isCordova && (!multiple || _isMobileType)\">\n        <div class=\"app-button-wrapper\">\n            <form class=\"form-horizontal\" name=\"{{formName}}\">\n                <!-- support for file upload in Mobileapp in its runmode (Web) -->\n                <input class=\"file-input\" aria-label=\"Select files\" type=\"file\" name=\"files\" *ngIf=\"multiple\" [disabled]=\"disabled\" [accept]=\"chooseFilter\" (click)=\"onFileElemClick()\" (change)=\"onFileSelect($event, $event.target.files)\" multiple>\n                <input class=\"file-input\" aria-label=\"Select Files\" type=\"file\" name=\"files\" *ngIf=\"!multiple\" [disabled]=\"disabled\" [accept]=\"chooseFilter\" (click)=\"onFileElemClick()\" (change)=\"onFileSelect($event, $event.target.files)\" >\n                <button focus-target class=\"app-button btn btn-default\">\n                    <i class=\"{{iconclass}}\" aria-hidden=\"true\"></i>\n                    <span class=\"caption\">{{caption}}</span>\n                </button>\n            </form>\n        </div>\n        <div class=\"app-files-upload-status single\"></div>\n    </div>\n    <!-- support for file upload in Mobile Application (device) -->\n    <button *ngIf=\"_isCordova\" focus-target class=\"app-button btn btn-default\" (click)=\"openFileSelector()\" [disabled]=\"disabled\">\n        <i class=\"{{iconclass}}\"></i>\n        <span class=\"caption\">{{caption}}</span>\n    </button>\n    <!-- list of selectedfiles UI -->\n    <ul class=\"list-group file-upload\" [ngStyle]=\"{height: filelistheight, overflow: overflow}\" *ngIf=\"selectedFiles.length > 0\" >\n        <div *ngFor=\"let ft of selectedFiles\">\n            <li class=\"list-group-item file-upload-status\" *ngIf=\"ft.status !== 'abort'\">\n                <div class=\"media upload-file-list\">\n                    <div class=\"media-left media-middle file-icon {{getFileExtension(ft.name) | fileIconClass}}\" title=\"{{getFileExtension(ft.name)}}\"></div>\n                    <div class=\"media-body media-middle file-details\">\n                        <p class=\"uploaddetails\">\n                            <label class=\"upload-title\">{{ft.name}}</label><br/>\n                            <span class=\"filesize\" *ngIf=\"ft.fileLength  !== 0\">{{ft.size | filesize:0}}</span>\n                        </p>\n                        <div class=\"progress\" *ngIf=\"ft.status === 'onProgress'\">\n                            <div class=\"progress-bar progress-bar-striped progress-bar-info\" [ngStyle]=\"{width: (ft.progress +'%')}\"></div>\n                        </div>\n                    </div>\n                    <div class=\"media-right media-middle\" *ngIf=\"ft.status === 'onProgress' || ft.status === 'queued'\">\n                        <a class=\"btn btn-transparent file-upload-stop\" type=\"button\" (click)=\"abortFileUpload(ft)\">\n                            <i class=\"wi wi-close\"></i>\n                        </a>\n                    </div>\n                    <div class=\"media-right media-middle\"  *ngIf=\"ft.status === 'success'\">\n                        <span class=\"status-icon {{ft.status | stateClass }}\"></span>\n                    </div>\n                </div>\n            </li>\n        </div>\n    </ul>\n</div>\n",
                providers: [
                    provideAsWidgetRef(FileUploadComponent)
                ]
            }] }
];
/** @nocollapse */
FileUploadComponent.ctorParameters = () => [
    { type: Injector },
    { type: App },
    { type: undefined, decorators: [{ type: Attribute, args: ['select.event',] }] }
];

const openedDialogs = [];
/*We need closedDialogs array because onHidden event is asynchronous,
and if the user uses script and calls dialog1.close() and then dialog2.close() then
we cannot be sure if both the dialogs onClose callback will be called or not.*/
const closeDialogsArray = [];
class DialogServiceImpl {
    constructor() {
        /**
         * map which contains the references to all dialogs by name
         * @type {Map<any, any>}
         * Ex Map[[dialogName, [[dialogScope, dialogRef]]]]
         */
        this.dialogRefsCollection = new Map();
        this.appConfirmDialog = '_app-confirm-dialog';
    }
    /**
     * Register dialog by name and scope
     * @param {string} name
     * @param {BaseDialog} dialogRef
     * @param {scope}
     */
    register(name, dialogRef, scope) {
        if (!name) {
            return;
        }
        if (this.dialogRefsCollection.get(name)) {
            this.dialogRefsCollection.get(name).set(scope, dialogRef);
        }
        else {
            this.dialogRefsCollection.set(name, new Map([[scope, dialogRef]]));
        }
    }
    getDialogRefsCollection() {
        return this.dialogRefsCollection;
    }
    /**
     * De Register dialog by name and scope
     * @param name
     * @param dialogRef
     * @param scope
     */
    deRegister(name, scope) {
        if (!name) {
            return;
        }
        if (this.dialogRefsCollection.get(name)) {
            this.dialogRefsCollection.get(name).delete(scope);
        }
    }
    getDialogRef(name, scope) {
        const dialogRefMap = this.dialogRefsCollection.get(name);
        let dialogRef;
        if (scope) {
            dialogRef = dialogRefMap.get(scope);
            if (!dialogRef) {
                // Check if the scope is App level scope
                // else throw a console error
                if (!scope.pageName && !scope.partialName && !scope.prefabName) {
                    dialogRefMap.forEach((dRef, dialogScope) => {
                        // Check if the collection of dialogs have a "common" partial scope
                        // If yes use that else through a console error
                        if (dialogScope && dialogScope.partialName === 'Common') {
                            dialogRef = dRef;
                        }
                        else {
                            console.error('No dialog with the name "' + name + '" found in the App scope.');
                        }
                    });
                }
                else {
                    console.error('No dialog with the name "' + name + '" found in the given scope.');
                }
            }
        }
        else {
            if (dialogRefMap.size === 1) {
                dialogRef = dialogRefMap.entries().next().value[1];
            }
            else {
                console.error('There are multiple instances of this dialog name. Please provide the Page/Partial/App instance in which the dialog exists.');
            }
        }
        return dialogRef;
    }
    /**
     * Opens the dialog with the given name
     * @param {string} name
     */
    open(name, scope, initState) {
        const dialogRef = this.getDialogRef(name, scope);
        if (!dialogRef) {
            return;
        }
        dialogRef.open(initState);
    }
    /**
     * closes the dialog with the given name
     * @param {string} name
     */
    close(name, scope) {
        const dialogRef = this.getDialogRef(name, scope);
        if (!dialogRef) {
            return;
        }
        dialogRef.close();
    }
    /**
     * closes all the opened dialogs
     */
    closeAllDialogs() {
        _.forEach(openedDialogs.reverse(), (dialog) => {
            dialog.close();
        });
    }
    showAppConfirmDialog(initState) {
        this.open(this.getAppConfirmDialog(), undefined, initState);
    }
    closeAppConfirmDialog() {
        this.close(this.getAppConfirmDialog());
    }
    getAppConfirmDialog() {
        return this.appConfirmDialog;
    }
    setAppConfirmDialog(dialogName) {
        this.appConfirmDialog = dialogName;
    }
    addToOpenedDialogs(ref) {
        openedDialogs.push(ref);
    }
    getLastOpenedDialog() {
        return openedDialogs[openedDialogs.length - 1];
    }
    removeFromOpenedDialogs(ref) {
        if (openedDialogs.indexOf(ref) !== -1) {
            openedDialogs.splice(openedDialogs.indexOf(ref), 1);
        }
    }
    getOpenedDialogs() {
        return openedDialogs;
    }
    addToClosedDialogs(ref) {
        closeDialogsArray.push(ref);
    }
    removeFromClosedDialogs(ref) {
        if (closeDialogsArray.indexOf(ref) !== -1) {
            closeDialogsArray.splice(closeDialogsArray.indexOf(ref), 1);
        }
    }
    getDialogRefFromClosedDialogs() {
        return closeDialogsArray.splice(0, 1)[0];
    }
}
DialogServiceImpl.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DialogServiceImpl.ctorParameters = () => [];

const wmComponents = [
    // AccordionDirective,
    // AccordionPaneComponent,
    TabsComponent,
    TabPaneComponent,
    AlertDialogComponent,
    AnchorComponent,
    // AudioComponent,
    BreadcrumbComponent,
    ButtonComponent,
    ButtonGroupDirective,
    CalendarComponent,
    CardComponent,
    CardActionsDirective,
    CardContentComponent,
    CardFooterDirective,
    // CarouselDirective,
    // CarouselTemplateDirective,
    ChartComponent,
    CheckboxComponent,
    // ProgressCircleComponent,
    // ColorPickerComponent,
    CompositeDirective,
    ConfirmDialogComponent,
    ContainerDirective,
    ContentComponent,
    CurrencyComponent,
    CheckboxsetComponent,
    ChipsComponent,
    DateComponent,
    DatetimeComponent,
    DependsonDirective,
    DialogComponent,
    DialogBodyDirective,
    DialogFooterDirective,
    DialogHeaderComponent,
    FooterDirective,
    // LoginDialogDirective,
    FormActionDirective,
    FormComponent,
    FormFieldDirective,
    HeaderComponent,
    HtmlDirective,
    IconComponent,
    IframeComponent,
    IframeDialogComponent,
    InputCalendarComponent,
    InputColorComponent,
    InputEmailComponent,
    InputNumberComponent,
    InputTextComponent,
    FileUploadComponent,
    FormWidgetDirective,
    LabelDirective,
    LayoutGridColumnDirective,
    LayoutgridDirective,
    LayoutGridRowDirective,
    LazyLoadDirective,
    LeftPanelDirective,
    ListComponent,
    ListItemDirective,
    LiveActionsDirective,
    LiveFilterDirective,
    LiveFormDirective,
    LiveTableComponent,
    // LoginComponent,
    MarqueeDirective,
    MenuComponent,
    MenuDropdownComponent,
    MenuDropdownItemComponent,
    MessageComponent,
    NavbarComponent,
    NavComponent,
    NavItemDirective,
    NavigationControlDirective,
    NumberComponent,
    OnFileSelectDirective,
    PageContentComponent,
    PageDirective,
    PaginationComponent,
    PanelComponent,
    PartialDialogComponent,
    PartialDirective,
    PartialParamHandlerDirective,
    PartialParamDirective,
    PictureDirective,
    PopoverComponent,
    PrefabDirective,
    PrefabContainerDirective,
    // ProgressBarComponent,
    RadiosetComponent,
    // RatingComponent,
    RedrawableDirective,
    RichTextEditorComponent,
    RightPanelDirective,
    ScrollableDirective,
    SearchComponent,
    SelectComponent,
    ShowInDeviceDirective,
    // SliderComponent,
    SmoothScrollDirective,
    SpinnerComponent,
    SwitchComponent,
    TableActionDirective,
    TableColumnDirective,
    TableColumnGroupDirective,
    TableComponent,
    TableCUDDirective,
    TableFilterSortDirective,
    TableRowDirective,
    TableRowActionDirective,
    TextareaComponent,
    TextContentDirective,
    TileDirective,
    TimeComponent,
    TopNavDirective,
    // TreeDirective,
    // VideoComponent,
    WizardComponent,
    WizardStepDirective
];
const PIPES = [
    ToDatePipe,
    FileIconClassPipe,
    FileExtensionFromMimePipe,
    FilterPipe,
    FileSizePipe,
    ToNumberPipe,
    ToCurrencyPipe,
    PrefixPipe,
    SuffixPipe,
    TimeFromNowPipe,
    NumberToStringPipe,
    StateClassPipe,
    StringToNumberPipe,
    TrustAsPipe,
    ImagePipe
];
const bsDatePickerModule = BsDatepickerModule.forRoot();
const datepickerModule = DatepickerModule.forRoot();
const timepickerModule = TimepickerModule.forRoot();
const bsDropdownModule = BsDropdownModule.forRoot();
const paginationModule = PaginationModule.forRoot();
const typeaheadModule = TypeaheadModule.forRoot();
const progressbarModule = ProgressbarModule.forRoot();
const carouselModule = CarouselModule.forRoot();
const popoverModule = PopoverModule.forRoot();
const ngCircleProgressModule = NgCircleProgressModule.forRoot({});
class WmComponentsModule {
    static forRoot() {
        return {
            ngModule: WmComponentsModule,
            providers: [
                ToDatePipe,
                FilterPipe,
                TrustAsPipe,
                ImagePipe,
                Location,
                { provide: AbstractDialogService, useClass: DialogServiceImpl }
            ]
        };
    }
}
WmComponentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ColorPickerModule,
                    CommonModule,
                    FormsModule,
                    ModalModule,
                    SecurityModule,
                    TextMaskModule,
                    bsDatePickerModule,
                    datepickerModule,
                    timepickerModule,
                    bsDropdownModule,
                    paginationModule,
                    typeaheadModule,
                    progressbarModule,
                    carouselModule,
                    popoverModule,
                    ngCircleProgressModule
                ],
                declarations: [...wmComponents, ...PIPES],
                exports: [...wmComponents, ...PIPES],
                entryComponents: [
                    MenuComponent,
                    MenuDropdownComponent
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { ShowInDeviceDirective as ɵdm, ImagePipe as ɵde, TrustAsPipe as ɵbx, AnchorComponent as ɵf, BaseDateTimeComponent as ɵbh, BaseFormCustomComponent as ɵv, BaseFormComponent as ɵw, DatasetAwareFormComponent as ɵbf, DatasetAwareNavComponent as ɵi, MenuAdapterComponent as ɵn, TextContentDirective as ɵdy, BreadcrumbComponent as ɵh, ButtonGroupDirective as ɵk, ButtonComponent as ɵj, CalendarComponent as ɵl, CardActionsDirective as ɵq, CardContentComponent as ɵr, CardFooterDirective as ɵs, CardComponent as ɵm, ChartComponent as ɵt, CheckboxComponent as ɵu, CheckboxsetComponent as ɵbe, ChipsComponent as ɵbg, CompositeDirective as ɵx, ContainerDirective as ɵz, ContentComponent as ɵba, CurrencyComponent as ɵbb, AlertDialogComponent as ɵd, BaseDialog as ɵe, DialogBodyDirective as ɵbp, DialogFooterDirective as ɵbq, DialogHeaderComponent as ɵbr, ConfirmDialogComponent as ɵy, DialogComponent as ɵbo, IframeDialogComponent as ɵca, PartialDialogComponent as ɵcz, OnFileSelectDirective as ɵcx, FooterDirective as ɵbs, FormActionDirective as ɵbt, FormFieldDirective as ɵbu, FormWidgetDirective as ɵcg, FormComponent as ɵbj, DependsonDirective as ɵbi, LiveActionsDirective as ɵcn, LiveFilterDirective as ɵco, LiveFormDirective as ɵcp, HeaderComponent as ɵbv, HtmlDirective as ɵbw, IconComponent as ɵby, IframeComponent as ɵbz, LabelDirective as ɵci, LayoutGridColumnDirective as ɵcj, LayoutGridRowDirective as ɵcl, LayoutgridDirective as ɵck, LazyLoadDirective as ɵcm, ListItemDirective as ɵbn, ListComponent as ɵbl, LiveTableComponent as ɵcq, MarqueeDirective as ɵcr, MenuDropdownItemComponent as ɵct, MenuDropdownComponent as ɵcs, MenuComponent as ɵo, MessageComponent as ɵbk, NavItemDirective as ɵg, NavComponent as ɵp, NavigationControlDirective as ɵcv, NavbarComponent as ɵcu, NumberComponent as ɵcw, PaginationComponent as ɵbm, PanelComponent as ɵcy, PartialParamDirective as ɵdc, PartialParamHandlerDirective as ɵdb, PartialDirective as ɵda, PictureDirective as ɵdd, PopoverComponent as ɵdf, PrefabContainerDirective as ɵdg, RadiosetComponent as ɵdh, RedrawableDirective as ɵc, RichTextEditorComponent as ɵdi, RightPanelDirective as ɵdj, ScrollableDirective as ɵdk, SelectComponent as ɵdl, SmoothScrollDirective as ɵdn, SpinnerComponent as ɵdo, SwitchComponent as ɵdp, TableActionDirective as ɵdq, TableColumnGroupDirective as ɵds, TableColumnDirective as ɵdr, TableCUDDirective as ɵdt, TableFilterSortDirective as ɵdu, TableRowActionDirective as ɵdw, TableRowDirective as ɵdv, TableComponent as ɵch, TabPaneComponent as ɵb, TabsComponent as ɵa, BaseInput as ɵbd, InputCalendarComponent as ɵcb, InputColorComponent as ɵcc, InputEmailComponent as ɵcd, NumberLocale as ɵbc, InputNumberComponent as ɵce, InputTextComponent as ɵcf, TextareaComponent as ɵdx, TileDirective as ɵdz, TopNavDirective as ɵea, WizardStepDirective as ɵec, WizardComponent as ɵeb, bsDatePickerModule, datepickerModule, timepickerModule, bsDropdownModule, paginationModule, typeaheadModule, progressbarModule, carouselModule, popoverModule, ngCircleProgressModule, WmComponentsModule, getObjValueByKey, getEvaluatedData, isActiveNavItem, getOrderByExpr, isDataSetWidget, getImageUrl, getBackGroundImageUrl, provideAs, provideAsNgValidators, provideAsNgValueAccessor, provideAsWidgetRef, provideAsDialogRef, NAVIGATION_TYPE, getWatchIdentifier, getMatchModeTypesMap, getMatchModeMsgs, getConditionalClasses, prepareFieldDefs, ɵ0, ɵ1, ɵ2, ɵ3, BaseComponent, StylableComponent, DateComponent, DatetimeComponent, FileUploadComponent, AnimationType, LeftPanelDirective, PageDirective, PrefabDirective, PageContentComponent, SearchComponent, TimeComponent, APPLY_STYLES_TYPE, propNameCSSKeyMap, isStyle, styler, WidgetRef, DialogRef, Context, getWidgetPropsByType, register, PROP_TYPE, PROP_STRING, PROP_NUMBER, PROP_BOOLEAN, PROP_ANY, DialogServiceImpl, ToDatePipe, ToNumberPipe, ToCurrencyPipe, PrefixPipe, SuffixPipe, TimeFromNowPipe, NumberToStringPipe, StringToNumberPipe, FilterPipe, FileSizePipe, FileIconClassPipe, StateClassPipe, FileExtensionFromMimePipe };

//# sourceMappingURL=index.js.map