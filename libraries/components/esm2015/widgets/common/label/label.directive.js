import { Directive, Injector, SecurityContext } from '@angular/core';
import { setProperty, toggleClass } from '@wm/core';
import { styler } from '../../framework/styler';
import { registerProps } from './label.props';
import { StylableComponent } from '../base/stylable.component';
import { DISPLAY_TYPE } from '../../framework/constants';
import { provideAsWidgetRef } from '../../../utils/widget-utils';
import { TrustAsPipe } from '../../../pipes/trust-as.pipe';
const DEFAULT_CLS = 'app-label';
const WIDGET_CONFIG = {
    widgetType: 'wm-label',
    hostClass: DEFAULT_CLS,
    displayType: DISPLAY_TYPE.INLINE_BLOCK
};
export class LabelDirective extends StylableComponent {
    constructor(inj, trustAsPipe) {
        super(inj, WIDGET_CONFIG);
        this.trustAsPipe = trustAsPipe;
        styler(this.nativeElement, this);
    }
    onPropertyChange(key, nv, ov) {
        if (key === 'caption') {
            if (_.isObject(nv)) {
                setProperty(this.nativeElement, 'textContent', JSON.stringify(nv));
            }
            else {
                setProperty(this.nativeElement, 'innerHTML', this.trustAsPipe.transform(nv, SecurityContext.HTML));
            }
        }
        else if (key === 'required') {
            toggleClass(this.nativeElement, 'required', nv);
        }
        else {
            super.onPropertyChange(key, nv, ov);
        }
    }
}
LabelDirective.initializeProps = registerProps();
LabelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wmLabel]',
                providers: [
                    provideAsWidgetRef(LabelDirective)
                ]
            },] }
];
/** @nocollapse */
LabelDirective.ctorParameters = () => [
    { type: Injector },
    { type: TrustAsPipe }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFiZWwuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHdtL2NvbXBvbmVudHMvIiwic291cmNlcyI6WyJ3aWRnZXRzL2NvbW1vbi9sYWJlbC9sYWJlbC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXJFLE9BQU8sRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRXBELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUVoRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzlDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUNqRSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFJM0QsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDO0FBQ2hDLE1BQU0sYUFBYSxHQUFrQjtJQUNqQyxVQUFVLEVBQUUsVUFBVTtJQUN0QixTQUFTLEVBQUUsV0FBVztJQUN0QixXQUFXLEVBQUUsWUFBWSxDQUFDLFlBQVk7Q0FDekMsQ0FBQztBQVFGLE1BQU0sT0FBTyxjQUFlLFNBQVEsaUJBQWlCO0lBR2pELFlBQVksR0FBYSxFQUFVLFdBQXdCO1FBQ3ZELEtBQUssQ0FBQyxHQUFHLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFESyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUd2RCxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFHO1FBRXpCLElBQUksR0FBRyxLQUFLLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUU7Z0JBQ2hCLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDdEU7aUJBQU07Z0JBQ0gsV0FBVyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUN0RztTQUVKO2FBQU0sSUFBSSxHQUFHLEtBQUssVUFBVSxFQUFFO1lBQzNCLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNuRDthQUFNO1lBQ0gsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDdkM7SUFDTCxDQUFDOztBQXRCTSw4QkFBZSxHQUFHLGFBQWEsRUFBRSxDQUFDOztZQVA1QyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFdBQVc7Z0JBQ3JCLFNBQVMsRUFBRTtvQkFDUCxrQkFBa0IsQ0FBQyxjQUFjLENBQUM7aUJBQ3JDO2FBQ0o7Ozs7WUExQm1CLFFBQVE7WUFVbkIsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5qZWN0b3IsIFNlY3VyaXR5Q29udGV4dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBzZXRQcm9wZXJ0eSwgdG9nZ2xlQ2xhc3MgfSBmcm9tICdAd20vY29yZSc7XG5cbmltcG9ydCB7IHN0eWxlciB9IGZyb20gJy4uLy4uL2ZyYW1ld29yay9zdHlsZXInO1xuaW1wb3J0IHsgSVdpZGdldENvbmZpZyB9IGZyb20gJy4uLy4uL2ZyYW1ld29yay90eXBlcyc7XG5pbXBvcnQgeyByZWdpc3RlclByb3BzIH0gZnJvbSAnLi9sYWJlbC5wcm9wcyc7XG5pbXBvcnQgeyBTdHlsYWJsZUNvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2Uvc3R5bGFibGUuY29tcG9uZW50JztcbmltcG9ydCB7IERJU1BMQVlfVFlQRSB9IGZyb20gJy4uLy4uL2ZyYW1ld29yay9jb25zdGFudHMnO1xuaW1wb3J0IHsgcHJvdmlkZUFzV2lkZ2V0UmVmIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvd2lkZ2V0LXV0aWxzJztcbmltcG9ydCB7IFRydXN0QXNQaXBlIH0gZnJvbSAnLi4vLi4vLi4vcGlwZXMvdHJ1c3QtYXMucGlwZSc7XG5cbmRlY2xhcmUgY29uc3QgXztcblxuY29uc3QgREVGQVVMVF9DTFMgPSAnYXBwLWxhYmVsJztcbmNvbnN0IFdJREdFVF9DT05GSUc6IElXaWRnZXRDb25maWcgPSB7XG4gICAgd2lkZ2V0VHlwZTogJ3dtLWxhYmVsJyxcbiAgICBob3N0Q2xhc3M6IERFRkFVTFRfQ0xTLFxuICAgIGRpc3BsYXlUeXBlOiBESVNQTEFZX1RZUEUuSU5MSU5FX0JMT0NLXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t3bUxhYmVsXScsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHByb3ZpZGVBc1dpZGdldFJlZihMYWJlbERpcmVjdGl2ZSlcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIExhYmVsRGlyZWN0aXZlIGV4dGVuZHMgU3R5bGFibGVDb21wb25lbnQge1xuICAgIHN0YXRpYyBpbml0aWFsaXplUHJvcHMgPSByZWdpc3RlclByb3BzKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihpbmo6IEluamVjdG9yLCBwcml2YXRlIHRydXN0QXNQaXBlOiBUcnVzdEFzUGlwZSkge1xuICAgICAgICBzdXBlcihpbmosIFdJREdFVF9DT05GSUcpO1xuXG4gICAgICAgIHN0eWxlcih0aGlzLm5hdGl2ZUVsZW1lbnQsIHRoaXMpO1xuICAgIH1cblxuICAgIG9uUHJvcGVydHlDaGFuZ2Uoa2V5LCBudiwgb3Y/KSB7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NhcHRpb24nKSB7XG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChudikpIHtcbiAgICAgICAgICAgICAgICBzZXRQcm9wZXJ0eSh0aGlzLm5hdGl2ZUVsZW1lbnQsICd0ZXh0Q29udGVudCcsIEpTT04uc3RyaW5naWZ5KG52KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFByb3BlcnR5KHRoaXMubmF0aXZlRWxlbWVudCwgJ2lubmVySFRNTCcsIHRoaXMudHJ1c3RBc1BpcGUudHJhbnNmb3JtKG52LCBTZWN1cml0eUNvbnRleHQuSFRNTCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLm5hdGl2ZUVsZW1lbnQsICdyZXF1aXJlZCcsIG52KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLm9uUHJvcGVydHlDaGFuZ2Uoa2V5LCBudiwgb3YpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19