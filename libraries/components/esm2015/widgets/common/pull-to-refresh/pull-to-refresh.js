import { SwipeAnimation } from '@swipey';
import { isIos, setCSS } from '@wm/core';
export class PullToRefresh extends SwipeAnimation {
    constructor($el, app, onPullToRefresh) {
        super();
        this.$el = $el;
        this.app = app;
        this.onPullToRefresh = onPullToRefresh;
        this.count = 0;
        const template = '<div class="refresh-container"></div>';
        this.$el.prepend(template);
        this.infoContainer = this.$el.find('.refresh-container');
        if (isIos()) {
            this.infoContainer.addClass('ios-refresh-container');
        }
        this.init(this.$el);
    }
    threshold() {
        return 10;
    }
    direction() {
        return $.fn.swipey.DIRECTIONS.VERTICAL;
    }
    subscribe() {
        // Subscribing for variable updates, wait till the response and stop the animation.
        this.cancelSubscription = this.app.subscribe('toggle-variable-state', (data) => {
            // data.active is true means the variable update has just started whereas false means update has ended.
            if (data.active && this.animationInProgress) {
                this.count++;
                this.wait();
            }
            else if (this.count > 0) {
                this.count--;
            }
            // call stop animation only when animation has started.
            if (!this.count && this.animationInProgress) {
                this.stopAnimation();
            }
        });
    }
    bounds($event, $d) {
        const pageIscroll = this.$el[0].iscroll;
        // If scroll position is not at the top of the page then do not trigger the animation.
        if ($d < 0 || (pageIscroll && !isNaN(pageIscroll.y) && pageIscroll.y !== 0)) {
            return {
                lower: undefined,
                upper: undefined
            };
        }
        if (!this.spinner) {
            this.spinner = isIos() ? new IOSSpinner(this.infoContainer) : new AndroidSpinner(this.infoContainer);
            this.subscribe();
        }
        return {
            lower: 0,
            center: 0,
            upper: isIos() ? 0 : 150,
            strict: !isIos()
        };
    }
    context() {
        this.infoContainer.show();
        if (isIos()) {
            this.infoContainer.addClass('entry');
        }
        return {
            spin: $d => {
                this.spinner.setRotation($d * 2);
            }
        };
    }
    animation() {
        if (isIos()) {
            return {
                css: {
                    transform: 'translate3d(0, ${{$D + $d}}px, 0)',
                    spin: '${{spin($d)}}'
                }
            };
        }
        return {
            target: this.infoContainer,
            css: {
                transform: 'translate3d(0, ${{$D + $d}}px, 0)',
                spin: '${{spin($d)}}',
                opacity: '${{min(($D + $d) / 100, 1)}}'
            }
        };
    }
    // Start the spinner animation and invokes the pulltorefresh event. Stops the animation after the wait time.
    onAnimation() {
        this.animationInProgress = true;
        this.spinner.start();
        if (this.onPullToRefresh) {
            this.onPullToRefresh();
        }
        setTimeout(() => {
            // if listenToAnimation is set, then wait for stopAnimation to be invoked. Otherwise call stopAnimation manually.
            if (this.runAnimation) {
                return;
            }
            this.stopAnimation();
        });
    }
    stopAnimation() {
        setTimeout(() => {
            this.runAnimation = false;
            this.animationInProgress = false;
            this.spinner.stop();
            this.infoContainer.hide();
            setCSS(this.infoContainer[0], 'transform', 'none');
            if (!isIos()) {
                setCSS(this.infoContainer[0], 'opacity', 0);
            }
            this.infoContainer.removeClass('entry');
        }, 800);
    }
    wait() {
        this.runAnimation = true;
    }
}
// Android Spinner implementation
class AndroidSpinner {
    constructor($el, options) {
        this.$el = $el;
        this.options = options || {};
    }
    polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY + (radius * Math.sin(angleInRadians))
        };
    }
    describeArc(x, y, radius, startAngle, endAngle) {
        const start = this.polarToCartesian(x, y, radius, endAngle);
        const end = this.polarToCartesian(x, y, radius, startAngle);
        const arcSweep = endAngle - startAngle <= 180 ? '0' : '1';
        return [
            'M', start.x, start.y,
            'A', radius, radius, 0, arcSweep, 0, end.x, end.y,
            'L', end.x, end.y
        ].join(' ');
    }
    init() {
        if (this.initialized) {
            return;
        }
        // append the svg to the element on which spinner has to be shown.
        const androidTemplate = $('<svg><path id="arc1"/></svg>');
        const container = $('<div class="android-spinner"></div>');
        container.append(androidTemplate);
        this.$el.append(container);
        this.cx = container.outerWidth() / 2;
        this.cy = container.outerHeight() / 2;
        this.r = this.cx * 0.6;
        this.path = container.find('path');
        this.initialized = true;
        this.container = container;
    }
    // sets rotation to the path
    setRotation(deg) {
        this.init();
        this.path.attr('d', this.describeArc(this.cx, this.cy, this.r, 0, deg));
    }
    // animate the path to rotate continuously with some interval
    start() {
        this.init();
        const self = this, totalTime = this.options.time || 1800, degreesToTraverse = 10;
        let i = 0;
        this.container.addClass('spin');
        this.intervalId = setInterval(() => {
            let deg;
            i = i + degreesToTraverse;
            if (i > 720) {
                deg = i = 0;
            }
            else if (i > 360) {
                deg = 720 - i;
            }
            else {
                deg = i;
            }
            self.path.attr('d', this.describeArc(self.cx, self.cy, self.r, 0, deg));
        }, (totalTime * degreesToTraverse / 360));
    }
    // Removes the animation by clearing the intervals
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = 0;
        }
        this.container.removeClass('spin');
    }
}
// iOS spinner implementation
class IOSSpinner {
    constructor($el) {
        this.$el = $el;
    }
    // create the iOS spinner using svg
    init() {
        if (this.svg) {
            return;
        }
        const container = $('<div class="ios-spinner"><svg></svg></div>');
        const svg = container.find('svg');
        this.$el.append(container);
        const d = container.width();
        for (let i = 0; i < 12; i++) {
            svg[0].innerHTML += `<line y1="${0.15 * d}" y2="${0.3 * d}"
                                    transform="translate(${0.5 * d}, ${0.5 * d}) rotate(${i * 30})">
                                </line>`;
        }
        container.append(svg);
        this.svg = svg;
    }
    // Sets the svg to rotate depending on "d" value
    setRotation(d) {
        this.init();
        this.svg.css('transform', `rotateZ( ${Math.round(d / 30) * 30}deg)`);
    }
    // Triggers the rotation with some interval
    start() {
        this.init();
        let i = 0;
        this.intervalId = setInterval(() => {
            i += 10;
            this.setRotation(i);
        }, 20);
    }
    // Removes the animation by clearing the intervals
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = 0;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVsbC10by1yZWZyZXNoLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHdtL2NvbXBvbmVudHMvIiwic291cmNlcyI6WyJ3aWRnZXRzL2NvbW1vbi9wdWxsLXRvLXJlZnJlc2gvcHVsbC10by1yZWZyZXNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFekMsT0FBTyxFQUFPLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFJOUMsTUFBTSxPQUFPLGFBQWMsU0FBUSxjQUFjO0lBUTdDLFlBQW9CLEdBQXdCLEVBQVUsR0FBUSxFQUFVLGVBQTJCO1FBQy9GLEtBQUssRUFBRSxDQUFDO1FBRFEsUUFBRyxHQUFILEdBQUcsQ0FBcUI7UUFBVSxRQUFHLEdBQUgsR0FBRyxDQUFLO1FBQVUsb0JBQWUsR0FBZixlQUFlLENBQVk7UUFMM0YsVUFBSyxHQUFHLENBQUMsQ0FBQztRQU9kLE1BQU0sUUFBUSxHQUFHLHVDQUF1QyxDQUFDO1FBQ3pELElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzNCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUV6RCxJQUFJLEtBQUssRUFBRSxFQUFFO1lBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUMsQ0FBQztTQUN4RDtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFTSxTQUFTO1FBQ1osT0FBTyxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRU0sU0FBUztRQUNaLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQztJQUMzQyxDQUFDO0lBRU8sU0FBUztRQUNiLG1GQUFtRjtRQUNuRixJ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QixDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRUQsa0RBQWtEO0lBQzNDLElBQUk7UUFDUCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDakIsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQztTQUN2QjtJQUNMLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN3aXBlQW5pbWF0aW9uIH0gZnJvbSAnQHN3aXBleSc7XG5cbmltcG9ydCB7IEFwcCwgaXNJb3MsIHNldENTUyB9IGZyb20gJ0B3bS9jb3JlJztcblxuZGVjbGFyZSBjb25zdCAkO1xuXG5leHBvcnQgY2xhc3MgUHVsbFRvUmVmcmVzaCBleHRlbmRzIFN3aXBlQW5pbWF0aW9uIHtcbiAgICBwcml2YXRlIGluZm9Db250YWluZXI6IEpRdWVyeTxIVE1MRWxlbWVudD47XG4gICAgcHJpdmF0ZSBydW5BbmltYXRpb246IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBjb3VudCA9IDA7XG4gICAgcHJpdmF0ZSBzcGlubmVyOiBTcGlubmVyO1xuICAgIHB1YmxpYyBjYW5jZWxTdWJzY3JpcHRpb246IEZ1bmN0aW9uO1xuICAgIHByaXZhdGUgYW5pbWF0aW9uSW5Qcm9ncmVzczogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgJGVsOiBKUXVlcnk8SFRNTEVsZW1lbnQ+LCBwcml2YXRlIGFwcDogQXBwLCBwcml2YXRlIG9uUHVsbFRvUmVmcmVzaDogKCkgPT4gdm9pZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwicmVmcmVzaC1jb250YWluZXJcIj48L2Rpdj4nO1xuICAgICAgICB0aGlzLiRlbC5wcmVwZW5kKHRlbXBsYXRlKTtcbiAgICAgICAgdGhpcy5pbmZvQ29udGFpbmVyID0gdGhpcy4kZWwuZmluZCgnLnJlZnJlc2gtY29udGFpbmVyJyk7XG5cbiAgICAgICAgaWYgKGlzSW9zKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mb0NvbnRhaW5lci5hZGRDbGFzcygnaW9zLXJlZnJlc2gtY29udGFpbmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXQodGhpcy4kZWwpO1xuICAgIH1cblxuICAgIHB1YmxpYyB0aHJlc2hvbGQoKSB7XG4gICAgICAgIHJldHVybiAxMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJC5mbi5zd2lwZXkuRElSRUNUSU9OUy5WRVJUSUNBTDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN1YnNjcmliZSgpIHtcbiAgICAgICAgLy8gU3Vic2NyaWJpbmcgZm9yIHZhcmlhYmxlIHVwZGF0ZXMsIHdhaXQgdGlsbCB0aGUgcmVzcG9uc2UgYW5kIHN0b3AgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgdGhpcy5jYW5jZWxTdWJzY3JpcHRpb24gPSB0aGlzLmFwcC5zdWJzY3JpYmUoJ3RvZ2dsZS12YXJpYWJsZS1zdGF0ZScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBkYXRhLmFjdGl2ZSBpcyB0cnVlIG1lYW5zIHRoZSB2YXJpYWJsZSB1cGRhdGUgaGFzIGp1c3Qgc3RhcnRlZCB3aGVyZWFzIGZhbHNlIG1lYW5zIHVwZGF0ZSBoYXMgZW5kZWQuXG4gICAgICAgICAgICBpZiAoZGF0YS5hY3RpdmUgJiYgdGhpcy5hbmltYXRpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGwgc3RvcCBhbmltYXRpb24gb25seSB3aGVuIGFuaW1hdGlvbiBoYXMgc3RhcnRlZC5cbiAgICAgICAgICAgIGlmICghdGhpcy5jb3VudCAmJiB0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGJvdW5kcygkZXZlbnQsICRkKSB7XG4gICAgICAgIGNvbnN0IHBhZ2VJc2Nyb2xsID0gKHRoaXMuJGVsWzBdIGFzIGFueSkuaXNjcm9sbDtcbiAgICAgICAgLy8gSWYgc2Nyb2xsIHBvc2l0aW9uIGlzIG5vdCBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlIHRoZW4gZG8gbm90IHRyaWdnZXIgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgaWYgKCRkIDwgMCB8fCAocGFnZUlzY3JvbGwgJiYgIWlzTmFOKHBhZ2VJc2Nyb2xsLnkpICYmIHBhZ2VJc2Nyb2xsLnkgIT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvd2VyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdXBwZXI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3Bpbm5lcikge1xuICAgICAgICAgICAgdGhpcy5zcGlubmVyID0gaXNJb3MoKSA/IG5ldyBJT1NTcGlubmVyKHRoaXMuaW5mb0NvbnRhaW5lcikgOiBuZXcgQW5kcm9pZFNwaW5uZXIodGhpcy5pbmZvQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG93ZXI6IDAsXG4gICAgICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgICAgICB1cHBlcjogaXNJb3MoKSA/IDAgOiAxNTAsXG4gICAgICAgICAgICBzdHJpY3Q6ICFpc0lvcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIGNvbnRleHQoKTogT2JqZWN0IHtcbiAgICAgICAgdGhpcy5pbmZvQ29udGFpbmVyLnNob3coKTtcbiAgICAgICAgaWYgKGlzSW9zKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mb0NvbnRhaW5lci5hZGRDbGFzcygnZW50cnknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BpbjogJGQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Bpbm5lci5zZXRSb3RhdGlvbigkZCAqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBhbmltYXRpb24oKSB7XG4gICAgICAgIGlmIChpc0lvcygpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAke3skRCArICRkfX1weCwgMCknLFxuICAgICAgICAgICAgICAgICAgICBzcGluOiAnJHt7c3BpbigkZCl9fSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuaW5mb0NvbnRhaW5lcixcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsICR7eyREICsgJGR9fXB4LCAwKScsXG4gICAgICAgICAgICAgICAgc3BpbjogJyR7e3NwaW4oJGQpfX0nLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICcke3ttaW4oKCREICsgJGQpIC8gMTAwLCAxKX19J1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRoZSBzcGlubmVyIGFuaW1hdGlvbiBhbmQgaW52b2tlcyB0aGUgcHVsbHRvcmVmcmVzaCBldmVudC4gU3RvcHMgdGhlIGFuaW1hdGlvbiBhZnRlciB0aGUgd2FpdCB0aW1lLlxuICAgIHB1YmxpYyBvbkFuaW1hdGlvbigpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zcGlubmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmICh0aGlzLm9uUHVsbFRvUmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy5vblB1bGxUb1JlZnJlc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbGlzdGVuVG9BbmltYXRpb24gaXMgc2V0LCB0aGVuIHdhaXQgZm9yIHN0b3BBbmltYXRpb24gdG8gYmUgaW52b2tlZC4gT3RoZXJ3aXNlIGNhbGwgc3RvcEFuaW1hdGlvbiBtYW51YWxseS5cbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bkFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RvcEFuaW1hdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ1bkFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5pbmZvQ29udGFpbmVyLmhpZGUoKTtcbiAgICAgICAgICAgIHNldENTUyh0aGlzLmluZm9Db250YWluZXJbMF0sICd0cmFuc2Zvcm0nLCAnbm9uZScpO1xuICAgICAgICAgICAgaWYgKCFpc0lvcygpKSB7XG4gICAgICAgICAgICAgICAgc2V0Q1NTKHRoaXMuaW5mb0NvbnRhaW5lclswXSwgJ29wYWNpdHknLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5mb0NvbnRhaW5lci5yZW1vdmVDbGFzcygnZW50cnknKTtcbiAgICAgICAgfSwgODAwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgd2FpdCgpIHtcbiAgICAgICAgdGhpcy5ydW5BbmltYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cblxuLy8gSW50ZXJmYWNlIGZvciBTcGlubmVyXG5pbnRlcmZhY2UgU3Bpbm5lciB7XG4gICAgc3RhcnQoKTtcbiAgICBzdG9wKCk7XG4gICAgc2V0Um90YXRpb24oZDogbnVtYmVyKTtcbn1cblxuLy8gQW5kcm9pZCBTcGlubmVyIGltcGxlbWVudGF0aW9uXG5jbGFzcyBBbmRyb2lkU3Bpbm5lciBpbXBsZW1lbnRzIFNwaW5uZXIge1xuICAgIHByaXZhdGUgb3B0aW9uczogT2JqZWN0O1xuICAgIHByaXZhdGUgaW5pdGlhbGl6ZWQ6IGFueTtcbiAgICBwcml2YXRlIGN4OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBjeTogbnVtYmVyO1xuICAgIHByaXZhdGUgcjogbnVtYmVyO1xuICAgIHByaXZhdGUgcGF0aDogYW55O1xuICAgIHByaXZhdGUgaW50ZXJ2YWxJZDtcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogYW55O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSAkZWw6IEpRdWVyeTxIVE1MRWxlbWVudD4sIG9wdGlvbnM/OiBhbnkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgcG9sYXJUb0NhcnRlc2lhbihjZW50ZXJYOiBudW1iZXIsIGNlbnRlclk6IG51bWJlciwgcmFkaXVzOiBudW1iZXIsIGFuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBhbnkge1xuICAgICAgICBjb25zdCBhbmdsZUluUmFkaWFucyA9IChhbmdsZUluRGVncmVlcyAtIDkwKSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNlbnRlclggKyAocmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpKSxcbiAgICAgICAgICAgIHk6IGNlbnRlclkgKyAocmFkaXVzICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgZGVzY3JpYmVBcmMoeDogbnVtYmVyLCB5OiBudW1iZXIsIHJhZGl1czogbnVtYmVyLCBzdGFydEFuZ2xlOiBudW1iZXIsIGVuZEFuZ2xlOiBudW1iZXIpOiBzdHJpbmcge1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5wb2xhclRvQ2FydGVzaWFuKHgsIHksIHJhZGl1cywgZW5kQW5nbGUpO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLnBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlKTtcblxuICAgICAgICBjb25zdCBhcmNTd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSA8PSAxODAgPyAnMCcgOiAnMSc7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdNJywgc3RhcnQueCwgc3RhcnQueSxcbiAgICAgICAgICAgICdBJywgcmFkaXVzLCByYWRpdXMsIDAsIGFyY1N3ZWVwLCAwLCBlbmQueCwgZW5kLnksXG4gICAgICAgICAgICAnTCcsIGVuZC54LCBlbmQueVxuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgdGhlIHN2ZyB0byB0aGUgZWxlbWVudCBvbiB3aGljaCBzcGlubmVyIGhhcyB0byBiZSBzaG93bi5cbiAgICAgICAgY29uc3QgYW5kcm9pZFRlbXBsYXRlID0gJCgnPHN2Zz48cGF0aCBpZD1cImFyYzFcIi8+PC9zdmc+Jyk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XCJhbmRyb2lkLXNwaW5uZXJcIj48L2Rpdj4nKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZChhbmRyb2lkVGVtcGxhdGUpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5jeCA9IGNvbnRhaW5lci5vdXRlcldpZHRoKCkgLyAyO1xuICAgICAgICB0aGlzLmN5ID0gY29udGFpbmVyLm91dGVySGVpZ2h0KCkgLyAyO1xuICAgICAgICB0aGlzLnIgPSB0aGlzLmN4ICogMC42O1xuICAgICAgICB0aGlzLnBhdGggPSBjb250YWluZXIuZmluZCgncGF0aCcpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuXG4gICAgLy8gc2V0cyByb3RhdGlvbiB0byB0aGUgcGF0aFxuICAgIHB1YmxpYyBzZXRSb3RhdGlvbihkZWcpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMucGF0aC5hdHRyKCdkJywgdGhpcy5kZXNjcmliZUFyYyh0aGlzLmN4LCB0aGlzLmN5LCB0aGlzLnIsIDAsIGRlZykpO1xuICAgIH1cblxuICAgIC8vIGFuaW1hdGUgdGhlIHBhdGggdG8gcm90YXRlIGNvbnRpbnVvdXNseSB3aXRoIHNvbWUgaW50ZXJ2YWxcbiAgICBwdWJsaWMgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHRvdGFsVGltZSA9ICh0aGlzLm9wdGlvbnMgYXMgYW55KS50aW1lIHx8IDE4MDAsXG4gICAgICAgICAgICBkZWdyZWVzVG9UcmF2ZXJzZSA9IDEwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdzcGluJyk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBkZWc7XG4gICAgICAgICAgICBpID0gaSArIGRlZ3JlZXNUb1RyYXZlcnNlO1xuICAgICAgICAgICAgaWYgKGkgPiA3MjApIHtcbiAgICAgICAgICAgICAgICBkZWcgPSBpID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDM2MCkge1xuICAgICAgICAgICAgICAgIGRlZyA9IDcyMCAtIGk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZyA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnBhdGguYXR0cignZCcsIHRoaXMuZGVzY3JpYmVBcmMoc2VsZi5jeCwgc2VsZi5jeSwgc2VsZi5yLCAwLCBkZWcpKTtcbiAgICAgICAgfSwgKHRvdGFsVGltZSAqIGRlZ3JlZXNUb1RyYXZlcnNlIC8gMzYwKSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlcyB0aGUgYW5pbWF0aW9uIGJ5IGNsZWFyaW5nIHRoZSBpbnRlcnZhbHNcbiAgICBwdWJsaWMgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnc3BpbicpO1xuICAgIH1cbn1cblxuLy8gaU9TIHNwaW5uZXIgaW1wbGVtZW50YXRpb25cbmNsYXNzIElPU1NwaW5uZXIgaW1wbGVtZW50cyBTcGlubmVyIHtcbiAgICBwcml2YXRlIHN2ZzogYW55O1xuICAgIHByaXZhdGUgaW50ZXJ2YWxJZDogYW55O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSAkZWwpIHt9XG5cbiAgICAvLyBjcmVhdGUgdGhlIGlPUyBzcGlubmVyIHVzaW5nIHN2Z1xuICAgIHByaXZhdGUgaW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gJCgnPGRpdiBjbGFzcz1cImlvcy1zcGlubmVyXCI+PHN2Zz48L3N2Zz48L2Rpdj4nKTtcbiAgICAgICAgY29uc3Qgc3ZnID0gY29udGFpbmVyLmZpbmQoJ3N2ZycpO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoY29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgZCA9IGNvbnRhaW5lci53aWR0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHN2Z1swXS5pbm5lckhUTUwgKz0gYDxsaW5lIHkxPVwiJHswLjE1ICogZH1cIiB5Mj1cIiR7MC4zICogZH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKCR7MC41ICogZH0sICR7MC41ICogZH0pIHJvdGF0ZSgke2kgKiAzMH0pXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGluZT5gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICAgICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgc3ZnIHRvIHJvdGF0ZSBkZXBlbmRpbmcgb24gXCJkXCIgdmFsdWVcbiAgICBwdWJsaWMgc2V0Um90YXRpb24oZDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLnN2Zy5jc3MoJ3RyYW5zZm9ybScsIGByb3RhdGVaKCAke01hdGgucm91bmQoZCAvIDMwKSAqIDMwfWRlZylgKTtcbiAgICB9XG5cbiAgICAvLyBUcmlnZ2VycyB0aGUgcm90YXRpb24gd2l0aCBzb21lIGludGVydmFsXG4gICAgcHVibGljIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBpICs9IDEwO1xuICAgICAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihpKTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZXMgdGhlIGFuaW1hdGlvbiBieSBjbGVhcmluZyB0aGUgaW50ZXJ2YWxzXG4gICAgcHVibGljIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=