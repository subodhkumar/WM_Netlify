import { IDGenerator, updateTemplateAttrs } from '@wm/core';
import { getAttrMarkup, getBoundToExpr, register } from '@wm/transpiler';
const tagName = 'div';
const dataSetKey = 'dataset';
const idGen = new IDGenerator('table_');
register('wm-table', () => {
    return {
        template: (node, shared) => {
            // If table does not have child columns, set isdynamictable to true
            if (node.children.length) {
                const isColumnsPresent = node.children.some(childNode => {
                    return childNode.name === 'wm-table-column' || childNode.name === 'wm-table-column-group';
                });
                shared.set('isdynamictable', isColumnsPresent ? 'false' : 'true');
            }
            else {
                shared.set('isdynamictable', 'true');
            }
            const datasetAttr = node.attrs.find(attr => attr.name === dataSetKey);
            const widgetNameAttr = node.attrs.find(attr => attr.name === 'name');
            if (!datasetAttr) {
                return;
            }
            const boundExpr = getBoundToExpr(datasetAttr.value);
            if (!boundExpr) {
                return;
            }
            updateTemplateAttrs(node, boundExpr, widgetNameAttr.value, '', 'row');
        },
        pre: (attrs, shared) => {
            const counter = idGen.nextUid();
            shared.set('counter', counter);
            attrs.set('isdynamictable', shared.get('isdynamictable'));
            return `<${tagName} wmTable="${counter}" wmTableFilterSort wmTableCUD #${counter} data-identifier="table" role="table" ${getAttrMarkup(attrs)}>`;
        },
        post: () => `</${tagName}>`,
        provide: (attrs, shared) => {
            const provider = new Map();
            provider.set('table_reference', shared.get('counter'));
            provider.set('filtermode', attrs.get('filtermode'));
            provider.set('editmode', attrs.get('editmode'));
            provider.set('shownewrow', attrs.get('shownewrow'));
            return provider;
        }
    };
});
export default () => { };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuYnVpbGQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ad20vY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbIndpZGdldHMvY29tbW9uL3RhYmxlL3RhYmxlLmJ1aWxkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxXQUFXLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDNUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQWlCLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXhGLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQztBQUN0QixNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUM7QUFDN0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7QUFFeEMsUUFBUSxDQUFDLFVBQVUsRUFBRSxHQUFrQixFQUFFO0lBQ3JDLE9BQU87UUFDSCxRQUFRLEVBQUUsQ0FBQyxJQUFhLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDaEMsbUVBQW1FO1lBQ25FLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7Z0JBQ3RCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7b0JBQ3BELE9BQWEsU0FBVSxDQUFDLElBQUksS0FBSyxpQkFBaUIsSUFBVSxTQUFVLENBQUMsSUFBSSxLQUFLLHVCQUF1QixDQUFDO2dCQUM1RyxDQUFDLENBQUMsQ0FBQztnQkFDSCxNQUFNLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3JFO2lCQUFNO2dCQUNILE1BQU0sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDeEM7WUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDLENBQUM7WUFDdEUsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxDQUFDO1lBRXJFLElBQUksQ0FBQyxXQUFXLEVBQUU7Z0JBQ2QsT0FBTzthQUNWO1lBQ0QsTUFBTSxTQUFTLEdBQUcsY0FBYyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUVwRCxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNaLE9BQU87YUFDVjtZQUNELG1CQUFtQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsY0FBYyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDMUUsQ0FBQztRQUNELEdBQUcsRUFBRSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUNuQixNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDaEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDL0IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQztZQUMxRCxPQUFPLElBQUksT0FBTyxhQUFhLE9BQU8sbUNBQW1DLE9BQU8seUNBQXlDLGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3JKLENBQUM7UUFDRCxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSyxPQUFPLEdBQUc7UUFDM0IsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3ZCLE1BQU0sUUFBUSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7WUFDM0IsUUFBUSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsUUFBUSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ3BELFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNoRCxRQUFRLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDcEQsT0FBTyxRQUFRLENBQUM7UUFDcEIsQ0FBQztLQUNKLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQztBQUVILGVBQWUsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyJztcblxuaW1wb3J0IHsgSURHZW5lcmF0b3IsIHVwZGF0ZVRlbXBsYXRlQXR0cnMgfSBmcm9tICdAd20vY29yZSc7XG5pbXBvcnQgeyBnZXRBdHRyTWFya3VwLCBnZXRCb3VuZFRvRXhwciwgSUJ1aWxkVGFza0RlZiwgcmVnaXN0ZXIgfSBmcm9tICdAd20vdHJhbnNwaWxlcic7XG5cbmNvbnN0IHRhZ05hbWUgPSAnZGl2JztcbmNvbnN0IGRhdGFTZXRLZXkgPSAnZGF0YXNldCc7XG5jb25zdCBpZEdlbiA9IG5ldyBJREdlbmVyYXRvcigndGFibGVfJyk7XG5cbnJlZ2lzdGVyKCd3bS10YWJsZScsICgpOiBJQnVpbGRUYXNrRGVmID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZW1wbGF0ZTogKG5vZGU6IEVsZW1lbnQsIHNoYXJlZCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGFibGUgZG9lcyBub3QgaGF2ZSBjaGlsZCBjb2x1bW5zLCBzZXQgaXNkeW5hbWljdGFibGUgdG8gdHJ1ZVxuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb2x1bW5zUHJlc2VudCA9IG5vZGUuY2hpbGRyZW4uc29tZShjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDxhbnk+Y2hpbGROb2RlKS5uYW1lID09PSAnd20tdGFibGUtY29sdW1uJyB8fCAoPGFueT5jaGlsZE5vZGUpLm5hbWUgPT09ICd3bS10YWJsZS1jb2x1bW4tZ3JvdXAnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNoYXJlZC5zZXQoJ2lzZHluYW1pY3RhYmxlJywgaXNDb2x1bW5zUHJlc2VudCA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFyZWQuc2V0KCdpc2R5bmFtaWN0YWJsZScsICd0cnVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXRBdHRyID0gbm9kZS5hdHRycy5maW5kKGF0dHIgPT4gYXR0ci5uYW1lID09PSBkYXRhU2V0S2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHdpZGdldE5hbWVBdHRyID0gbm9kZS5hdHRycy5maW5kKGF0dHIgPT4gYXR0ci5uYW1lID09PSAnbmFtZScpO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGFzZXRBdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm91bmRFeHByID0gZ2V0Qm91bmRUb0V4cHIoZGF0YXNldEF0dHIudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoIWJvdW5kRXhwcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVRlbXBsYXRlQXR0cnMobm9kZSwgYm91bmRFeHByLCB3aWRnZXROYW1lQXR0ci52YWx1ZSwgJycsICdyb3cnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlOiAoYXR0cnMsIHNoYXJlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY291bnRlciA9IGlkR2VuLm5leHRVaWQoKTtcbiAgICAgICAgICAgIHNoYXJlZC5zZXQoJ2NvdW50ZXInLCBjb3VudGVyKTtcbiAgICAgICAgICAgIGF0dHJzLnNldCgnaXNkeW5hbWljdGFibGUnLCBzaGFyZWQuZ2V0KCdpc2R5bmFtaWN0YWJsZScpKTtcbiAgICAgICAgICAgIHJldHVybiBgPCR7dGFnTmFtZX0gd21UYWJsZT1cIiR7Y291bnRlcn1cIiB3bVRhYmxlRmlsdGVyU29ydCB3bVRhYmxlQ1VEICMke2NvdW50ZXJ9IGRhdGEtaWRlbnRpZmllcj1cInRhYmxlXCIgcm9sZT1cInRhYmxlXCIgJHtnZXRBdHRyTWFya3VwKGF0dHJzKX0+YDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdDogKCkgPT4gYDwvJHt0YWdOYW1lfT5gLFxuICAgICAgICBwcm92aWRlOiAoYXR0cnMsIHNoYXJlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBwcm92aWRlci5zZXQoJ3RhYmxlX3JlZmVyZW5jZScsIHNoYXJlZC5nZXQoJ2NvdW50ZXInKSk7XG4gICAgICAgICAgICBwcm92aWRlci5zZXQoJ2ZpbHRlcm1vZGUnLCBhdHRycy5nZXQoJ2ZpbHRlcm1vZGUnKSk7XG4gICAgICAgICAgICBwcm92aWRlci5zZXQoJ2VkaXRtb2RlJywgYXR0cnMuZ2V0KCdlZGl0bW9kZScpKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLnNldCgnc2hvd25ld3JvdycsIGF0dHJzLmdldCgnc2hvd25ld3JvdycpKTtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICAgICAgfVxuICAgIH07XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge307XG4iXX0=