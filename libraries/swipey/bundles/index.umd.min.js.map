{"version":3,"sources":["ng://@wm/swipey/swipey.jquery.plugin.ts","ng://@wm/swipey/swipe.animation.ts"],"names":["window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimaitonFrame","callback","setTimeout","$","SwipeTracer","activeEventProcessor","DIRECTIONS","NONE","HORIZONTAL","LEFT_TO_RIGHT","RIGHT_TO_LEFT","VERTICAL","TOP_TO_DOWN","DOWN_TO_TOP","abs","Math","max","swipeMask","touchMoveListeners","touchEndListeners","onTouch","e","each","i","fn","onTouchEnd","length","addEventListener","target","event","__zone_symbol__addEventListener","call","ScrollObserver","parent","child","direction","elementsToObserve","array","iter","push","$ele","last","scrollLeft","iscroll","x","scrollTop","y","parentElement","this","hasSrcolled","swipey","isVerticalScroll","result","isNaN","isHorizontalScroll","getTouchEvent","originalEvent","touches","computeDistance","startPoint","endPoint","deltaX","deltaY","distance","onActiveSwipeEnd","settings","touch","data","path","pageX","pageY","onSwipeEnd","process","listenActiveSwipe","swipeEndHandler","passiveDistance","passiveSwipeStartPoint","activeSwipeStartPoint","lastDistance","totalLength","startTime","Date","now","onSwipeStart","appendTo","ee","remove","em","onActiveSwipe","increment","limit","point","eventSplits","renderInProgress","d","velocity","onSwipe","isThresholdReached","threshold","isThresholdAngleReached","bind","events","bindEvents","listenFor","_","includes","on","es","listenPassiveSwipe","passiveSwipeHandler","scrollObserver","currentTarget","document","SwipeEventSmoother","queue","isProcessing","shift","console","error","extend","swipeTarget","noop","trace","append","tracer","pathd","attr","p","firstPoint","expected_1","trace_1","forEach","ep","jQuery","$parse","expressionRegex","compile","script","match","tArr","getParseService","swipeAnimation","expressionEvaluator","exprEval","Parser","exp","parser","parse","context","evaluate","isFunction","exec","expression","prefix","substring","index","args","arguments","map","v","apply","undefined","join","getObject","obj","calculateBounds","$el","centerVal","bounds","isUndefined","center","lower","upper","retrieveTargets","animation","a","targetFn","SettingsProperty","setSettings","getSettings","animate","metaData","time","distanceMoved","$i","css","mapValues","k","transition","one","$D","onLower","onUpper","onAnimation","methods","gotoUpper","swipeToEnd","gotoLower","moveTo","$d","addSwipey","state","baseContext","min","isArray","cd","strictLower","strict","strictUpper","enableGestures","vc","VelocityComputator","lastTime","addDistance","currentTime","getVelocity","getTime","localState","SwipeAnimation","_isGesturesEnabled","prototype","setGesturesEnabled","enabled","isGesturesEnabled","goToLower","_$ele","goToUpper","init","$swipeTargetEle"],"mappings":"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","sourcesContent":["declare const window, _, jQuery;\n\n// Get a regular interval for drawing to the screen\nwindow.requestAnimationFrame = (function () {\n    'use strict';\n    return window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.oRequestAnimationFrame ||\n        window.msRequestAnimaitonFrame ||\n        function (callback) {\n            window.setTimeout(callback, 1000 / 60);\n        };\n}());\n(function ($) {\n    'use strict';\n    const DIRECTIONS = {\n        'NONE': 0,\n        'HORIZONTAL': 1,\n        'LEFT_TO_RIGHT': 2,\n        'RIGHT_TO_LEFT': 3,\n        'VERTICAL': 4,\n        'TOP_TO_DOWN': 5,\n        'DOWN_TO_TOP': 6\n    };\n    const abs = Math.abs;\n    const max = Math.max;\n    let SwipeTracer;\n    let activeEventProcessor;\n    const swipeMask = $('<div style=\"background-color:rgba(0, 0, 0, 0);position: fixed; top: 0;width:100vw; height: 100vh;z-index: 100000;\"></div>');\n    let touchMoveListeners = [];\n    let touchEndListeners = [];\n\n    const onTouch = function (e) {\n        $.each(touchMoveListeners, function (i, fn) {\n            return fn(e);\n        });\n    };\n    const onTouchEnd = function (e) {\n        $.each(touchEndListeners, function (i, fn) {\n            return fn(e);\n        });\n        touchMoveListeners.length = 0;\n        touchEndListeners.length = 0;\n    };\n\n    // Binds events outside of zone\n    function addEventListener(target, event, callback) {\n        (target.__zone_symbol__addEventListener || target.addEventListener).call(target, event, callback);\n    }\n\n    addEventListener(document, 'mousemove', onTouch);\n    addEventListener(document, 'touchmove', onTouch);\n    addEventListener(document, 'mouseup', onTouchEnd);\n    addEventListener(document, 'touchcancel', onTouchEnd);\n    addEventListener(document, 'touchend', onTouchEnd);\n\n    function ScrollObserver(parent, child, direction) {\n        const elementsToObserve = (function (array) {\n            let iter = child;\n            while (iter) {\n                array.push({\n                    '$ele': $(iter),\n                    'last': {\n                        'scrollLeft': iter.iscroll ? iter.iscroll.x : iter.scrollLeft,\n                        'scrollTop': iter.iscroll ? iter.iscroll.y : iter.scrollTop\n                    }\n                });\n                iter = iter.parentElement;\n            }\n            return array;\n        })([]);\n\n        function isVerticalScroll() {\n            let result;\n            $.each(elementsToObserve, function () {\n                if (this.$ele[0].iscroll) {\n                    if (!isNaN(this.$ele[0].iscroll.y) && this.$ele[0].iscroll.y !== 0) {\n                        result = true;\n                    }\n                } else if (this.$ele[0].scrollTop !== 0) {\n                    result = true;\n                }\n            });\n            return result;\n        }\n\n        function isHorizontalScroll() {\n            let result;\n            $.each(elementsToObserve, function () {\n                if (this.$ele[0].iscroll) {\n                    if (!isNaN(this.$ele[0].iscroll.x) && this.$ele[0].iscroll.x !== 0) {\n                        result = true;\n                    }\n                } else if (this.$ele[0].scrollLeft !== 0) {\n                    result = true;\n                }\n            });\n            return result;\n        }\n\n        this.hasSrcolled = function () {\n            if (direction === $.fn.swipey.DIRECTIONS.VERTICAL) {\n                return isVerticalScroll();\n            }\n            if (direction === $.fn.swipey.DIRECTIONS.HORIZONTAL) {\n                return isHorizontalScroll();\n            }\n        };\n    }\n\n    function SwipeEventSmoother() {\n        const queue = [];\n        let isProcessing = false;\n        let time;\n\n        function process() {\n            if (queue.length > 0) {\n                try {\n                    queue.shift()();\n                } catch (e) {\n                    console.error('Function invocation failed', e);\n                }\n                window.requestAnimationFrame(process);\n            } else {\n                isProcessing = false;\n            }\n        }\n\n        this.push = function (fn) {\n            queue.push(fn);\n        };\n\n        this.process = function () {\n            if (!isProcessing) {\n                isProcessing = true;\n                // time = 0;\n                process();\n            }\n        };\n    }\n\n    activeEventProcessor = new SwipeEventSmoother();\n\n    function getTouchEvent(event) {\n        return (event.originalEvent && event.originalEvent.touches && event.originalEvent.touches[0]) ||\n            (event && event.touches && event.touches[0]) ||\n            event;\n    }\n\n    function computeDistance(startPoint, endPoint, direction) {\n        let distance = 0,\n            deltaX,\n            deltaY;\n        if (direction === DIRECTIONS.HORIZONTAL) {\n            distance = endPoint.x - startPoint.x;\n        } else if (direction === DIRECTIONS.LEFT_TO_RIGHT) {\n            distance = max(endPoint.x - startPoint.x, 0);\n        } else if (direction === DIRECTIONS.RIGHT_TO_LEFT) {\n            distance = max(startPoint.x - endPoint.x, 0);\n        } else if (direction === DIRECTIONS.VERTICAL) {\n            distance = endPoint.y - startPoint.y;\n        } else if (direction === DIRECTIONS.TOP_TO_DOWN) {\n            distance = max(endPoint.y - startPoint.y, 0);\n        } else if (direction === DIRECTIONS.DOWN_TO_TOP) {\n            distance = max(startPoint.y - endPoint.y, 0);\n        } else {\n            deltaX = endPoint.x - startPoint.x;\n            deltaY = endPoint.y - startPoint.y;\n            distance = max(abs(deltaX), abs(deltaY));\n            if ((deltaX < 0 && abs(deltaX) === distance) || (deltaY < 0 && abs(deltaY) === distance)) {\n                distance = -distance;\n            }\n        }\n        return distance;\n    }\n\n    function onActiveSwipe(event, settings) {\n        const touch = getTouchEvent(event);\n        const startPoint = settings.data.path[0];\n        const point = {\n            'x': touch.pageX,\n            'y': touch.pageY\n        };\n        const distance = computeDistance(startPoint, point, settings.direction);\n        const eventSplits = [];\n        let increment;\n        let limit;\n        settings.renderInProgress = false;\n        if (distance !== settings.lastDistance) {\n            increment = (distance < settings.lastDistance ? -1 : 1) * 30;\n            limit = (distance - settings.lastDistance);\n            for (let i = increment;\n                 (increment > 0 && i <= limit) || (increment < 0 && i >= limit); i += increment) {\n                eventSplits.push(i + settings.lastDistance);\n            }\n            if (limit % increment !== 0) {\n                eventSplits.push(limit % abs(increment) + (eventSplits.length === 0 ? settings.lastDistance : eventSplits[eventSplits.length - 1]));\n            }\n            // eventSplits = [distance];\n            settings.lastDistance = distance;\n            $.each(eventSplits, function () {\n                const d = this;\n                activeEventProcessor.push(function () {\n                    settings.data.length = d;\n                    settings.data.totalLength += abs(d);\n                    settings.data.velocity = abs(settings.data.totalLength / (Date.now() - settings.data.startTime));\n                    settings.data.path.push(point);\n                    if (settings.onSwipe.call(settings.target, event, settings.data) === false) {\n                        onActiveSwipeEnd(event, settings);\n                    }\n                    SwipeTracer.onSwipe(event, settings.data);\n                });\n            });\n            activeEventProcessor.process();\n        }\n    }\n\n    function onActiveSwipeEnd(event, settings) {\n        const touch = getTouchEvent(event);\n        if (touch) {\n            settings.data.path.push({\n                'x': touch.pageX,\n                'y': touch.pageY\n            });\n        }\n        activeEventProcessor.push(function () {\n            SwipeTracer.onSwipeEnd(event, settings.data);\n            settings.onSwipeEnd.call(settings.target, event, settings.data);\n        });\n        activeEventProcessor.process();\n    }\n\n    function listenActiveSwipe(event, settings) {\n        const touch = getTouchEvent(event);\n        let swipeHandler;\n        let swipeEndHandler;\n        let passiveDistance;\n        const passiveSwipeStartPoint = settings.data.path[0];\n        const activeSwipeStartPoint = {\n            'x': touch.pageX,\n            'y': touch.pageY\n        };\n        passiveDistance = computeDistance(passiveSwipeStartPoint, activeSwipeStartPoint, settings.direction);\n        settings.data.length = passiveDistance < 0 ? -1 : 1;\n        settings.lastDistance = settings.data.length;\n        settings.data.path = [activeSwipeStartPoint];\n        settings.data.totalLength = abs(settings.data.length);\n        settings.data.startTime = Date.now();\n        if (settings.onSwipeStart.call(settings.target, event, settings.data) === false) {\n            return false;\n        }\n        swipeMask.appendTo($('body'));\n        swipeHandler = function (em) {\n            onActiveSwipe(em, settings);\n        };\n        swipeEndHandler = function (ee) {\n            swipeMask.remove();\n            onActiveSwipeEnd(ee, settings);\n        };\n        touchMoveListeners = [];\n        touchMoveListeners.push(swipeHandler);\n\n        touchEndListeners = [];\n        touchEndListeners.push(swipeEndHandler);\n        SwipeTracer.onSwipeStart(event, settings.data);\n        return true;\n    }\n\n    // This function checks if touch positions are within +/- 20deg error in horizontal and 70deg in vertical direction.\n    function isThresholdAngleReached(startPoint, endPoint, direction) {\n        // tan20, tan(-20deg)\n        if (direction === DIRECTIONS.HORIZONTAL) {\n            if (Math.abs((endPoint.y - startPoint.y) / (endPoint.x - startPoint.x)) <= 0.36397023426) {\n                return true;\n            }\n        } else if (direction === DIRECTIONS.VERTICAL) { // between tan70 & tan110\n            if (Math.abs((endPoint.y - startPoint.y) / (endPoint.x - startPoint.x)) >= 2.74747741945) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isThresholdReached(touch, settings) {\n        const startPoint = settings.data.path[0];\n        const endPoint = {\n            'x': touch.pageX,\n            'y': touch.pageY\n        };\n        const distance = computeDistance(startPoint, endPoint, settings.direction);\n        return abs(distance) > settings.threshold && isThresholdAngleReached(startPoint, endPoint, settings.direction);\n    }\n\n    function listenPassiveSwipe(touch, settings) {\n        let passiveSwipeHandler;\n        settings.scrollObserver = new ScrollObserver(event.currentTarget, event.target, settings.direction);\n        passiveSwipeHandler = function (em) {\n            if (isThresholdReached(getTouchEvent(em), settings)) {\n                if (settings.scrollObserver.hasSrcolled() || listenActiveSwipe(em, settings)) {\n                    return false;\n                }\n            }\n        };\n        touchMoveListeners.push(passiveSwipeHandler);\n        settings.data = {\n            path: [{\n                'x': touch.pageX,\n                'y': touch.pageY\n            }]\n        };\n    }\n\n\n    function bind(settings) {\n        // Listens for events depending on value passed to bindEvents.\n        const events = settings.bindEvents;\n        let listenFor = '';\n        if (_.includes(events, 'touch')) {\n            listenFor += ' touchstart';\n        } else if (_.includes(events, 'mouse')) {\n            listenFor += ' mousedown';\n        }\n\n        if (!listenFor) {\n            return;\n        }\n\n        settings.target.on(listenFor, function (es) {\n            const touch = getTouchEvent(es);\n            if (touch) {\n                listenPassiveSwipe(touch, settings);\n            }\n        });\n    }\n\n    $.fn.swipey = function (settings) {\n        this.each(function () {\n            bind($.extend({\n                'direction': DIRECTIONS.NONE,\n                'target': $(this),\n                'bindEvents': ['touch', 'mouse'],\n                'swipeTarget': document,\n                'threshold': 30,\n                'onSwipeStart': $.noop,\n                'onSwipe': $.noop,\n                'onSwipeEnd': $.noop\n            }, settings));\n        });\n        return this;\n    };\n\n    SwipeTracer = {\n        'onSwipeStart': function (e, data) {\n            if ($.fn.swipey.trace) {\n                $('body').append('<svg height=\"100vh\" width=\"100vw\" ' +\n                    '   style=\"position : fixed;top: 0;left: 0; width:100vw; height: 100vh; z-index:10000\" id =\"canvas\">' +\n                    '       <path stroke=\"rgba(0, 0, 0, 0.5)\" stroke-linecap=\"round\" stroke-width=\"20\" fill-opacity=\"0\" ' +\n                    '           stroke-opacity=\"0.8\" d=\"M' + data.path[0].x + ' ' + data.path[0].y + ' \" />' +\n                    '   </svg>');\n                data.tracer = {\n                    pathd: $('#canvas path')\n                };\n            }\n        },\n        'onSwipe': function (e, data) {\n            if (data.tracer) {\n                const d = data.tracer.pathd.attr('d');\n                const p = data.path[data.path.length - 1];\n                data.tracer.pathd.attr('d', d + ' L' + p.x + ' ' + p.y + ' ');\n            }\n        },\n        'onSwipeEnd': function (e, data) {\n            if (data.tracer) {\n                const firstPoint = data.path[0];\n                const expected = [\n                    firstPoint,\n                    { y: firstPoint.y - 50 },\n                    { x: firstPoint.x + 50 },\n                    { y: firstPoint.y + 50}\n                ];\n                let trace = 0;\n                _.forEach(data.path, function (p) {\n                    let ep;\n                    if (trace !== expected.length) {\n                        ep = expected[trace];\n                        if ((!ep.x || ep.x <= p.x) && (!ep.y || ep.y <= p.y)) {\n                            trace++;\n                        }\n                    }\n                });\n                setTimeout(function () {\n                    $('body >#canvas').remove();\n                }, 500);\n            }\n        }\n    };\n    $.fn.swipey.DIRECTIONS = DIRECTIONS;\n})(jQuery);\n\n// Plugin extension for swipeAnimation.\n(function ($) {\n    let $parse;\n    const expressionRegex = /\\$\\{\\{[a-zA-Z\\+-/%\\.\\*\\s\\(\\)\\d,\\\\'\"\\$_]*\\}\\}/;\n\n    function getParseService() {\n        if ($.fn.swipeAnimation.expressionEvaluator) {\n            return $.fn.swipeAnimation.expressionEvaluator;\n        }\n        if (window.exprEval && window.exprEval.Parser) {\n            return function (exp) {\n                const parser = new window.exprEval.Parser().parse(exp);\n                return function (context) {\n                    return parser.evaluate(context);\n                };\n            };\n        }\n    }\n\n    // Angular parser to parse the expression inside the interpolation\n    function compile(script) {\n        const tArr = [];\n        let match;\n\n        $parse = $parse || getParseService();\n        if (_.isFunction(script)) {\n            return script;\n        } else if ($parse) {\n            while ((match = expressionRegex.exec(script)) !== null) {\n                let expression = match[0];\n                const prefix = script.substring(0, match.index);\n                script = script.substring(match.index + expression.length);\n                expression = expression.substring(3, expression.length - 2);\n                tArr.push(prefix);\n                tArr.push($parse(expression).bind({}));\n            }\n            tArr.push(script);\n            return function () {\n                const args = arguments;\n                return _.map(tArr, function (v) {\n                    return _.isFunction(v) ? v.apply(undefined, args) : v;\n                }).join('');\n            };\n        }\n\n    }\n\n    function getObject(obj, $ele, args?) {\n        if (_.isFunction(obj)) {\n            return obj.apply($ele, args);\n        }\n        return obj;\n    }\n\n    function VelocityComputator() {\n        let lastDistance = 0;\n        let lastTime = 0;\n        let v = 0;\n        return {\n            addDistance: function (d) {\n                const currentTime = Date.now();\n                if (Math.abs(d - lastDistance) > 10 && currentTime !== lastTime) {\n                    v = (d - lastDistance) / (currentTime - lastTime);\n                    lastDistance = d;\n                    lastTime = currentTime;\n                }\n                if (v < 0) {\n                    v = Math.min(v, -1);\n                } else {\n                    v = Math.max(v, 1);\n                }\n                return this;\n            },\n            getVelocity: function () {\n                return v;\n            },\n            getTime: function (d) {\n                return Math.abs(d / v);\n            }\n        };\n    }\n\n    /**\n     * lower and upper bounds are relative distance from the center.\n     * Calculates the lower and upper bounds based on relative position from center\n     * @param $el\n     * @param settings\n     */\n    function calculateBounds($el, settings, args?) {\n        let centerVal = 0;\n        const bounds = getObject(settings.bounds, $el, args);\n\n        if (!_.isUndefined(bounds.center)) {\n            centerVal = bounds.center;\n        }\n        if (!_.isUndefined(bounds.lower)) {\n            bounds.lower = bounds.lower + centerVal;\n        }\n        if (!_.isUndefined(bounds.upper)) {\n            bounds.upper = bounds.upper + centerVal;\n        }\n\n        return bounds;\n    }\n\n    /**\n     * This function checks if target is a function or an element and gets the target element.\n     * @param settings\n     */\n    function retrieveTargets(settings) {\n        _.forEach(settings.animation, function (a) {\n            if (_.isFunction(a.target) || a.targetFn) {\n                a.targetFn = _.isUndefined(a.targetFn) ? a.target : a.targetFn;\n                a.target = a.targetFn();\n            }\n        });\n    }\n\n    /**\n     * Getter and setter for settings object\n     */\n    function SettingsProperty() {\n        this.setSettings = function (settings, $el) {\n            $el.data('swipeAnimationDefaults', settings);\n        };\n        this.getSettings = function ($el) {\n            return $el.data('swipeAnimationDefaults');\n        };\n    }\n\n    /**\n     * This function handles the animation on element\n     * @param settings , metadata related to animation\n     * @param metaData , contains the distance moved i.e. $d and current position $D, and also bounds details\n     * @param time , time to persist transition\n     * @param $el , element on which swipe is applied\n     */\n    function animate(settings, metaData, time, $el, distanceMoved?, e?) {\n        _.forEach(settings.animation, function (a) {\n            if (!a.target) {\n                return;\n            }\n            if (a.target.length > 1) {\n                a.target.each(function (i) {\n                    metaData.$i = i;\n                    $(this).css(_.mapValues(a.css, function (v, k) {\n                        return v(metaData);\n                    }));\n                });\n            } else {\n                metaData.$i = 0;\n                a.target.css(_.mapValues(a.css, function (v, k) {\n                    return v(metaData);\n                }));\n            }\n            a.target.css({\n                'transition': 'all ease-out ' + time + 'ms'\n            });\n            a.target.one('webkitTransitionEnd transitionend', function () {\n                a.target.css({\n                    'transition': ''\n                });\n            });\n        });\n        setTimeout(function () {\n            window.requestAnimationFrame(function () {\n                if (metaData.$D === metaData.bounds.lower) {\n                    settings.onLower.call($el);\n                } else if (metaData.$D === metaData.bounds.upper) {\n                    settings.onUpper.call($el);\n                }\n                settings.onAnimation(e, distanceMoved);\n            });\n        }, time);\n    }\n\n    const methods = {\n        'gotoUpper': function () {\n            swipeToEnd(this, 'upper', arguments[1]);\n        },\n        'gotoLower': function (time) {\n            swipeToEnd(this, 'lower', arguments[1]);\n        }\n    };\n\n    // This function animates to the upper or lower bound.\n    function swipeToEnd($ele, moveTo, time) {\n        const settingsObj = new SettingsProperty();\n        const settings = settingsObj.getSettings($ele);\n        let metaData: any = {};\n        const bounds = calculateBounds($ele, settings);\n        let context;\n\n        retrieveTargets(settings);\n\n        time = time || 300;\n\n        context = getObject(settings.context, $ele);\n        metaData = _.extend({}, context);\n        metaData.$d = 0;\n        metaData.$D = moveTo === 'lower' ? bounds.lower : bounds.upper;\n        metaData.bounds = bounds;\n\n        animate(settings, metaData, time, $ele);\n    }\n\n    // This function adds swipe functionality on the element.\n    function addSwipey($ele, settings) {\n        const state: any = { '$D': 0 };\n        const baseContext = {\n            'max': Math.max,\n            'min': Math.min,\n            'abs': Math.abs\n        };\n\n        if (!_.isArray(settings.animation)) {\n            const target = settings.animation.target || $ele;\n            const css = settings.animation.css || settings.animation;\n            delete css[$ele];\n            settings.animation = [{\n                'target': target,\n                'css': css\n            }];\n        }\n        _.forEach(settings.animation, function (a) {\n            a.css = _.mapValues(a.css, function (v, k) {\n                return compile(v);\n            });\n        });\n        const settingsObj = new SettingsProperty();\n        settingsObj.setSettings(settings, $ele);\n        $ele.swipey({\n            'direction': settings.direction,\n            'threshold': settings.threshold,\n            'bindEvents': settings.bindEvents,\n            'target': settings.target,\n            'onSwipeStart': function (e, data) {\n                let cd;\n                state.$d = 0;\n\n                state.bounds = calculateBounds(this, settings, [e, data.length]);\n                if (!_.isUndefined(state.bounds.center)) {\n                    state.$D = state.bounds.center;\n                } else {\n                    state.$D = 0;\n                }\n\n                cd = state.$D + data.length;\n\n                // by default strict is true\n                state.bounds.strictLower = !(state.bounds.strict === false || state.bounds.strictLower === false);\n                state.bounds.strictUpper = !(state.bounds.strict === false || state.bounds.strictUpper === false);\n\n                if (!settings.enableGestures() ||\n                    (state.bounds.strictLower &&\n                        ((_.isUndefined(state.bounds.lower) && data.length < 0) ||\n                            (!_.isUndefined(state.bounds.lower) && state.bounds.lower > cd))) ||\n                    (state.bounds.strictUpper &&\n                        ((_.isUndefined(state.bounds.upper) && data.length > 0) ||\n                            (!_.isUndefined(state.bounds.upper) && state.bounds.upper < cd)))) {\n                    return false;\n                }\n                state.vc = VelocityComputator();\n                state.context = _.extend(baseContext, getObject(settings.context, $ele));\n                state.localState = _.extend({}, state.context);\n\n                retrieveTargets(settings);\n\n                _.forEach(settings.animation, function (a) {\n                    if (a.target) {\n                        a.target.css({\n                            'transition': 'none'\n                        });\n                    }\n                });\n            },\n            'onSwipe': function (e, data) {\n                const localState = state.localState;\n                const cd = state.$D + data.length;\n\n                localState.$d = data.length;\n                localState.$D = state.$D;\n\n                // only in strict mode, restrict the $d value to go beyond the bounds.\n                if (state.bounds.strictLower && !_.isUndefined(state.bounds.lower) && state.bounds.lower > cd) {\n                    localState.$d = (state.bounds.lower - state.$D);\n                } else if (state.bounds.strictUpper && !_.isUndefined(state.bounds.upper) && state.bounds.upper < cd) {\n                    localState.$d = (state.bounds.upper - state.$D);\n                }\n\n                state.vc.addDistance(data.length);\n                _.forEach(settings.animation, function (a) {\n                    if (a.target) {\n                        if (a.target.length > 1) {\n                            a.target.each(function (i) {\n                                localState.$i = i;\n                                $(this).css(_.mapValues(a.css, function (v, k) {\n                                    return v(localState);\n                                }));\n                            });\n                        } else {\n                            localState.$i = 0;\n                            a.target.css(_.mapValues(a.css, function (v, k) {\n                                return v(localState);\n                            }));\n                        }\n                    }\n                });\n            },\n            'onSwipeEnd': function (e, data) {\n                const localState = state.localState;\n                const cd = state.$D + data.length;\n                const v = state.vc.getVelocity();\n                let time;\n\n                localState.$d = data.length;\n                localState.$D = state.$D;\n\n                // assigns upper or lower bounds to $D\n                if (!_.isUndefined(state.bounds.lower) && v <= 0 && state.$D > cd) {\n                    localState.$D = state.bounds.lower;\n                } else if (!_.isUndefined(state.bounds.upper) && v >= 0 && state.$D < cd) {\n                    localState.$D = state.bounds.upper;\n                }\n\n                localState.$d = 0;\n                localState.bounds = state.bounds;\n                state.$D = localState.$D;\n                time = state.vc.getTime(localState.$D - cd);\n\n                animate(settings, localState, time, $ele, cd, e);\n            }\n        });\n    }\n\n    // Adds the swipe functionality on the element\n    $.fn.swipeAnimation = function (settings) {\n        if (methods[settings]) {\n            return methods[settings].apply(this, arguments);\n        }\n        this.each(function () {\n            addSwipey($(this), $.extend({\n                'direction': $.fn.swipey.DIRECTIONS.HORIZONTAL,\n                'target': $(this),\n                // 'step': 10,\n                'threshold': 30,\n                'enableGestures': function () {\n                    return true;\n                },\n                'bindEvents': ['touch'],\n                'bounds': {},\n                'context': {},\n                'animation': {},\n                'onLower': $.noop,\n                'onUpper': $.noop,\n                'onAnimation': $.noop\n            }, settings));\n        });\n        return this;\n    };\n})(jQuery);\n\nexport default () => {};\n","\nimport initSwipeyJqueryPlugin from './swipey.jquery.plugin';\n\ninitSwipeyJqueryPlugin();\n\ndeclare const  $;\n\nexport abstract class SwipeAnimation {\n\n    private _$ele;\n    private _isGesturesEnabled = true;\n\n    public abstract animation(): [{}] | {};\n    public bindEvents() { return ['touch']; }\n    public bounds(e?, $d?: number) { return {}; }\n    public context() { return {}; }\n    public direction() { return $.fn.swipey.DIRECTIONS.HORIZONTAL; }\n    public setGesturesEnabled(enabled: boolean) { this._isGesturesEnabled = enabled; }\n    public isGesturesEnabled() { return this._isGesturesEnabled; }\n    public goToLower(time?) {\n        this._$ele.swipeAnimation('gotoLower', time);\n    }\n    public goToUpper(time?) {\n        this._$ele.swipeAnimation('gotoUpper', time);\n    }\n    public onAnimation(e, distanceMoved: number) {}\n    public onUpper() {}\n    public onLower() {}\n    public threshold() { return 30; }\n\n    public constructor() {\n\n    }\n\n    public init($ele, $swipeTargetEle?) {\n        this._$ele = $ele;\n        $ele.swipeAnimation({\n            animation: this.animation(),\n            target: $swipeTargetEle,\n            bounds: this.bounds.bind(this),\n            bindEvents: this.bindEvents(),\n            context: this.context.bind(this),\n            direction: this.direction(),\n            enableGestures: this.isGesturesEnabled.bind(this),\n            onAnimation: this.onAnimation.bind(this),\n            onLower: this.onLower.bind(this),\n            onUpper: this.onUpper.bind(this),\n            threshold: this.threshold()\n        });\n    }\n}\n"]}